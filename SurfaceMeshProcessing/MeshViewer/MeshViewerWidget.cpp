#include <QtCore>
#include <complex.h>
#include <OpenMesh/Core/IO/MeshIO.hh>
#include "MeshViewerWidget.h"
#include <math.h>
#include <cmath>
#define _USE_MATH_DEFINES

#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "stb_image_write.h"
#define STB_IMAGE_RESIZE2_IMPLEMENTATION
#include "stb_image_resize2.h"

#include <boost/math/quadrature/gauss_kronrod.hpp>
// Horner 法
template <typename C>
inline std::complex<double> eval_poly(const C& coeffs, int deg, double x) {
	std::complex<double> r = 0.0;
	for (int i = deg; i >= 0; --i)
		r = r * x + coeffs[i]; // r = r*x + coeffs[i]
	return r;
}

template <std::size_t N1, std::size_t N2>
std::complex<double> integrate_rational(
	const std::array<std::complex<double>, N1>& num,
	const std::array<std::complex<double>, N2>& den,
	double tol = 1e-12)
{
	using boost::math::quadrature::gauss_kronrod;

	const int deg_num = static_cast<int>(N1) - 1;
	const int deg_den = static_cast<int>(N2) - 1;

	auto f = [&](double t) {
		return eval_poly(num, deg_num, t) / eval_poly(den, deg_den, t);
	};

	// 一次性对复数整体自适应积分（第4参是 max_depth，第5参是 tol）
	return gauss_kronrod<double, 15>::integrate(f, 0.0, 1.0, 9, tol);
}

#if 0
using polyvec = std::vector<double>;
#else
using polyvec = boost::container::small_vector<double, 128>;
#endif
void DrawPoints3d(const vector<OpenMesh::Vec3d>& Points, float r = 0.0f, float g = 0.0f, float b = 1.0f, float pointsize = 5.0f);
Eigen::MatrixXd pseudoInverse(const Eigen::MatrixXd& matrix, double tolerance = 1e-9);
OpenMesh::Vec3d computeNormal(const OpenMesh::Vec3d& v1, const OpenMesh::Vec3d& v2, const OpenMesh::Vec3d& v3);
double GCTrlInt(const OpenMesh::Vec3d& p, const OpenMesh::Vec3d& v1, const OpenMesh::Vec3d& v2, const OpenMesh::Vec3d& n);
double SolidAngle(const OpenMesh::Vec3d& v1, const OpenMesh::Vec3d& v2, const OpenMesh::Vec3d& v3, const OpenMesh::Vec3d& eta);
template <typename VecType>
std::vector<VecType> subdivideCage(const std::vector<VecType>& linear_cage);
template <typename VecType>
std::vector<VecType> subdivideCage123(const std::vector<VecType>& linear_cage);
template <typename VecType>
std::vector<VecType> subdivideCage124(const std::vector<VecType>& linear_cage);
//二次bezier曲线的细分
template <typename VecType>
std::vector<VecType> subdivideCage2(const std::vector<VecType>& twice_cage);
//三次bezier曲线的细分
template <typename VecType>
std::vector<VecType> subdivideCage3(const std::vector<VecType>& twice_cage);
//三次bezier曲线的细分,系采样点
template <typename VecType>
std::vector<VecType> subdivideCage3(const std::vector<VecType>& twice_cage, const int n_samples);
//三次bezier曲线的细分,系采样点
template <typename VecType>
std::vector<VecType> subdivideCage3(const std::vector<VecType>& twice_cage, const int n_samples,double length);
template <typename VecType>
std::vector<VecType> subdivideCage4(const std::vector<VecType>& twice_cage);
//std::vector<OpenMesh::Vec2d> offsetCage(const std::vector<OpenMesh::Vec2d>& linear_cage, double displacement);
void CalGreenBasis3D(OpenMesh::Vec3d& v0, OpenMesh::Vec3d& v1, OpenMesh::Vec3d& v2, OpenMesh::Vec3d& eta, int & index,
	double& ksiH, std::vector<double>& phiH);
void CalBiharmonicBasis3D(OpenMesh::Vec3d& v0, OpenMesh::Vec3d& v1, OpenMesh::Vec3d& v2, OpenMesh::Vec3d& eta, int& index,
	double& ksiBH,  std::vector<double>& phiBH );
void CalBiharmonicBasis(OpenMesh::Vec2d& v0, OpenMesh::Vec2d& v1, OpenMesh::Vec2d& v2, OpenMesh::Vec2d& eta, double& ksiH, double& phiH, double& BHksi, double& BHphi);
void CalBiharmonicTwiceBasis(OpenMesh::Vec2d& v0, OpenMesh::Vec2d& v1, OpenMesh::Vec2d& v2, OpenMesh::Vec2d& eta, std::vector<double>& values);
void CalBiharmonicTwiceBasisNew(OpenMesh::Vec2d& v0, OpenMesh::Vec2d& v1, OpenMesh::Vec2d& v2, OpenMesh::Vec2d& eta, std::vector<double>& values);
void Cal222BiharmonicBasis(OpenMesh::Vec2d& v0, OpenMesh::Vec2d& v01, OpenMesh::Vec2d& v1, OpenMesh::Vec2d& v12, OpenMesh::Vec2d& v2, OpenMesh::Vec2d& eta, std::vector<double>& values);
void CalBiharmonicTwiceBasisNewDer(OpenMesh::Vec2d& v0, OpenMesh::Vec2d& v1, OpenMesh::Vec2d& v2, OpenMesh::Vec2d& eta, std::vector<double>& values);
void CalBiharmonicTwiceBasisNewDerBoundary(OpenMesh::Vec2d& v0, OpenMesh::Vec2d& v1, OpenMesh::Vec2d& v2, OpenMesh::Vec2d& eta,
	std::vector<double>& values, int signEdge);
void CalBiharmonicTwiceBasisNewDerV1(OpenMesh::Vec2d& v0, OpenMesh::Vec2d& v1, OpenMesh::Vec2d& v2, OpenMesh::Vec2d& eta, std::vector<double>& values, int signEdge);
void CalBiharmonicThirdBasis(OpenMesh::Vec2d& v0, OpenMesh::Vec2d& v1, OpenMesh::Vec2d& v2, OpenMesh::Vec2d& eta, std::vector<double>& values);
void CalBiharmonicThirdBasisNew(OpenMesh::Vec2d& v0, OpenMesh::Vec2d& v1, OpenMesh::Vec2d& v2, OpenMesh::Vec2d& eta, std::vector<double>& values);
void CalBiharmonicThirdBasis_edge(OpenMesh::Vec2d& v0, OpenMesh::Vec2d& v1, OpenMesh::Vec2d& v2, OpenMesh::Vec2d& eta,double t, std::vector<double>& values);
void CalBiharmonicFourthBasisNew(OpenMesh::Vec2d& v0, OpenMesh::Vec2d& v1, OpenMesh::Vec2d& v2, OpenMesh::Vec2d& eta, std::vector<double>& values);
void CalBiharmonicBasisBef(OpenMesh::Vec2d& v0, OpenMesh::Vec2d& v1, OpenMesh::Vec2d& v2, OpenMesh::Vec2d& eta, double& ksiH, double& phiH, double& BHksi, double& BHphi);
void CalBiharmonicBasisonVertexs(OpenMesh::Vec2d& v0, OpenMesh::Vec2d& v1, OpenMesh::Vec2d& v2,double& ksiH, double& phiH, double& BHksi, double& BHphi);
void CalBiharmonicBasisonVertexsNext(OpenMesh::Vec2d& v0, OpenMesh::Vec2d& v1, OpenMesh::Vec2d& v2, double& ksiH, double& phiH, double& BHksi, double& BHphi);
Mesh createMeshFromCurveCage(const std::vector<Mesh::Point>& curvecage2);
std::vector<std::vector<Mesh::Point>> CCpoints_fromCCmesh(const Mesh CC_mesh,int degree);
std::vector<double> mvc(const Mesh::Point p, const std::vector<Mesh::Point> vts);
//计算积分，分子t的m次方,分母是t的1次方
double F1_n(const Mesh::Point eta, const Mesh::Point c0, const Mesh::Point c1,  int m);
double F1_n(const OpenMesh::Vec2d eta, const OpenMesh::Vec2d c0, const OpenMesh::Vec2d c1, int m);
//计算积分，分子t的m次方,分母是t的2次方
double F2_n(const Mesh::Point eta, const Mesh::Point c0, const Mesh::Point c1, const Mesh::Point c2, int m);
double F2_n(const OpenMesh::Vec2d eta, const OpenMesh::Vec2d c0, const OpenMesh::Vec2d c1, const OpenMesh::Vec2d c2, int m);
vector<double> ALL_F2_n(const OpenMesh::Vec2d& eta, const OpenMesh::Vec2d& c0, const OpenMesh::Vec2d& c1, const OpenMesh::Vec2d& c2, const int n);
template <typename ContainerA, typename ContainerB>
polyvec multiplyPolynomials(const ContainerA& A, const ContainerB& B);
template <typename ContainerA, typename ContainerB>
polyvec addPolynomials(const ContainerA& A, const ContainerB& B, int n);
template <typename ContainerA>
polyvec integratePolynomial(const ContainerA& poly, int n);
double F2_n_new(const OpenMesh::Vec2d eta, const OpenMesh::Vec2d c0, const OpenMesh::Vec2d c1, const OpenMesh::Vec2d c2, int m);

double F2_que(const Mesh::Point eta, const Mesh::Point c0, const Mesh::Point c1, const Mesh::Point c2, int m);
//计算cauchy坐标里的积分，分子t的m次方
complex<double> cauchy_F2_n(const complex<double> z, const complex<double> z0, const complex<double> z1, const complex<double> z2, int m);
//计算有理多项式的积分，分子t的m次方
complex<double> rationalInte(std::vector<complex<double>> &roots, std::vector<int>& root_orders, std::vector<complex<double>>& poly);
std::vector<complex<double>> rationalIntes(std::vector<complex<double>>& roots, std::vector<int>& root_orders, std::vector<complex<double>>& poly);
std::array<complex<double>, 2> rationalIntes_121(std::array<complex<double>, 1>& roots, std::array<std::array<complex<double>, 2>, 2>& poly);
std::array<complex<double>, 4> rationalIntes_123(std::array<complex<double>, 1>& roots, std::array<std::array<complex<double>, 4>, 4>& poly);
std::array<complex<double>, 3> rationalIntes_2(std::array<complex<double>, 2>& roots, std::array<std::array<complex<double>, 4>, 3>& poly);
std::array<complex<double>,4> rationalIntes_3(const std::array<complex<double>,3>& roots, const std::array<std::array<complex<double>,6>,4>& poly);
//计算cauchy坐标里的积分，分子t的m次方
complex<double> cauchy_F3_n(const complex<double> z, const complex<double> z0, const complex<double> z1, const complex<double> z2, const complex<double> z3, int m);

//计算cauchy坐标里的积分的二阶导数，分子t的m次方
complex<double> cauchy_D2F2_n(const complex<double> z, const complex<double> z0, const complex<double> z1, const complex<double> z2, int m);
//计算cauchy坐标里的积分的二阶导数，分子t的m次方
complex<double> cauchy_D2F3_n(const complex<double> z, const complex<double> z0, const complex<double> z1, const complex<double> z2, const complex<double> z3, int m);
//计算D积分，分子t的m次方,分母是t的2次方，分母是模长的四次方
double D2F2_n(const Mesh::Point eta, const Mesh::Point c0, const Mesh::Point c1, const Mesh::Point c2, int m);
void Cardano(complex<double> a, complex<double> b, complex<double> c, complex<double>d, complex<double>& x1, complex<double>& x2, complex<double>& x3);
void Cubicsolve(complex<double> poly3, complex<double> poly2, complex<double> poly1, complex<double>poly0, complex<double>& x0, complex<double>& x1, complex<double>& x2);
//计算积分，分子t的m次方，分母是t的3次方
double F3_n(const Mesh::Point eta, const Mesh::Point c0, const Mesh::Point c1, const Mesh::Point c2, const Mesh::Point c3, int m);
double F3_n(const OpenMesh::Vec2d eta, const OpenMesh::Vec2d c0, const OpenMesh::Vec2d c1, const OpenMesh::Vec2d c2, const OpenMesh::Vec2d c3, int m);
vector<double> ALL_F3_n(const OpenMesh::Vec2d& eta, const OpenMesh::Vec2d& c0, const OpenMesh::Vec2d& c1, const OpenMesh::Vec2d& c2, const OpenMesh::Vec2d& c3, const int n);
void partion_handles(const std::vector<Mesh::Point>& Handle_points,
	std::vector<std::complex<double>>& deform_cps,
	std::vector<std::complex<double>>& deform_cps_t);





Mesh::Point evaluate_coor(const std::vector<double> weight, const std::vector<Mesh::Point> ctps);
//lsb关灯
MeshViewerWidget::MeshViewerWidget(QWidget* parent)
	: QGLViewerWidget(parent),
	ptMin(0.0),
	ptMax(0.0),
	isEnableLighting(false),
	isTwoSideLighting(false),
	isDrawBoundingBox(false),
	isDrawBoundary(false)
{
}

MeshViewerWidget::~MeshViewerWidget(void)
{
}

bool MeshViewerWidget::LoadMesh(const std::string & filename)
{
	Clear();
	bool read_OK = MeshTools::ReadMesh(mesh, filename);
	std::cout << "Load mesh from file " << filename << std::endl;
	if (read_OK)
	{
		strMeshFileName = QString::fromStdString(filename);
		QFileInfo fi(strMeshFileName);
		strMeshPath = fi.path();
		strMeshBaseName = fi.baseName();
		auto vertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(mesh, "vertexState");
		for (auto vh : mesh.vertices())
		{
			vertexState[vh] = NotSelected;
		}
		selectMode = NoSelect;
		UpdateMesh();
		update();
		return true;
	}
	return false;
}

void MeshViewerWidget::Clear(void)
{
	mesh.clear();
}

void MeshViewerWidget::UpdateMesh(void)
{
	mesh.update_normals();
	if (mesh.vertices_empty())
	{
		std::cerr << "ERROR: UpdateMesh() No vertices!" << std::endl;
		return;
	}
	ptMin[0] = ptMin[1] = ptMin[2] = DBL_MAX;
	ptMax[0] = ptMax[1] = ptMax[2] = -DBL_MAX;
	for (const auto& vh : mesh.vertices())
	{
		ptMin.minimize(mesh.point(vh));
		ptMax.maximize(mesh.point(vh));
	}

	//我在做视频的时候将这两个例子的bounding box放大了，忘记了为什么
	/*for haixing
	ptMin *= 1.01; ptMax *= 1.01;
	for oct
	ptMin *= 1.1; ptMax *= 1.1;*/

	double avelen = 0.0;
	double maxlen = 0.0;
	double minlen = DBL_MAX;
	for (const auto& eh : mesh.edges())
	{
		double len = mesh.calc_edge_length(eh);
		maxlen = len > maxlen ? len : maxlen;
		minlen = len < minlen ? len : minlen;
		avelen += len;
	}
	avgEdgeLength = avelen / mesh.n_vertices();

	SetScenePosition((ptMin + ptMax)*0.5, (ptMin - ptMax).norm()*0.5);
	std::cout << "Information of the input mesh:" << std::endl;
	std::cout << "  [V, E, F] = [" << mesh.n_vertices() << ", " << mesh.n_edges() << ", " << mesh.n_faces() << "]\n";
	std::cout << "  BoundingBox:\n";
	std::cout << "  X: [" << ptMin[0] << ", " << ptMax[0] << "]\n";
	std::cout << "  Y: [" << ptMin[1] << ", " << ptMax[1] << "]\n";
	std::cout << "  Z: [" << ptMin[2] << ", " << ptMax[2] << "]\n";
	std::cout << "  Diag length of BBox: " << (ptMax - ptMin).norm() << std::endl;
	std::cout << "  Edge Length: [" << minlen << ", " << maxlen << "]; AVG: " << avelen / mesh.n_edges() << std::endl;
}

bool MeshViewerWidget::SaveMesh(const std::string & filename)
{
	return MeshTools::WriteMesh(mesh, filename, DBL_DECIMAL_DIG);
}

bool MeshViewerWidget::ScreenShot()
{
	update();
	QString filename = strMeshPath + "/" + QDateTime::currentDateTime().toString("yyyyMMddHHmmsszzz") + QString(".png");
	QImage image = grabFramebuffer();
	image.save(filename);
	std::cout << "Save screen shot to " << filename.toStdString() << std::endl;
	return true;
}

void MeshViewerWidget::SetDrawBoundingBox(bool b)
{
	isDrawBoundingBox = b;
	update();
}
void MeshViewerWidget::SetDrawBoundary(bool b)
{
	isDrawBoundary = b;
	update();
}
void MeshViewerWidget::EnableLighting(bool b)
{
	isEnableLighting = b;
	update();
}
void MeshViewerWidget::EnableDoubleSide(bool b)
{
	isTwoSideLighting = b;
	update();
}

void MeshViewerWidget::ResetView(void)
{
	ResetModelviewMatrix();
	ViewCenter();
	update();
}

void MeshViewerWidget::ViewCenter(void)
{
	if (!mesh.vertices_empty())
	{
		UpdateMesh();
	}
	update();
}

void MeshViewerWidget::CopyRotation(void)
{
	CopyModelViewMatrix();
}

void MeshViewerWidget::LoadRotation(void)
{
	LoadCopyModelViewMatrix();
	update();
}

void MeshViewerWidget::setBezierRGB(QRgb rgb)
{
	int r = qRed(rgb), g = qGreen(rgb), b = qBlue(rgb);
	bezierR = r / 255.f;
	bezierG = g / 255.f;
	bezierB = b / 255.f;
	std::cout << r << "," << g << "," << b << std::endl;
	update();
}

void MeshViewerWidget::setPointsRGB(QRgb rgb)
{
	int r = qRed(rgb), g = qGreen(rgb), b = qBlue(rgb);
	pointsR = r / 255.f;
	pointsG = g / 255.f;
	pointsB = b / 255.f;
	std::cout <<"points color" << r << "," << g << "," << b << std::endl;
	update();
}

void MeshViewerWidget::PrintMeshInfo(void)
{
	std::cout << "Mesh Info:\n";
	std::cout << "  [V, E, F] = [" << mesh.n_vertices() << ", " << mesh.n_edges() << ", " << mesh.n_faces() << "]\n";
	std::cout << "  BoundingBox:\n";
	std::cout << "  X: [" << ptMin[0] << ", " << ptMax[0] << "]\n";
	std::cout << "  Y: [" << ptMin[1] << ", " << ptMax[1] << "]\n";
	std::cout << "  Z: [" << ptMin[2] << ", " << ptMax[2] << "]\n";
	std::cout << "  Diag length of BBox: " << (ptMax - ptMin).norm() << std::endl;

	if (degree == 2)
		calculate_green_weight222();
	else if (degree == 3)
		calculate_green_weight323();
}

void MeshViewerWidget::SelectSMAdjust(void)
{
	selectMode = SelectAdjust;
}

void MeshViewerWidget::SetSMCustom(void)
{
	selectMode = SelectCustom;
}

void MeshViewerWidget::SetSMMove(void)
{
	selectMode = Move;
}
//没用
void MeshViewerWidget::SetSMSelectAdjustMesh(void)
{
	selectMode = SelectAdjustMesh;
}
//升阶
void MeshViewerWidget::SetSMUpdegree(void)
{
	std::cout << "升阶!" << std::endl;
	calculate_green_weight327();//先计算3次cage到7次控制点的权重
	auto curvecage7 = curvecage2;
	Bezier2Bezier7(curvecage2, curvecage7);
	curvecage2 = curvecage7;
	//通过curvecage2计算cc_points;
	CC_points.clear();
	for (int i = 0; i < curvecage2.size(); i++) {
		for (int j = 0; j < todegree; j++) {
			CC_points.push_back(curvecage2[i][j]);
		}
	}
	CC_mesh = createMeshFromCurveCage(CC_points);
	auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
	for (auto vh : CC_mesh.vertices())
	{
		CagevertexState[vh] = NotSelected;
	}
	highdegree = true;
	update();
}

//变阶
void MeshViewerWidget::SetSMChangedegree(void)
{
	todegree = 2;
	highdegree = true;
	std::cout << "变阶到" << todegree << std::endl;
	auto curvecage1 = curvecage2;
	if (degree == 2) {
		if (todegree == 1) {
			calculate_green_weight221();//先计算2次cage到1次控制点的权重
			Bezier2Bezier221(curvecage2, curvecage1);
			curvecage2 = curvecage1;
		}
		if (todegree == 3) {
			calculate_green_weight223();//先计算2次cage到3次控制点的权重
			Bezier2Bezier223(curvecage2, curvecage1);
			curvecage2 = curvecage1;
		}
		if (todegree == 7) {
			calculate_green_weight227();//先计算2次cage到7次控制点的权重
			Bezier2Bezier227(curvecage2, curvecage1);
			curvecage2 = curvecage1;
		}
	}
	if (degree == 3) {
		if (todegree == 1) {
			calculate_green_weight321();//先计算2次cage到1次控制点的权重
			{
				CC_points = { OpenMesh::Vec3d(0.060138, -2.34968, 0),
	OpenMesh::Vec3d(0.167533, -1.16113, 0),
	OpenMesh::Vec3d(0.304982, 0.160104, 0),
	OpenMesh::Vec3d(0.231798, 1.08177, 0),
	OpenMesh::Vec3d(0.61252, 2.32314, 0),
	OpenMesh::Vec3d(0.771864, 3.13087, 0),
	OpenMesh::Vec3d(0.855257, 4.5897, 0),
	OpenMesh::Vec3d(3.38975, 5.46352, 0),
	OpenMesh::Vec3d(4.41819, 7.10405, 0),
	OpenMesh::Vec3d(8.67744, 7.8645, 0),
	OpenMesh::Vec3d(4.59444, 11.1053, 0),
	OpenMesh::Vec3d(-2.40215, 10.8965, 0),
	OpenMesh::Vec3d(-7.26403, 7.93585, 0),
	OpenMesh::Vec3d(-4.30306, 6.87478, 0),
	OpenMesh::Vec3d(-2.76766, 5.30325, 0),
	OpenMesh::Vec3d(-0.552003, 4.00657, 0),
	OpenMesh::Vec3d(-0.0860061, 2.21267, 0),
	OpenMesh::Vec3d(0.0878497, 0.616274, 0),
	OpenMesh::Vec3d(-0.0636332, -0.969635, 0),
	OpenMesh::Vec3d(-1.42388, 1.41961, 0),
	OpenMesh::Vec3d(-3.71789, 1.96421, 0),
	OpenMesh::Vec3d(-7.39052, 1.52015, 0),
	OpenMesh::Vec3d(-5.55652, -0.704119, 0),
	OpenMesh::Vec3d(-3.16591, -1.64514, 0),
	OpenMesh::Vec3d(-0.29709, -1.64989, 0),
	OpenMesh::Vec3d(-0.284548, -4.19343, 0),
	OpenMesh::Vec3d(-4.56897, -5.40077, 0),
	OpenMesh::Vec3d(-3.58096, -9.71999, 0),
	OpenMesh::Vec3d(-3.51223, -4.61304, 0),
	OpenMesh::Vec3d(-0.378727, -4.82229, 0),
	OpenMesh::Vec3d(0.125836, -2.84884, 0),
	OpenMesh::Vec3d(1.10361, -2.36519, 0),
	OpenMesh::Vec3d(3.49, -2.80699, 0),
	OpenMesh::Vec3d(7.08069, -3.99408, 0),
	OpenMesh::Vec3d(4.17284, -0.459165, 0),
	OpenMesh::Vec3d(0.512756, -0.0850323, 0),
				};
			}
			CC_mesh = createMeshFromCurveCage(CC_points);
			curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
			Bezier2Bezier321(curvecage2, curvecage1);
			curvecage2 = curvecage1;
		}
		if (todegree == 2) {
			calculate_green_weight322();//先计算2次cage到1次控制点的权重
			{
				CC_points = { OpenMesh::Vec3d(0.060138, -2.34968, 0),
	OpenMesh::Vec3d(0.167533, -1.16113, 0),
	OpenMesh::Vec3d(0.304982, 0.160104, 0),
	OpenMesh::Vec3d(0.231798, 1.08177, 0),
	OpenMesh::Vec3d(0.61252, 2.32314, 0),
	OpenMesh::Vec3d(0.771864, 3.13087, 0),
	OpenMesh::Vec3d(0.855257, 4.5897, 0),
	OpenMesh::Vec3d(3.38975, 5.46352, 0),
	OpenMesh::Vec3d(4.41819, 7.10405, 0),
	OpenMesh::Vec3d(8.67744, 7.8645, 0),
	OpenMesh::Vec3d(4.59444, 11.1053, 0),
	OpenMesh::Vec3d(-2.40215, 10.8965, 0),
	OpenMesh::Vec3d(-7.26403, 7.93585, 0),
	OpenMesh::Vec3d(-4.30306, 6.87478, 0),
	OpenMesh::Vec3d(-2.76766, 5.30325, 0),
	OpenMesh::Vec3d(-0.552003, 4.00657, 0),
	OpenMesh::Vec3d(-0.0860061, 2.21267, 0),
	OpenMesh::Vec3d(0.0878497, 0.616274, 0),
	OpenMesh::Vec3d(-0.0636332, -0.969635, 0),
	OpenMesh::Vec3d(-1.42388, 1.41961, 0),
	OpenMesh::Vec3d(-3.71789, 1.96421, 0),
	OpenMesh::Vec3d(-7.39052, 1.52015, 0),
	OpenMesh::Vec3d(-5.55652, -0.704119, 0),
	OpenMesh::Vec3d(-3.16591, -1.64514, 0),
	OpenMesh::Vec3d(-0.29709, -1.64989, 0),
	OpenMesh::Vec3d(-0.284548, -4.19343, 0),
	OpenMesh::Vec3d(-4.56897, -5.40077, 0),
	OpenMesh::Vec3d(-3.58096, -9.71999, 0),
	OpenMesh::Vec3d(-3.51223, -4.61304, 0),
	OpenMesh::Vec3d(-0.378727, -4.82229, 0),
	OpenMesh::Vec3d(0.125836, -2.84884, 0),
	OpenMesh::Vec3d(1.10361, -2.36519, 0),
	OpenMesh::Vec3d(3.49, -2.80699, 0),
	OpenMesh::Vec3d(7.08069, -3.99408, 0),
	OpenMesh::Vec3d(4.17284, -0.459165, 0),
	OpenMesh::Vec3d(0.512756, -0.0850323, 0),
				};
			}
			CC_mesh = createMeshFromCurveCage(CC_points);
			curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
			Bezier2Bezier322(curvecage2, curvecage1);
			curvecage2 = curvecage1;
		}
		if (todegree == 7) {
			calculate_green_weight327();//先计算2次cage到1次控制点的权重
			{
				CC_points = { OpenMesh::Vec3d(0.060138, -2.34968, 0),
	OpenMesh::Vec3d(0.167533, -1.16113, 0),
	OpenMesh::Vec3d(0.304982, 0.160104, 0),
	OpenMesh::Vec3d(0.231798, 1.08177, 0),
	OpenMesh::Vec3d(0.61252, 2.32314, 0),
	OpenMesh::Vec3d(0.771864, 3.13087, 0),
	OpenMesh::Vec3d(0.855257, 4.5897, 0),
	OpenMesh::Vec3d(3.38975, 5.46352, 0),
	OpenMesh::Vec3d(4.41819, 7.10405, 0),
	OpenMesh::Vec3d(8.67744, 7.8645, 0),
	OpenMesh::Vec3d(4.59444, 11.1053, 0),
	OpenMesh::Vec3d(-2.40215, 10.8965, 0),
	OpenMesh::Vec3d(-7.26403, 7.93585, 0),
	OpenMesh::Vec3d(-4.30306, 6.87478, 0),
	OpenMesh::Vec3d(-2.76766, 5.30325, 0),
	OpenMesh::Vec3d(-0.552003, 4.00657, 0),
	OpenMesh::Vec3d(-0.0860061, 2.21267, 0),
	OpenMesh::Vec3d(0.0878497, 0.616274, 0),
	OpenMesh::Vec3d(-0.0636332, -0.969635, 0),
	OpenMesh::Vec3d(-1.42388, 1.41961, 0),
	OpenMesh::Vec3d(-3.71789, 1.96421, 0),
	OpenMesh::Vec3d(-7.39052, 1.52015, 0),
	OpenMesh::Vec3d(-5.55652, -0.704119, 0),
	OpenMesh::Vec3d(-3.16591, -1.64514, 0),
	OpenMesh::Vec3d(-0.29709, -1.64989, 0),
	OpenMesh::Vec3d(-0.284548, -4.19343, 0),
	OpenMesh::Vec3d(-4.56897, -5.40077, 0),
	OpenMesh::Vec3d(-3.58096, -9.71999, 0),
	OpenMesh::Vec3d(-3.51223, -4.61304, 0),
	OpenMesh::Vec3d(-0.378727, -4.82229, 0),
	OpenMesh::Vec3d(0.125836, -2.84884, 0),
	OpenMesh::Vec3d(1.10361, -2.36519, 0),
	OpenMesh::Vec3d(3.49, -2.80699, 0),
	OpenMesh::Vec3d(7.08069, -3.99408, 0),
	OpenMesh::Vec3d(4.17284, -0.459165, 0),
	OpenMesh::Vec3d(0.512756, -0.0850323, 0),
				};
			}
			CC_mesh = createMeshFromCurveCage(CC_points);
			curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
			Bezier2Bezier7(curvecage2, curvecage1);
			curvecage2 = curvecage1;
		}
	}
	//通过curvecage2计算cc_points;
	CC_points.clear();
	for (int i = 0; i < curvecage2.size(); i++) {
		for (int j = 0; j < todegree; j++) {
			CC_points.push_back(curvecage2[i][j]);
		}
	}
	CC_mesh = createMeshFromCurveCage(CC_points);
	auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
	for (auto vh : CC_mesh.vertices())
	{
		CagevertexState[vh] = NotSelected;
	}
	//highdegree = true;
	update();
}

void MeshViewerWidget::SetSMNodrawpoint(void)
{
	std::cout << "no select!" << std::endl;
	if (drawpoints)
		drawpoints = false;
	else
		drawpoints = true;
	update();
}

void MeshViewerWidget::SetSMAddpoints(void)
{
	std::cout << "add points!" << std::endl;
	auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
	int vertex_index;
	for (auto vh : CC_mesh.vertices())
	{
		if (CagevertexState[vh] == Custom) {
			vertex_index = vh.idx();
		}
		
	}
	// Get the points at vertex_index and vertex_index + 1
	Mesh::Point p1 = CC_points[vertex_index];
	Mesh::Point p2 = CC_points[vertex_index + 1];

	// Calculate the three division points
	Mesh::Point p1_third = p1 + (p2 - p1) / 4.0f;
	Mesh::Point p2_third = p1 + 2.0f * (p2 - p1) / 4.0f;
	Mesh::Point p3_third = p1 + 3.0f * (p2 - p1) / 4.0f;

	// Insert the three points into the vector
	CC_points.insert(CC_points.begin() + vertex_index + 1, p3_third); // Insert third division point
	CC_points.insert(CC_points.begin() + vertex_index + 1, p2_third); // Insert second division point
	CC_points.insert(CC_points.begin() + vertex_index + 1, p1_third); // Insert first division point
	
	CC_mesh = createMeshFromCurveCage(CC_points);
	CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
	for (auto vh : CC_mesh.vertices())
	{
		CagevertexState[vh] = NotSelected;
	}

	update();
}

void MeshViewerWidget::SetSMAddhandles(void)
{
	std::cout << "add handles!" << std::endl;
	
	// Get the points at vertex_index and vertex_index + 1
	Mesh::Point p1(0., 0., 0.);
	Mesh::Point p2(1., 0., 0.);

	Handle_points.push_back(p1);
	Handle_points.push_back(p2);

	partion_handles(Handle_points, deform_cps, deform_cps_t);

	Handle_mesh = createMeshFromCurveCage(Handle_points);
	auto HandlevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(Handle_mesh, "vertexState");
	for (auto vh : Handle_mesh.vertices())
	{
		HandlevertexState[vh] = NotSelected;
	}

	update();
}

void MeshViewerWidget::SetSMDrawDistort(void)
{
	std::cout << "draw distort!" << std::endl;
	if (!drawDistort && !drawDistortDirichlet)
		drawDistort = !drawDistort;
	else if (drawDistort && !drawDistortDirichlet)
	{
		drawDistort = !drawDistort;
		drawDistortDirichlet = !drawDistortDirichlet;
		DrawSmoothDistort();
	}
	else if (!drawDistort && drawDistortDirichlet)
	{
		drawDistortDirichlet = !drawDistortDirichlet;
		//DrawSmoothDistort();
	}

	

	update();
}

void MeshViewerWidget::SetSMMovehandles(void)
{
	std::cout << "calculate then move handles!" << std::endl;
	if (degree == 1)
		calculate_cauchy_weight121(deform_cps);
	if (degree == 2)
		calculate_cauchy_weight222(deform_cps);
	if (degree == 3)
		calculate_cauchy_weight323(deform_cps);
	//deform_cage_from_handles();
}



void MeshViewerWidget::SetSMNoSelect(void)
{
	//selectMode = NoSelect;
	std::cout << "no select!" << std::endl;
	drawpoints = false;
	update();
}

void MeshViewerWidget::ClearSelected(void)
{
	/*auto vertexState = OpenMesh::getProperty<OpenMesh::VertexHandle, VertexState>(mesh, "vertexState");
	for (auto vh : mesh.vertices())
	{
		vertexState[vh] = NotSelected;
	}*/
	Mesh deformedMesh;
	deformedMesh.assign(mesh);

	moveHistories.clear();
	currentHistoryPos = 0;
	if(!useHandle){
//	CC_points = { //deer
//OpenMesh::Vec3d(8.01426, -9.42736, 0),
//OpenMesh::Vec3d(8.33338, -9.22516, 0),
//OpenMesh::Vec3d(8.57722, -9.0101, 0),
//OpenMesh::Vec3d(8.8489, -8.78959, 0),
//OpenMesh::Vec3d(7.10063, -6.55714, 0),
//OpenMesh::Vec3d(6.71007, -5.29668, 0),
//OpenMesh::Vec3d(6.70587, -3.83298, 0),
//OpenMesh::Vec3d(5.83477, -2.3301, 0),
//OpenMesh::Vec3d(7.05116, -0.928495, 0),
//OpenMesh::Vec3d(6.61916, 0.630525, 0),
//OpenMesh::Vec3d(8.02456, 2.09566, 0),
//OpenMesh::Vec3d(8.65167, 3.70863, 0),
//OpenMesh::Vec3d(6.40582, 5.04416, 0),
//OpenMesh::Vec3d(6.37169, 3.87665, 0),
//OpenMesh::Vec3d(5.80833, 2.98216, 0),
//OpenMesh::Vec3d(5.62158, 2.09523, 0),
//OpenMesh::Vec3d(3.23511, 2.54016, 0),
//OpenMesh::Vec3d(0.750374, 1.38221, 0),
//OpenMesh::Vec3d(-1.69483, 2.49143, 0),
//OpenMesh::Vec3d(-3.65702, 4.17105, 0),
//OpenMesh::Vec3d(-2.17201, 6.0254, 0),
//OpenMesh::Vec3d(-3.05934, 7.31317, 0),
//OpenMesh::Vec3d(-1.89982, 8.15725, 0),
//OpenMesh::Vec3d(-1.63298, 9.67336, 0),
//OpenMesh::Vec3d(-2.82579, 10.398, 0),
//OpenMesh::Vec3d(-3.92575, 10.5965, 0),
//OpenMesh::Vec3d(-2.76592, 8.26476, 0),
//OpenMesh::Vec3d(-5.78046, 7.07922, 0),
//OpenMesh::Vec3d(-6.48863, 6.34431, 0),
//OpenMesh::Vec3d(-5.30909, 5.86309, 0),
//OpenMesh::Vec3d(-7.14945, 4.31455, 0),
//OpenMesh::Vec3d(-6.72589, 3.45316, 0),
//OpenMesh::Vec3d(-5.35703, 4.33777, 0),
//OpenMesh::Vec3d(-4.45691, 4.19383, 0),
//OpenMesh::Vec3d(-3.65641, 2.89317, 0),
//OpenMesh::Vec3d(-4.13472, -0.366618, 0),
//OpenMesh::Vec3d(-2.87246, -1.14708, 0),
//OpenMesh::Vec3d(-3.61957, -1.90331, 0),
//OpenMesh::Vec3d(-2.36707, -2.13026, 0),
//OpenMesh::Vec3d(-2.28264, -2.59782, 0),
//OpenMesh::Vec3d(-4.87634, -4.58312, 0),
//OpenMesh::Vec3d(-3.97765, -6.59246, 0),
//OpenMesh::Vec3d(-1.14421, -9.59584, 0),
//OpenMesh::Vec3d(-0.906403, -9.58534, 0),
//OpenMesh::Vec3d(-0.639413, -9.58154, 0),
//OpenMesh::Vec3d(-0.305103, -9.56834, 0),
//OpenMesh::Vec3d(-2.6836, -6.57468, 0),
//OpenMesh::Vec3d(-3.98979, -4.66978, 0),
//OpenMesh::Vec3d(-0.925819, -3.20408, 0),
//OpenMesh::Vec3d(0.770266, -1.45608, 0),
//OpenMesh::Vec3d(2.14696, -1.64475, 0),
//OpenMesh::Vec3d(3.40852, -2.90979, 0),
//OpenMesh::Vec3d(4.44002, -4.23804, 0),
//OpenMesh::Vec3d(5.05317, -4.38792, 0),
//OpenMesh::Vec3d(6.7502, -6.72501, 0),
//OpenMesh::Vec3d(7.59131, -7.41388, 0),
//OpenMesh::Vec3d(7.20539, -8.66758, 0),
//	};


//	CC_points = { //ball 变形
//		OpenMesh::Vec3d(4.93469, -4.95787, 0),
//OpenMesh::Vec3d(4.00952, -2.92598, 0),
//OpenMesh::Vec3d(3.73102, 1.06033, 0),
//OpenMesh::Vec3d(4.89974, 5.07107, 0),
//OpenMesh::Vec3d(1.80626, 2.01981, 0),
//OpenMesh::Vec3d(-2.8923, 2.12251, 0),
//OpenMesh::Vec3d(-5.78844, 4.26243, 0),
//OpenMesh::Vec3d(-4.26235, 1.69334, 0),
//OpenMesh::Vec3d(-4.06703, -2.70747, 0),
//OpenMesh::Vec3d(-4.89242, -5.17084, 0),
//OpenMesh::Vec3d(-2.12912, -3.0845, 0),
//OpenMesh::Vec3d(1.4489, -2.94237, 0),
//	};
//	CC_points = {//changjinlu
//OpenMesh::Vec3d(4.26544, -2.08319, 0),
//OpenMesh::Vec3d(2.14808, -1.76166, 0),
//OpenMesh::Vec3d(1.05683, 0.58523, 0),
//OpenMesh::Vec3d(-0.959219, 1.60384, 0),
//OpenMesh::Vec3d(-2.12218, 6.64445, 0),
//OpenMesh::Vec3d(-7.00934, 10.7648, 0),
//OpenMesh::Vec3d(-3.68572, 13.2197, 0),
//OpenMesh::Vec3d(-5.01245, 15.6318, 0),
//OpenMesh::Vec3d(-7.78227, 15.2923, 0),
//OpenMesh::Vec3d(-9.72932, 12.9165, 0),
//OpenMesh::Vec3d(-8.66079, 7.13327, 0),
//OpenMesh::Vec3d(-4.31018, 5.64754, 0),
//OpenMesh::Vec3d(-4.30619, 1.46692, 0),
//OpenMesh::Vec3d(-5.6163, -8.3802, 0),
//OpenMesh::Vec3d(-7.78844, -18.0231, 0),
//OpenMesh::Vec3d(2.65463, -13.4286, 0),
//OpenMesh::Vec3d(0.741755, -4.48237, 0),
//OpenMesh::Vec3d(2.73214, -4.76554, 0),
//OpenMesh::Vec3d(3.64475, -3.15402, 0),
//OpenMesh::Vec3d(5.22527, -2.66165, 0),
//OpenMesh::Vec3d(6.60758, -3.9218, 0),
//OpenMesh::Vec3d(6.79063, -7.53675, 0),
//OpenMesh::Vec3d(8.52689, -0.989955, 0),
//OpenMesh::Vec3d(5.22416, -1.9387, 0),
//	};

	CC_points = {//paris tower
		OpenMesh::Vec3d(2.21312, -3.64502, 0),
OpenMesh::Vec3d(0.0729413, -1.26159, 0),
OpenMesh::Vec3d(0.71968, 2.04631, 0),
OpenMesh::Vec3d(-3.67721, 2.8085, 0),
OpenMesh::Vec3d(-0.533977, 2.06356, 0),
OpenMesh::Vec3d(0.020478, -1.26554, 0),
OpenMesh::Vec3d(-2.13172, -3.62273, 0),
OpenMesh::Vec3d(-1.5717, -3.65431, 0),
OpenMesh::Vec3d(-0.789005, -3.66778, 0),
OpenMesh::Vec3d(-0.017268, -3.66608, 0),
OpenMesh::Vec3d(0.997374, -3.65183, 0),
OpenMesh::Vec3d(1.73898, -3.63311, 0),
	};//测测的
//	CC_mesh = createMeshFromCurveCage(CC_points);
//	curvecage2 = CCpoints_fromCCmesh(CC_mesh, 3);
//	for (int i = 0; i < curvecage2.size(); i++)
//	{
//		BezierCurve c_temp(curvecage2[i], false);
//		auto p31 = c_temp.Evaluate(1. / 3);
//		auto p32 = c_temp.Evaluate(2. / 3);
//		CC_points[3 * i + 1] = p31;
//		CC_points[3 * i + 2] = p32;
//	}
	/*CC_points = { OpenMesh::Vec3d(2.21312, -3.64502, 0),
OpenMesh::Vec3d(0.27768, -1.19251, 0),
OpenMesh::Vec3d(-1.10464, 0.951851, 0),
OpenMesh::Vec3d(-3.5787, 2.79865, 0),
OpenMesh::Vec3d(-1.96114, 0.959281, 0),
OpenMesh::Vec3d(-0.970674, -1.21779, 0),
OpenMesh::Vec3d(-2.13172, -3.62273, 0),
OpenMesh::Vec3d(-0.68344, -3.63016, 0),
OpenMesh::Vec3d(0.76484, -3.63759, 0),
	};*/


	//双调和后的tower
	/*CC_points = { OpenMesh::Vec3d(2.21312, -3.64502, 0),
OpenMesh::Vec3d(-0.200273, -1.09766, 0),
OpenMesh::Vec3d(0.410037, 1.70935, 0),
OpenMesh::Vec3d(-2.93953, 2.89046, 0),
OpenMesh::Vec3d(-0.707013, 1.49892, 0),
OpenMesh::Vec3d(0.147978, -1.42036, 0),
OpenMesh::Vec3d(-2.13172, -3.62273, 0),
OpenMesh::Vec3d(-1.5717, -3.65431, 0),
OpenMesh::Vec3d(-0.789005, -3.66778, 0),
OpenMesh::Vec3d(-0.017268, -3.66608, 0),
OpenMesh::Vec3d(0.997374, -3.65183, 0),
OpenMesh::Vec3d(1.73898, -3.63311, 0),
	};*/

//	CC_points = { //xiyi
//		OpenMesh::Vec3d(4.92078, 0.75431, 0),
//OpenMesh::Vec3d(4.92171, 0.341636, 0),
//OpenMesh::Vec3d(4.44507, 0.0967474, 0),
//OpenMesh::Vec3d(3.96134, 0.159551, 0),
//OpenMesh::Vec3d(3.47603, 0.311732, 0),
//OpenMesh::Vec3d(2.88748, 0.628007, 0),
//OpenMesh::Vec3d(2.29758, 0.985943, 0),
//OpenMesh::Vec3d(1.85205, 1.32421, 0),
//OpenMesh::Vec3d(1.40636, 1.68818, 0),
//OpenMesh::Vec3d(0.899758, 1.92868, 0),
//OpenMesh::Vec3d(-6.36326, 3.14212, 0),
//OpenMesh::Vec3d(-6.99906, 0.160185, 0),
//OpenMesh::Vec3d(-3.73234, -0.87026, 0),
//OpenMesh::Vec3d(-4.44834, -2.77133, 0),
//OpenMesh::Vec3d(-1.61845, -2.46282, 0),
//OpenMesh::Vec3d(1.3063, -2.28422, 0),
//OpenMesh::Vec3d(2.40598, -1.75447, 0),
//OpenMesh::Vec3d(3.4009, -1.70409, 0),
//OpenMesh::Vec3d(3.97396, -0.721832, 0),
//OpenMesh::Vec3d(4.7022, -0.574047, 0),
//OpenMesh::Vec3d(5.43234, -0.237719, 0),
//OpenMesh::Vec3d(5.27836, 0.536115, 0),
//OpenMesh::Vec3d(5.24537, 0.81085, 0),
//OpenMesh::Vec3d(5.21128, 0.978488, 0),
//OpenMesh::Vec3d(5.163, 1.1691, 0),
//OpenMesh::Vec3d(5.1308, 1.26986, 0),
//OpenMesh::Vec3d(5.11452, 1.35778, 0),
//OpenMesh::Vec3d(5.0679, 1.44686, 0),
//OpenMesh::Vec3d(5.03641, 1.5098, 0),
//OpenMesh::Vec3d(4.9936, 1.58935, 0),
//OpenMesh::Vec3d(4.95548, 1.6604, 0),
//OpenMesh::Vec3d(4.93293, 1.71456, 0),
//OpenMesh::Vec3d(4.90947, 1.76926, 0),
//OpenMesh::Vec3d(4.89419, 1.81234, 0),
//OpenMesh::Vec3d(4.88076, 1.85356, 0),
//OpenMesh::Vec3d(4.83605, 1.93948, 0),
//OpenMesh::Vec3d(4.80808, 1.97549, 0),
//OpenMesh::Vec3d(4.76601, 1.94966, 0),
//OpenMesh::Vec3d(4.64732, 1.87148, 0),
//OpenMesh::Vec3d(4.73483, 1.7446, 0),
//OpenMesh::Vec3d(4.76038, 1.71223, 0),
//OpenMesh::Vec3d(4.80796, 1.67724, 0),
//OpenMesh::Vec3d(4.81982, 1.64139, 0),
//OpenMesh::Vec3d(4.85015, 1.5427, 0),
//OpenMesh::Vec3d(4.85435, 1.46805, 0),
//OpenMesh::Vec3d(4.88057, 1.39875, 0),
//OpenMesh::Vec3d(4.91037, 1.32445, 0),
//OpenMesh::Vec3d(4.92414, 1.23595, 0),
//OpenMesh::Vec3d(4.92582, 1.1442, 0),
//OpenMesh::Vec3d(4.92959, 1.02978, 0),
//OpenMesh::Vec3d(4.93091, 0.924267, 0)
//	};

//CC_points = { // dol
//OpenMesh::Vec3d(0.63761, -0.660277, 0),
//OpenMesh::Vec3d(3.14003, -0.732556, 0),
//OpenMesh::Vec3d(3.0645, 1.3484, 0),
//OpenMesh::Vec3d(4.38427, 2.42837, 0),
//OpenMesh::Vec3d(5.56291, 3.20101, 0),
//OpenMesh::Vec3d(7.65234, 4.09488, 0),
//OpenMesh::Vec3d(7.27868, 6.14083, 0),
//OpenMesh::Vec3d(6.2098, 7.90869, 0),
//OpenMesh::Vec3d(3.90938, 9.23955, 0),
//OpenMesh::Vec3d(-0.0891882, 9.18919, 0),
//OpenMesh::Vec3d(-4.56112, 8.60392, 0),
//OpenMesh::Vec3d(-6.77834, 6.79633, 0),
//OpenMesh::Vec3d(-10.6223, 3.6997, 0),
//OpenMesh::Vec3d(-13.3975, 0.700892, 0),
//OpenMesh::Vec3d(-13.4554, -0.858672, 0),
//OpenMesh::Vec3d(-14.544, -2.53266, 0),
//OpenMesh::Vec3d(-15.4846, -4.20564, 0),
//OpenMesh::Vec3d(-24.3779, -6.61914, 0),
//OpenMesh::Vec3d(-17.6743, -10.0401, 0),
//OpenMesh::Vec3d(-13.0741, -12.4505, 0),
//OpenMesh::Vec3d(-10.7654, -13.9095, 0),
//OpenMesh::Vec3d(-6.00619, -6.90196, 0),
//OpenMesh::Vec3d(-1.84791, -1.38715, 0),
//OpenMesh::Vec3d(-0.190255, -0.48011, 0),
//};

//CC_points = { //chong
//OpenMesh::Vec3d(2.31172, -2.24835, 0),
//OpenMesh::Vec3d(2.93226, -2.00103, 0),
//OpenMesh::Vec3d(2.84555, -0.942774, 0),
//OpenMesh::Vec3d(1.9832, -1.02767, 0),
//OpenMesh::Vec3d(0.79348, -1.31285, 0),
//OpenMesh::Vec3d(0.435181, -1.23997, 0),
//OpenMesh::Vec3d(0.121183, -1.23926, 0),
//OpenMesh::Vec3d(-0.219802, -1.18486, 0),
//OpenMesh::Vec3d(-0.695866, -1.3576, 0),
//OpenMesh::Vec3d(-1.28263, -1.28898, 0),
//OpenMesh::Vec3d(-1.68982, -1.26859, 0),
//OpenMesh::Vec3d(-2.46385, -1.34415, 0),
//OpenMesh::Vec3d(-3.28917, -1.21649, 0),
//OpenMesh::Vec3d(-3.80408, -1.2099, 0),
//OpenMesh::Vec3d(-3.93492, -2.05121, 0),
//OpenMesh::Vec3d(-3.36134, -2.13236, 0),
//OpenMesh::Vec3d(-2.45401, -2.27473, 0),
//OpenMesh::Vec3d(-1.94868, -2.24872, 0),
//OpenMesh::Vec3d(-1.40602, -2.22918, 0),
//OpenMesh::Vec3d(-0.741744, -2.25685, 0),
//OpenMesh::Vec3d(-0.227673, -2.13926, 0),
//OpenMesh::Vec3d(0.341261, -2.20653, 0),
//OpenMesh::Vec3d(1.52086, -2.35177, 0),
//OpenMesh::Vec3d(2.03308, -2.3683, 0),
//};
//CC_points = { //yezi
//OpenMesh::Vec3d(1.28005, 0.747643, 0),
//OpenMesh::Vec3d(1.59587, 1.37881, 0),
//OpenMesh::Vec3d(2.83807, 2.46742, 0),
//OpenMesh::Vec3d(0.599109, 1.41282, 0),
//OpenMesh::Vec3d(0.595919, 1.76723, 0),
//OpenMesh::Vec3d(-0.419939, 3.77188, 0),
//OpenMesh::Vec3d(-0.261508, 1.77209, 0),
//OpenMesh::Vec3d(-0.789817, 1.51979, 0),
//OpenMesh::Vec3d(-1.92133, 3.38804, 0),
//OpenMesh::Vec3d(-1.10456, 0.78307, 0),
//OpenMesh::Vec3d(-2.62032, 0.228932, 0),
//OpenMesh::Vec3d(-1.9933, -0.408598, 0),
//OpenMesh::Vec3d(-1.28621, -0.174901, 0),
//OpenMesh::Vec3d(-0.201279, 0.516323, 0),
//OpenMesh::Vec3d(-1.29493, -0.622261, 0),
//OpenMesh::Vec3d(-2.18399, -1.25927, 0),
//OpenMesh::Vec3d(-3.16523, -1.90528, 0),
//OpenMesh::Vec3d(-2.21709, -3.00135, 0),
//OpenMesh::Vec3d(-1.52962, -1.68603, 0),
//OpenMesh::Vec3d(-0.934208, -0.589085, 0),
//OpenMesh::Vec3d(-0.131823, 0.466649, 0),
//OpenMesh::Vec3d(0.0477148, -0.377318, 0),
//OpenMesh::Vec3d(0.651505, -1.86746, 0),
//OpenMesh::Vec3d(1.61528, -1.355, 0),
//OpenMesh::Vec3d(0.757984, 0.0465247, 0),
//OpenMesh::Vec3d(1.4688, -0.254338, 0),
//OpenMesh::Vec3d(2.96672, -0.596237, 0),
//};
//CC_points = { //hat
//OpenMesh::Vec3d(0.341161, 0.0279293, 0),
//OpenMesh::Vec3d(-0.36466, 1.00387, 0),
//OpenMesh::Vec3d(-0.344373, 1.24921, 0),
//OpenMesh::Vec3d(-0.218735, 1.38934, 0),
//OpenMesh::Vec3d(-0.0336582, 1.54203, 0),
//OpenMesh::Vec3d(0.135403, 1.5512, 0),
//OpenMesh::Vec3d(0.72612, 0.465361, 0),
//OpenMesh::Vec3d(1.53273, 1.97175, 0),
//OpenMesh::Vec3d(0.148393, 3.14242, 0),
//OpenMesh::Vec3d(-0.870971, 2.29525, 0),
//OpenMesh::Vec3d(-1.54674, 1.57033, 0),
//OpenMesh::Vec3d(-1.36614, -0.00844352, 0),
//OpenMesh::Vec3d(-0.943107, -0.507909, 0),
//OpenMesh::Vec3d(-0.671505, -0.924759, 0),
//OpenMesh::Vec3d(-1.43117, -2.31645, 0),
//OpenMesh::Vec3d(-0.862172, -2.63141, 0),
//OpenMesh::Vec3d(-0.42769, -2.76733, 0),
//OpenMesh::Vec3d(-0.174053, -2.76644, 0),
//OpenMesh::Vec3d(0.0921805, -2.76908, 0),
//OpenMesh::Vec3d(0.296833, -2.7896, 0),
//OpenMesh::Vec3d(0.544134, -2.79181, 0),
//OpenMesh::Vec3d(0.949696, -2.61659, 0),
//OpenMesh::Vec3d(1.4252, -2.32336, 0),
//OpenMesh::Vec3d(0.902503, -0.854805, 0),
//};

//CC_points = { //seahorse
//OpenMesh::Vec3d(1.10587, -11.3535, 0),
//OpenMesh::Vec3d(9.82732, -11.166, 0),
//OpenMesh::Vec3d(6.46635, -1.71038, 0),
//OpenMesh::Vec3d(5.34163, 0.357431, 0),
//OpenMesh::Vec3d(4.07309, 2.29787, 0),
//OpenMesh::Vec3d(5.07445, 3.81767, 0),
//OpenMesh::Vec3d(5.52096, 5.0543, 0),
//OpenMesh::Vec3d(5.98136, 6.20066, 0),
//OpenMesh::Vec3d(9.82471, 8.13143, 0),
//OpenMesh::Vec3d(6.49376, 12.0033, 0),
//OpenMesh::Vec3d(4.29714, 13.8646, 0),
//OpenMesh::Vec3d(0.593434, 11.1102, 0),
//OpenMesh::Vec3d(0.626391, 11.8899, 0),
//OpenMesh::Vec3d(0.617458, 13.3146, 0),
//OpenMesh::Vec3d(1.66547, 14.8711, 0),
//OpenMesh::Vec3d(-2.29227, 14.9617, 0),
//OpenMesh::Vec3d(-3.06409, 10.0616, 0),
//OpenMesh::Vec3d(2.11885, 7.86408, 0),
//OpenMesh::Vec3d(0.766875, 6.38087, 0),
//OpenMesh::Vec3d(-2.17808, 3.08898, 0),
//OpenMesh::Vec3d(-2.22258, 0.578676, 0),
//OpenMesh::Vec3d(-1.28324, -1.09501, 0),
//OpenMesh::Vec3d(-0.259984, -2.38225, 0),
//OpenMesh::Vec3d(3.32626, -4.16305, 0),
//OpenMesh::Vec3d(3.13432, -6.30106, 0),
//OpenMesh::Vec3d(2.14658, -7.28983, 0),
//OpenMesh::Vec3d(0.71665, -6.12485, 0),
//OpenMesh::Vec3d(1.62584, -5.56678, 0),
//OpenMesh::Vec3d(2.42903, -5.04416, 0),
//OpenMesh::Vec3d(2.69342, -6.32512, 0),
//OpenMesh::Vec3d(3.3514, -4.32757, 0),
//OpenMesh::Vec3d(2.06371, -2.91663, 0),
//OpenMesh::Vec3d(0.521438, -1.92251, 0),
//OpenMesh::Vec3d(-2.52941, -2.43938, 0),
//OpenMesh::Vec3d(-5.55292, -3.08583, 0),
//OpenMesh::Vec3d(-4.98893, -10.2899, 0)
//};

//CC_points = { //jinglin
//OpenMesh::Vec3d(1.91972, 0.195116, 0),
//OpenMesh::Vec3d(6.08424, 2.23706, 0),
//OpenMesh::Vec3d(3.64262, 3.74024, 0),
//OpenMesh::Vec3d(1.68019, 2.15192, 0),
//OpenMesh::Vec3d(3.61726, 3.73099, 0),
//OpenMesh::Vec3d(3.25275, 4.43643, 0),
//OpenMesh::Vec3d(1.9032, 3.7464, 0),
//OpenMesh::Vec3d(0.512868, 4.04792, 0),
//OpenMesh::Vec3d(0.483428, 4.64027, 0),
//OpenMesh::Vec3d(1.98064, 5.33259, 0),
//OpenMesh::Vec3d(0.121486, 5.99051, 0),
//OpenMesh::Vec3d(-1.03984, 4.91636, 0),
//OpenMesh::Vec3d(-1.58463, 3.64843, 0),
//OpenMesh::Vec3d(-3.01756, 5.00816, 0),
//OpenMesh::Vec3d(-3.07664, 3.92272, 0),
//OpenMesh::Vec3d(-1.38212, 2.17469, 0),
//OpenMesh::Vec3d(-2.1839, 2.24673, 0),
//OpenMesh::Vec3d(-4.00185, 2.17792, 0),
//OpenMesh::Vec3d(-1.54477, 0.876463, 0),
//OpenMesh::Vec3d(-2.09305, 1.03224, 0),
//OpenMesh::Vec3d(-4.17669, 1.44912, 0),
//OpenMesh::Vec3d(-2.3295, 2.48603, 0),
//OpenMesh::Vec3d(-5.0686, 2.7207, 0),
//OpenMesh::Vec3d(-4.57053, 0.206897, 0),
//OpenMesh::Vec3d(-1.68457, -0.127649, 0),
//OpenMesh::Vec3d(-3.55245, -1.30047, 0),
//OpenMesh::Vec3d(-4.67804, -1.76622, 0),
//OpenMesh::Vec3d(-6.41525, -1.5929, 0),
//OpenMesh::Vec3d(-2.4434, -3.82286, 0),
//OpenMesh::Vec3d(-1.78583, -2.11598, 0),
//OpenMesh::Vec3d(-1.6909, -3.68632, 0),
//OpenMesh::Vec3d(-1.6105, -5.08009, 0),
//OpenMesh::Vec3d(-1.686, -6.03777, 0),
//OpenMesh::Vec3d(-2.18741, -8.09184, 0),
//OpenMesh::Vec3d(-0.328675, -8.19098, 0),
//OpenMesh::Vec3d(-0.0389428, -7.00424, 0),
//OpenMesh::Vec3d(-0.232178, -5.09547, 0),
//OpenMesh::Vec3d(-0.23406, -3.13166, 0),
//OpenMesh::Vec3d(0.323718, -4.1617, 0),
//OpenMesh::Vec3d(1.31864, -5.35324, 0),
//OpenMesh::Vec3d(2.51279, -6.45389, 0),
//OpenMesh::Vec3d(6.17274, -5.39508, 0),
//OpenMesh::Vec3d(3.35554, -4.29179, 0),
//OpenMesh::Vec3d(1.68528, -4.27782, 0),
//OpenMesh::Vec3d(1.93536, -3.37731, 0),
//OpenMesh::Vec3d(3.08036, -2.66735, 0),
//OpenMesh::Vec3d(8.30976, -2.48261, 0),
//OpenMesh::Vec3d(4.64093, -1.40544, 0),
//};
//CC_points = { //yu
//	OpenMesh::Vec3d(1.92641, -1.5622, 0),
//OpenMesh::Vec3d(1.92093, -1.42981, 0),
//OpenMesh::Vec3d(1.91418, -1.27198, 0),
//OpenMesh::Vec3d(1.90741, -1.11983, 0),
//OpenMesh::Vec3d(1.90298, -0.988665, 0),
//OpenMesh::Vec3d(1.90126, -0.842423, 0),
//OpenMesh::Vec3d(1.89499, -0.723717, 0),
//OpenMesh::Vec3d(1.88534, -0.589824, 0),
//OpenMesh::Vec3d(0.918267, 2.37635, 0),
//OpenMesh::Vec3d(0.189832, -5.62026, 0),
//OpenMesh::Vec3d(-1.08374, 2.40682, 0),
//OpenMesh::Vec3d(-1.3776, 0.930637, 0),
//OpenMesh::Vec3d(-2.33054, -3.02618, 0),
//OpenMesh::Vec3d(-2.78674, 1.10829, 0),
//OpenMesh::Vec3d(-3.24116, -0.577623, 0),
//OpenMesh::Vec3d(-3.23842, -0.686008, 0),
//OpenMesh::Vec3d(-3.23358, -0.780003, 0),
//OpenMesh::Vec3d(-3.22776, -0.859145, 0),
//OpenMesh::Vec3d(-3.22375, -0.936334, 0),
//OpenMesh::Vec3d(-3.22635, -1.01901, 0),
//OpenMesh::Vec3d(-3.22532, -1.11623, 0),
//OpenMesh::Vec3d(-3.2268, -1.23156, 0),
//OpenMesh::Vec3d(-2.75638, 0.473092, 0),
//OpenMesh::Vec3d(-2.32616, -3.6897, 0),
//OpenMesh::Vec3d(-1.35225, 0.368065, 0),
//OpenMesh::Vec3d(-1.1074, 2.01805, 0),
//OpenMesh::Vec3d(0.203981, -5.85821, 0),
//OpenMesh::Vec3d(0.949495, 1.71095, 0),
//};

//kuzi
//CC_points = {
//	//kuzi
//	OpenMesh::Vec3d(11.4493, 14.8504, 0),
//OpenMesh::Vec3d(6.50769, 22.2384, 0),
//OpenMesh::Vec3d(-3.7327, 14.8504, 0),
//OpenMesh::Vec3d(-11.3237, 14.8504, 0),
//OpenMesh::Vec3d(-10.855, -2.94221, 0),
//OpenMesh::Vec3d(-13.0942, -0.373684, 0),
//OpenMesh::Vec3d(-21.0616, -0.669252, 0),
//OpenMesh::Vec3d(-20.9948, -3.2209, 0),
//OpenMesh::Vec3d(-21.0322, -5.72048, 0),
//OpenMesh::Vec3d(-21.382, -7.49102, 0),
//OpenMesh::Vec3d(-14.1957, -7.37668, 0),
//OpenMesh::Vec3d(-0.656309, -9.60571, 0),
//OpenMesh::Vec3d(-0.812533, 1.34013, 0),
//OpenMesh::Vec3d(-0.232666, 1.34382, 0),
//OpenMesh::Vec3d(0.3472, 1.34751, 0),
//OpenMesh::Vec3d(0.927067, 1.3512, 0),
//OpenMesh::Vec3d(8.48836, 0.617676, 0),
//OpenMesh::Vec3d(13.901, -5.79966, 0),
//OpenMesh::Vec3d(14.4254, -15.146, 0),
//OpenMesh::Vec3d(17.9292, -15.146, 0),
//OpenMesh::Vec3d(21.4329, -15.146, 0),
//OpenMesh::Vec3d(24.9366, -15.146, 0),
//OpenMesh::Vec3d(24.7283, 0.459509, 0),
//OpenMesh::Vec3d(11.4493, 4.86897, 0),
//};

//CC_points = { //tree
//OpenMesh::Vec3d(2.0537, -0.435543, 0),
//OpenMesh::Vec3d(1.49692, -0.37487, 0),
//OpenMesh::Vec3d(1.33058, 0.209637, 0),
//OpenMesh::Vec3d(1.27165, 0.40987, 0),
//OpenMesh::Vec3d(1.36334, 0.501755, 0),
//OpenMesh::Vec3d(1.46979, 0.472587, 0),
//OpenMesh::Vec3d(1.64334, 0.578146, 0),
//OpenMesh::Vec3d(1.31127, 0.711767, 0),
//OpenMesh::Vec3d(0.324724, 1.8227, 0),
//OpenMesh::Vec3d(1.17013, 2.49899, 0),
//OpenMesh::Vec3d(-0.07839, 2.41016, 0),
//OpenMesh::Vec3d(-0.506334, 0.682899, 0),
//OpenMesh::Vec3d(-0.973036, 0.588728, 0),
//OpenMesh::Vec3d(-0.764894, 0.562184, 0),
//OpenMesh::Vec3d(-0.693146, 0.448528, 0),
//OpenMesh::Vec3d(-0.524623, 0.442704, 0),
//OpenMesh::Vec3d(-0.708671, 0.121208, 0),
//OpenMesh::Vec3d(-0.894053, -0.312081, 0),
//OpenMesh::Vec3d(-1.29552, -0.425553, 0),
//OpenMesh::Vec3d(-1.18172, -0.613284, 0),
//OpenMesh::Vec3d(-1.04982, -0.658767, 0),
//OpenMesh::Vec3d(-0.883788, -0.63228, 0),
//OpenMesh::Vec3d(-0.936324, -1.01509, 0),
//OpenMesh::Vec3d(-1.12625, -1.14854, 0),
//OpenMesh::Vec3d(-1.80669, -1.18906, 0),
//OpenMesh::Vec3d(-1.20328, -1.71551, 0),
//OpenMesh::Vec3d(-0.500752, -1.73562, 0),
//OpenMesh::Vec3d(-0.113223, -1.71689, 0),
//OpenMesh::Vec3d(-0.111229, -1.83346, 0),
//OpenMesh::Vec3d(-0.118549, -2.00999, 0),
//OpenMesh::Vec3d(-0.132176, -2.20222, 0),
//OpenMesh::Vec3d(0.215863, -2.19158, 0),
//OpenMesh::Vec3d(0.47987, -2.20167, 0),
//OpenMesh::Vec3d(0.864429, -2.22463, 0),
//OpenMesh::Vec3d(0.872264, -2.0404, 0),
//OpenMesh::Vec3d(0.888873, -1.84137, 0),
//OpenMesh::Vec3d(0.894361, -1.69082, 0),
//OpenMesh::Vec3d(1.41142, -1.76007, 0),
//OpenMesh::Vec3d(1.94926, -1.72271, 0),
//OpenMesh::Vec3d(2.59947, -1.0991, 0),
//OpenMesh::Vec3d(1.81581, -1.05268, 0),
//OpenMesh::Vec3d(1.60456, -0.927927, 0),
//OpenMesh::Vec3d(1.54771, -0.617916, 0),
//OpenMesh::Vec3d(1.6809, -0.650369, 0),
//OpenMesh::Vec3d(1.85804, -0.62592, 0),
//};

		{ // 新sheji
			/*CC_points = { OpenMesh::Vec3d(-19.97, -12.93, 0),
OpenMesh::Vec3d(-8.07116, -13.4039, 0),
OpenMesh::Vec3d(2.73905, -20.0582, 0),
OpenMesh::Vec3d(3.93699, -33.6234, 0),
OpenMesh::Vec3d(21.8838, -32.7331, 0),
OpenMesh::Vec3d(39.6629, -32.1336, 0),
OpenMesh::Vec3d(58.5242, -31.8953, 0),
OpenMesh::Vec3d(51.7882, 13.6405, 0),
OpenMesh::Vec3d(7.99005, 20.4923, 0),
OpenMesh::Vec3d(-19.97, 12.93, 0),
OpenMesh::Vec3d(-19.9975, 4.23817, 0),
OpenMesh::Vec3d(-19.8525, -4.41174, 0),
			};*/
		}


 
//auto sub_points = subdivideCage3(CC_points);//测试细分
//CC_points = sub_points;//测试细分

//CC_points = {//car
//OpenMesh::Vec3d(18.207, -4.48427, 0),
//OpenMesh::Vec3d(17.0602, -0.865747, 0),
//OpenMesh::Vec3d(16.9603, 3.13988, 0),
//OpenMesh::Vec3d(13.1047, 2.52286, 0),
//OpenMesh::Vec3d(14.1094, 21.6961, 0),
//OpenMesh::Vec3d(4.01465, 16.2523, 0),
//OpenMesh::Vec3d(-2.6146, 4.44862, 0),
//OpenMesh::Vec3d(-6.64821, 6.31885, 0),
//OpenMesh::Vec3d(-12.1076, 5.34944, 0),
//OpenMesh::Vec3d(-12.7923, -2.21603, 0),
//OpenMesh::Vec3d(-5.40276, -4.51037, 0),
//OpenMesh::Vec3d(8.38458, 0.846978, 0),
//};

//CC_points = {//tuzi
//	OpenMesh::Vec3d(1.2338, -0.872146, 0),
//OpenMesh::Vec3d(0.848741, -0.488863, 0),
//OpenMesh::Vec3d(0.994741, -0.428605, 0),
//OpenMesh::Vec3d(1.03727, -0.118332, 0),
//OpenMesh::Vec3d(1.48523, -0.403536, 0),
//OpenMesh::Vec3d(0.959169, -0.893975, 0),
//OpenMesh::Vec3d(1.47613, -1.00747, 0),
//OpenMesh::Vec3d(1.97429, -0.710009, 0),
//OpenMesh::Vec3d(1.54183, 0.144788, 0),
//OpenMesh::Vec3d(0.507068, 0.378323, 0),
//OpenMesh::Vec3d(-0.335255, 0.525864, 0),
//OpenMesh::Vec3d(-0.896345, 0.022467, 0),
//OpenMesh::Vec3d(-0.979956, -0.381595, 0),
//OpenMesh::Vec3d(-1.03288, -0.89268, 0),
//OpenMesh::Vec3d(-1.25456, -0.83442, 0),
//OpenMesh::Vec3d(-1.21265, -1.61744, 0),
//OpenMesh::Vec3d(-0.690139, -1.62269, 0),
//OpenMesh::Vec3d(-0.28394, -1.64832, 0),
//OpenMesh::Vec3d(0.223731, -1.65626, 0),
//OpenMesh::Vec3d(0.416271, -1.6679, 0),
//OpenMesh::Vec3d(0.533081, -1.66271, 0),
//OpenMesh::Vec3d(0.753259, -1.66561, 0),
//OpenMesh::Vec3d(0.811291, -1.37615, 0),
//OpenMesh::Vec3d(1.19484, -1.34047, 0),
//};
 

//CC_points = { //daizi
//	OpenMesh::Vec3d(-45.4715, -4.44834, 0),
//OpenMesh::Vec3d(-45.1077, -3.19904, 0),
//OpenMesh::Vec3d(-43.3737, -2.21489, 0),
//OpenMesh::Vec3d(-44.2633, -0.503097, 0),
//OpenMesh::Vec3d(-44.2644, 0.337876, 0),
//OpenMesh::Vec3d(-41.3244, 1.5609, 0),
//OpenMesh::Vec3d(-41.3281, 2.27688, 0),
//OpenMesh::Vec3d(-41.3336, 3.49199, 0),
//OpenMesh::Vec3d(-72.1444, -2.66667, 0),
//OpenMesh::Vec3d(-77.7012, -26.7162, 0),
//OpenMesh::Vec3d(-60.2857, -59.3187, 0),
//OpenMesh::Vec3d(-22.2499, -59.0844, 0),
//OpenMesh::Vec3d(-7.31521, -26.3709, 0),
//OpenMesh::Vec3d(-16.4601, -3.0048, 0),
//OpenMesh::Vec3d(-45.0842, 3.50565, 0),
//OpenMesh::Vec3d(-45.0786, 2.25173, 0),
//OpenMesh::Vec3d(-45.0749, 1.22532, 0),
//OpenMesh::Vec3d(-42.7613, 0.304172, 0),
//OpenMesh::Vec3d(-42.7602, -0.536801, 0),
//OpenMesh::Vec3d(-43.7393, -2.27171, 0),
//OpenMesh::Vec3d(-41.8222, -3.21588, 0),
//OpenMesh::Vec3d(-41.8222, -4.45255, 0),
//OpenMesh::Vec3d(-20.0514, -7.14788, 0),
//OpenMesh::Vec3d(-14.1207, -26.0952, 0),
//OpenMesh::Vec3d(-25.508, -54.5302, 0),
//OpenMesh::Vec3d(-56.9787, -54.7188, 0),
//OpenMesh::Vec3d(-71.292, -26.2217, 0),
//OpenMesh::Vec3d(-66.6177, -7.2701, 0),
//};
 

//CC_points = { //fish
//	OpenMesh::Vec3d(8.43404, -9.00585, 0),
//OpenMesh::Vec3d(7.47304, -1.84145, 0),
//OpenMesh::Vec3d(7.60398, -0.916129, 0),
//OpenMesh::Vec3d(10.8396, 7.86985, 0),
//OpenMesh::Vec3d(8.99175, 1.64069, 0),
//OpenMesh::Vec3d(4.69127, -0.627544, 0),
//OpenMesh::Vec3d(2.66809, -0.0643164, 0),
//OpenMesh::Vec3d(2.72136, 0.590422, 0),
//OpenMesh::Vec3d(1.37385, 1.77557, 0),
//OpenMesh::Vec3d(0.240029, 1.49932, 0),
//OpenMesh::Vec3d(-2.49334, 2.50637, 0),
//OpenMesh::Vec3d(-6.33127, 3.18449, 0),
//OpenMesh::Vec3d(-8.90656, 2.49647, 0),
//OpenMesh::Vec3d(-10.3053, 3.09553, 0),
//OpenMesh::Vec3d(-10.0761, 2.09196, 0),
//OpenMesh::Vec3d(-9.00522, 1.38062, 0),
//OpenMesh::Vec3d(-8.98836, 1.07329, 0),
//OpenMesh::Vec3d(-8.99063, 0.702774, 0),
//OpenMesh::Vec3d(-8.75359, 0.482605, 0),
//OpenMesh::Vec3d(-8.63689, 0.763358, 0),
//OpenMesh::Vec3d(-8.78799, 1.02137, 0),
//OpenMesh::Vec3d(-8.72299, 1.21815, 0),
//OpenMesh::Vec3d(-6.77407, -2.07211, 0),
//OpenMesh::Vec3d(-3.72537, -3.12714, 0),
//OpenMesh::Vec3d(-1.61215, -3.01141, 0),
//OpenMesh::Vec3d(-1.16986, -3.56759, 0),
//OpenMesh::Vec3d(0.232353, -4.09102, 0),
//OpenMesh::Vec3d(0.0920223, -2.80436, 0),
//OpenMesh::Vec3d(0.365635, -2.75175, 0),
//OpenMesh::Vec3d(0.651136, -2.71796, 0),
//OpenMesh::Vec3d(0.895707, -2.68846, 0),
//OpenMesh::Vec3d(1.40535, -1.90493, 0),
//OpenMesh::Vec3d(3.27536, -4.52581, 0),
//OpenMesh::Vec3d(2.61347, -2.47371, 0),
//OpenMesh::Vec3d(5.24685, -1.85539, 0),
//OpenMesh::Vec3d(6.49604, -3.83112, 0),
//};
 
//CC_points = { //choufish
//	OpenMesh::Vec3d(2.27477, -5.47137, 0),
//    OpenMesh::Vec3d(1.8946, -4.29797, 0),
//    OpenMesh::Vec3d(1.76649, -3.4866, 0),
//    OpenMesh::Vec3d(2.33876, -3.72963, 0),
//    OpenMesh::Vec3d(4.26167, -3.63543, 0),
//    OpenMesh::Vec3d(3.85949, -1.66655, 0),
//    OpenMesh::Vec3d(5.77752, -1.50034, 0),
//    OpenMesh::Vec3d(4.98695, 0.732251, 0),
//    OpenMesh::Vec3d(3.27073, 0.866982, 0),
//    OpenMesh::Vec3d(2.85876, 2.93215, 0),
//    OpenMesh::Vec3d(0.10979, 3.08279, 0),
//    OpenMesh::Vec3d(-1.88859, 4.21388, 0),
//    OpenMesh::Vec3d(0.0442605, 5.69605, 0),
//    OpenMesh::Vec3d(-0.172236, 5.83505, 0),
//    OpenMesh::Vec3d(-0.488855, 6.00424, 0),
//    OpenMesh::Vec3d(-0.872024, 6.13353, 0),
//    OpenMesh::Vec3d(-3.33598, 4.58416, 0),
//    OpenMesh::Vec3d(-1.63781, 2.39221, 0),
//    OpenMesh::Vec3d(0.310345, 2.27181, 0),
//    OpenMesh::Vec3d(-0.884167, 1.77491, 0),
//    OpenMesh::Vec3d(-2.55503, 1.80748, 0),
//    OpenMesh::Vec3d(-3.35906, 1.4997, 0),
//    OpenMesh::Vec3d(-5.28685, 1.27267, 0),
//    OpenMesh::Vec3d(-5.5253, -1.89937, 0),
//    OpenMesh::Vec3d(-3.81445, -2.608, 0),
//    OpenMesh::Vec3d(-2.6613, -1.81394, 0),
//    OpenMesh::Vec3d(-2.12056, -2.29342, 0),
//    OpenMesh::Vec3d(-2.20238, -3.11821, 0),
//    OpenMesh::Vec3d(-1.63304, -3.92693, 0),
//    OpenMesh::Vec3d(-0.393606, -4.68184, 0),
//    OpenMesh::Vec3d(0.503098, -2.97635, 0),
//    OpenMesh::Vec3d(0.916171, -3.35227, 0),
//    OpenMesh::Vec3d(1.32529, -3.13754, 0),
//    OpenMesh::Vec3d(1.78622, -2.87407, 0),
//    OpenMesh::Vec3d(1.21669, -3.3626, 0),
//    OpenMesh::Vec3d(1.27813, -4.24631, 0),
//};


//CC_points= { //zomm fish
//	OpenMesh::Vec3d(10.5207, 1.26963, 0),
//OpenMesh::Vec3d(9.80995, 20.178, 0),
//OpenMesh::Vec3d(-10.8162, 20.0895, 0),
//OpenMesh::Vec3d(-11.1068, 1.26963, 0),
//OpenMesh::Vec3d(-11.1068, 0.22077, 0),
//OpenMesh::Vec3d(-11.1068, -0.82809, 0),
//OpenMesh::Vec3d(-11.1068, -1.87695, 0),
//OpenMesh::Vec3d(-7.5541, 10.7143, 0),
//OpenMesh::Vec3d(7.14498, 10.7733, 0),
//OpenMesh::Vec3d(10.5207, -1.87695, 0),
//OpenMesh::Vec3d(10.5207, -0.82809, 0),
//OpenMesh::Vec3d(10.5207, 0.22077, 0),
//};


//CC_points = { //deformed circle
//	OpenMesh::Vec3d(3.45289, 1.63941, 0),
//OpenMesh::Vec3d(4.30953, -0.696405, 0),
//OpenMesh::Vec3d(8.83846, -0.334435, 0),
//OpenMesh::Vec3d(7.30388, 2.62878, 0),
//OpenMesh::Vec3d(6.28855, -2.62518, 0),
//OpenMesh::Vec3d(3.90656, 6.20451, 0),
//OpenMesh::Vec3d(-1.69168, 3.85054, 0),
//OpenMesh::Vec3d(1.09155, 5.00703, 0),
//OpenMesh::Vec3d(1.30912, 9.30382, 0),
//OpenMesh::Vec3d(-2.54111, 7.34319, 0),
//OpenMesh::Vec3d(3.17407, 6.91966, 0),
//OpenMesh::Vec3d(-5.90614, 4.59064, 0),
//OpenMesh::Vec3d(-3.65812, -1.22062, 0),
//OpenMesh::Vec3d(-4.82526, 1.79114, 0),
//OpenMesh::Vec3d(-8.67249, 0.318421, 0),
//OpenMesh::Vec3d(-7.36877, -2.80688, 0),
//OpenMesh::Vec3d(-6.62193, 2.72038, 0),
//OpenMesh::Vec3d(-4.64774, -5.87751, 0),
//OpenMesh::Vec3d(1.34646, -3.2845, 0),
//OpenMesh::Vec3d(-1.61716, -4.57378, 0),
//OpenMesh::Vec3d(-1.13283, -8.95429, 0),
//OpenMesh::Vec3d(2.75132, -7.28116, 0),
//OpenMesh::Vec3d(-3.34859, -6.70248, 0),
//OpenMesh::Vec3d(5.46868, -4.0388, 0),
//};

//CC_points = { //deformed circle new
//	OpenMesh::Vec3d(3.45289, 1.63941, 0),
//OpenMesh::Vec3d(6.76375, 1.57117, 0),
//OpenMesh::Vec3d(6.50663, 6.68737, 0),
//OpenMesh::Vec3d(2.59476, 7.52767, 0),
//OpenMesh::Vec3d(6.52016, 3.41986, 0),
//OpenMesh::Vec3d(3.51282, 5.94974, 0),
//OpenMesh::Vec3d(-1.69168, 3.85054, 0),
//OpenMesh::Vec3d(-0.739426, 7.46023, 0),
//OpenMesh::Vec3d(-5.80258, 7.03216, 0),
//OpenMesh::Vec3d(-6.85908, 3.35323, 0),
//OpenMesh::Vec3d(-3.01995, 6.31121, 0),
//OpenMesh::Vec3d(-5.5124, 3.82632, 0),
//OpenMesh::Vec3d(-3.65812, -1.22062, 0),
//OpenMesh::Vec3d(-7.57777, -1.29563, 0),
//OpenMesh::Vec3d(-6.16779, -6.64343, 0),
//OpenMesh::Vec3d(-2.63291, -6.80906, 0),
//OpenMesh::Vec3d(-6.03714, -3.68413, 0),
//OpenMesh::Vec3d(-3.69563, -5.43646, 0),
//OpenMesh::Vec3d(1.34646, -3.2845, 0),
//OpenMesh::Vec3d(1.52332, -6.63453, 0),
//OpenMesh::Vec3d(5.49032, -7.07563, 0),
//OpenMesh::Vec3d(6.97355, -2.60171, 0),
//OpenMesh::Vec3d(2.96145, -6.57085, 0),
//OpenMesh::Vec3d(5.27339, -3.66767, 0),
//};


//hunman
//CC_points = { //human 2次
//	OpenMesh::Vec3d(2.2434, -4.09831, 0),
//OpenMesh::Vec3d(1.33897, -1.2763, 0),
//OpenMesh::Vec3d(0.168209, 0.44022, 0),
//OpenMesh::Vec3d(1.4422, 0.351278, 0),
//OpenMesh::Vec3d(2.71398, 0.333548, 0),
//OpenMesh::Vec3d(2.71397, 1.68434, 0),
//OpenMesh::Vec3d(3.46302, 4.87632, 0),
//OpenMesh::Vec3d(2.02594, 5.163, 0),
//OpenMesh::Vec3d(0.502351, 5.27545, 0),
//OpenMesh::Vec3d(0.555983, 4.54789, 0),
//OpenMesh::Vec3d(0.618441, 3.76385, 0),
//OpenMesh::Vec3d(1.34768, 3.70515, 0),
//OpenMesh::Vec3d(2.12808, 3.63751, 0),
//OpenMesh::Vec3d(1.15359, 2.4928, 0),
//OpenMesh::Vec3d(0.929425, 1.2952, 0),
//OpenMesh::Vec3d(0.312689, 3.28967, 0),
//OpenMesh::Vec3d(-0.901575, 4.85807, 0),
//OpenMesh::Vec3d(-1.23977, 3.5368, 0),
//OpenMesh::Vec3d(-1.9027, 4.60764, 0),
//OpenMesh::Vec3d(-2.60159, 4.08557, 0),
//OpenMesh::Vec3d(-3.67377, 2.94282, 0),
//OpenMesh::Vec3d(-4.19734, 1.3431, 0),
//OpenMesh::Vec3d(-2.67894, 0.569752, 0),
//OpenMesh::Vec3d(-4.41661, 0.875907, 0),
//OpenMesh::Vec3d(-5.35647, 1.84359, 0),
//OpenMesh::Vec3d(-4.28499, -1.33886, 0),
//OpenMesh::Vec3d(-2.25433, -1.02231, 0),
//OpenMesh::Vec3d(-2.9142, -1.57256, 0),
//OpenMesh::Vec3d(-3.11938, -1.99522, 0),
//OpenMesh::Vec3d(-2.32945, -2.77795, 0),
//OpenMesh::Vec3d(-2.39632, -3.96978, 0),
//OpenMesh::Vec3d(-0.151571, -4.57271, 0),
//};

//新的human2次 1224
//CC_points = { OpenMesh::Vec3d(2.2434, -4.09831, 0),
//OpenMesh::Vec3d(1.33897, -1.2763, 0),
//OpenMesh::Vec3d(0.168209, 0.44022, 0),
//OpenMesh::Vec3d(1.4422, 0.351278, 0),
//OpenMesh::Vec3d(2.71398, 0.333548, 0),
//OpenMesh::Vec3d(2.71397, 1.68434, 0),
//OpenMesh::Vec3d(3.46302, 4.87632, 0),
//OpenMesh::Vec3d(2.02594, 5.163, 0),
//OpenMesh::Vec3d(0.502351, 5.27545, 0),
//OpenMesh::Vec3d(0.555983, 4.54789, 0),
//OpenMesh::Vec3d(0.131869, 3.21646, 0),
//OpenMesh::Vec3d(0.861108, 3.15776, 0),
//OpenMesh::Vec3d(1.64151, 3.09012, 0),
//OpenMesh::Vec3d(1.15359, 2.4928, 0),
//OpenMesh::Vec3d(0.929425, 1.2952, 0),
//OpenMesh::Vec3d(0.312689, 3.28967, 0),
//OpenMesh::Vec3d(-0.901575, 4.85807, 0),
//OpenMesh::Vec3d(-1.23977, 3.5368, 0),
//OpenMesh::Vec3d(-1.9027, 4.60764, 0),
//OpenMesh::Vec3d(-2.60159, 4.08557, 0),
//OpenMesh::Vec3d(-3.67377, 2.94282, 0),
//OpenMesh::Vec3d(-4.19734, 1.3431, 0),
//OpenMesh::Vec3d(-2.67894, 0.569752, 0),
//OpenMesh::Vec3d(-4.41661, 0.875907, 0),
//OpenMesh::Vec3d(-5.35647, 1.84359, 0),
//OpenMesh::Vec3d(-4.28499, -1.33886, 0),
//OpenMesh::Vec3d(-2.25433, -1.02231, 0),
//OpenMesh::Vec3d(-2.9142, -1.57256, 0),
//OpenMesh::Vec3d(-3.11938, -1.99522, 0),
//OpenMesh::Vec3d(-2.32945, -2.77795, 0),
//OpenMesh::Vec3d(-2.39632, -3.96978, 0),
//OpenMesh::Vec3d(-0.151571, -4.57271, 0),
//};

//CC_points = { //human 1次
//	OpenMesh::Vec3d(2.2434, -4.09831, 0),
//OpenMesh::Vec3d(0.168209, 0.44022, 0),
//OpenMesh::Vec3d(2.59141, 0.159537, 0),
//OpenMesh::Vec3d(2.75152, 5.52769, 0),
//OpenMesh::Vec3d(0.311402, 5.24667, 0),
//OpenMesh::Vec3d(0.0708214, 3.50104, 0),
//OpenMesh::Vec3d(2.1565, 3.58798, 0),
//OpenMesh::Vec3d(0.929425, 1.2952, 0),
//OpenMesh::Vec3d(-0.901575, 4.85807, 0),
//OpenMesh::Vec3d(-1.9027, 4.60764, 0),
//OpenMesh::Vec3d(-3.67377, 2.94282, 0),
//OpenMesh::Vec3d(-2.67894, 0.569752, 0),
//OpenMesh::Vec3d(-4.13832, -0.216033, 0),
//OpenMesh::Vec3d(-2.25433, -1.02231, 0),
//OpenMesh::Vec3d(-3.11938, -1.99522, 0),
//OpenMesh::Vec3d(-2.39632, -3.96978, 0),
//};
//CC_points = { //三次
//	OpenMesh::Vec3d(2.2434, -4.09831, 0),
//OpenMesh::Vec3d(-0.769148, -3.04015, 0),
//OpenMesh::Vec3d(2.3222, -0.889475, 0),
//OpenMesh::Vec3d(0.168209, 0.44022, 0),
//OpenMesh::Vec3d(1.009, -0.045892, 0),
//OpenMesh::Vec3d(1.84906, -0.38449, 0),
//OpenMesh::Vec3d(2.68837, -0.575573, 0),
//OpenMesh::Vec3d(1.55687, 1.20745, 0),
//OpenMesh::Vec3d(4.88948, 3.42979, 0),
//OpenMesh::Vec3d(3.94164, 4.94133, 0),
//OpenMesh::Vec3d(3.07853, 4.98889, 0),
//OpenMesh::Vec3d(2.06426, 5.05415, 0),
//OpenMesh::Vec3d(0.591506, 5.43161, 0),
//OpenMesh::Vec3d(0.584249, 4.90679, 0),
//OpenMesh::Vec3d(0.512881, 4.38422, 0),
//OpenMesh::Vec3d(0.210941, 3.88952, 0),
//OpenMesh::Vec3d(0.623509, 3.67733, 0),
//OpenMesh::Vec3d(1.0465, 3.47584, 0),
//OpenMesh::Vec3d(1.45429, 3.28504, 0),
//OpenMesh::Vec3d(2.04615, 2.5743, 0),
//OpenMesh::Vec3d(0.742298, 2.41874, 0),
//OpenMesh::Vec3d(0.929425, 1.2952, 0),
//OpenMesh::Vec3d(0.518268, 2.62485, 0),
//OpenMesh::Vec3d(-0.0920657, 3.81247, 0),
//OpenMesh::Vec3d(-0.901575, 4.85807, 0),
//OpenMesh::Vec3d(-1.12704, 3.97722, 0),
//OpenMesh::Vec3d(-1.46075, 3.89375, 0),
//OpenMesh::Vec3d(-1.9027, 4.60764, 0),
//OpenMesh::Vec3d(-2.36863, 4.25959, 0),
//OpenMesh::Vec3d(-2.95898, 3.70465, 0),
//OpenMesh::Vec3d(-3.67377, 2.94282, 0),
//OpenMesh::Vec3d(-4.02282, 1.87634, 0),
//OpenMesh::Vec3d(-3.69121, 1.08532, 0),
//OpenMesh::Vec3d(-2.67894, 0.569752, 0),
//OpenMesh::Vec3d(-4.13322, 1.15321, 0),
//OpenMesh::Vec3d(-4.05724, -1.83736, 0),
//OpenMesh::Vec3d(-5.46007, 0.228285, 0),
//OpenMesh::Vec3d(-3.21245, -2.86571, 0),
//OpenMesh::Vec3d(-3.14689, -0.405828, 0),
//OpenMesh::Vec3d(-2.25433, -1.02231, 0),
//OpenMesh::Vec3d(-2.69424, -1.38914, 0),
//OpenMesh::Vec3d(-2.98259, -1.71345, 0),
//OpenMesh::Vec3d(-3.11938, -1.99522, 0),
//OpenMesh::Vec3d(-2.59276, -2.51704, 0),
//OpenMesh::Vec3d(-2.35174, -3.17523, 0),
//OpenMesh::Vec3d(-2.39632, -3.96978, 0),
//OpenMesh::Vec3d(-0.899821, -4.37173, 0),
//OpenMesh::Vec3d(0.646753, -4.41458, 0),
//};

//CC_points= { //human 7次
//	OpenMesh::Vec3d(2.2434, -4.09831, 0),
//OpenMesh::Vec3d(1.98499, -3.29202, 0),
//OpenMesh::Vec3d(1.7139, -2.53838, 0),
//OpenMesh::Vec3d(1.43013, -1.83737, 0),
//OpenMesh::Vec3d(1.13367, -1.18901, 0),
//OpenMesh::Vec3d(0.824533, -0.593291, 0),
//OpenMesh::Vec3d(0.502712, -0.0502143, 0),
//OpenMesh::Vec3d(0.168209, 0.44022, 0),
//OpenMesh::Vec3d(0.528549, 0.231886, 0),
//OpenMesh::Vec3d(0.888784, 0.044626, 0),
//OpenMesh::Vec3d(1.24891, -0.121561, 0),
//OpenMesh::Vec3d(1.60894, -0.266674, 0),
//OpenMesh::Vec3d(1.96885, -0.390714, 0),
//OpenMesh::Vec3d(2.32866, -0.49368, 0),
//OpenMesh::Vec3d(2.68837, -0.575573, 0),
//OpenMesh::Vec3d(2.36958, 0.574717, 0),
//OpenMesh::Vec3d(4.04595, -0.611701, 0),
//OpenMesh::Vec3d(3.37615, 1.16304, 0),
//OpenMesh::Vec3d(4.94639, 0.0309733, 0),
//OpenMesh::Vec3d(4.59013, 1.75041, 0),
//OpenMesh::Vec3d(5.29918, 1.4732, 0),
//OpenMesh::Vec3d(5.28407, 2.03122, 0),
//OpenMesh::Vec3d(5.2983, 2.51805, 0),
//OpenMesh::Vec3d(5.30008, 3.00193, 0),
//OpenMesh::Vec3d(5.28941, 3.48284, 0),
//OpenMesh::Vec3d(5.2663, 3.9608, 0),
//OpenMesh::Vec3d(5.23073, 4.4358, 0),
//OpenMesh::Vec3d(5.18272, 4.90783, 0),
//OpenMesh::Vec3d(5.12226, 5.37691, 0),
//OpenMesh::Vec3d(4.68562, 5.47027, 0),
//OpenMesh::Vec3d(4.2691, 5.53468, 0),
//OpenMesh::Vec3d(3.87268, 5.57015, 0),
//OpenMesh::Vec3d(3.49637, 5.57668, 0),
//OpenMesh::Vec3d(3.14017, 5.55426, 0),
//OpenMesh::Vec3d(2.80408, 5.50289, 0),
//OpenMesh::Vec3d(2.4881, 5.42258, 0),
//OpenMesh::Vec3d(2.41248, 5.1286, 0),
//OpenMesh::Vec3d(2.35664, 4.84529, 0),
//OpenMesh::Vec3d(2.32059, 4.57266, 0),
//OpenMesh::Vec3d(2.30431, 4.3107, 0),
//OpenMesh::Vec3d(2.30782, 4.05942, 0),
//OpenMesh::Vec3d(2.3311, 3.81881, 0),
//OpenMesh::Vec3d(2.37417, 3.58887, 0),
//OpenMesh::Vec3d(2.70708, 3.03427, 0),
//OpenMesh::Vec3d(2.26469, 3.32868, 0),
//OpenMesh::Vec3d(2.8365, 1.6402, 0),
//OpenMesh::Vec3d(1.43069, 2.817, 0),
//OpenMesh::Vec3d(2.21378, 1.10076, 0),
//OpenMesh::Vec3d(0.599588, 2.35945, 0),
//OpenMesh::Vec3d(0.929425, 1.2952, 0),
//OpenMesh::Vec3d(0.753215, 1.86505, 0),
//OpenMesh::Vec3d(0.548551, 2.41461, 0),
//OpenMesh::Vec3d(0.315433, 2.94388, 0),
//OpenMesh::Vec3d(0.0538616, 3.45286, 0),
//OpenMesh::Vec3d(-0.236164, 3.94155, 0),
//OpenMesh::Vec3d(-0.554642, 4.40996, 0),
//OpenMesh::Vec3d(-0.901575, 4.85807, 0),
//OpenMesh::Vec3d(-0.998202, 4.48056, 0),
//OpenMesh::Vec3d(-1.11029, 4.21697, 0),
//OpenMesh::Vec3d(-1.23785, 4.06728, 0),
//OpenMesh::Vec3d(-1.38087, 4.03151, 0),
//OpenMesh::Vec3d(-1.53935, 4.10964, 0),
//OpenMesh::Vec3d(-1.71329, 4.30169, 0),
//OpenMesh::Vec3d(-1.9027, 4.60764, 0),
//OpenMesh::Vec3d(-2.10238, 4.45848, 0),
//OpenMesh::Vec3d(-2.31984, 4.27976, 0),
//OpenMesh::Vec3d(-2.55508, 4.07148, 0),
//OpenMesh::Vec3d(-2.80809, 3.83365, 0),
//OpenMesh::Vec3d(-3.07887, 3.56626, 0),
//OpenMesh::Vec3d(-3.36743, 3.26932, 0),
//OpenMesh::Vec3d(-3.67377, 2.94282, 0),
//OpenMesh::Vec3d(-3.82336, 2.48576, 0),
//OpenMesh::Vec3d(-3.87572, 2.06805, 0),
//OpenMesh::Vec3d(-3.83083, 1.68968, 0),
//OpenMesh::Vec3d(-3.68872, 1.35067, 0),
//OpenMesh::Vec3d(-3.44936, 1.05102, 0),
//OpenMesh::Vec3d(-3.11277, 0.790709, 0),
//OpenMesh::Vec3d(-2.67894, 0.569752, 0),
//OpenMesh::Vec3d(-3.72316, 1.23398, 0),
//OpenMesh::Vec3d(-3.70137, 0.279413, 0),
//OpenMesh::Vec3d(-3.43965, -0.725036, 0),
//OpenMesh::Vec3d(-4.43595, 1.305, 0),
//OpenMesh::Vec3d(-4.93327, -0.948555, 0),
//OpenMesh::Vec3d(-5.54271, 1.48429, 0),
//OpenMesh::Vec3d(-5.86143, 0.0619877, 0),
//OpenMesh::Vec3d(-5.18066, 1.04357, 0),
//OpenMesh::Vec3d(-5.04011, -1.7729, 0),
//OpenMesh::Vec3d(-4.45911, 0.61759, 0),
//OpenMesh::Vec3d(-3.2615, -1.3835, 0),
//OpenMesh::Vec3d(-3.24322, -0.137838, 0),
//OpenMesh::Vec3d(-2.92926, -1.4303, 0),
//OpenMesh::Vec3d(-2.25433, -1.02231, 0),
//OpenMesh::Vec3d(-2.44286, -1.17952, 0),
//OpenMesh::Vec3d(-2.60975, -1.33066, 0),
//OpenMesh::Vec3d(-2.75498, -1.47573, 0),
//OpenMesh::Vec3d(-2.87856, -1.61471, 0),
//OpenMesh::Vec3d(-2.98048, -1.74762, 0),
//OpenMesh::Vec3d(-3.06076, -1.87446, 0),
//OpenMesh::Vec3d(-3.11938, -1.99522, 0),
//OpenMesh::Vec3d(-2.89369, -2.21886, 0),
//OpenMesh::Vec3d(-2.70879, -2.46198, 0),
//OpenMesh::Vec3d(-2.5647, -2.72457, 0),
//OpenMesh::Vec3d(-2.4614, -3.00665, 0),
//OpenMesh::Vec3d(-2.39891, -3.30822, 0),
//OpenMesh::Vec3d(-2.37721, -3.62926, 0),
//OpenMesh::Vec3d(-2.39632, -3.96978, 0),
//OpenMesh::Vec3d(-1.75496, -4.14205, 0),
//OpenMesh::Vec3d(-1.10645, -4.26301, 0),
//OpenMesh::Vec3d(-0.450789, -4.33267, 0),
//OpenMesh::Vec3d(0.212028, -4.35103, 0),
//OpenMesh::Vec3d(0.881999, -4.31809, 0),
//OpenMesh::Vec3d(1.55912, -4.23385, 0),
//};

//CC_points = {//老登flower3?
//  OpenMesh::Vec3d(0.060138, -2.34968, 0),
//OpenMesh::Vec3d(0.167533, -1.16113, 0),
//OpenMesh::Vec3d(0.304982, 0.160104, 0),
//OpenMesh::Vec3d(0.231798, 1.08177, 0),
//OpenMesh::Vec3d(0.61252, 2.32314, 0),
//OpenMesh::Vec3d(0.771864, 3.13087, 0),
//OpenMesh::Vec3d(0.855257, 4.5897, 0),
//OpenMesh::Vec3d(3.38975, 5.46352, 0),
//OpenMesh::Vec3d(4.41819, 7.10405, 0),
//OpenMesh::Vec3d(8.67744, 7.8645, 0),
//OpenMesh::Vec3d(4.59444, 11.1053, 0),
//OpenMesh::Vec3d(-2.40215, 10.8965, 0),
//OpenMesh::Vec3d(-7.26403, 7.93585, 0),
//OpenMesh::Vec3d(-4.30306, 6.87478, 0),
//OpenMesh::Vec3d(-2.76766, 5.30325, 0),
//OpenMesh::Vec3d(-0.552003, 4.00657, 0),
//OpenMesh::Vec3d(-0.0860061, 2.21267, 0),
//OpenMesh::Vec3d(0.0878497, 0.616274, 0),
//OpenMesh::Vec3d(-0.0636332, -0.969635, 0),
//OpenMesh::Vec3d(-1.42388, 1.41961, 0),
//OpenMesh::Vec3d(-3.71789, 1.96421, 0),
//OpenMesh::Vec3d(-7.39052, 1.52015, 0),
//OpenMesh::Vec3d(-5.55652, -0.704119, 0),
//OpenMesh::Vec3d(-3.16591, -1.64514, 0),
//OpenMesh::Vec3d(-0.29709, -1.64989, 0),
//OpenMesh::Vec3d(-0.284548, -4.19343, 0),
//OpenMesh::Vec3d(-4.56897, -5.40077, 0),
//OpenMesh::Vec3d(-3.58096, -9.71999, 0),
//OpenMesh::Vec3d(-3.51223, -4.61304, 0),
//OpenMesh::Vec3d(-0.378727, -4.82229, 0),
//OpenMesh::Vec3d(0.125836, -2.84884, 0),
//OpenMesh::Vec3d(1.10361, -2.36519, 0),
//OpenMesh::Vec3d(3.49, -2.80699, 0),
//OpenMesh::Vec3d(7.08069, -3.99408, 0),
//OpenMesh::Vec3d(4.17284, -0.459165, 0),
//OpenMesh::Vec3d(0.512756, -0.0850323, 0),
//};

//新的flower3次

//CC_points = { OpenMesh::Vec3d(0.060138, -2.34968, 0),
//OpenMesh::Vec3d(0.167533, -1.16113, 0),
//OpenMesh::Vec3d(0.304982, 0.160104, 0),
//OpenMesh::Vec3d(0.231798, 1.08177, 0),
//OpenMesh::Vec3d(0.61252, 2.32314, 0),
//OpenMesh::Vec3d(0.771864, 3.13087, 0),
//OpenMesh::Vec3d(0.855257, 4.5897, 0),
//OpenMesh::Vec3d(2.89591, 4.94616, 0),
//OpenMesh::Vec3d(4.39467, 5.55197, 0),
//OpenMesh::Vec3d(5.94954, 8.8757, 0),
//OpenMesh::Vec3d(1.65489, 12.3282, 0),
//OpenMesh::Vec3d(-2.59028, 11.5079, 0),
//OpenMesh::Vec3d(-6.9348, 8.52376, 0),
//OpenMesh::Vec3d(-4.30306, 6.87478, 0),
//OpenMesh::Vec3d(-2.76766, 5.30325, 0),
//OpenMesh::Vec3d(-0.552003, 4.00657, 0),
//OpenMesh::Vec3d(-0.0860061, 2.21267, 0),
//OpenMesh::Vec3d(0.0878497, 0.616274, 0),
//OpenMesh::Vec3d(-0.0636332, -0.969635, 0),
//OpenMesh::Vec3d(-1.42388, 1.41961, 0),
//OpenMesh::Vec3d(-3.71789, 1.96421, 0),
//OpenMesh::Vec3d(-7.39052, 1.52015, 0),
//OpenMesh::Vec3d(-5.55652, -0.704119, 0),
//OpenMesh::Vec3d(-3.16591, -1.64514, 0),
//OpenMesh::Vec3d(-0.29709, -1.64989, 0),
//OpenMesh::Vec3d(-0.880161, -5.01245, 0),
//OpenMesh::Vec3d(-4.56897, -5.40077, 0),
//OpenMesh::Vec3d(-3.58096, -9.71999, 0),
//OpenMesh::Vec3d(-3.38573, -5.32988, 0),
//OpenMesh::Vec3d(-0.046254, -3.66715, 0),
//OpenMesh::Vec3d(-0.0274259, -2.608, 0),
//OpenMesh::Vec3d(1.10361, -2.36519, 0),
//OpenMesh::Vec3d(3.49, -2.80699, 0),
//OpenMesh::Vec3d(6.14003, -2.63013, 0),
//OpenMesh::Vec3d(4.17284, -0.459165, 0),
//OpenMesh::Vec3d(0.512756, -0.0850323, 0),
//};

//CC_points = { //flower 2
//	OpenMesh::Vec3d(0.060138, -2.34968, 0),
//OpenMesh::Vec3d(0.236257, -0.500513, 0),
//OpenMesh::Vec3d(0.231798, 1.08177, 0),
//OpenMesh::Vec3d(0.692192, 2.72701, 0),
//OpenMesh::Vec3d(0.855257, 4.5897, 0),
//OpenMesh::Vec3d(5.47551, 4.08825, 0),
//OpenMesh::Vec3d(8.67744, 7.8645, 0),
//OpenMesh::Vec3d(1.09614, 11.0009, 0),
//OpenMesh::Vec3d(-7.26403, 7.93585, 0),
//OpenMesh::Vec3d(-4.36735, 4.74858, 0),
//OpenMesh::Vec3d(-0.552003, 4.00657, 0),
//OpenMesh::Vec3d(0.0009218, 1.41447, 0),
//OpenMesh::Vec3d(-0.0636332, -0.969635, 0),
//OpenMesh::Vec3d(-2.57089, 1.69191, 0),
//OpenMesh::Vec3d(-7.39052, 1.52015, 0),
//OpenMesh::Vec3d(-4.36121, -1.17463, 0),
//OpenMesh::Vec3d(-0.29709, -1.64989, 0),
//OpenMesh::Vec3d(-4.32186, -5.28243, 0),
//OpenMesh::Vec3d(-3.58096, -9.71999, 0),
//OpenMesh::Vec3d(-3.37836, -5.11055, 0),
//OpenMesh::Vec3d(0.125836, -2.84884, 0),
//OpenMesh::Vec3d(2.94391, -4.43496, 0),
//OpenMesh::Vec3d(7.08069, -3.99408, 0),
//OpenMesh::Vec3d(2.3428, -0.272099, 0),
//};

//CC_points = {//flower 7
//	OpenMesh::Vec3d(0.060138, -2.34968, 0),
//OpenMesh::Vec3d(0.106164, -1.8403, 0),
//OpenMesh::Vec3d(0.156484, -1.31197, 0),
//OpenMesh::Vec3d(0.204221, -0.779887, 0),
//OpenMesh::Vec3d(0.242497, -0.259265, 0),
//OpenMesh::Vec3d(0.264437, 0.234689, 0),
//OpenMesh::Vec3d(0.725381, 0.565134, 0),
//OpenMesh::Vec3d(1.27787, 1.1061, 0),
//OpenMesh::Vec3d(0.394965, 1.61379, 0),
//OpenMesh::Vec3d(0.526506, 2.08385, 0),
//OpenMesh::Vec3d(0.630576, 2.52296, 0),
//OpenMesh::Vec3d(0.711332, 2.96211, 0),
//OpenMesh::Vec3d(0.772927, 3.43229, 0),
//OpenMesh::Vec3d(0.819517, 3.96449, 0),
//OpenMesh::Vec3d(0.855257, 4.5897, 0),
//OpenMesh::Vec3d(1.94147, 4.96419, 0),
//OpenMesh::Vec3d(3.73668, 4.93421, 0),
//OpenMesh::Vec3d(4.52793, 5.48071, 0),
//OpenMesh::Vec3d(4.45056, 6.55665, 0),
//OpenMesh::Vec3d(5.02614, 7.61761, 0),
//OpenMesh::Vec3d(6.38999, 8.06925, 0),
//OpenMesh::Vec3d(8.67744, 7.8645, 0),
//OpenMesh::Vec3d(6.24266, 10.6718, 0),
//OpenMesh::Vec3d(3.86555, 7.90151, 0),
//OpenMesh::Vec3d(2.47202, 11.7662, 0),
//OpenMesh::Vec3d(-0.517681, 9.43055, 0),
//OpenMesh::Vec3d(-3.73159, 11.8117, 0),
//OpenMesh::Vec3d(-3.7706, 7.81967, 0),
//OpenMesh::Vec3d(-7.26403, 7.93585, 0),
//OpenMesh::Vec3d(-5.99504, 7.48111, 0),
//OpenMesh::Vec3d(-4.92971, 6.95344, 0),
//OpenMesh::Vec3d(-3.63227, 7.001, 0),
//OpenMesh::Vec3d(-2.79374, 6.3948, 0),
//OpenMesh::Vec3d(-2.35396, 5.15727, 0),
//OpenMesh::Vec3d(-1.50157, 4.56229, 0),
//OpenMesh::Vec3d(-0.552003, 4.00657, 0),
//OpenMesh::Vec3d(-0.35229, 3.23776, 0),
//OpenMesh::Vec3d(-1.09442, 2.13225, 0),
//OpenMesh::Vec3d(-0.079016, 1.77943, 0),
//OpenMesh::Vec3d(-0.00735184, 1.07923, 0),
//OpenMesh::Vec3d(0.0197323, 0.391214, 0),
//OpenMesh::Vec3d(0.00128804, -0.28996, 0),
//OpenMesh::Vec3d(-0.0636332, -0.969635, 0),
//OpenMesh::Vec3d(-0.646596, 0.0543271, 0),
//OpenMesh::Vec3d(-1.36295, 0.814769, 0),
//OpenMesh::Vec3d(-2.22542, 1.33615, 0),
//OpenMesh::Vec3d(-3.24669, 1.64292, 0),
//OpenMesh::Vec3d(-4.4395, 1.75954, 0),
//OpenMesh::Vec3d(-5.81654, 1.71046, 0),
//OpenMesh::Vec3d(-7.39052, 1.52015, 0),
//OpenMesh::Vec3d(-6.60452, 0.566892, 0),
//OpenMesh::Vec3d(-5.739, -0.203045, 0),
//OpenMesh::Vec3d(-4.79621, -0.799575, 0),
//OpenMesh::Vec3d(-3.77839, -1.23261, 0),
//OpenMesh::Vec3d(-2.68776, -1.51207, 0),
//OpenMesh::Vec3d(-1.52658, -1.64785, 0),
//OpenMesh::Vec3d(-0.29709, -1.64989, 0),
//OpenMesh::Vec3d(-1.72703, -2.95892, 0),
//OpenMesh::Vec3d(0.632428, -4.75824, 0),
//OpenMesh::Vec3d(-0.365144, -5.35037, 0),
//OpenMesh::Vec3d(-3.78949, -4.69212, 0),
//OpenMesh::Vec3d(-3.67462, -6.46236, 0),
//OpenMesh::Vec3d(-1.37705, -8.74468, 0),
//OpenMesh::Vec3d(-3.53231, -9.71999, 0),
//OpenMesh::Vec3d(-0.924157, -8.40708, 0),
//OpenMesh::Vec3d(-3.08422, -6.10206, 0),
//OpenMesh::Vec3d(-3.26623, -4.53686, 0),
//OpenMesh::Vec3d(-0.00293407, -5.54073, 0),
//OpenMesh::Vec3d(0.85041, -5.34761, 0),
//OpenMesh::Vec3d(-0.0904053, -3.6946, 0),
//OpenMesh::Vec3d(0.125836, -2.84884, 0),
//OpenMesh::Vec3d(0.544882, -2.64156, 0),
//OpenMesh::Vec3d(1.16516, -2.56649, 0),
//OpenMesh::Vec3d(1.98083, -2.61848, 0),
//OpenMesh::Vec3d(2.98605, -2.79238, 0),
//OpenMesh::Vec3d(4.175, -3.08304, 0),
//OpenMesh::Vec3d(5.54182, -3.48533, 0),
//OpenMesh::Vec3d(7.08069, -3.99408, 0),
//OpenMesh::Vec3d(5.83447, -2.47912, 0),
//OpenMesh::Vec3d(4.48079, -1.41569, 0),
//OpenMesh::Vec3d(3.13277, -0.788896, 0),
//OpenMesh::Vec3d(1.90357, -0.58381, 0),
//OpenMesh::Vec3d(0.906306, -0.785522, 0),
//OpenMesh::Vec3d(0.254117, -1.37912, 0),
//};



//CC_points = { //flower 7,new
// OpenMesh::Vec3d(0.060138, -2.34968, 0),
//OpenMesh::Vec3d(0.106164, -1.8403, 0),
//OpenMesh::Vec3d(0.156484, -1.31197, 0),
//OpenMesh::Vec3d(0.204221, -0.779887, 0),
//OpenMesh::Vec3d(0.242497, -0.259265, 0),
//OpenMesh::Vec3d(0.264437, 0.234689, 0),
//OpenMesh::Vec3d(0.263163, 0.68677, 0),
//OpenMesh::Vec3d(0.316944, 1.0988, 0),
//OpenMesh::Vec3d(1.13816, 1.9118, 0),
//OpenMesh::Vec3d(0.526506, 2.08385, 0),
//OpenMesh::Vec3d(0.630576, 2.52296, 0),
//OpenMesh::Vec3d(2.33153, 2.20675, 0),
//OpenMesh::Vec3d(2.39312, 2.67693, 0),
//OpenMesh::Vec3d(0.819517, 3.96449, 0),
//OpenMesh::Vec3d(0.855257, 4.5897, 0),
//OpenMesh::Vec3d(2.70697, 4.46184, 0),
//OpenMesh::Vec3d(3.57803, 4.94586, 0),
//OpenMesh::Vec3d(3.60378, 5.99472, 0),
//OpenMesh::Vec3d(4.45056, 6.55665, 0),
//OpenMesh::Vec3d(5.4882, 7.08696, 0),
//OpenMesh::Vec3d(6.85205, 7.53859, 0),
//OpenMesh::Vec3d(8.67744, 7.8645, 0),
//OpenMesh::Vec3d(4.12873, 7.55496, 0),
//OpenMesh::Vec3d(1.96264, 8.45108, 0),
//OpenMesh::Vec3d(2.32342, 10.5728, 0),
//OpenMesh::Vec3d(-0.242403, 10.5431, 0),
//OpenMesh::Vec3d(-3.77254, 12.1138, 0),
//OpenMesh::Vec3d(-3.86467, 8.29567, 0),
//OpenMesh::Vec3d(-7.26403, 7.93585, 0),
//OpenMesh::Vec3d(-5.99504, 7.48111, 0),
//OpenMesh::Vec3d(-4.30774, 7.59933, 0),
//OpenMesh::Vec3d(-3.38589, 7.02118, 0),
//OpenMesh::Vec3d(-3.16933, 5.76909, 0),
//OpenMesh::Vec3d(-3.14338, 4.7506, 0),
//OpenMesh::Vec3d(-2.29099, 4.15562, 0),
//OpenMesh::Vec3d(-0.552003, 4.00657, 0),
//OpenMesh::Vec3d(-0.35229, 3.23776, 0),
//OpenMesh::Vec3d(-1.11388, 2.51905, 0),
//OpenMesh::Vec3d(0.369823, 2.075, 0),
//OpenMesh::Vec3d(0.14591, 1.53901, 0),
//OpenMesh::Vec3d(-0.661432, 0.618268, 0),
//OpenMesh::Vec3d(-0.679876, -0.062905, 0),
//OpenMesh::Vec3d(-0.0636332, -0.969635, 0),
//OpenMesh::Vec3d(-0.646596, 0.0543271, 0),
//OpenMesh::Vec3d(-1.36295, 0.814769, 0),
//OpenMesh::Vec3d(-2.22542, 1.33615, 0),
//OpenMesh::Vec3d(-3.24669, 1.64292, 0),
//OpenMesh::Vec3d(-4.4395, 1.75954, 0),
//OpenMesh::Vec3d(-5.81654, 1.71046, 0),
//OpenMesh::Vec3d(-7.39052, 1.52015, 0),
//OpenMesh::Vec3d(-6.60452, 0.566892, 0),
//OpenMesh::Vec3d(-5.739, -0.203045, 0),
//OpenMesh::Vec3d(-4.79621, -0.799575, 0),
//OpenMesh::Vec3d(-3.77839, -1.23261, 0),
//OpenMesh::Vec3d(-2.68776, -1.51207, 0),
//OpenMesh::Vec3d(-1.52658, -1.64785, 0),
//OpenMesh::Vec3d(-0.29709, -1.64989, 0),
//OpenMesh::Vec3d(-1.28548, -3.01893, 0),
//OpenMesh::Vec3d(1.314, -5.34777, 0),
//OpenMesh::Vec3d(-0.157957, -5.71244, 0),
//OpenMesh::Vec3d(-4.15521, -5.37328, 0),
//OpenMesh::Vec3d(-3.67462, -6.46236, 0),
//OpenMesh::Vec3d(-1.05795, -7.9212, 0),
//OpenMesh::Vec3d(-3.58096, -9.71999, 0),
//OpenMesh::Vec3d(-0.605064, -7.5836, 0),
//OpenMesh::Vec3d(-3.08422, -6.10206, 0),
//OpenMesh::Vec3d(-3.63195, -5.21803, 0),
//OpenMesh::Vec3d(0.204253, -5.9028, 0),
//OpenMesh::Vec3d(1.53198, -5.93714, 0),
//OpenMesh::Vec3d(-0.0904053, -3.6946, 0),
//OpenMesh::Vec3d(0.125836, -2.84884, 0),
//OpenMesh::Vec3d(0.544882, -2.64156, 0),
//OpenMesh::Vec3d(1.16516, -2.56649, 0),
//OpenMesh::Vec3d(1.98083, -2.61848, 0),
//OpenMesh::Vec3d(2.98605, -2.79238, 0),
//OpenMesh::Vec3d(4.175, -3.08304, 0),
//OpenMesh::Vec3d(5.54182, -3.48533, 0),
//OpenMesh::Vec3d(7.08069, -3.99408, 0),
//OpenMesh::Vec3d(5.83447, -2.47912, 0),
//OpenMesh::Vec3d(4.48079, -1.41569, 0),
//OpenMesh::Vec3d(3.13277, -0.788896, 0),
//OpenMesh::Vec3d(1.90357, -0.58381, 0),
//OpenMesh::Vec3d(0.906306, -0.785522, 0),
//OpenMesh::Vec3d(0.254117, -1.37912, 0),
//};

//CC_points = { //octcpos
//OpenMesh::Vec3d(14.1163, -2.13572, 0),
//OpenMesh::Vec3d(11.6986, -2.58835, 0),
//OpenMesh::Vec3d(9.93025, -2.04599, 0),
//OpenMesh::Vec3d(6.50689, -3.68536, 0),
//OpenMesh::Vec3d(5.42654, -1.87831, 0),
//OpenMesh::Vec3d(4.92811, 1.19895, 0),
//OpenMesh::Vec3d(6.11625, 1.44333, 0),
//OpenMesh::Vec3d(6.71954, -0.124826, 0),
//OpenMesh::Vec3d(7.67902, 0.404205, 0),
//OpenMesh::Vec3d(8.47221, 1.76796, 0),
//OpenMesh::Vec3d(9.05846, 3.72884, 0),
//OpenMesh::Vec3d(8.84838, 5.3717, 0),
//OpenMesh::Vec3d(6.49071, 5.0889, 0),
//OpenMesh::Vec3d(7.77231, 9.87716, 0),
//OpenMesh::Vec3d(5.30888, 14.7788, 0),
//OpenMesh::Vec3d(-0.841746, 14.3125, 0),
//OpenMesh::Vec3d(-5.90767, 11.3197, 0),
//OpenMesh::Vec3d(-8.86451, 3.55846, 0),
//OpenMesh::Vec3d(-0.246632, 4.78125, 0),
//OpenMesh::Vec3d(1.06736, 1.00327, 0),
//OpenMesh::Vec3d(-4.23325, 0.219585, 0),
//OpenMesh::Vec3d(-11.8515, 4.19812, 0),
//OpenMesh::Vec3d(-12.0648, 2.31314, 0),
//OpenMesh::Vec3d(-10.1253, 0.317715, 0),
//OpenMesh::Vec3d(-6.06773, 0.106026, 0),
//OpenMesh::Vec3d(-7.90343, -1.09784, 0),
//OpenMesh::Vec3d(-12.4609, -0.711102, 0),
//OpenMesh::Vec3d(-10.8011, -3.7199, 0),
//OpenMesh::Vec3d(-11.7545, -4.62186, 0),
//OpenMesh::Vec3d(-11.8664, -5.95728, 0),
//OpenMesh::Vec3d(-11.2416, -8.89297, 0),
//OpenMesh::Vec3d(-9.92311, -4.87563, 0),
//OpenMesh::Vec3d(-4.59648, -5.33218, 0),
//OpenMesh::Vec3d(-2.05936, -4.13197, 0),
//OpenMesh::Vec3d(-3.09482, -7.04246, 0),
//OpenMesh::Vec3d(-13.654, -11.0081, 0),
//OpenMesh::Vec3d(-6.70591, -12.2449, 0),
//OpenMesh::Vec3d(-7.3868, -10.8175, 0),
//OpenMesh::Vec3d(-8.22787, -9.63252, 0),
//OpenMesh::Vec3d(-6.34981, -9.67327, 0),
//OpenMesh::Vec3d(-6.18194, -10.5259, 0),
//OpenMesh::Vec3d(-5.16694, -10.9844, 0),
//OpenMesh::Vec3d(-4.43513, -10.705, 0),
//OpenMesh::Vec3d(-2.69772, -8.66487, 0),
//OpenMesh::Vec3d(-1.78497, -7.37903, 0),
//OpenMesh::Vec3d(0.488619, -4.78304, 0),
//OpenMesh::Vec3d(-0.0659694, -6.98257, 0),
//OpenMesh::Vec3d(-0.438017, -8.1058, 0),
//OpenMesh::Vec3d(2.47188, -10.8048, 0),
//OpenMesh::Vec3d(1.71534, -8.54231, 0),
//OpenMesh::Vec3d(1.34671, -7.00428, 0),
//OpenMesh::Vec3d(1.89121, -5.32397, 0),
//OpenMesh::Vec3d(3.61222, -8.87285, 0),
//OpenMesh::Vec3d(5.47686, -9.79907, 0),
//OpenMesh::Vec3d(4.93164, -12.9952, 0),
//OpenMesh::Vec3d(8.7507, -9.71153, 0),
//OpenMesh::Vec3d(2.57694, -5.41496, 0),
//OpenMesh::Vec3d(4.12527, -0.841089, 0),
//OpenMesh::Vec3d(4.43461, -3.18152, 0),
//OpenMesh::Vec3d(5.09308, -5.72131, 0),
//OpenMesh::Vec3d(7.13664, -5.11346, 0),
//OpenMesh::Vec3d(9.72134, -3.74938, 0),
//OpenMesh::Vec3d(11.762, -4.0687, 0),
//OpenMesh::Vec3d(14.823, -3.17095, 0),
//OpenMesh::Vec3d(15.2188, -3.22438, 0),
//OpenMesh::Vec3d(14.9258, -2.34444, 0),
//};
// 

//octcpos 新的
//CC_points = { OpenMesh::Vec3d(12.3864, 1.30865, 0),
//OpenMesh::Vec3d(8.54005, 0.408923, 0),
//OpenMesh::Vec3d(9.88238, -2.27053, 0),
//OpenMesh::Vec3d(6.50689, -3.68536, 0),
//OpenMesh::Vec3d(5.42654, -1.87831, 0),
//OpenMesh::Vec3d(4.92811, 1.19895, 0),
//OpenMesh::Vec3d(5.93302, 3.06514, 0),
//OpenMesh::Vec3d(6.30168, 2.45448, 0),
//OpenMesh::Vec3d(6.96742, 2.46364, 0),
//OpenMesh::Vec3d(7.48735, 2.9549, 0),
//OpenMesh::Vec3d(8.28608, 4.10443, 0),
//OpenMesh::Vec3d(7.36178, 4.91438, 0),
//OpenMesh::Vec3d(6.49071, 5.0889, 0),
//OpenMesh::Vec3d(7.77231, 9.87716, 0),
//OpenMesh::Vec3d(5.30888, 14.7788, 0),
//OpenMesh::Vec3d(-0.841746, 14.3125, 0),
//OpenMesh::Vec3d(-5.90767, 11.3197, 0),
//OpenMesh::Vec3d(-8.86451, 3.55846, 0),
//OpenMesh::Vec3d(-0.246632, 4.78125, 0),
//OpenMesh::Vec3d(1.06736, 1.00327, 0),
//OpenMesh::Vec3d(-4.23325, 0.219585, 0),
//OpenMesh::Vec3d(-9.87861, 1.2831, 0),
//OpenMesh::Vec3d(-9.93051, 0.340549, 0),
//OpenMesh::Vec3d(-9.36496, -0.907093, 0),
//OpenMesh::Vec3d(-7.91073, -1.6347, 0),
//OpenMesh::Vec3d(-9.74643, -2.83856, 0),
//OpenMesh::Vec3d(-11.1236, -4.51355, 0),
//OpenMesh::Vec3d(-9.4638, -7.52235, 0),
//OpenMesh::Vec3d(-10.4172, -8.42431, 0),
//OpenMesh::Vec3d(-10.5291, -9.75973, 0),
//OpenMesh::Vec3d(-9.90432, -12.6954, 0),
//OpenMesh::Vec3d(-8.16579, -7.67258, 0),
//OpenMesh::Vec3d(-5.05235, -5.10958, 0),
//OpenMesh::Vec3d(-2.05936, -4.13197, 0),
//OpenMesh::Vec3d(-3.00349, -7.3811, 0),
//OpenMesh::Vec3d(-9.9766, -8.65238, 0),
//OpenMesh::Vec3d(-6.91464, -13.3494, 0),
//OpenMesh::Vec3d(-6.11135, -11.8783, 0),
//OpenMesh::Vec3d(-5.67153, -10.2482, 0),
//OpenMesh::Vec3d(-4.3495, -9.482, 0),
//OpenMesh::Vec3d(-4.35228, -10.333, 0),
//OpenMesh::Vec3d(-3.93815, -11.6564, 0),
//OpenMesh::Vec3d(-2.84812, -12.3313, 0),
//OpenMesh::Vec3d(-2.69772, -8.66487, 0),
//OpenMesh::Vec3d(-1.78497, -7.37903, 0),
//OpenMesh::Vec3d(0.488619, -4.78304, 0),
//OpenMesh::Vec3d(-0.0659694, -6.98257, 0),
//OpenMesh::Vec3d(-0.438017, -8.1058, 0),
//OpenMesh::Vec3d(0.945469, -9.78723, 0),
//OpenMesh::Vec3d(1.71534, -8.54231, 0),
//OpenMesh::Vec3d(1.34671, -7.00428, 0),
//OpenMesh::Vec3d(1.89121, -5.32397, 0),
//OpenMesh::Vec3d(3.59191, -8.62094, 0),
//OpenMesh::Vec3d(3.23889, -9.70184, 0),
//OpenMesh::Vec3d(7.02884, -11.7123, 0),
//OpenMesh::Vec3d(5.53764, -7.20535, 0),
//OpenMesh::Vec3d(3.33795, -6.95713, 0),
//OpenMesh::Vec3d(4.12527, -0.841089, 0),
//OpenMesh::Vec3d(4.43461, -3.18152, 0),
//OpenMesh::Vec3d(5.09308, -5.72131, 0),
//OpenMesh::Vec3d(7.13664, -5.11346, 0),
//OpenMesh::Vec3d(10.9394, -3.89096, 0),
//OpenMesh::Vec3d(9.9504, 0.890253, 0),
//OpenMesh::Vec3d(13.0931, 0.273418, 0),
//OpenMesh::Vec3d(13.4889, 0.219988, 0),
//OpenMesh::Vec3d(13.1959, 1.09993, 0),
//};

////新的袋子
//CC_points = { OpenMesh::Vec3d(-0, 6, 0),
//OpenMesh::Vec3d(-0.0, 7.03417, 0),
//OpenMesh::Vec3d(-0.0, 9.22533, 0),
//OpenMesh::Vec3d(-0, 12, 0),
//OpenMesh::Vec3d(-6.6, 12, 0),
//OpenMesh::Vec3d(-12, 6.6, 0),
//OpenMesh::Vec3d(-12, 0, 0),
//OpenMesh::Vec3d(-12, -6.6, 0),
//OpenMesh::Vec3d(-6.6, -12, 0),
//OpenMesh::Vec3d(0, -12, 0),
//OpenMesh::Vec3d(6.6, -12, 0),
//OpenMesh::Vec3d(12, -6.6, 0),
//OpenMesh::Vec3d(12, 0, 0),
//OpenMesh::Vec3d(12, 6.6, 0),
//OpenMesh::Vec3d(6.6, 12, 0),
//OpenMesh::Vec3d(0.1, 12, 0),
//OpenMesh::Vec3d(0.1, 9.22533, 0),
//OpenMesh::Vec3d(0.1, 7.03417, 0),
//OpenMesh::Vec3d(0.1, 6, 0),
//OpenMesh::Vec3d(3.3, 6, 0),
//OpenMesh::Vec3d(6, 3.3, 0),
//OpenMesh::Vec3d(6, 0, 0),
//OpenMesh::Vec3d(6, -3.3, 0),
//OpenMesh::Vec3d(3.3, -6, 0),
//OpenMesh::Vec3d(0, -6, 0),
//OpenMesh::Vec3d(-3.3, -6, 0),
//OpenMesh::Vec3d(-6, -3.3, 0),
//OpenMesh::Vec3d(-6, 0, 0),
//OpenMesh::Vec3d(-6, 3.3, 0),
//OpenMesh::Vec3d(-3.3, 6, 0),
//};

//
////fengzheng
//CC_points = { OpenMesh::Vec3d(2.95636, -6.41235, 0),
//OpenMesh::Vec3d(1.88515, -4.62764, 0),
//OpenMesh::Vec3d(0.0711291, -5.83429, 0),
//OpenMesh::Vec3d(-1.11431, -3.5168, 0),
//OpenMesh::Vec3d(-2.73615, -2.95983, 0),
//OpenMesh::Vec3d(-0.902459, -1.21878, 0),
//OpenMesh::Vec3d(1.18098, 0.937381, 0),
//OpenMesh::Vec3d(2.84992, 2.52361, 0),
//OpenMesh::Vec3d(5.89091, 3.44471, 0),
//OpenMesh::Vec3d(7.51854, 5.20495, 0),
//OpenMesh::Vec3d(7.23255, 6.53119, 0),
//OpenMesh::Vec3d(6.52723, 8.04632, 0),
//OpenMesh::Vec3d(4.90999, 9.64671, 0),
//OpenMesh::Vec3d(1.78519, 10.0566, 0),
//OpenMesh::Vec3d(0.0681707, 8.56252, 0),
//OpenMesh::Vec3d(-0.669942, 6.9409, 0),
//OpenMesh::Vec3d(0.130788, 4.67688, 0),
//OpenMesh::Vec3d(0.0196744, 3.32361, 0),
//OpenMesh::Vec3d(-0.115682, 1.27079, 0),
//OpenMesh::Vec3d(-2.63821, 0.253892, 0),
//OpenMesh::Vec3d(-4.38974, -1.81549, 0),
//OpenMesh::Vec3d(-1.97308, -4.87352, 0),
//OpenMesh::Vec3d(0.268123, -6.98818, 0),
//OpenMesh::Vec3d(2.0731, -5.54189, 0),
//};

//CC_points = {//sheji
//	OpenMesh::Vec3d(-15.1181, -7.27403, 0),
//OpenMesh::Vec3d(-7.47435, -7.27403, 0),
//OpenMesh::Vec3d(-1.31281, -7.27403, 0),
//OpenMesh::Vec3d(1.437, -7.27403, 0),
//OpenMesh::Vec3d(1.39394, -6.40042, 0),
//OpenMesh::Vec3d(1.437, 1.82655, 0),
//OpenMesh::Vec3d(1.437, 5.21889, 0),
//OpenMesh::Vec3d(-4.08329, 5.21889, 0),
//OpenMesh::Vec3d(-10.0778, 5.21889, 0),
//OpenMesh::Vec3d(-15.1181, 5.21889, 0),
//OpenMesh::Vec3d(-15.0535, 1.26594, 0),
//OpenMesh::Vec3d(-15.075, -6.50998, 0),
//};
//CC_points = {//sheji polyGC
//	OpenMesh::Vec3d(-15.1181, -7.31403, 0),
//	OpenMesh::Vec3d(-13.1181, -7.36403, 0),
//	OpenMesh::Vec3d(-11.1181, -7.41403, 0),
//OpenMesh::Vec3d(-7.47435, -7.28, 0),
//OpenMesh::Vec3d(-3.31281, -7.35403, 0),
//OpenMesh::Vec3d(-1.31281, -7.59403, 0),
//OpenMesh::Vec3d(1.437, -7.71403, 0),
//OpenMesh::Vec3d(1.39394, -6.40042, 0),
//OpenMesh::Vec3d(1.437, 1.82655, 0),
//OpenMesh::Vec3d(1.437, 5.21889, 0),
//OpenMesh::Vec3d(-4.08329, 5.21889, 0),
//OpenMesh::Vec3d(-10.0778, 5.21889, 0),
//OpenMesh::Vec3d(-15.1181, 5.21889, 0),
//OpenMesh::Vec3d(-15.0535, 1.26594, 0),
//OpenMesh::Vec3d(-15.075, -6.50998, 0),
//};
//CC_points = { //shejiCVM
// OpenMesh::Vec3d(-12.729, -6.31988, 0),
//OpenMesh::Vec3d(-10.997, -6.3684, 0),
//OpenMesh::Vec3d(-8.98264, -6.41056, 0),
//OpenMesh::Vec3d(-6.73546, -6.27695, 0),
//OpenMesh::Vec3d(-4.10206, -6.35682, 0),
//OpenMesh::Vec3d(-1.83219, -6.59565, 0),
//OpenMesh::Vec3d(1.47363, -6.71038, 0),
//OpenMesh::Vec3d(1.91409, -1.48812, 0),
//OpenMesh::Vec3d(1.91601, 1.91747, 0),
//OpenMesh::Vec3d(2.24009, 5.19837, 0),
//OpenMesh::Vec3d(-4.52556, 4.91904, 0),
//OpenMesh::Vec3d(-9.04531, 4.60278, 0),
//OpenMesh::Vec3d(-12.3981, 4.54636, 0),
//OpenMesh::Vec3d(-12.5084, 0.92428, 0),
//OpenMesh::Vec3d(-12.6187, -2.6978, 0),
//OpenMesh::Vec3d(-12.729, -6.31988, 0),
//};

//pangxie

//CC_points = { //pangxie
//	OpenMesh::Vec3d(7.71977, -2.05287, 0),
//OpenMesh::Vec3d(14.0104, 0.411218, 0),
//OpenMesh::Vec3d(19.374, -4.0279, 0),
//OpenMesh::Vec3d(22.4267, -11.7043, 0),
//OpenMesh::Vec3d(22.6234, -4.69254, 0),
//OpenMesh::Vec3d(16.5132, 3.32898, 0),
//OpenMesh::Vec3d(7.68061, 1.27629, 0),
//OpenMesh::Vec3d(11.8108, 5.72265, 0),
//OpenMesh::Vec3d(24.3071, 0.0673024, 0),
//OpenMesh::Vec3d(25.5395, -8.6918, 0),
//OpenMesh::Vec3d(24.2683, 1.50686, 0),
//OpenMesh::Vec3d(15.8142, 7.55389, 0),
//OpenMesh::Vec3d(7.82502, 4.58309, 0),
//OpenMesh::Vec3d(13.0287, 7.31829, 0),
//OpenMesh::Vec3d(20.2624, 6.36308, 0),
//OpenMesh::Vec3d(25.4787, 9.17267, 0),
//OpenMesh::Vec3d(18.4321, 10.7327, 0),
//OpenMesh::Vec3d(13.6405, 8.00646, 0),
//OpenMesh::Vec3d(4.85222, 5.92983, 0),
//OpenMesh::Vec3d(10.4038, 10.2729, 0),
//OpenMesh::Vec3d(14.7017, 15.1746, 0),
//OpenMesh::Vec3d(12.0969, 19.6625, 0),
//OpenMesh::Vec3d(11.6911, 15.6914, 0),
//OpenMesh::Vec3d(8.19465, 10.9663, 0),
//OpenMesh::Vec3d(2.16398, 7.18829, 0),
//OpenMesh::Vec3d(-0.0248164, 9.29763, 0),
//OpenMesh::Vec3d(-1.17408, 9.21065, 0),
//OpenMesh::Vec3d(-3.33054, 6.62634, 0),
//OpenMesh::Vec3d(-6.47158, 9.13021, 0),
//OpenMesh::Vec3d(-13.0069, 12.1429, 0),
//OpenMesh::Vec3d(-13.8588, 18.6794, 0),
//OpenMesh::Vec3d(-18.8441, 13.6221, 0),
//OpenMesh::Vec3d(-12.6782, 8.694, 0),
//OpenMesh::Vec3d(-5.13643, 5.07839, 0),
//OpenMesh::Vec3d(-5.27052, 4.97835, 0),
//OpenMesh::Vec3d(-5.46014, 4.84129, 0),
//OpenMesh::Vec3d(-5.64977, 4.70424, 0),
//OpenMesh::Vec3d(-16.6586, 6.71951, 0),
//OpenMesh::Vec3d(-22.5467, 6.17214, 0),
//OpenMesh::Vec3d(-27.2511, 11.2113, 0),
//OpenMesh::Vec3d(-24.0825, 3.01043, 0),
//OpenMesh::Vec3d(-15.7064, 4.55985, 0),
//OpenMesh::Vec3d(-7.0058, 3.14714, 0),
//OpenMesh::Vec3d(-17.113, 3.54583, 0),
//OpenMesh::Vec3d(-25.8122, -0.336797, 0),
//OpenMesh::Vec3d(-28.889, -9.77593, 0),
//OpenMesh::Vec3d(-21.7434, -1.11048, 0),
//OpenMesh::Vec3d(-15.7677, 1.49321, 0),
//OpenMesh::Vec3d(-7.4344, 0.51362, 0),
//OpenMesh::Vec3d(-18.7285, 0.0406011, 0),
//OpenMesh::Vec3d(-23.595, -7.64864, 0),
//OpenMesh::Vec3d(-19.4429, -13.2397, 0),
//OpenMesh::Vec3d(-19.1456, -5.33267, 0),
//OpenMesh::Vec3d(-13.9446, -1.15383, 0),
//OpenMesh::Vec3d(-7.53781, -3.00233, 0),
//OpenMesh::Vec3d(-16.6865, -2.97738, 0),
//OpenMesh::Vec3d(-18.0268, -14.6281, 0),
//OpenMesh::Vec3d(-2.51255, -20.4804, 0),
//OpenMesh::Vec3d(-4.32991, -14.8028, 0),
//OpenMesh::Vec3d(-7.41556, -7.88393, 0),
//OpenMesh::Vec3d(-11.3053, -6.94069, 0),
//OpenMesh::Vec3d(-7.82506, -6.74206, 0),
//OpenMesh::Vec3d(-4.0724, -6.50565, 0),
//OpenMesh::Vec3d(0.270762, -12.5408, 0),
//OpenMesh::Vec3d(4.64637, -10.1421, 0),
//OpenMesh::Vec3d(7.19738, -5.76408, 0),
//OpenMesh::Vec3d(11.4721, -5.97088, 0),
//OpenMesh::Vec3d(9.8597, -10.8824, 0),
//OpenMesh::Vec3d(3.22116, -19.9134, 0),
//OpenMesh::Vec3d(-0.202762, -25.0171, 0),
//OpenMesh::Vec3d(1.82509, -36.1817, 0),
//OpenMesh::Vec3d(10.8714, -18.1249, 0),
//OpenMesh::Vec3d(15.5892, -11.8939, 0),
//OpenMesh::Vec3d(18.353, -8.94576, 0),
//OpenMesh::Vec3d(15.939, -2.21534, 0),
//};
//CC_points = subdivideCage3(CC_points, 5);

//haixing

//CC_points = { OpenMesh::Vec3d(-2.25375, 0.541636, 0),
//OpenMesh::Vec3d(-1.5692, -0.0704777, 0),
//OpenMesh::Vec3d(-0.939124, -0.304947, 0),
//OpenMesh::Vec3d(-0.342821, -0.389381, 0),
//OpenMesh::Vec3d(-0.305095, -0.980101, 0),
//OpenMesh::Vec3d(-0.192065, -1.52177, 0),
//OpenMesh::Vec3d(0.266718, -2.03271, 0),
//OpenMesh::Vec3d(0.356279, -1.45354, 0),
//OpenMesh::Vec3d(0.28072, -1.12409, 0),
//OpenMesh::Vec3d(0.47484, -0.621889, 0),
//OpenMesh::Vec3d(1.03449, -0.742853, 0),
//OpenMesh::Vec3d(1.61279, -0.742645, 0),
//OpenMesh::Vec3d(2.18771, -0.566004, 0),
//OpenMesh::Vec3d(1.77086, -0.300585, 0),
//OpenMesh::Vec3d(1.35738, -0.211599, 0),
//OpenMesh::Vec3d(0.959173, 0.174992, 0),
//OpenMesh::Vec3d(1.22582, 0.605225, 0),
//OpenMesh::Vec3d(1.52043, 0.937587, 0),
//OpenMesh::Vec3d(2.03408, 1.04625, 0),
//OpenMesh::Vec3d(1.29787, 1.25297, 0),
//OpenMesh::Vec3d(0.836625, 1.04026, 0),
//OpenMesh::Vec3d(0.375383, 0.827541, 0),
//OpenMesh::Vec3d(-0.039958, 1.16658, 0),
//OpenMesh::Vec3d(-0.315485, 1.60814, 0),
//OpenMesh::Vec3d(-0.222835, 2.14291, 0),
//OpenMesh::Vec3d(-0.607585, 1.51606, 0),
//OpenMesh::Vec3d(-0.54027, 1.00105, 0),
//OpenMesh::Vec3d(-0.458974, 0.453426, 0),
//OpenMesh::Vec3d(-1.05033, 0.40696, 0),
//OpenMesh::Vec3d(-1.62709, 0.335766, 0),
//};

//L_zimu
//CC_points = { OpenMesh::Vec3d(-2.78, -2.17974, 0),
//OpenMesh::Vec3d(-0.743021, -0.837509, 0),
//OpenMesh::Vec3d(0.723879, -3.22733, 0),
//OpenMesh::Vec3d(2.41881, -2.02589, 0),
//OpenMesh::Vec3d(1.53845, -1.79846, 0),
//OpenMesh::Vec3d(1.53845, -1.13513, 0),
//OpenMesh::Vec3d(2.05128, -0.300849, 0),
//OpenMesh::Vec3d(0.81444, -0.822226, 0),
//OpenMesh::Vec3d(-0.0292326, 0.400018, 0),
//OpenMesh::Vec3d(-0.855811, -0.317944, 0),
//OpenMesh::Vec3d(-1.10368, 0.930691, 0),
//OpenMesh::Vec3d(-0.25751, 1.5212, 0),
//OpenMesh::Vec3d(-0.437, 3.57326, 0),
//OpenMesh::Vec3d(-1.15247, 2.72709, 0),
//OpenMesh::Vec3d(-1.78247, 2.72709, 0),
//OpenMesh::Vec3d(-2.327, 3.57326, 0),
//OpenMesh::Vec3d(-2.07913, 0.874956, 0),
//OpenMesh::Vec3d(-3.91677, -0.387428, 0),
//};
{//sharp
	/*CC_points = {
		OpenMesh::Vec3d(2.5, 3.2592, 0),
	OpenMesh::Vec3d(2.9, 2.5402, 0),
	OpenMesh::Vec3d(3.3, 1.4428, 0),
		OpenMesh::Vec3d(4.48506, 1.4428, 0),
	OpenMesh::Vec3d(7.4, 1.7739, 0),
	OpenMesh::Vec3d(9.9, 3.1173, 0),
	OpenMesh::Vec3d(10.1, 4.3756, 0),
	OpenMesh::Vec3d(10.2, 6.6462, 0),
	OpenMesh::Vec3d(7.7, 7.5544, 0),
	OpenMesh::Vec3d(4.8, 8.6613, 0),
	OpenMesh::Vec3d(3.7, 7.9139, 0),
	OpenMesh::Vec3d(3.9, 7.0246, 0),
	OpenMesh::Vec3d(2.5, 5.9461, 0),
	OpenMesh::Vec3d(2.3, 6.7124, 0),
	OpenMesh::Vec3d(3.3, 8.9356, 0),
	OpenMesh::Vec3d(3.3, 10.447, 0),
	OpenMesh::Vec3d(2.3, 8.4194, 0),
	OpenMesh::Vec3d(0.6, 8.7881, 0),
	OpenMesh::Vec3d(0, 10.595, 0),
	OpenMesh::Vec3d(-0.42, 8.0322, 0),
	OpenMesh::Vec3d(-0.07, 6.4282, 0),
	
	};*/
}
{//半圆2次
	/*CC_points={OpenMesh::Vec3d(12.05, 12.1, 1),
		OpenMesh::Vec3d(-0.708706, 8.74919, 0.707107),
		OpenMesh::Vec3d(9.45828, -0.171837, 1),
		OpenMesh::Vec3d(-0.622788, -8.72055, 0.707107),
		OpenMesh::Vec3d(12.05, -12.1, 1),
		OpenMesh::Vec3d(12.05, -9.5, 0.707107),
		OpenMesh::Vec3d(12.05, -6.9, 1),
		OpenMesh::Vec3d(4.74905, -5.69714, 0.707107),
		OpenMesh::Vec3d(13.3695, -0.286394, 1),
		OpenMesh::Vec3d(4.89224, 4.95252, 0.707107),
		OpenMesh::Vec3d(12.05, 6.9, 1),
		OpenMesh::Vec3d(12.05, 9.5, 0.707107),
	};*/
}
{//半圆1次
	//CC_points = { OpenMesh::Vec3d(12.05, 12.1, 1),
	//	OpenMesh::Vec3d(-0.708706, 8.74919, 0.707107),
	//	OpenMesh::Vec3d(9.45828, -0.171837, 1),
	//	OpenMesh::Vec3d(-0.622788, -8.72055, 0.707107),
	//	OpenMesh::Vec3d(12.05, -12.1, 1),
	//	OpenMesh::Vec3d(12.05, -9.5, 0.707107),
	//	OpenMesh::Vec3d(12.05, -6.9, 1),
	//	OpenMesh::Vec3d(9.41232, -4.46468, 0.707107),//bian
	//	OpenMesh::Vec3d(13.3695, -0.286394, 1),
	//	OpenMesh::Vec3d(9.47163, 3.98848, 0.707107),//bian
	//	OpenMesh::Vec3d(12.05, 6.9, 1),
	//	OpenMesh::Vec3d(12.05, 9.5, 0.707107),
	//};
}
//{//zimu_S
//	CC_points = { OpenMesh::Vec3d(-0.477647, -0.0101147, 0),
//OpenMesh::Vec3d(2.53541, -1.06429, 0),
//OpenMesh::Vec3d(2.90254, 1.8419, 0),
//OpenMesh::Vec3d(2.68604, 4.00149, 0),
//OpenMesh::Vec3d(2.47029, 3.97561, 0),
//OpenMesh::Vec3d(2.23327, 3.93561, 0),
//OpenMesh::Vec3d(2.07341, 3.91891, 0),
//OpenMesh::Vec3d(2.23797, 1.60183, 0),
//OpenMesh::Vec3d(1.95667, -0.148694, 0),
//OpenMesh::Vec3d(0.210648, 0.281259, 0),
//OpenMesh::Vec3d(-1.70295, 0.994505, 0),
//OpenMesh::Vec3d(-0.571699, 2.32499, 0),
//OpenMesh::Vec3d(1.00319, 1.49733, 0),
//OpenMesh::Vec3d(1.01068, 1.6999, 0),
//OpenMesh::Vec3d(1.00507, 1.93938, 0),
//OpenMesh::Vec3d(0.992243, 2.11998, 0),
//OpenMesh::Vec3d(-0.960925, 2.78616, 0),
//OpenMesh::Vec3d(-2.43433, 0.977681, 0),
//	};
//	//poly zimu
//	CC_points = { OpenMesh::Vec3d(0.596266, -1.16511, 0),
//OpenMesh::Vec3d(0.898172, -2.07537, 0),
//OpenMesh::Vec3d(0.973478, -3.15015, 0),
//OpenMesh::Vec3d(0.825015, -4.27126, 0),
//OpenMesh::Vec3d(1.1123, -4.27268, 0),
//OpenMesh::Vec3d(1.39959, -4.2741, 0),
//OpenMesh::Vec3d(1.68687, -4.27552, 0),
//OpenMesh::Vec3d(1.63402, -3.16611, 0),
//OpenMesh::Vec3d(1.57093, -2.44873, 0),
//OpenMesh::Vec3d(1.48495, -1.7227, 0),
//OpenMesh::Vec3d(1.19863, -0.64689, 0),
//OpenMesh::Vec3d(0.460171, 0.30181, 0),
//OpenMesh::Vec3d(-0.671918, 1.48669, 0),
//OpenMesh::Vec3d(-0.104849, 1.49019, 0),
//OpenMesh::Vec3d(0.462221, 1.4937, 0),
//OpenMesh::Vec3d(1.02929, 1.4972, 0),
//OpenMesh::Vec3d(1.02907, 1.75843, 0),
//OpenMesh::Vec3d(1.02886, 2.01965, 0),
//OpenMesh::Vec3d(1.02864, 2.28088, 0),
//OpenMesh::Vec3d(-0.33965, 2.26868, 0),
//OpenMesh::Vec3d(-1.70794, 2.25647, 0),
//OpenMesh::Vec3d(-3.07623, 2.24427, 0),
//OpenMesh::Vec3d(-1.85206, 1.10781, 0),
//OpenMesh::Vec3d(-0.627899, -0.02865, 0),
//	};
//	//rainbow
//	CC_points = { OpenMesh::Vec3d(-5.77366, -0.928836, 0),
//OpenMesh::Vec3d(-3.65098, 4.19543, 0),
//OpenMesh::Vec3d(2.03709, 8.46171, 0),
//OpenMesh::Vec3d(9.68661, 6.70256, 0),
//OpenMesh::Vec3d(9.4823, 6.97699, 0),
//OpenMesh::Vec3d(9.35452, 7.20967, 0),
//OpenMesh::Vec3d(9.23336, 7.4763, 0),
//OpenMesh::Vec3d(2.0932, 8.94037, 0),
//OpenMesh::Vec3d(-3.6725, 5.20192, 0),
//OpenMesh::Vec3d(-6.41423, -0.846814, 0),
//OpenMesh::Vec3d(-4.12424, 5.29816, 0),
//OpenMesh::Vec3d(-3.29185, 9.43953, 0),
//OpenMesh::Vec3d(6.93526, 10.9867, 0),
//OpenMesh::Vec3d(6.73435, 11.1651, 0),
//OpenMesh::Vec3d(6.59713, 11.2938, 0),
//OpenMesh::Vec3d(6.46108, 11.3846, 0),
//OpenMesh::Vec3d(-2.66827, 10.0345, 0),
//OpenMesh::Vec3d(-5.0881, 7.15129, 0),
//OpenMesh::Vec3d(-7.42613, -2.25787, 0),
//OpenMesh::Vec3d(-8.65612, -1.67216, 0),
//OpenMesh::Vec3d(-13.1998, -3.81923, 0),
//OpenMesh::Vec3d(-6.02623, -6.5032, 0),
//OpenMesh::Vec3d(-2.88592, -5.16367, 0),
//OpenMesh::Vec3d(-0.978079, -2.18366, 0),
//OpenMesh::Vec3d(-4.02564, -1.5895, 0),
//OpenMesh::Vec3d(-0.942283, 4.27499, 0),
//OpenMesh::Vec3d(5.88163, 3.10995, 0),
//OpenMesh::Vec3d(4.12653, -5.57261, 0),
//OpenMesh::Vec3d(4.4302, -5.53371, 0),
//OpenMesh::Vec3d(4.74567, -5.50482, 0),
//OpenMesh::Vec3d(5.03021, -5.49228, 0),
//OpenMesh::Vec3d(6.5918, 3.61028, 0),
//OpenMesh::Vec3d(-1.1495, 4.66369, 0),
//OpenMesh::Vec3d(-4.38251, -0.855424, 0),
//OpenMesh::Vec3d(-1.41844, 4.78383, 0),
//OpenMesh::Vec3d(5.94785, 5.05397, 0),
//OpenMesh::Vec3d(8.57693, -3.08065, 0),
//OpenMesh::Vec3d(8.57938, -2.66126, 0),
//OpenMesh::Vec3d(8.60379, -2.36224, 0),
//OpenMesh::Vec3d(8.63264, -2.05827, 0),
//OpenMesh::Vec3d(4.99936, 6.54761, 0),
//OpenMesh::Vec3d(-2.13908, 4.46348, 0),
//OpenMesh::Vec3d(-5.0399, -0.745585, 0),
//OpenMesh::Vec3d(-2.61174, 4.15792, 0),
//OpenMesh::Vec3d(4.66582, 6.75996, 0),
//OpenMesh::Vec3d(9.68352, 0.652446, 0),
//OpenMesh::Vec3d(9.73424, 0.909529, 0),
//OpenMesh::Vec3d(9.75751, 1.17138, 0),
//OpenMesh::Vec3d(9.79496, 1.37106, 0),
//OpenMesh::Vec3d(4.4877, 7.31385, 0),
//OpenMesh::Vec3d(-3.19225, 4.7506, 0),
//	};
//}
}
if (useHandle)
{
	partion_handles(Handle_points, deform_cps, deform_cps_t);
	if (degree == 1) {
		calculate_cauchy_weight121(deform_cps);//计算了cps顶点上的cauchy权重矩阵
	}
	if (degree == 2) {
		calculate_cauchy_weight222(deform_cps);//计算了cps顶点上的cauchy权重矩阵
	}
	if (degree == 3) {
		//calculate_cauchy_weight123(deform_cps);
		calculate_cauchy_weight323(deform_cps);
	}

	double lambda = p2pweight;//lambda

	int n = CC_points.size();
	int p = deform_cps.size();
	int k = Cboundary_vertices.size();//
	// 将std::vector转换为Eigen矩阵
	Eigen::MatrixXcd C(p, n);
	for (int i = 0; i < p; ++i) {
		for (int j = 0; j < n; ++j) {
			C(i, j) = cp_cauchyweights[i][j];
		}
	}
	

	Eigen::MatrixXcd D(k, n);
	for (int i = 0; i < k; ++i) {
		for (int j = 0; j < n; ++j) {
			D(i, j) = lambda*D2cauchyweights[i][j];
		}
	}

	Eigen::VectorXcd f(p);
	for (int i = 0; i < p; ++i) {
		f(i) = deform_cps_t[i];
	}
	/*Eigen::VectorXcd CC_points_comp(n);
	for (int i = 0; i < n; i++) {
		CC_points_comp[i] = std::complex<double>(CC_points[i][0], CC_points[i][1]);
	}
	std::cout << C * CC_points_comp - f<<std :: endl;*/

	// 创建零向量 0（k 维）
	Eigen::VectorXcd zero_vec = Eigen::VectorXcd::Zero(k);
	// 创建 A 矩阵，通过垂直拼接 C 和 D
	Eigen::MatrixXcd A(p + k, n);
	A << C, D;

	// 创建 b 向量，通过垂直拼接 f 和 0 向量
	Eigen::VectorXcd b(p + k);
	b << f, zero_vec;

	//// 计算 C^T * C 和 D^T * D
	//Eigen::MatrixXcd CtC = C.adjoint() * C;  // C^T * C
	//Eigen::MatrixXcd DtD = D.adjoint() * D;  // D^T * D

	//// 构建 (C^T * C + lambda^2 * D^T * D)
	//Eigen::MatrixXcd A = CtC +  DtD;

	//// 构建 C^T * f
	//Eigen::VectorXcd b = C.adjoint() * f;

	// 解方程组 A * u = b
	Eigen::VectorXcd u = A.colPivHouseholderQr().solve(b);
	std::cout << "u:" << std::endl;
	std::cout << u  << std::endl;
	std::cout << "C*u-f" << std::endl;
	std::cout << C*u-f << std::endl;
	//更新ccPoints
	for (int i = 0; i < CC_points.size(); i++)
	{
		CC_points[i][0] = real(u[i]);
		CC_points[i][1] = imag(u[i]);
	}

	Eigen::MatrixXcd Cauchyweight(mesh.n_vertices(), n);
	for (int i = 0; i < mesh.n_vertices(); ++i) {
		for (int j = 0; j < n; ++j) {
			Cauchyweight(i, j) = standad_cauchyweights[i][j];
		}
	}
	Eigen::VectorXcd coors = Cauchyweight * u;
	for (int i = 0; i < deformedMesh.n_vertices(); i++)
	{
		auto vh = deformedMesh.vertex_handle(i);
		auto new_point = OpenMesh::Vec3d(real(coors[i]), imag(coors[i]), 0);
		deformedMesh.set_point(vh, new_point);
	}
	CC_mesh = createMeshFromCurveCage(CC_points);
	auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
	for (auto vh : CC_mesh.vertices())
	{
		CagevertexState[vh] = NotSelected;
	}
	curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
	MeshTools::AssignPoints(mesh, deformedMesh);
	update();
	return;
}
if (degree == 1&&usebih ) {
	std::cout << "linear 双调和" << std::endl;
	/*linear_cage = { OpenMesh::Vec2d(-17, -17),
OpenMesh::Vec2d(17.99, -17),
OpenMesh::Vec2d(17, 17),
OpenMesh::Vec2d(-17, 17),
	};
	linear_cage = { OpenMesh::Vec2d(-11.45, -15.1),
OpenMesh::Vec2d(11.46, -15.1),
OpenMesh::Vec2d(11.45, 14.9),
OpenMesh::Vec2d(-11.45, 14.9),
	};
	linear_cage = { OpenMesh::Vec2d(0.677801, 1.2003),
OpenMesh::Vec2d(0.91439, -15.1614),
OpenMesh::Vec2d(11.6537, -15.2348),
OpenMesh::Vec2d(11.6459, 14.9842),
OpenMesh::Vec2d(-11.383, 15.0709),
OpenMesh::Vec2d(-11.4171, -15.2809),
OpenMesh::Vec2d(-0.62658, -15.2758),
OpenMesh::Vec2d(-0.751239, 1.18322),
	};*/
	/*linear_cage = { OpenMesh::Vec2d(-1, -1),
			  OpenMesh::Vec2d(2, -1),
			  OpenMesh::Vec2d(1, 1),
			  OpenMesh::Vec2d(-1, 1),
	};*/
	linear_cage = {
			OpenMesh::Vec2d(14.9424245065 - 15, -2.02704493154),
			OpenMesh::Vec2d(14.2852188434 - 15, -5.11591154797),
			OpenMesh::Vec2d(20.5286726426 - 15, -5.18163211427),
			OpenMesh::Vec2d(18.6884967860 - 15, 0.338895455509),
			OpenMesh::Vec2d(22.9603335959 - 15, 3.62492377086),
			OpenMesh::Vec2d(17.8341294240 - 15, 3.49348263824),
			OpenMesh::Vec2d(16.9140414957 - 15, 7.37099605035),
			OpenMesh::Vec2d(14.6138216750 - 15, 3.49348263824),
			OpenMesh::Vec2d(10.5391465639 - 15, 4.54501169915),
			OpenMesh::Vec2d(13.2994103488 - 15, 0.996101118578),
			OpenMesh::Vec2d(7.31883881489 - 15, 3.49348263824),
			OpenMesh::Vec2d(11.5906756248 - 15, -1.43555983478),
			OpenMesh::Vec2d(9.55333806933 - 15, -4.52442645121),
	};
	linear_cage = { 
		    OpenMesh::Vec2d(-18.2238, -0.94699),
            OpenMesh::Vec2d(-18.881, -4.03586),
            OpenMesh::Vec2d(5.52867, -5.18163),
            OpenMesh::Vec2d(3.6885, 0.338895),
            OpenMesh::Vec2d(7.96033, 3.62492),
            OpenMesh::Vec2d(2.83413, 3.49348),
            OpenMesh::Vec2d(1.91404, 7.371),
            OpenMesh::Vec2d(-18.5524, 4.57354),
            OpenMesh::Vec2d(-22.627, 5.62507),
            OpenMesh::Vec2d(-19.8668, 2.07616),
            OpenMesh::Vec2d(-25.8473, 4.57354),
            OpenMesh::Vec2d(-21.5755, -0.355505),
            OpenMesh::Vec2d(-23.6128, -3.44437),
	};
	//haixing
	linear_cage = { OpenMesh::Vec2d(-2.06111, 0.479614),
OpenMesh::Vec2d(-1.4976, -0.0331412),
OpenMesh::Vec2d(-0.939124, -0.304947),
OpenMesh::Vec2d(-0.342821, -0.389381),
OpenMesh::Vec2d(-0.387675, -0.928141),
OpenMesh::Vec2d(-0.119345, -1.59902),
OpenMesh::Vec2d(0.00218024, -2.15736),
OpenMesh::Vec2d(0.128741, -1.41717),
OpenMesh::Vec2d(0.157433, -1.08315),
OpenMesh::Vec2d(0.47484, -0.621889),
OpenMesh::Vec2d(1.03449, -0.742853),
OpenMesh::Vec2d(1.68745, -0.69492),
OpenMesh::Vec2d(2.43657, -0.456263),
OpenMesh::Vec2d(1.77807, -0.298051),
OpenMesh::Vec2d(1.35738, -0.211599),
OpenMesh::Vec2d(0.959173, 0.174992),
OpenMesh::Vec2d(1.22582, 0.605225),
OpenMesh::Vec2d(1.38993, 0.918946),
OpenMesh::Vec2d(2.12729, 1.09285),
OpenMesh::Vec2d(1.42836, 1.26229),
OpenMesh::Vec2d(0.836625, 1.04026),
OpenMesh::Vec2d(0.375383, 0.827541),
OpenMesh::Vec2d(0.029949, 1.21784),
OpenMesh::Vec2d(-0.222276, 1.62678),
OpenMesh::Vec2d(-0.330026, 2.08233),
OpenMesh::Vec2d(-0.505055, 1.56266),
OpenMesh::Vec2d(-0.526289, 0.968431),
OpenMesh::Vec2d(-0.458974, 0.453426),
OpenMesh::Vec2d(-1.01656, 0.256924),
OpenMesh::Vec2d(-1.53632, 0.247794),
	};
	//paris tower
	//双调和后的paristower
	/*CC_points = { OpenMesh::Vec3d(2.21312, -3.64502, 0),
OpenMesh::Vec3d(-0.200273, -1.09766, 0),
OpenMesh::Vec3d(0.410037, 1.70935, 0),
OpenMesh::Vec3d(-2.93953, 2.89046, 0),
OpenMesh::Vec3d(-0.707013, 1.49892, 0),
OpenMesh::Vec3d(0.147978, -1.42036, 0),
OpenMesh::Vec3d(-2.13172, -3.62273, 0),
OpenMesh::Vec3d(-1.5717, -3.65431, 0),
OpenMesh::Vec3d(-0.789005, -3.66778, 0),
OpenMesh::Vec3d(-0.017268, -3.66608, 0),
OpenMesh::Vec3d(0.997374, -3.65183, 0),
OpenMesh::Vec3d(1.73898, -3.63311, 0),
	};*/
	CC_points.clear();
	for (const auto& vec2 : linear_cage) {
		OpenMesh::Vec3d vec3(vec2[0], vec2[1], 0.0);  // 将第三个维度设为 0.0
		CC_points.push_back(vec3);
	}
	for (int i = 0; i < dividecages; i++) {
		auto linearcage3 = subdivideCage(linear_cage);
		linear_cage = linearcage3;
	}
	
	
	CC_mesh = createMeshFromCurveCage(CC_points);
	auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
	for (auto vh : CC_mesh.vertices())
	{
		CagevertexState[vh] = NotSelected;
	}
	curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
	//linear_cage[1] = linear_cage[1] - OpenMesh::Vec2d(0.1, 0.);
	/*auto linearcage2 = subdivideCage(linear_cage);
	linear_cage = linearcage2;
	auto linearcage3 = subdivideCage(linear_cage);
	linear_cage = linearcage3;*/
	deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
	MeshTools::AssignPoints(mesh, deformedMesh);
	update();
	return;
}
if (degree==2 && usebih) {
	std::cout << "twice 双调和变形" << std::endl;
	//CC_points表示linear_cage细分一次后的控制点，
	/*linear_cage = {
			OpenMesh::Vec2d(14.9424245065 - 15, -2.02704493154),
			OpenMesh::Vec2d(14.2852188434 - 15, -5.11591154797),
			OpenMesh::Vec2d(20.5286726426 - 15, -5.18163211427),
			OpenMesh::Vec2d(18.6884967860 - 15, 0.338895455509),
			OpenMesh::Vec2d(22.9603335959 - 15, 3.62492377086),
			OpenMesh::Vec2d(17.8341294240 - 15, 3.49348263824),
			OpenMesh::Vec2d(16.9140414957 - 15, 7.37099605035),
			OpenMesh::Vec2d(14.6138216750 - 15, 3.49348263824),
			OpenMesh::Vec2d(10.5391465639 - 15, 4.54501169915),
			OpenMesh::Vec2d(13.2994103488 - 15, 0.996101118578),
			OpenMesh::Vec2d(7.31883881489 - 15, 3.49348263824),
			OpenMesh::Vec2d(11.5906756248 - 15, -1.43555983478),
			OpenMesh::Vec2d(9.55333806933 - 15, -4.52442645121),
	};*/
	CC_points = { OpenMesh::Vec3d(11.4493, 14.8504, 0),
OpenMesh::Vec3d(0.0628, 14.8504, 0),
OpenMesh::Vec3d(-11.3237, 14.8504, 0),
OpenMesh::Vec3d(-11.3237, -0.12175, 0),
OpenMesh::Vec3d(-23.2152, -1.24194, 0),
OpenMesh::Vec3d(-23.1867, -6.10531, 0),
OpenMesh::Vec3d(-23.4977, -11.3072, 0),
OpenMesh::Vec3d(-0.812533, -6.87688, 0),
OpenMesh::Vec3d(-0.812533, 1.34013, 0),
OpenMesh::Vec3d(0.057267, 1.34566, 0),
OpenMesh::Vec3d(0.927067, 1.3512, 0),
OpenMesh::Vec3d(12.1561, 2.36974, 0),
OpenMesh::Vec3d(11.0304, -13.7587, 0),
OpenMesh::Vec3d(16.2859, -13.7587, 0),
OpenMesh::Vec3d(21.5415, -13.7587, 0),
OpenMesh::Vec3d(14.4571, 2.0521, 0),
	};
	if (1) {//cube
		CC_points = {
			OpenMesh::Vec3d(0., 0.,0),
			OpenMesh::Vec3d(2.5, 2,0),
			OpenMesh::Vec3d(5., 0.,0),
			OpenMesh::Vec3d(3, 2.5,0),
			OpenMesh::Vec3d(5.,5.,0),
			OpenMesh::Vec3d(2.5, 3,0),
			OpenMesh::Vec3d(0., 5.,0),
			OpenMesh::Vec3d(2, 2.5,0),
		};
	}
	//human
	if (0) {
		//hunman
		CC_points = { //human 2次
			OpenMesh::Vec3d(2.2434, -4.09831, 0),
		OpenMesh::Vec3d(1.33897, -1.2763, 0),
		OpenMesh::Vec3d(0.168209, 0.44022, 0),
		OpenMesh::Vec3d(1.4422, 0.351278, 0),
		OpenMesh::Vec3d(2.71398, 0.333548, 0),
		OpenMesh::Vec3d(2.71397, 1.68434, 0),
		OpenMesh::Vec3d(3.46302, 4.87632, 0),
		OpenMesh::Vec3d(2.02594, 5.163, 0),
		OpenMesh::Vec3d(0.502351, 5.27545, 0),
		OpenMesh::Vec3d(0.555983, 4.54789, 0),
		OpenMesh::Vec3d(0.618441, 3.76385, 0),
		OpenMesh::Vec3d(1.34768, 3.70515, 0),
		OpenMesh::Vec3d(2.12808, 3.63751, 0),
		OpenMesh::Vec3d(1.15359, 2.4928, 0),
		OpenMesh::Vec3d(0.929425, 1.2952, 0),
		OpenMesh::Vec3d(0.312689, 3.28967, 0),
		OpenMesh::Vec3d(-0.901575, 4.85807, 0),
		OpenMesh::Vec3d(-1.23977, 3.5368, 0),
		OpenMesh::Vec3d(-1.9027, 4.60764, 0),
		OpenMesh::Vec3d(-2.60159, 4.08557, 0),
		OpenMesh::Vec3d(-3.67377, 2.94282, 0),
		OpenMesh::Vec3d(-4.19734, 1.3431, 0),
		OpenMesh::Vec3d(-2.67894, 0.569752, 0),
		OpenMesh::Vec3d(-4.41661, 0.875907, 0),
		OpenMesh::Vec3d(-5.35647, 1.84359, 0),
		OpenMesh::Vec3d(-4.28499, -1.33886, 0),
		OpenMesh::Vec3d(-2.25433, -1.02231, 0),
		OpenMesh::Vec3d(-2.9142, -1.57256, 0),
		OpenMesh::Vec3d(-3.11938, -1.99522, 0),
		OpenMesh::Vec3d(-2.32945, -2.77795, 0),
		OpenMesh::Vec3d(-2.39632, -3.96978, 0),
		OpenMesh::Vec3d(-0.151571, -4.57271, 0),
		};

	}
	//auto linearcage4 = subdivideCage(linear_cage);
	//CC_points.clear();
	//for (const auto& vec2 : linearcage4) {
	//	OpenMesh::Vec3d vec3(vec2[0], vec2[1], 0.0);  // 将第三个维度设为 0.0
	//	CC_points.push_back(vec3);
	//}
	//for (int i = 0; i < dividecages; i++) {
	//	auto linearcage3 = subdivideCage(linear_cage);
	//	linear_cage = linearcage3;
	//}
	
	
	CC_mesh = createMeshFromCurveCage(CC_points);
	auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
	for (auto vh : CC_mesh.vertices())
	{
		CagevertexState[vh] = NotSelected;
	}
	curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
	
	deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
	MeshTools::AssignPoints(mesh, deformedMesh);
	update();
	return;
}
if (degree == 3 && usebih) {
	std::cout << "third 双调和变形" << std::endl;
	//CC_points表示linear_cage细分一次后的控制点，
	//linear_cage = {
	//		OpenMesh::Vec2d(14.9424245065 - 15, -2.02704493154),
	//		OpenMesh::Vec2d(14.2852188434 - 15, -5.11591154797),
	//		OpenMesh::Vec2d(20.5286726426 - 15, -5.18163211427),
	//		OpenMesh::Vec2d(18.6884967860 - 15, 0.338895455509),
	//		OpenMesh::Vec2d(22.9603335959 - 15, 3.62492377086),
	//		OpenMesh::Vec2d(17.8341294240 - 15, 3.49348263824),
	//		OpenMesh::Vec2d(16.9140414957 - 15, 7.37099605035),
	//		OpenMesh::Vec2d(14.6138216750 - 15, 3.49348263824),
	//		OpenMesh::Vec2d(10.5391465639 - 15, 4.54501169915),
	//		OpenMesh::Vec2d(13.2994103488 - 15, 0.996101118578),
	//		OpenMesh::Vec2d(7.31883881489 - 15, 3.49348263824),
	//		OpenMesh::Vec2d(11.5906756248 - 15, -1.43555983478),
	//		OpenMesh::Vec2d(9.55333806933 - 15, -4.52442645121),
	//};
	//auto linearcage4 = subdivideCage123(linear_cage);
	//CC_points.clear();
	//for (const auto& vec2 : linearcage4) {
	//	OpenMesh::Vec3d vec3(vec2[0], vec2[1], 0.0);  // 将第三个维度设为 0.0
	//	CC_points.push_back(vec3);
	//}
	//auto linearcage2 = subdivideCage(linear_cage);
	//linear_cage = linearcage2;

	CC_mesh = createMeshFromCurveCage(CC_points);
	auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
	for (auto vh : CC_mesh.vertices())
	{
		CagevertexState[vh] = NotSelected;
	}
	curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);

	deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
	MeshTools::AssignPoints(mesh, deformedMesh);
	update();
	return;
}
	CC_mesh = createMeshFromCurveCage(CC_points);
	auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
	for (auto vh : CC_mesh.vertices())
	{
		CagevertexState[vh] = NotSelected;
	}
	if (!highdegree)
		curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
	else
		curvecage2 = CCpoints_fromCCmesh(CC_mesh, todegree);
	deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
	MeshTools::AssignPoints(mesh, deformedMesh);
	update();
}

void MeshViewerWidget::setBezierSubdiv(int i)
{
	bezierSubdiv = i;
	update();
}

void MeshViewerWidget::setBezierLineWidth(double w)
{
	bezierLineWidth = (float)w;
	update();
}

void MeshViewerWidget::setBezierPolyLineWidth(double w)
{
	bezierPolyLineWidth = (float)w;
	update();
}

void MeshViewerWidget::setBezierPolyPointWidth(double w)
{
	bezierPolyPointWidth = (float)w;
	update();
}
//bezierPointSize现在是双调和坐标和green坐标的权重
void MeshViewerWidget::setBezierPointSize(double s)
{
	bezierPointSize = (float)s;
	Mesh deformedMesh;
	deformedMesh.assign(mesh);
	deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
	MeshTools::AssignPoints(mesh, deformedMesh);
	update();
}
//设置篇p2pweight
void MeshViewerWidget::setGreenWeightsBih(double s)
{
	std::cout << "p2p weights"<<s << std::endl;
	p2pweight = s;
	deform_cage_from_handles();
	update();
}

void getRotation(const OpenMesh::Vec3d& start, const OpenMesh::Vec3d& end, const OpenMesh::Vec3d& center, double& angle, double& scale)
{
	OpenMesh::Vec3d start_r = start - center;
	OpenMesh::Vec3d end_r = end - center;
	start_r[2] = 0;
	end_r[2] = 0;
	double start_norm = start_r.norm();
	double end_norm = end_r.norm();
	scale = end_norm / start_norm;
	double cos_value = start_r.dot(end_r) / (start_norm * end_norm);
	if (cos_value > 1) cos_value = 1.;
	if (cos_value < -1) cos_value = -1.;
	angle = acos(cos_value);
	auto f = start_r[0] * end_r[1] - start_r[1] * end_r[0];
	if (f < 0) angle = -angle;
}

bool MeshViewerWidget::event(QEvent* _event)
{
	//移动handle
	if (useHandle) {
		if (_event->type() == QEvent::MouseButtonPress)
		{
			if (selectMode == Move)
			{
				auto e = static_cast<QMouseEvent*>(_event);
				QPoint winCor = e->pos();
				double depth;
				OpenMesh::Vec3d objCor;
				WinCor2ObjCor(winCor.x(), winCor.y(), objCor, depth);
				objCor = OpenMesh::Vec3d{ objCor[0],objCor[1],0 };

				OpenMesh::VertexHandle minVh;
				if (NearestCageVertex(objCor, minVh))
				{

					auto vertexState = OpenMesh::getProperty<OpenMesh::VertexHandle, VertexState>(Handle_mesh, "vertexState");
					if (vertexState[minVh] == Custom)
					{
						isMovable = true;
						moveDepth = depth;
						lastObjCor = objCor;
						return true;
					}
				}
			}
			if (selectMode == SelectAdjust)
			{
				auto e = static_cast<QMouseEvent*>(_event);
				QPoint winCor = e->pos();
				double depth;
				OpenMesh::Vec3d objCor;
				WinCor2ObjCor(winCor.x(), winCor.y(), objCor, depth);
				objCor = OpenMesh::Vec3d{ objCor[0],objCor[1],0 };

				OpenMesh::VertexHandle minVh;
				if (NearestCageVertex(objCor, minVh))
				{
					auto vertexState = OpenMesh::getProperty<OpenMesh::VertexHandle, VertexState>(Handle_mesh, "vertexState");
					if (vertexState[minVh] == Custom)
					{
						isMovable = true;
						moveDepth = depth;
						lastObjCor = objCor;
						currentMoveStart = objCor;
						return true;
					}
				}
			}
			if (selectMode == SelectAdjustMesh)
			{
				auto e = static_cast<QMouseEvent*>(_event);
				QPoint winCor = e->pos();
				double depth;
				OpenMesh::Vec3d objCor;
				WinCor2ObjCor(winCor.x(), winCor.y(), objCor, depth);
				objCor = OpenMesh::Vec3d{ objCor[0],objCor[1],0 };

				OpenMesh::VertexHandle minVh;
				if (NearestCageVertex(objCor, minVh))
				{
					auto vertexState = OpenMesh::getProperty<OpenMesh::VertexHandle, VertexState>(Handle_mesh, "vertexState");
					if (vertexState[minVh] == Custom)
					{
						isMovable = true;
						moveDepth = depth;
						lastObjCor = objCor;
						currentMoveStart = objCor;
						return true;
					}
				}
			}
		}
		else if (_event->type() == QEvent::MouseMove)
		{

			if ((selectMode == Move || selectMode == SelectAdjustMesh) && isMovable)
			{

				auto e = static_cast<QMouseEvent*>(_event);
				QPoint winCor = e->pos();
				OpenMesh::Vec3d objCor;
				WinCor2ObjCor(winCor.x(), winCor.y(), moveDepth, objCor);
				objCor = OpenMesh::Vec3d{ objCor[0],objCor[1],0 };

				auto moveVec = objCor - lastObjCor;


				if (isRotationMode)
				{
					auto CCvertexState = OpenMesh::getProperty<OpenMesh::VertexHandle, VertexState>(Handle_mesh, "vertexState");
					double angle = 0., scale = 1.;
					getRotation(lastObjCor, objCor, rotationCenter, angle, scale);
					for (auto vh_ : Handle_mesh.vertices())
					{
						if (CCvertexState[Handle_mesh.vertex_handle(vh_.idx())] == Custom)
						{
							auto& pos = Handle_mesh.point(vh_);
							auto pos_r = pos - rotationCenter;
							OpenMesh::Vec3d newPos_r(
								pos_r[0] * cos(angle) - pos_r[1] * sin(angle),
								pos_r[0] * sin(angle) + pos_r[1] * cos(angle),
								0.
							);
							newPos_r *= scale;
							auto newPos = newPos_r + rotationCenter;
							Handle_mesh.set_point(vh_, newPos);
							int vertex_id = vh_.idx();
							Handle_points[vertex_id] = newPos;
						}
					}
				}
				else
				{
					auto CCvertexState = OpenMesh::getProperty<OpenMesh::VertexHandle, VertexState>(Handle_mesh, "vertexState");
					for (auto vh_ : Handle_mesh.vertices())
					{
						if (CCvertexState[Handle_mesh.vertex_handle(vh_.idx())] == Custom)
						{
							Handle_mesh.set_point(vh_, Handle_mesh.point(vh_) + moveVec);
							int vertex_id = vh_.idx();
							Handle_points[vertex_id] = Handle_points[vertex_id] + moveVec;
						}
					}
				}



				lastObjCor = objCor;

				deform_cage_from_handles();
				update();
				return true;
			}

			if (selectMode == SelectAdjust && isMovable)
			{

				auto e = static_cast<QMouseEvent*>(_event);
				QPoint winCor = e->pos();
				OpenMesh::Vec3d objCor;
				WinCor2ObjCor(winCor.x(), winCor.y(), moveDepth, objCor);
				objCor = OpenMesh::Vec3d{ objCor[0],objCor[1],0 };

				auto moveVec = objCor - lastObjCor;
				lastObjCor = objCor;
				//for cage mesh
				//Mesh deformedCCMesh;
				//deformedCCMesh.assign(CC_mesh);
				auto CCvertexState = OpenMesh::getProperty<OpenMesh::VertexHandle, VertexState>(Handle_mesh, "vertexState");
				for (auto vh_ : Handle_mesh.vertices())
				{
					if (CCvertexState[Handle_mesh.vertex_handle(vh_.idx())] == Custom)
					{
						Handle_mesh.set_point(vh_, Handle_mesh.point(vh_) + moveVec);
						int vertex_id = vh_.idx();
						OpenMesh::VertexHandle next_vh = Handle_mesh.vertex_handle(vertex_id+1);
						Handle_mesh.set_point(next_vh, Handle_mesh.point(vh_) + OpenMesh::Vec3d(0.1, 0, 0));
						Handle_points[vertex_id] = Handle_points[vertex_id] + moveVec;
						Handle_points[vertex_id + 1] = Handle_points[vertex_id] + OpenMesh::Vec3d(0.1, 0, 0);
					}
				}


				//MeshTools::AssignPoints(CC_mesh, deformedCCMesh);
				//deform_cage_from_handles();
				partion_handles(Handle_points, deform_cps, deform_cps_t);
				update();
				return true;
			}
			

		}
		else if (_event->type() == QEvent::MouseButtonRelease)
		{

			if ((selectMode == Move || selectMode == SelectAdjustMesh) && isMovable)
			{
				std::cout << "{";
				for (const auto& point : Handle_points) {
					std::cout << "OpenMesh::Vec3d(" << point[0] << ", " << point[1] << ", " << point[2] << ")," << std::endl;
				}
				std::cout << "}" << std::endl;
				isMovable = false;

				MoveInfo currentInfo;
				if (isRotationMode)
				{
					currentInfo.move = rotationCenter;
					currentInfo.isRotation = true;
					auto CCvertexState = OpenMesh::getProperty<OpenMesh::VertexHandle, VertexState>(Handle_mesh, "vertexState");
					for (auto& vh_ : Handle_mesh.vertices())
					{
						if (CCvertexState[Handle_mesh.vertex_handle(vh_.idx())] == Custom)
						{
							currentInfo.vertices.push_back(vh_);
						}
					}
					getRotation(currentMoveStart, lastObjCor, rotationCenter, currentInfo.angle, currentInfo.scale);
					if (!currentInfo.vertices.empty() && (currentMoveStart - lastObjCor).norm() > 1e-4)
					{
						moveHistories.resize(currentHistoryPos);
						moveHistories.push_back(std::move(currentInfo));
						currentHistoryPos++;
					}
				}
				else
				{
					currentInfo.move = lastObjCor - currentMoveStart;
					currentInfo.isRotation = false;
					auto CCvertexState = OpenMesh::getProperty<OpenMesh::VertexHandle, VertexState>(Handle_mesh, "vertexState");
					for (auto& vh_ : Handle_mesh.vertices())
					{
						if (CCvertexState[Handle_mesh.vertex_handle(vh_.idx())] == Custom)
						{
							currentInfo.vertices.push_back(vh_);
						}
					}

					if (!currentInfo.vertices.empty() && currentInfo.move.norm() > 1e-4)
					{
						moveHistories.resize(currentHistoryPos);
						moveHistories.push_back(std::move(currentInfo));
						currentHistoryPos++;
					}
				}

				return true;
			}
			if (selectMode == SelectAdjust && isMovable)
			{
				std::cout << "{";
				for (const auto& point : Handle_points) {
					std::cout << "OpenMesh::Vec3d(" << point[0] << ", " << point[1] << ", " << point[2] << ")," << std::endl;
				}
				std::cout << "}" << std::endl;
				isMovable = false;

				MoveInfo currentInfo;
				currentInfo.move = lastObjCor - currentMoveStart;
				auto CCvertexState = OpenMesh::getProperty<OpenMesh::VertexHandle, VertexState>(Handle_mesh, "vertexState");
				for (auto& vh_ : Handle_mesh.vertices())
				{
					if (CCvertexState[Handle_mesh.vertex_handle(vh_.idx())] == Custom)
					{
						currentInfo.vertices.push_back(vh_);
					}
				}

				if (!currentInfo.vertices.empty() && currentInfo.move.norm() > 1e-4)
				{
					moveHistories.resize(currentHistoryPos);
					moveHistories.push_back(std::move(currentInfo));
					currentHistoryPos++;
				}
				return true;
			}
		}
		else if (_event->type() == QEvent::KeyPress)
		{
			auto e = static_cast<QKeyEvent*>(_event);
			if (e->key() == Qt::Key_Z)
			{
				// Undo
				if (currentHistoryPos > 0)
				{
					currentHistoryPos--;
					auto& moveInfo = moveHistories[currentHistoryPos];
					if (moveInfo.isRotation)
					{
						auto moveRotationCenter = moveInfo.move;
						Mesh deformedMesh;
						deformedMesh.assign(mesh);

						//for cage mesh
						//Mesh deformedCCMesh;
						//deformedCCMesh.assign(Handle_mesh);
						for (auto vh_ : moveInfo.vertices)
						{
							auto pos = Handle_mesh.point(vh_);
							auto pos_r = pos - moveRotationCenter;
							OpenMesh::Vec3d newPos_r(
								pos_r[0] * cos(moveInfo.angle) + pos_r[1] * sin(moveInfo.angle),
								-pos_r[0] * sin(moveInfo.angle) + pos_r[1] * cos(moveInfo.angle),
								0.
							);
							newPos_r /= moveInfo.scale;
							auto newPos = newPos_r + moveRotationCenter;
							Handle_mesh.set_point(vh_, newPos);
							int vertex_id = vh_.idx();
							Handle_points[vertex_id] = newPos;
						}

						//MeshTools::AssignPoints(Handle_mesh, deformedCCMesh);
						if (!highdegree)
						{
							auto deformedcurvecage2 = CCpoints_fromCCmesh(Handle_mesh, degree);
							curvecage2 = deformedcurvecage2;
						}
						else
						{
							auto deformedcurvecage2 = CCpoints_fromCCmesh(Handle_mesh, todegree);
							curvecage2 = deformedcurvecage2;
						}
						deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
						MeshTools::AssignPoints(mesh, deformedMesh);
						update();
						return true;
					}
					else
					{
						auto moveVec = -moveInfo.move;
						auto CCvertexState = OpenMesh::getProperty<OpenMesh::VertexHandle, VertexState>(Handle_mesh, "vertexState");
						if (selectMode == SelectAdjust)
						{
							for (auto vh_ : moveInfo.vertices)
							{
								Handle_mesh.set_point(vh_, Handle_mesh.point(vh_) + moveVec);
								int vertex_id = vh_.idx();
								Handle_points[vertex_id] = Handle_points[vertex_id] + moveVec;
							}
							auto deformedcurvecage2 = CCpoints_fromCCmesh(Handle_mesh, degree);
							curvecage2 = deformedcurvecage2;

							update();
							return true;
						}
						else if (selectMode == SelectCustom || selectMode == SelectAdjustMesh || selectMode == Move)
						{
							Mesh deformedMesh;
							deformedMesh.assign(mesh);

							//for cage mesh
							//Mesh deformedCCMesh;
							//deformedCCMesh.assign(Handle_mesh);
							for (auto vh_ : moveInfo.vertices)
							{
								Handle_mesh.set_point(vh_, Handle_mesh.point(vh_) + moveVec);
								int vertex_id = vh_.idx();
								Handle_points[vertex_id] = Handle_points[vertex_id] + moveVec;
							}

							//MeshTools::AssignPoints(Handle_mesh, deformedCCMesh);
							if (!highdegree)
							{
								auto deformedcurvecage2 = CCpoints_fromCCmesh(Handle_mesh, degree);
								curvecage2 = deformedcurvecage2;
							}
							else
							{
								auto deformedcurvecage2 = CCpoints_fromCCmesh(Handle_mesh, todegree);
								curvecage2 = deformedcurvecage2;
							}
							deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
							MeshTools::AssignPoints(mesh, deformedMesh);
							update();
							return true;
						}
					}
				}
				else
				{
					std::cout << "Warning: Unable to undo the last operation\n";
				}
			}
			else if (e->key() == Qt::Key_X)
			{
				// Redo
				if (currentHistoryPos < moveHistories.size())
				{
					auto& moveInfo = moveHistories[currentHistoryPos];
					currentHistoryPos++;
					if (moveInfo.isRotation)
					{
						auto moveRotationCenter = moveInfo.move;
						Mesh deformedMesh;
						deformedMesh.assign(mesh);

						//for cage mesh
						//Mesh deformedCCMesh;
						//deformedCCMesh.assign(Handle_mesh);
						for (auto vh_ : moveInfo.vertices)
						{
							auto pos = Handle_mesh.point(vh_);
							auto pos_r = pos - moveRotationCenter;
							OpenMesh::Vec3d newPos_r(
								pos_r[0] * cos(moveInfo.angle) - pos_r[1] * sin(moveInfo.angle),
								pos_r[0] * sin(moveInfo.angle) + pos_r[1] * cos(moveInfo.angle),
								0.
							);
							newPos_r *= moveInfo.scale;
							auto newPos = newPos_r + moveRotationCenter;
							Handle_mesh.set_point(vh_, newPos);
							int vertex_id = vh_.idx();
							Handle_points[vertex_id] = newPos;
						}

						//MeshTools::AssignPoints(Handle_mesh, deformedCCMesh);
						if (!highdegree)
						{
							auto deformedcurvecage2 = CCpoints_fromCCmesh(Handle_mesh, degree);
							curvecage2 = deformedcurvecage2;
						}
						else
						{
							auto deformedcurvecage2 = CCpoints_fromCCmesh(Handle_mesh, todegree);
							curvecage2 = deformedcurvecage2;
						}
						deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
						MeshTools::AssignPoints(mesh, deformedMesh);
						update();
						return true;
					}
					else
					{
						auto moveVec = moveInfo.move;
						auto CCvertexState = OpenMesh::getProperty<OpenMesh::VertexHandle, VertexState>(Handle_mesh, "vertexState");
						if (selectMode == SelectAdjust)
						{
							for (auto vh_ : moveInfo.vertices)
							{
								Handle_mesh.set_point(vh_, Handle_mesh.point(vh_) + moveVec);
								int vertex_id = vh_.idx();
								Handle_points[vertex_id] = Handle_points[vertex_id] + moveVec;
							}
							auto deformedcurvecage2 = CCpoints_fromCCmesh(Handle_mesh, degree);
							curvecage2 = deformedcurvecage2;

							update();
							return true;
						}
						else if (selectMode == SelectCustom || selectMode == SelectAdjustMesh || selectMode == Move)
						{
							Mesh deformedMesh;
							deformedMesh.assign(mesh);

							//for cage mesh
							//Mesh deformedCCMesh;
							//deformedCCMesh.assign(Handle_mesh);
							for (auto vh_ : moveInfo.vertices)
							{
								Handle_mesh.set_point(vh_, Handle_mesh.point(vh_) + moveVec);
								int vertex_id = vh_.idx();
								Handle_points[vertex_id] = Handle_points[vertex_id] + moveVec;
							}

							//MeshTools::AssignPoints(Handle_mesh, deformedCCMesh);
							if (!highdegree)
							{
								auto deformedcurvecage2 = CCpoints_fromCCmesh(Handle_mesh, degree);
								curvecage2 = deformedcurvecage2;
							}
							else
							{
								auto deformedcurvecage2 = CCpoints_fromCCmesh(Handle_mesh, todegree);
								curvecage2 = deformedcurvecage2;
							}
							deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
							MeshTools::AssignPoints(mesh, deformedMesh);
							update();
							return true;
						}
					}
				}
				else
				{
					std::cout << "Warning: Unable to redo the operation\n";
				}
			}
			else if (e->key() == Qt::Key_C)
			{
				auto CCvertexState = OpenMesh::getProperty<OpenMesh::VertexHandle, VertexState>(Handle_mesh, "vertexState");
				for (auto& vh_ : Handle_mesh.vertices())
				{
					CCvertexState[Handle_mesh.vertex_handle(vh_.idx())] = NotSelected;
				}
				update();
			}
			std::cout << "{";
			for (const auto& point : Handle_points) {
				std::cout << "OpenMesh::Vec3d(" << point[0] << ", " << point[1] << ", " << point[2] << ")," << std::endl;
			}
			std::cout << "}" << std::endl;
			}
	}
	if (!useHandle) {//正常模式
		
		if (_event->type() == QEvent::MouseButtonPress)
		{
			if (selectMode == Move)
			{
				auto e = static_cast<QMouseEvent*>(_event);
				QPoint winCor = e->pos();
				double depth;
				OpenMesh::Vec3d objCor;
				WinCor2ObjCor(winCor.x(), winCor.y(), objCor, depth);
				objCor = OpenMesh::Vec3d{ objCor[0],objCor[1],0 };

				OpenMesh::VertexHandle minVh;
				if (NearestCageVertex(objCor, minVh))
				{
					//cout << "move mesh1" << endl;
					auto vertexState = OpenMesh::getProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
					if (vertexState[minVh] == Custom)
					{
						isMovable = true;
						moveDepth = depth;
						lastObjCor = objCor;
						currentMoveStart = objCor;
						return true;
					}
				}
				if (draw_mesh2) {
					objCor[0] -= movemesh2;
					if (NearestCageVertex(objCor, CC_mesh22, minVh))
					{
						/*cout << "move mesh2" << endl;
						move_mesh2_flag = true;*/
						auto vertexState22 = OpenMesh::getProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh22, "vertexState");
						if (vertexState22[minVh] == Custom)
						{
							isMovable = true;
							moveDepth = depth;
							lastObjCor = objCor;
							currentMoveStart = objCor;
							return true;
						}
					}
				}
			}
			if (selectMode == SelectAdjust)
			{
				auto e = static_cast<QMouseEvent*>(_event);
				QPoint winCor = e->pos();
				double depth;
				OpenMesh::Vec3d objCor;
				WinCor2ObjCor(winCor.x(), winCor.y(), objCor, depth);
				objCor = OpenMesh::Vec3d{ objCor[0],objCor[1],0 };

				OpenMesh::VertexHandle minVh;
				if (NearestCageVertex(objCor, minVh))
				{
					auto vertexState = OpenMesh::getProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
					if (vertexState[minVh] == Custom)
					{
						isMovable = true;
						moveDepth = depth;
						lastObjCor = objCor;
						currentMoveStart = objCor;
						return true;
					}
				}
			}
			if (selectMode == SelectAdjustMesh)
			{
				auto e = static_cast<QMouseEvent*>(_event);
				QPoint winCor = e->pos();
				double depth;
				OpenMesh::Vec3d objCor;
				WinCor2ObjCor(winCor.x(), winCor.y(), objCor, depth);
				objCor = OpenMesh::Vec3d{ objCor[0],objCor[1],0 };

				OpenMesh::VertexHandle minVh;
				if (NearestCageVertex(objCor, minVh))
				{
					cout << "SelectAdjustMesh" << endl;
					auto vertexState = OpenMesh::getProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
					if (vertexState[minVh] == Custom)
					{
						isMovable = true;
						moveDepth = depth;
						lastObjCor = objCor;
						currentMoveStart = objCor;
						return true;
					}
				}
				if (draw_mesh2) {
					auto objCor_temp = objCor;
					objCor_temp[0] -= movemesh2;
					if (NearestCageVertex(objCor_temp, CC_mesh22, minVh))
					{
						auto vertexState22 = OpenMesh::getProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh22, "vertexState");
						if (vertexState22[minVh] == Custom)
						{
							isMovable = true;
							moveDepth = depth;
							lastObjCor = objCor;
							currentMoveStart = objCor;
							return true;
						}
					}
				}
			}
		}
		else if (_event->type() == QEvent::MouseMove)
		{

			if ((selectMode == Move || selectMode == SelectAdjustMesh) && isMovable)
			{
				auto e = static_cast<QMouseEvent*>(_event);
				QPoint winCor = e->pos();
				OpenMesh::Vec3d objCor;
				WinCor2ObjCor(winCor.x(), winCor.y(), moveDepth, objCor);
				objCor = OpenMesh::Vec3d{ objCor[0],objCor[1],0 };

				Mesh deformedMesh;
				deformedMesh.assign(mesh);
				auto vertexState = OpenMesh::getProperty<OpenMesh::VertexHandle, VertexState>(mesh, "vertexState");
				auto moveVec = objCor - lastObjCor;
				for (auto vh_ : deformedMesh.vertices())
				{
					if (vertexState[mesh.vertex_handle(vh_.idx())] != Custom)
					{
						deformedMesh.set_point(vh_, deformedMesh.point(vh_) + moveVec);
					}
				}

				MeshTools::AssignPoints(mesh, deformedMesh);

				if (isRotationMode)
				{
					auto CCvertexState = OpenMesh::getProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
					double angle = 0., scale = 1.;
					getRotation(lastObjCor, objCor, rotationCenter, angle, scale);
					for (auto vh_ : CC_mesh.vertices())
					{
						if (CCvertexState[CC_mesh.vertex_handle(vh_.idx())] == Custom)
						{
							auto& pos = CC_mesh.point(vh_);
							auto pos_r = pos - rotationCenter;
							OpenMesh::Vec3d newPos_r(
								pos_r[0] * cos(angle) - pos_r[1] * sin(angle),
								pos_r[0] * sin(angle) + pos_r[1] * cos(angle),
								0.
							);
							newPos_r *= scale;
							auto newPos = newPos_r + rotationCenter;
							CC_mesh.set_point(vh_, newPos);
							int vertex_id = vh_.idx();
							CC_points[vertex_id] = newPos;
						}
					}
				}
				else
				{
					auto CCvertexState = OpenMesh::getProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
					for (auto vh_ : CC_mesh.vertices())
					{
						if (CCvertexState[CC_mesh.vertex_handle(vh_.idx())] == Custom)
						{
							CC_mesh.set_point(vh_, CC_mesh.point(vh_) + moveVec);
							int vertex_id = vh_.idx();
							CC_points[vertex_id] = CC_points[vertex_id] + moveVec;
						}
					}
					//若绘制mesh2
					if (draw_mesh2) {
						//cout << move_mesh2_flag << endl;
						if (move_mesh2_flag) {
							auto CCvertexState = OpenMesh::getProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh22, "vertexState");
							for (auto vh_ : CC_mesh22.vertices())
							{
								if (CCvertexState[CC_mesh22.vertex_handle(vh_.idx())] == Custom)
								{
									CC_mesh22.set_point(vh_, CC_mesh22.point(vh_) + moveVec);
									int vertex_id = vh_.idx();
									CC_points22[vertex_id] = CC_points22[vertex_id] + moveVec;
								}
							}
						}
						else {
							CC_points22[3] = CC_points22[3] + moveVec;
							// 假设 ID 3 对应的句柄是 vertex handle 索引 3
							OpenMesh::VertexHandle vh = CC_mesh22.vertex_handle(3);
							CC_mesh22.set_point(vh, CC_mesh22.point(vh) + moveVec);

							//第三个网格
							CC_points33[3] = CC_points33[3] + moveVec;
							// 假设 ID 3 对应的句柄是 vertex handle 索引 3
							OpenMesh::VertexHandle vh3 = CC_mesh33.vertex_handle(3);
							CC_mesh33.set_point(vh3, CC_mesh33.point(vh3) + moveVec);
						}
					}
				}
				lastObjCor = objCor;
				//for cage mesh
				//Mesh deformedCCMesh;
				//deformedCCMesh.assign(CC_mesh);
				


				//MeshTools::AssignPoints(CC_mesh, deformedCCMesh);
				if (!highdegree)
				{
					auto deformedcurvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
					curvecage2 = deformedcurvecage2;
					auto deformedcurvecage22 = CCpoints_fromCCmesh(CC_mesh22, degree);
					curvecage22 = deformedcurvecage22;
					auto deformedcurvecage33 = CCpoints_fromCCmesh(CC_mesh33, 1);
					curvecage33 = deformedcurvecage33;
				}
				else
				{
					auto deformedcurvecage2 = CCpoints_fromCCmesh(CC_mesh, todegree);
					curvecage2 = deformedcurvecage2;
				}
				deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
				if (draw_mesh2) {
					Mesh deformedMesh2 = mesh;
					deform_mesh_from_cc(deformedMesh2,CC_points22,cauchyweights_2);//通过重心坐标改变mesh2的顶点位置
					MeshTools::AssignPoints(mesh2, deformedMesh2);
					//网格三
					Mesh deformedMesh3 = mesh;
					deform_mesh_from_cc(deformedMesh3, CC_points33, cauchyweights_3);//通过重心坐标改变mesh2的顶点位置
					MeshTools::AssignPoints(mesh3, deformedMesh3);
				}
				MeshTools::AssignPoints(mesh, deformedMesh);
				update();
				return true;
			}

			if (selectMode == SelectAdjust && isMovable)
			{

				auto e = static_cast<QMouseEvent*>(_event);
				QPoint winCor = e->pos();
				OpenMesh::Vec3d objCor;
				WinCor2ObjCor(winCor.x(), winCor.y(), moveDepth, objCor);
				objCor = OpenMesh::Vec3d{ objCor[0],objCor[1],0 };

				auto moveVec = objCor - lastObjCor;
				lastObjCor = objCor;
				//for cage mesh
				//Mesh deformedCCMesh;
				//deformedCCMesh.assign(CC_mesh);
				auto CCvertexState = OpenMesh::getProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
				for (auto vh_ : CC_mesh.vertices())
				{
					if (CCvertexState[CC_mesh.vertex_handle(vh_.idx())] == Custom)
					{
						CC_mesh.set_point(vh_, CC_mesh.point(vh_) + moveVec);
						int vertex_id = vh_.idx();
						CC_points[vertex_id] = CC_points[vertex_id] + moveVec;
					}
				}


				//MeshTools::AssignPoints(CC_mesh, deformedCCMesh);
				auto deformedcurvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
				curvecage2 = deformedcurvecage2;

				update();
				return true;
			}
		}
		else if (_event->type() == QEvent::MouseButtonRelease)
		{
			if ((selectMode == Move || selectMode == SelectAdjustMesh) && isMovable)
			{
				std::cout << "{";
				for (const auto& point : CC_points) {
					std::cout << "OpenMesh::Vec3d(" << point[0] << ", " << point[1] << ", " << point[2] << ")," << std::endl;
				}
				std::cout << "}" << std::endl;
				isMovable = false;

				MoveInfo currentInfo;
				if (isRotationMode)
				{
					currentInfo.move = rotationCenter;
					currentInfo.isRotation = true;
					auto CCvertexState = OpenMesh::getProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
					for (auto& vh_ : CC_mesh.vertices())
					{
						if (CCvertexState[CC_mesh.vertex_handle(vh_.idx())] == Custom)
						{
							currentInfo.vertices.push_back(vh_);
						}
					}
					getRotation(currentMoveStart, lastObjCor, rotationCenter, currentInfo.angle, currentInfo.scale);
					if (!currentInfo.vertices.empty() && (currentMoveStart - lastObjCor).norm() > 1e-4)
					{
						moveHistories.resize(currentHistoryPos);
						moveHistories.push_back(std::move(currentInfo));
						currentHistoryPos++;
					}
				}
				else
				{
					currentInfo.move = lastObjCor - currentMoveStart;
					currentInfo.isRotation = false;
					auto CCvertexState = OpenMesh::getProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
					for (auto& vh_ : CC_mesh.vertices())
					{
						if (CCvertexState[CC_mesh.vertex_handle(vh_.idx())] == Custom)
						{
							currentInfo.vertices.push_back(vh_);
						}
					}

					if (!currentInfo.vertices.empty() && currentInfo.move.norm() > 1e-4)
					{
						moveHistories.resize(currentHistoryPos);
						moveHistories.push_back(std::move(currentInfo));
						currentHistoryPos++;
					}
				}
				return true;
			}
			if (selectMode == SelectAdjust && isMovable)
			{
				std::cout << "{";
				for (const auto& point : CC_points) {
					std::cout << "OpenMesh::Vec3d(" << point[0] << ", " << point[1] << ", " << point[2] << ")," << std::endl;
				}
				std::cout << "}" << std::endl;
				isMovable = false;

				MoveInfo currentInfo;
				currentInfo.move = lastObjCor - currentMoveStart;
				auto CCvertexState = OpenMesh::getProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
				for (auto& vh_ : CC_mesh.vertices())
				{
					if (CCvertexState[CC_mesh.vertex_handle(vh_.idx())] == Custom)
					{
						currentInfo.vertices.push_back(vh_);
					}
				}

				if (!currentInfo.vertices.empty() && currentInfo.move.norm() > 1e-4)
				{
					moveHistories.resize(currentHistoryPos);
					moveHistories.push_back(std::move(currentInfo));
					currentHistoryPos++;
				}
				return true;
			}
		}
		else if (_event->type() == QEvent::KeyPress)
		{
			auto e = static_cast<QKeyEvent*>(_event);
			if (e->key() == Qt::Key_Z)
			{
				// Undo
				if (currentHistoryPos > 0)
				{
					currentHistoryPos--;
					auto& moveInfo = moveHistories[currentHistoryPos];
					if (moveInfo.isRotation)
					{
						auto moveRotationCenter = moveInfo.move;
						Mesh deformedMesh;
						deformedMesh.assign(mesh);

						//for cage mesh
						//Mesh deformedCCMesh;
						//deformedCCMesh.assign(CC_mesh);
						for (auto vh_ : moveInfo.vertices)
						{
							auto pos = CC_mesh.point(vh_);
							auto pos_r = pos - moveRotationCenter;
							OpenMesh::Vec3d newPos_r(
								pos_r[0] * cos(moveInfo.angle) + pos_r[1] * sin(moveInfo.angle),
								-pos_r[0] * sin(moveInfo.angle) + pos_r[1] * cos(moveInfo.angle),
								0.
							);
							newPos_r /= moveInfo.scale;
							auto newPos = newPos_r + moveRotationCenter;
							CC_mesh.set_point(vh_, newPos);
							int vertex_id = vh_.idx();
							CC_points[vertex_id] = newPos;
						}

						//MeshTools::AssignPoints(CC_mesh, deformedCCMesh);
						if (!highdegree)
						{
							auto deformedcurvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
							curvecage2 = deformedcurvecage2;
						}
						else
						{
							auto deformedcurvecage2 = CCpoints_fromCCmesh(CC_mesh, todegree);
							curvecage2 = deformedcurvecage2;
						}
						deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
						MeshTools::AssignPoints(mesh, deformedMesh);
						update();
						return true;
					}
					else
					{
						auto moveVec = -moveInfo.move;
						auto CCvertexState = OpenMesh::getProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
						if (selectMode == SelectAdjust)
						{
							for (auto vh_ : moveInfo.vertices)
							{
								CC_mesh.set_point(vh_, CC_mesh.point(vh_) + moveVec);
								int vertex_id = vh_.idx();
								CC_points[vertex_id] = CC_points[vertex_id] + moveVec;
							}
							auto deformedcurvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
							curvecage2 = deformedcurvecage2;

							update();
							return true;
						}
						else if (selectMode == SelectCustom || selectMode == SelectAdjustMesh || selectMode == Move)
						{
							Mesh deformedMesh;
							deformedMesh.assign(mesh);

							//for cage mesh
							//Mesh deformedCCMesh;
							//deformedCCMesh.assign(CC_mesh);
							for (auto vh_ : moveInfo.vertices)
							{
								CC_mesh.set_point(vh_, CC_mesh.point(vh_) + moveVec);
								int vertex_id = vh_.idx();
								CC_points[vertex_id] = CC_points[vertex_id] + moveVec;
							}

							//MeshTools::AssignPoints(CC_mesh, deformedCCMesh);
							if (!highdegree)
							{
								auto deformedcurvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
								curvecage2 = deformedcurvecage2;
							}
							else
							{
								auto deformedcurvecage2 = CCpoints_fromCCmesh(CC_mesh, todegree);
								curvecage2 = deformedcurvecage2;
							}
							deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
							MeshTools::AssignPoints(mesh, deformedMesh);
							update();
							return true;
						}
					}
				}
				else
				{
					std::cout << "Warning: Unable to undo the last operation\n";
				}
			}
			else if (e->key() == Qt::Key_X)
			{
				// Redo
				if (currentHistoryPos < moveHistories.size())
				{
					auto& moveInfo = moveHistories[currentHistoryPos];
					currentHistoryPos++;
					if (moveInfo.isRotation)
					{
						auto moveRotationCenter = moveInfo.move;
						Mesh deformedMesh;
						deformedMesh.assign(mesh);

						//for cage mesh
						//Mesh deformedCCMesh;
						//deformedCCMesh.assign(CC_mesh);
						for (auto vh_ : moveInfo.vertices)
						{
							auto pos = CC_mesh.point(vh_);
							auto pos_r = pos - moveRotationCenter;
							OpenMesh::Vec3d newPos_r(
								pos_r[0] * cos(moveInfo.angle) - pos_r[1] * sin(moveInfo.angle),
								pos_r[0] * sin(moveInfo.angle) + pos_r[1] * cos(moveInfo.angle),
								0.
							);
							newPos_r *= moveInfo.scale;
							auto newPos = newPos_r + moveRotationCenter;
							CC_mesh.set_point(vh_, newPos);
							int vertex_id = vh_.idx();
							CC_points[vertex_id] = newPos;
						}

						//MeshTools::AssignPoints(CC_mesh, deformedCCMesh);
						if (!highdegree)
						{
							auto deformedcurvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
							curvecage2 = deformedcurvecage2;
						}
						else
						{
							auto deformedcurvecage2 = CCpoints_fromCCmesh(CC_mesh, todegree);
							curvecage2 = deformedcurvecage2;
						}
						deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
						MeshTools::AssignPoints(mesh, deformedMesh);
						update();
						return true;
					}
					else
					{
						auto moveVec = moveInfo.move;
						auto CCvertexState = OpenMesh::getProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
						if (selectMode == SelectAdjust)
						{
							for (auto vh_ : moveInfo.vertices)
							{
								CC_mesh.set_point(vh_, CC_mesh.point(vh_) + moveVec);
								int vertex_id = vh_.idx();
								CC_points[vertex_id] = CC_points[vertex_id] + moveVec;
							}
							auto deformedcurvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
							curvecage2 = deformedcurvecage2;

							update();
							return true;
						}
						else if (selectMode == SelectCustom || selectMode == SelectAdjustMesh || selectMode == Move)
						{
							Mesh deformedMesh;
							deformedMesh.assign(mesh);

							//for cage mesh
							//Mesh deformedCCMesh;
							//deformedCCMesh.assign(CC_mesh);
							for (auto vh_ : moveInfo.vertices)
							{
								CC_mesh.set_point(vh_, CC_mesh.point(vh_) + moveVec);
								int vertex_id = vh_.idx();
								CC_points[vertex_id] = CC_points[vertex_id] + moveVec;
							}

							//MeshTools::AssignPoints(CC_mesh, deformedCCMesh);
							if (!highdegree)
							{
								auto deformedcurvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
								curvecage2 = deformedcurvecage2;
							}
							else
							{
								auto deformedcurvecage2 = CCpoints_fromCCmesh(CC_mesh, todegree);
								curvecage2 = deformedcurvecage2;
							}
							deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
							MeshTools::AssignPoints(mesh, deformedMesh);
							update();
							return true;
						}
					}
				}
				else
				{
					std::cout << "Warning: Unable to redo the operation\n";
				}
			}
			else if (e->key() == Qt::Key_C)
			{
				auto CCvertexState = OpenMesh::getProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
				for (auto& vh_ : CC_mesh.vertices())
				{
					CCvertexState[CC_mesh.vertex_handle(vh_.idx())] = NotSelected;
				}
				update();
			}
			std::cout << "{";
			for (const auto& point : CC_points) {
				std::cout << "OpenMesh::Vec3d(" << point[0] << ", " << point[1] << ", " << point[2] << ")," << std::endl;
			}
			std::cout << "}" << std::endl;
		}
	}
	return QGLViewerWidget::event(_event);
}

void MeshViewerWidget::mouseDoubleClickEvent(QMouseEvent* _event)
{
	if (_event->button() == Qt::LeftButton)
	{
		switch (selectMode)
		{
		case NoSelect:
			break;
		case SelectAdjust:
		case SelectCustom:
		case SelectAdjustMesh:
		{
			QPoint winCor = _event->pos();
			//winCor.setX(609);
			//winCor.setY(183);
			double depth;
			OpenMesh::Vec3d objCor;
			WinCor2ObjCor(winCor.x(), winCor.y(), objCor, depth);
			OpenMesh::VertexHandle minVh;
			if (!useHandle) {
				if (NearestCageVertex(objCor, minVh))
				{
					cout << "double clip mesh1!" << endl;
					auto vertexState = OpenMesh::getProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
					if (selectMode == SelectAdjust)
					{
						if (vertexState[minVh] == NotSelected)
						{
							vertexState[minVh] = Custom;
						}
						else if (vertexState[minVh] == Custom)
						{
							vertexState[minVh] = NotSelected;
						}
					}
					else if (selectMode == SelectCustom || selectMode == SelectAdjustMesh)
					{
						if (vertexState[minVh] == NotSelected)
						{
							vertexState[minVh] = Custom;
						}
						else if (vertexState[minVh] == Custom)
						{
							vertexState[minVh] = NotSelected;
						}
					}
					update();
				}
				objCor[0] -= movemesh2;
				if (NearestCageVertex(objCor,CC_mesh22, minVh))
				{
					cout << "double clip mesh2!" << endl;
					auto vertexState22 = OpenMesh::getProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh22, "vertexState");
					if (selectMode == SelectAdjust)
					{
						if (vertexState22[minVh] == NotSelected)
						{
							vertexState22[minVh] = Custom;
							move_mesh2_flag = true;
						}
						else if (vertexState22[minVh] == Custom)
						{
							vertexState22[minVh] = NotSelected;
							move_mesh2_flag = false;
						}
					}
					else if (selectMode == SelectCustom || selectMode == SelectAdjustMesh)
					{
						if (vertexState22[minVh] == NotSelected)
						{
							vertexState22[minVh] = Custom;
							move_mesh2_flag = true;
						}
						else if (vertexState22[minVh] == Custom)
						{
							vertexState22[minVh] = NotSelected;
							move_mesh2_flag = false;
						}
					}
					update();
				}
			}
			else {
				if (NearestCageVertex(objCor, minVh))
				{
					std::cout << "xuanzhong!" << std::endl;
					auto HandlevertexState = OpenMesh::getProperty<OpenMesh::VertexHandle, VertexState>(Handle_mesh, "vertexState");
					if (selectMode == SelectAdjust)
					{
						if (HandlevertexState[minVh] == NotSelected)
						{
							HandlevertexState[minVh] = Custom;
						}
						else if (HandlevertexState[minVh] == Custom)
						{
							HandlevertexState[minVh] = NotSelected;
						}
					}
					else if (selectMode == SelectCustom || selectMode == SelectAdjustMesh)
					{
						if (HandlevertexState[minVh] == NotSelected)
						{
							HandlevertexState[minVh] = Custom;
						}
						else if (HandlevertexState[minVh] == Custom)
						{
							HandlevertexState[minVh] = NotSelected;
						}
					}
					update();
				}
			}
			break;
		}
		case Move:
			break;
		default:
			break;
		}
	}
	else if (_event->button() == Qt::RightButton)
	{
		if (selectMode == SelectAdjustMesh) {
			if (isRotationMode) {
				isRotationMode = false;
			}
			else
			{
				isRotationMode = true;
				QPoint winCor = _event->pos();
				double depth;
				OpenMesh::Vec3d objCor;
				WinCor2ObjCor(winCor.x(), winCor.y(), objCor, depth);
				rotationCenter = objCor;
			}
			update();
		}
	}
}

void MeshViewerWidget::DrawScene(void)
{
	glMatrixMode(GL_PROJECTION);
	glLoadMatrixd(&projectionmatrix[0]);
	glMatrixMode(GL_MODELVIEW);
	glLoadMatrixd(&modelviewmatrix[0]);
	//DrawAxis();
	if (isDrawBoundingBox) DrawBoundingBox();
	if (isDrawBoundary) DrawBoundary();
	if (isEnableLighting) glEnable(GL_LIGHTING);
	glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, isTwoSideLighting);
	DrawSceneMesh();
	if (isEnableLighting) glDisable(GL_LIGHTING);
}

void MeshViewerWidget::DrawSceneMesh(void)
{
	if (mesh.n_vertices() != 0) {
		SetMaterial();
		switch (drawmode)
		{
		case POINTS:
			DrawPoints();
			break;
		case WIREFRAME:
			DrawWireframe();
			break;
		case HIDDENLINES:
			DrawHiddenLines();
			break;
		case FLATLINES:
			DrawFlatLines();
			break;
		case FLAT:
			glColor3d(0.8, 0.8, 0.8);
			DrawFlat();
			break;
		case SMOOTH:
			DrawSmooth();
			break;
		case CURVECAGE:
			DrawCurveCage();
			break;
		default:
			break;
		}
	}
	
	glColor3d(1.0, 1.0, 1.0);
	glBegin(GL_QUADS);
	glVertex3d(-1000, -1000, 0);
	glVertex3d(-1000, 1000, 0);
	glVertex3d(1000, 1000, 0);
	glVertex3d(1000, -1000, 0);
	glEnd();
}

#include "toolbox\dprinter\dprint.h"
void MeshViewerWidget::CurveCage_Test(void)
{
	
	drawmode = CURVECAGE;
	usebih = false;//如果构造cage要去掉
	degree =3;
	useHandle = true;
	draw_mesh2 = false;
	if (degree == 1 && !usebih&&!useHandle)
	{
		//专门为螃蟹制造的
		if(0){
			CC_points = {//pangxie
				OpenMesh::Vec3d(7.71977, -2.05287, 0),
			OpenMesh::Vec3d(16.1661, 2.5924, 0),
			OpenMesh::Vec3d(22.5491, -0.870733, 0),
			OpenMesh::Vec3d(15.6577, -8.58216, 0),
			OpenMesh::Vec3d(26.8967, -7.59486, 0),
			OpenMesh::Vec3d(21.084, 11.3199, 0),
			OpenMesh::Vec3d(7.68061, 1.27629, 0),
			OpenMesh::Vec3d(11.5959, 6.63227, 0),
			OpenMesh::Vec3d(24.6401, 7.52288, 0),
			OpenMesh::Vec3d(21.7966, -5.4645, 0),
			OpenMesh::Vec3d(31.1961, 2.17972, 0),
			OpenMesh::Vec3d(15.6549, 13.7466, 0),
			OpenMesh::Vec3d(7.82502, 4.58309, 0),
			OpenMesh::Vec3d(11.8374, 11.0923, 0),
			OpenMesh::Vec3d(20.9685, 10.4649, 0),
			OpenMesh::Vec3d(24.9294, 1.87976, 0),
			OpenMesh::Vec3d(27.8247, 9.55625, 0),
			OpenMesh::Vec3d(14.2738, 16.6223, 0),
			OpenMesh::Vec3d(5.4765, 7.35184, 0),
			OpenMesh::Vec3d(8.64119, 11.865, 0),
			OpenMesh::Vec3d(14.7017, 15.1746, 0),
			OpenMesh::Vec3d(23.1277, 9.7121, 0),
			OpenMesh::Vec3d(19.424, 19.1598, 0),
			OpenMesh::Vec3d(6.83002, 15.4013, 0),
			OpenMesh::Vec3d(2.16398, 7.18829, 0),
			OpenMesh::Vec3d(-0.0248164, 9.29763, 0),
			OpenMesh::Vec3d(-1.17408, 9.21065, 0),
			OpenMesh::Vec3d(-3.33054, 6.62634, 0),
			OpenMesh::Vec3d(-8.85175, 14.7474, 0),
			OpenMesh::Vec3d(-24.3841, 17.0936, 0),
			OpenMesh::Vec3d(-23.6175, 7.39743, 0),
			OpenMesh::Vec3d(-18.8441, 13.6221, 0),
			OpenMesh::Vec3d(-10.5837, 11.5502, 0),
			OpenMesh::Vec3d(-5.13643, 5.07839, 0),
			OpenMesh::Vec3d(-5.27052, 4.97835, 0),
			OpenMesh::Vec3d(-5.46014, 4.84129, 0),
			OpenMesh::Vec3d(-5.64977, 4.70424, 0),
			OpenMesh::Vec3d(-12.9059, 15.3053, 0),
			OpenMesh::Vec3d(-28.4601, 9.29942, 0),
			OpenMesh::Vec3d(-24.863, 0.0668226, 0),
			OpenMesh::Vec3d(-22.7747, 8.29837, 0),
			OpenMesh::Vec3d(-14.3986, 9.84779, 0),
			OpenMesh::Vec3d(-7.0058, 3.14714, 0),
			OpenMesh::Vec3d(-18.5345, 12.5865, 0),
			OpenMesh::Vec3d(-30.6453, -0.223078, 0),
			OpenMesh::Vec3d(-21.5541, -7.27411, 0),
			OpenMesh::Vec3d(-24.3589, 0.197288, 0),
			OpenMesh::Vec3d(-18.8381, 7.34974, 0),
			OpenMesh::Vec3d(-7.4344, 0.51362, 0),
			OpenMesh::Vec3d(-24.585, 8.96755, 0),
			OpenMesh::Vec3d(-25.4714, -12.1974, 0),
			OpenMesh::Vec3d(-13.6432, -10.1693, 0),
			OpenMesh::Vec3d(-22.614, -4.87779, 0),
			OpenMesh::Vec3d(-17.811, 3.67923, 0),
			OpenMesh::Vec3d(-7.53781, -3.00233, 0),
			OpenMesh::Vec3d(-23.8508, 3.73205, 0),
			OpenMesh::Vec3d(-18.0268, -14.6281, 0),
			OpenMesh::Vec3d(0.581672, -14.6728, 0),
			OpenMesh::Vec3d(-1.23569, -8.99517, 0),
			OpenMesh::Vec3d(-10.3154, -6.40558, 0),
			OpenMesh::Vec3d(-14.2051, -5.46234, 0),
			OpenMesh::Vec3d(-10.7249, -5.26371, 0),
			OpenMesh::Vec3d(-4.0724, -6.50565, 0),
			OpenMesh::Vec3d(0.270762, -12.5408, 0),
			OpenMesh::Vec3d(6.57959, -7.9814, 0),
			OpenMesh::Vec3d(9.1306, -3.60342, 0),
			OpenMesh::Vec3d(13.4053, -3.81022, 0),
			OpenMesh::Vec3d(11.9635, -6.90228, 0),
			OpenMesh::Vec3d(4.07802, -8.25055, 0),
			OpenMesh::Vec3d(0.654098, -13.3543, 0),
			OpenMesh::Vec3d(3.50707, -16.7318, 0),
			OpenMesh::Vec3d(8.3762, -13.8882, 0),
			OpenMesh::Vec3d(12.9466, -9.91377, 0),
			OpenMesh::Vec3d(19.5164, -2.8494, 0),
			OpenMesh::Vec3d(19.745, 1.90087, 0),
			};
			CC_points = subdivideCage3(CC_points, 5);
			CC_points = { OpenMesh::Vec3d(7.71977, -2.05287, 0),
	OpenMesh::Vec3d(12.4503, -0.207835, 0),
	OpenMesh::Vec3d(16.1475, -0.123532, 0),
	OpenMesh::Vec3d(18.2732, -1.61468, 0),
	OpenMesh::Vec3d(18.2893, -4.49598, 0),
	OpenMesh::Vec3d(15.6577, -8.58216, 0),
	OpenMesh::Vec3d(20.6766, -7.323, 0),
	OpenMesh::Vec3d(21.5652, -1.79291, 0),
	OpenMesh::Vec3d(18.6429, 3.47657, 0),
	OpenMesh::Vec3d(14.7361, 4.34138, 0),
	OpenMesh::Vec3d(7.68061, 1.27629, 0),
	OpenMesh::Vec3d(10.9251, 3.87873, 0),
	OpenMesh::Vec3d(15.1598, 4.95768, 0),
	OpenMesh::Vec3d(19.1838, 4.06133, 0),
	OpenMesh::Vec3d(21.7963, 0.73787, 0),
	OpenMesh::Vec3d(21.7966, -5.4645, 0),
	OpenMesh::Vec3d(25.498, -1.71654, 0),
	OpenMesh::Vec3d(23.1942, 4.01365, 0),
	OpenMesh::Vec3d(18.4835, 7.99197, 0),
	OpenMesh::Vec3d(13.1871, 7.79077, 0),
	OpenMesh::Vec3d(7.82502, 4.58309, 0),
	OpenMesh::Vec3d(10.7644, 7.62565, 0),
	OpenMesh::Vec3d(14.4384, 8.91602, 0),
	OpenMesh::Vec3d(18.3531, 8.41477, 0),
	OpenMesh::Vec3d(22.0147, 6.08248, 0),
	OpenMesh::Vec3d(24.9294, 1.87976, 0),
	OpenMesh::Vec3d(25.4735, 6.33023, 0),
	OpenMesh::Vec3d(21.8664, 9.79207, 0),
	OpenMesh::Vec3d(16.9582, 11.8595, 0),
	OpenMesh::Vec3d(10.8066, 11.2977, 0),
	OpenMesh::Vec3d(5.4765, 7.35184, 0),
	OpenMesh::Vec3d(7.71857, 9.85476, 0),
	OpenMesh::Vec3d(10.6302, 11.7055, 0),
	OpenMesh::Vec3d(14.1859, 12.5409, 0),
	OpenMesh::Vec3d(18.3602, 11.9975, 0),
	OpenMesh::Vec3d(23.4054, 9.75838, 0),
	OpenMesh::Vec3d(20.6277, 14.2151, 0),
	OpenMesh::Vec3d(15.4923, 15.2705, 0),
	OpenMesh::Vec3d(10.4923, 14.3456, 0),
	OpenMesh::Vec3d(5.3176, 11.7429, 0),
	OpenMesh::Vec3d(2.16398, 7.18829, 0),
	OpenMesh::Vec3d(0.959072, 8.18793, 0),
	OpenMesh::Vec3d(-0.0945906, 8.646, 0),
	OpenMesh::Vec3d(-1.09525, 8.54806, 0),
	OpenMesh::Vec3d(-2.14115, 7.87965, 0),
	OpenMesh::Vec3d(-3.33054, 6.62634, 0),
	OpenMesh::Vec3d(-7.63412, 10.7559, 0),
	OpenMesh::Vec3d(-12.661, 13.5226, 0),
	OpenMesh::Vec3d(-18.3978, 13.6536, 0),
	OpenMesh::Vec3d(-23.5539, 10.9038, 0),
	OpenMesh::Vec3d(-23.8489, 7.25859, 0),
	OpenMesh::Vec3d(-20.3854, 10.1678, 0),
	OpenMesh::Vec3d(-16.6189, 11.1341, 0),
	OpenMesh::Vec3d(-12.6202, 10.4832, 0),
	OpenMesh::Vec3d(-8.69197, 8.40231, 0),
	OpenMesh::Vec3d(-5.13643, 5.07839, 0),
	OpenMesh::Vec3d(-5.2231, 5.01422, 0),
	OpenMesh::Vec3d(-5.32044, 4.94294, 0),
	OpenMesh::Vec3d(-5.42577, 4.86633, 0),
	OpenMesh::Vec3d(-5.53644, 4.78617, 0),
	OpenMesh::Vec3d(-5.64977, 4.70424, 0),
	OpenMesh::Vec3d(-11.6523, 9.78999, 0),
	OpenMesh::Vec3d(-16.2132, 10.6807, 0),
	OpenMesh::Vec3d(-21.7437, 8.74078, 0),
	OpenMesh::Vec3d(-26.0772, 4.19577, 0),
	OpenMesh::Vec3d(-24.863, 0.0668226, 0),
	OpenMesh::Vec3d(-22.9137, 4.19135, 0),
	OpenMesh::Vec3d(-19.8042, 6.63691, 0),
	OpenMesh::Vec3d(-15.8838, 7.32823, 0),
	OpenMesh::Vec3d(-11.5013, 6.19007, 0),
	OpenMesh::Vec3d(-7.0058, 3.14714, 0),
	OpenMesh::Vec3d(-14.0963, 6.68891, 0),
	OpenMesh::Vec3d(-19.7718, 5.77248, 0),
	OpenMesh::Vec3d(-23.6808, 2.15875, 0),
	OpenMesh::Vec3d(-24.8134, -3.84198, 0),
	OpenMesh::Vec3d(-21.5541, -7.27411, 0),
	OpenMesh::Vec3d(-22.2574, -2.9389, 0),
	OpenMesh::Vec3d(-21.0799, 0.663617, 0),
	OpenMesh::Vec3d(-18.1387, 2.87731, 0),
	OpenMesh::Vec3d(-13.5511, 3.04602, 0),
	OpenMesh::Vec3d(-7.4344, 0.51362, 0),
	OpenMesh::Vec3d(-16.0196, 2.89057, 0),
	OpenMesh::Vec3d(-20.4355, -0.178763, 0),
	OpenMesh::Vec3d(-21.5069, -4.85032, 0),
	OpenMesh::Vec3d(-18.5751, -10.4219, 0),
	OpenMesh::Vec3d(-13.6432, -10.1693, 0),
	OpenMesh::Vec3d(-17.4393, -6.75057, 0),
	OpenMesh::Vec3d(-18.3282, -3.4363, 0),
	OpenMesh::Vec3d(-16.7085, -1.11471, 0),
	OpenMesh::Vec3d(-12.9789, -0.673991, 0),
	OpenMesh::Vec3d(-7.53781, -3.00233, 0),
	OpenMesh::Vec3d(-15.7913, -1.36395, 0),
	OpenMesh::Vec3d(-17.5873, -4.49366, 0),
	OpenMesh::Vec3d(-15.0134, -8.60598, 0),
	OpenMesh::Vec3d(-7.66536, -14.0172, 0),
	OpenMesh::Vec3d(0.581672, -14.6728, 0),
	OpenMesh::Vec3d(-1.05978, -11.5327, 0),
	OpenMesh::Vec3d(-4.28814, -9.24964, 0),
	OpenMesh::Vec3d(-7.84321, -7.47674, 0),
	OpenMesh::Vec3d(-11.3481, -6.23738, 0),
	OpenMesh::Vec3d(-14.2051, -5.46234, 0),
	OpenMesh::Vec3d(-11.7802, -5.54285, 0),
	OpenMesh::Vec3d(-8.85698, -6.13003, 0),
	OpenMesh::Vec3d(-5.69869, -7.38479, 0),
	OpenMesh::Vec3d(-2.5684, -9.46807, 0),
	OpenMesh::Vec3d(0.270762, -12.5408, 0),
	OpenMesh::Vec3d(3.64897, -9.86216, 0),
	OpenMesh::Vec3d(6.38842, -7.43842, 0),
	OpenMesh::Vec3d(8.75221, -5.48094, 0),
	OpenMesh::Vec3d(11.0035, -4.20109, 0),
	OpenMesh::Vec3d(13.4053, -3.81022, 0),
	OpenMesh::Vec3d(11.8542, -5.5002, 0),
	OpenMesh::Vec3d(9.28011, -7.03563, 0),
	OpenMesh::Vec3d(6.20642, -8.68048, 0),
	OpenMesh::Vec3d(3.01776, -10.6524, 0),
	OpenMesh::Vec3d(0.654098, -13.3543, 0),
	OpenMesh::Vec3d(2.5893, -14.675, 0),
	OpenMesh::Vec3d(4.89727, -14.7469, 0),
	OpenMesh::Vec3d(7.46688, -13.8145, 0),
	OpenMesh::Vec3d(10.187, -12.122, 0),
	OpenMesh::Vec3d(12.9466, -9.91377, 0),
	OpenMesh::Vec3d(16.0802, -6.00396, 0),
	OpenMesh::Vec3d(17.4082, -2.95625, 0),
	OpenMesh::Vec3d(16.3848, -0.466443, 0),
	OpenMesh::Vec3d(13.5117, -0.673988, 0),
			};
		}
		//专门为rainbow造的
		if (0) {
			CC_points = { OpenMesh::Vec3d(-5.77366, -0.928836, 0),
	OpenMesh::Vec3d(-3.65098, 4.19543, 0),
	OpenMesh::Vec3d(3.83891, 7.69656, 0),
	OpenMesh::Vec3d(9.74542, 1.55503, 0),
	OpenMesh::Vec3d(9.71409, 1.85648, 0),
	OpenMesh::Vec3d(9.72213, 2.09149, 0),
	OpenMesh::Vec3d(9.75057, 2.34935, 0),
	OpenMesh::Vec3d(3.96906, 7.95307, 0),
	OpenMesh::Vec3d(-3.6725, 5.20192, 0),
	OpenMesh::Vec3d(-6.41423, -0.846814, 0),
	OpenMesh::Vec3d(-3.88359, 5.13772, 0),
	OpenMesh::Vec3d(3.65582, 8.02333, 0),
	OpenMesh::Vec3d(9.73233, 2.49004, 0),
	OpenMesh::Vec3d(9.72816, 2.82964, 0),
	OpenMesh::Vec3d(9.73162, 3.06732, 0),
	OpenMesh::Vec3d(9.70073, 3.27175, 0),
	OpenMesh::Vec3d(5.00196, 7.83177, 0),
	OpenMesh::Vec3d(-5.0881, 7.15129, 0),
	OpenMesh::Vec3d(-7.42613, -2.25787, 0),
	OpenMesh::Vec3d(-8.65612, -1.67216, 0),
	OpenMesh::Vec3d(-13.1998, -3.81923, 0),
	OpenMesh::Vec3d(-6.02623, -6.5032, 0),
	OpenMesh::Vec3d(-2.88592, -5.16367, 0),
	OpenMesh::Vec3d(-0.978079, -2.18366, 0),
	OpenMesh::Vec3d(-4.02564, -1.5895, 0),
	OpenMesh::Vec3d(-0.942283, 4.27499, 0),
	OpenMesh::Vec3d(6.25598, 4.66494, 0),
	OpenMesh::Vec3d(9.6561, -1.77424, 0),
	OpenMesh::Vec3d(9.67105, -1.42373, 0),
	OpenMesh::Vec3d(9.6996, -1.06183, 0),
	OpenMesh::Vec3d(9.74062, -0.738046, 0),
	OpenMesh::Vec3d(6.13106, 5.28046, 0),
	OpenMesh::Vec3d(-1.1495, 4.66369, 0),
	OpenMesh::Vec3d(-4.38251, -0.855424, 0),
	OpenMesh::Vec3d(-1.41844, 4.78383, 0),
	OpenMesh::Vec3d(6.2934, 5.23497, 0),
	OpenMesh::Vec3d(9.69998, -0.60418, 0),
	OpenMesh::Vec3d(9.70243, -0.18479, 0),
	OpenMesh::Vec3d(9.72684, 0.11423, 0),
	OpenMesh::Vec3d(9.75569, 0.418196, 0),
	OpenMesh::Vec3d(4.99936, 6.54761, 0),
	OpenMesh::Vec3d(-2.13908, 4.46348, 0),
	OpenMesh::Vec3d(-5.0399, -0.745585, 0),
	OpenMesh::Vec3d(-2.61174, 4.15792, 0),
	OpenMesh::Vec3d(4.66582, 6.75996, 0),
	OpenMesh::Vec3d(9.68352, 0.652446, 0),
	OpenMesh::Vec3d(9.73424, 0.909529, 0),
	OpenMesh::Vec3d(9.75751, 1.17138, 0),
	OpenMesh::Vec3d(9.79496, 1.37106, 0),
	OpenMesh::Vec3d(4.4877, 7.31385, 0),
	OpenMesh::Vec3d(-3.19225, 4.7506, 0),
			};
			LoadMesh("E:\\dgp2021\\dgp6\\newproject_BIHC\\project_BiHC\\mesh\\rainbow.obj");
			Set_Texture_coord();//设置纹理
			//CC_points = subdivideCage3(CC_points, 15,10);
			CC_points= { OpenMesh::Vec3d(-5.77366, -0.928836, 0),
OpenMesh::Vec3d(-5.27962, 0.0719992, 0),
OpenMesh::Vec3d(-4.65481, 1.01529, 0),
OpenMesh::Vec3d(-3.93627, 1.89913, 0),
OpenMesh::Vec3d(-3.06849, 2.70309, 0),
OpenMesh::Vec3d(-2.13168, 3.38822, 0),
OpenMesh::Vec3d(-1.09502, 3.92793, 0),
OpenMesh::Vec3d(-0.00171669, 4.36967, 0),
OpenMesh::Vec3d(1.14822, 4.66832, 0),
OpenMesh::Vec3d(2.34242, 4.80964, 0),
OpenMesh::Vec3d(3.56855, 4.77936, 0),
OpenMesh::Vec3d(4.81423, 4.56323, 0),
OpenMesh::Vec3d(6.10208, 4.16447, 0),
OpenMesh::Vec3d(7.34981, 3.55134, 0),
OpenMesh::Vec3d(8.56255, 2.67463, 0),
OpenMesh::Vec3d(9.74542, 1.55503, 0),
OpenMesh::Vec3d(9.71409, 1.85648, 0),
OpenMesh::Vec3d(9.72213, 2.09149, 0),
OpenMesh::Vec3d(9.75057, 2.34935, 0),
OpenMesh::Vec3d(8.60027, 3.37459, 0),
OpenMesh::Vec3d(7.36918, 4.18603, 0),
OpenMesh::Vec3d(6.11254, 4.76385, 0),
OpenMesh::Vec3d(4.85674, 5.14585, 0),
OpenMesh::Vec3d(3.59941, 5.35542, 0),
OpenMesh::Vec3d(2.35257, 5.38714, 0),
OpenMesh::Vec3d(1.12823, 5.25001, 0),
OpenMesh::Vec3d(-0.0615898, 4.95302, 0),
OpenMesh::Vec3d(-1.20487, 4.50516, 0),
OpenMesh::Vec3d(-2.26491, 3.95656, 0),
OpenMesh::Vec3d(-3.30374, 3.23392, 0),
OpenMesh::Vec3d(-4.2682, 2.37094, 0),
OpenMesh::Vec3d(-5.10515, 1.4095, 0),
OpenMesh::Vec3d(-5.80256, 0.317467, 0),
OpenMesh::Vec3d(-6.41423, -0.846814, 0),
OpenMesh::Vec3d(-5.84324, 0.307198, 0),
OpenMesh::Vec3d(-5.17486, 1.40202, 0),
OpenMesh::Vec3d(-4.37125, 2.34593, 0),
OpenMesh::Vec3d(-3.4439, 3.19528, 0),
OpenMesh::Vec3d(-2.45369, 3.90771, 0),
OpenMesh::Vec3d(-1.38744, 4.50666, 0),
OpenMesh::Vec3d(-0.256651, 4.96624, 0),
OpenMesh::Vec3d(0.927168, 5.27697, 0),
OpenMesh::Vec3d(2.15251, 5.42939, 0),
OpenMesh::Vec3d(3.40788, 5.41407, 0),
OpenMesh::Vec3d(4.68176, 5.22152, 0),
OpenMesh::Vec3d(5.98425, 4.8927, 0),
OpenMesh::Vec3d(7.26064, 4.30295, 0),
OpenMesh::Vec3d(8.53544, 3.51482, 0),
OpenMesh::Vec3d(9.73233, 2.49004, 0),
OpenMesh::Vec3d(9.72816, 2.82964, 0),
OpenMesh::Vec3d(9.73162, 3.06732, 0),
OpenMesh::Vec3d(9.70073, 3.27175, 0),
OpenMesh::Vec3d(8.69299, 4.11285, 0),
OpenMesh::Vec3d(7.56484, 4.808, 0),
OpenMesh::Vec3d(6.33966, 5.351, 0),
OpenMesh::Vec3d(5.04081, 5.73565, 0),
OpenMesh::Vec3d(3.69165, 5.95574, 0),
OpenMesh::Vec3d(2.31556, 6.00509, 0),
OpenMesh::Vec3d(0.935893, 5.87748, 0),
OpenMesh::Vec3d(-0.423979, 5.56672, 0),
OpenMesh::Vec3d(-1.74069, 5.0666, 0),
OpenMesh::Vec3d(-2.99088, 4.37092, 0),
OpenMesh::Vec3d(-4.15118, 3.47349, 0),
OpenMesh::Vec3d(-5.19821, 2.36809, 0),
OpenMesh::Vec3d(-6.10863, 1.04853, 0),
OpenMesh::Vec3d(-6.92899, -0.491387, 0),
OpenMesh::Vec3d(-7.42613, -2.25787, 0),
OpenMesh::Vec3d(-8.65612, -1.67216, 0),
OpenMesh::Vec3d(-13.1998, -3.81923, 0),
OpenMesh::Vec3d(-6.02623, -6.5032, 0),
OpenMesh::Vec3d(-2.88592, -5.16367, 0),
OpenMesh::Vec3d(-0.978079, -2.18366, 0),
OpenMesh::Vec3d(-4.02564, -1.5895, 0),
OpenMesh::Vec3d(-3.35645, -0.489997, 0),
OpenMesh::Vec3d(-2.59159, 0.46111, 0),
OpenMesh::Vec3d(-1.74514, 1.26141, 0),
OpenMesh::Vec3d(-0.831163, 1.9085, 0),
OpenMesh::Vec3d(0.136276, 2.39997, 0),
OpenMesh::Vec3d(1.14311, 2.73342, 0),
OpenMesh::Vec3d(2.17526, 2.90642, 0),
OpenMesh::Vec3d(3.21868, 2.91658, 0),
OpenMesh::Vec3d(4.25928, 2.76149, 0),
OpenMesh::Vec3d(5.28301, 2.43873, 0),
OpenMesh::Vec3d(6.27579, 1.94591, 0),
OpenMesh::Vec3d(7.22356, 1.28061, 0),
OpenMesh::Vec3d(8.11224, 0.440423, 0),
OpenMesh::Vec3d(8.92778, -0.577058, 0),
OpenMesh::Vec3d(9.6561, -1.77424, 0),
OpenMesh::Vec3d(9.67105, -1.42373, 0),
OpenMesh::Vec3d(9.6996, -1.06183, 0),
OpenMesh::Vec3d(9.74062, -0.738046, 0),
OpenMesh::Vec3d(8.99673, 0.40238, 0),
OpenMesh::Vec3d(8.13782, 1.33809, 0),
OpenMesh::Vec3d(7.19611, 2.09069, 0),
OpenMesh::Vec3d(6.21619, 2.69409, 0),
OpenMesh::Vec3d(5.19327, 3.13288, 0),
OpenMesh::Vec3d(4.14106, 3.41014, 0),
OpenMesh::Vec3d(3.07328, 3.52893, 0),
OpenMesh::Vec3d(2.00367, 3.49235, 0),
OpenMesh::Vec3d(0.945939, 3.30348, 0),
OpenMesh::Vec3d(-0.0861889, 2.96539, 0),
OpenMesh::Vec3d(-1.07899, 2.48117, 0),
OpenMesh::Vec3d(-2.01875, 1.8539, 0),
OpenMesh::Vec3d(-2.89173, 1.08666, 0),
OpenMesh::Vec3d(-3.68423, 0.182521, 0),
OpenMesh::Vec3d(-4.38251, -0.855424, 0),
OpenMesh::Vec3d(-3.72907, 0.202925, 0),
OpenMesh::Vec3d(-2.96513, 1.12097, 0),
OpenMesh::Vec3d(-2.10676, 1.89674, 0),
OpenMesh::Vec3d(-1.17007, 2.52828, 0),
OpenMesh::Vec3d(-0.171147, 3.01364, 0),
OpenMesh::Vec3d(0.87391, 3.35085, 0),
OpenMesh::Vec3d(1.94901, 3.53795, 0),
OpenMesh::Vec3d(3.03805, 3.57299, 0),
OpenMesh::Vec3d(4.12495, 3.454, 0),
OpenMesh::Vec3d(5.19361, 3.17903, 0),
OpenMesh::Vec3d(6.22793, 2.74611, 0),
OpenMesh::Vec3d(7.21183, 2.15329, 0),
OpenMesh::Vec3d(8.12919, 1.39861, 0),
OpenMesh::Vec3d(9.00096, 0.510959, 0),
OpenMesh::Vec3d(9.69998, -0.60418, 0),
OpenMesh::Vec3d(9.70243, -0.18479, 0),
OpenMesh::Vec3d(9.72684, 0.11423, 0),
OpenMesh::Vec3d(9.75569, 0.418196, 0),
OpenMesh::Vec3d(8.76228, 1.61012, 0),
OpenMesh::Vec3d(7.7418, 2.44397, 0),
OpenMesh::Vec3d(6.669, 3.15093, 0),
OpenMesh::Vec3d(5.56797, 3.666, 0),
OpenMesh::Vec3d(4.4505, 3.99823, 0),
OpenMesh::Vec3d(3.32834, 4.15666, 0),
OpenMesh::Vec3d(2.21328, 4.15035, 0),
OpenMesh::Vec3d(1.11707, 3.98833, 0),
OpenMesh::Vec3d(0.0514789, 3.67965, 0),
OpenMesh::Vec3d(-0.971715, 3.23337, 0),
OpenMesh::Vec3d(-1.95052, 2.6976, 0),
OpenMesh::Vec3d(-2.85362, 1.97392, 0),
OpenMesh::Vec3d(-3.66926, 1.15932, 0),
OpenMesh::Vec3d(-4.4052, 0.253054, 0),
OpenMesh::Vec3d(-5.0399, -0.745585, 0),
OpenMesh::Vec3d(-4.49172, 0.202531, 0),
OpenMesh::Vec3d(-3.82685, 1.07788, 0),
OpenMesh::Vec3d(-3.05795, 1.86908, 0),
OpenMesh::Vec3d(-2.19765, 2.56472, 0),
OpenMesh::Vec3d(-1.25858, 3.15343, 0),
OpenMesh::Vec3d(-0.253389, 3.6238, 0),
OpenMesh::Vec3d(0.805287, 3.96445, 0),
OpenMesh::Vec3d(1.90481, 4.16398, 0),
OpenMesh::Vec3d(3.03254, 4.21099, 0),
OpenMesh::Vec3d(4.17584, 4.09411, 0),
OpenMesh::Vec3d(5.32207, 3.80194, 0),
OpenMesh::Vec3d(6.45859, 3.32307, 0),
OpenMesh::Vec3d(7.57277, 2.64613, 0),
OpenMesh::Vec3d(8.65195, 1.7844, 0),
OpenMesh::Vec3d(9.68352, 0.652446, 0),
OpenMesh::Vec3d(9.73424, 0.909529, 0),
OpenMesh::Vec3d(9.75751, 1.17138, 0),
OpenMesh::Vec3d(9.79496, 1.37106, 0),
OpenMesh::Vec3d(8.71283, 2.47403, 0),
OpenMesh::Vec3d(7.58945, 3.31604, 0),
OpenMesh::Vec3d(6.40313, 3.98535, 0),
OpenMesh::Vec3d(5.18465, 4.41288, 0),
OpenMesh::Vec3d(3.97352, 4.67813, 0),
OpenMesh::Vec3d(2.76552, 4.76446, 0),
OpenMesh::Vec3d(1.57394, 4.68146, 0),
OpenMesh::Vec3d(0.412062, 4.4387, 0),
OpenMesh::Vec3d(-0.706828, 4.04577, 0),
OpenMesh::Vec3d(-1.80647, 3.53693, 0),
OpenMesh::Vec3d(-2.76869, 2.8724, 0),
OpenMesh::Vec3d(-3.6851, 2.08028, 0),
OpenMesh::Vec3d(-4.48688, 1.16397, 0),
OpenMesh::Vec3d(-5.19161, 0.163905, 0),
			};
		}
		//banyuan
		if (0) {
			auto filename = "S:/duwei/triangle/test.obj";
			bool read_OK = MeshTools::ReadMesh(mesh, filename);
			mesh_beifen = mesh;
			double rad_R = 12.1;
			double rad_r = 6.9;
			OpenMesh::Vec3d center(rad_R, 0, 0);
			for (int v_id = 0; v_id < mesh.n_vertices(); v_id++)
			{
				auto vh = mesh.vertex_handle(v_id);
				OpenMesh::Vec3d from_center = mesh.point(vh) - center;
				double x = (from_center.length() - rad_r) / (rad_R - rad_r);
				double y = std::asin(from_center[1] / from_center.length())/(M_PI/2);
				OpenMesh::Vec3d new_point3(x, y, 0);
				mesh.set_point(vh, new_point3);
			}
			
			Set_Texture_coord();//设置纹理
			MeshTools::AssignPoints(mesh, mesh_beifen);
			use_rational = true;
			OpenMesh::Vec3d right{ 0.1,0,0 };
			OpenMesh::Vec3d up{ 0,0.1,0 };
			OpenMesh::Vec3d down{ 0,-0.1,0 };
			OpenMesh::Vec3d left{ -0.05,0,0 };
			CC_points = {
				OpenMesh::Vec3d(rad_R, rad_R, 0) + left/*+up*10*/,
			OpenMesh::Vec3d(0, rad_R, 0) + left,
			OpenMesh::Vec3d(0, 0, 0) + left/*+left*10*/,
			OpenMesh::Vec3d(0, -rad_R, 0) + left /*+ left * 10*/,//1
			OpenMesh::Vec3d(rad_R, -rad_R, 0) + left/*+down*10*/,
			OpenMesh::Vec3d(rad_R, (-rad_R - rad_r) / 2, 0) + left,//1
			OpenMesh::Vec3d(rad_R, (-rad_r - rad_r) / 2, 0) + left,
			OpenMesh::Vec3d(rad_R , 0, 0) +OpenMesh::Vec3d(- rad_r*sqrt(2)/2, -rad_r * sqrt(2) / 2, 0) + left,//中点
			OpenMesh::Vec3d(rad_R - rad_r, 0, 0) + left,
			OpenMesh::Vec3d(rad_R , 0, 0) + OpenMesh::Vec3d(-rad_r * sqrt(2) / 2, rad_r * sqrt(2) / 2, 0) + left,//中点
			OpenMesh::Vec3d(rad_R , rad_r, 0) + left,
			OpenMesh::Vec3d(rad_R , (rad_R + rad_r) / 2, 0) + left,//1
			};
		}
		//paristower
		if (0) {
			int N = 3;//circle 4
			curvecage2.resize(N);

			// 逆时针定义3个顶点
			std::vector<OpenMesh::Vec3d> square_vertices = {


				OpenMesh::Vec3d(2.21312, -3.64502, 0),
				OpenMesh::Vec3d(-0.00294265, 4.30579, 0),
				OpenMesh::Vec3d(-2.13172, -3.62273, 0),
			};
			for (int i = 0; i < N; i++) {
				OpenMesh::Vec3d start = square_vertices[i];
				OpenMesh::Vec3d end = square_vertices[(i + 1) % N];

				OpenMesh::Vec3d p1 = start;
				OpenMesh::Vec3d p4 = end;

				// Intermediate control points (simple linear interpolation for demonstration)
				OpenMesh::Vec3d p2 = p1 + (p4 - p1) / 3;
				OpenMesh::Vec3d p3 = p1 + (p4 - p1) * 2 / 3;

				curvecage2[i] = { p1, p2, p3, p4 };

			}
			//通过curvecage2计算cc_points;
			for (int i = 0; i < N; i++) {
				for (int j = 0; j < 3; j++) {
					CC_points.push_back(curvecage2[i][j]);
				}
			}
			CC_points = { OpenMesh::Vec3d(2.21312, -3.64502, 0),
OpenMesh::Vec3d(0.681554, -1.0349, 0),
OpenMesh::Vec3d(0.510854, 1.61184, 0),
OpenMesh::Vec3d(-0.00294265, 4.30579, 0),
OpenMesh::Vec3d(-0.345648, 1.61927, 0),
OpenMesh::Vec3d(-0.5668, -1.06018, 0),
OpenMesh::Vec3d(-2.13172, -3.62273, 0),
OpenMesh::Vec3d(-0.68344, -3.63016, 0),
OpenMesh::Vec3d(0.76484, -3.63759, 0),
			};
			LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\paristower.obj");
			Set_Texture_coord();//设置纹理
		}
		//wanqu kuzi
		if (0) {
			CC_points = { OpenMesh::Vec3d(13.1249, 15.7963, 0),
                   OpenMesh::Vec3d(6.60353, 17.588, 0),
                   OpenMesh::Vec3d(-3.63625, 16.2857, 0),
                   OpenMesh::Vec3d(-12.413, 15.4446, 0),
                   OpenMesh::Vec3d(-11.6682, 7.95155, 0),
                   OpenMesh::Vec3d(-11.6854, 0.216769, 0),
                   OpenMesh::Vec3d(-20.2694, -1.26341, 0),
                   OpenMesh::Vec3d(-20.4997, -4.21117, 0),
                   OpenMesh::Vec3d(-20.7351, -7.75053, 0),
                   OpenMesh::Vec3d(-22.2237, -10.5609, 0),
                   OpenMesh::Vec3d(-11.2453, -15.9302, 0),
                   OpenMesh::Vec3d(-1.39037, -9.72281, 0),
                   OpenMesh::Vec3d(1.21752, -0.689923, 0),
                   OpenMesh::Vec3d(1.94593, -0.686233, 0),
                   OpenMesh::Vec3d(2.87239, -0.682543, 0),
                   OpenMesh::Vec3d(3.74934, -0.579826, 0),
                   OpenMesh::Vec3d(6.67731, -4.53932, 0),
                   OpenMesh::Vec3d(9.79138, -12.0879, 0),
                   OpenMesh::Vec3d(12.7915, -18.0178, 0),
                   OpenMesh::Vec3d(17.257, -16.0734, 0),
                   OpenMesh::Vec3d(21.0368, -15.3335, 0),
                   OpenMesh::Vec3d(24.1444, -15.1955, 0),
                   OpenMesh::Vec3d(22.3394, -3.90843, 0),
                   OpenMesh::Vec3d(15.7834, 5.48645, 0),
			};
			LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\kuzi.obj");
			bool read_OK = MeshTools::ReadMesh(mesh_beifen, "E:\\dgp2021\\dgp6\\newproject_BIHC\\project_BiHC\\mesh\\kuzi_polyGreen.obj");
			Set_Texture_coord();//设置纹理
			MeshTools::AssignPoints(mesh, mesh_beifen);
			
		}
		//gengwanqu kuzi
		if (0) {
			CC_points = { OpenMesh::Vec3d(13.5697, 17.7931, 0),
OpenMesh::Vec3d(6.69321, 19.6591, 0),
OpenMesh::Vec3d(-3.91537, 18.7124, 0),
OpenMesh::Vec3d(-10.2836, 17.3012, 0),
OpenMesh::Vec3d(-9.34994, 7.58748, 0),
OpenMesh::Vec3d(-19.0209, 13.4086, 0),
OpenMesh::Vec3d(-21.5496, 11.8298, 0),
OpenMesh::Vec3d(-24.158, 9.96621, 0),
OpenMesh::Vec3d(-29.1771, 6.36177, 0),
OpenMesh::Vec3d(-33.5071, 4.71512, 0),
OpenMesh::Vec3d(-25.2567, -12.8486, 0),
OpenMesh::Vec3d(-1.39037, -9.72281, 0),
OpenMesh::Vec3d(1.21752, -0.689923, 0),
OpenMesh::Vec3d(1.94593, -0.686233, 0),
OpenMesh::Vec3d(2.87239, -0.682543, 0),
OpenMesh::Vec3d(3.74934, -0.579826, 0),
OpenMesh::Vec3d(4.42834, -3.78613, 0),
OpenMesh::Vec3d(5.05489, -11.8011, 0),
OpenMesh::Vec3d(7.83982, -18.0171, 0),
OpenMesh::Vec3d(12.3053, -16.0727, 0),
OpenMesh::Vec3d(16.0851, -15.3328, 0),
OpenMesh::Vec3d(20.5552, -15.2719, 0),
OpenMesh::Vec3d(22.3394, -3.90843, 0),
OpenMesh::Vec3d(16.8107, 5.74144, 0),
			};
			LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\kuzi.obj");
			bool read_OK = MeshTools::ReadMesh(mesh_beifen,
				"E:\\dgp2021\\dgp6\\newproject_BIHC\\project_BiHC\\SurfaceMeshProcessing\\kuzi_curve.obj");
			Set_Texture_coord();//设置纹理
			MeshTools::AssignPoints(mesh, mesh_beifen);
		}
		//poly sheji
		if (0)
		{
			int N = 5;
			curvecage2.resize(N);
			std::vector<OpenMesh::Vec3d> square_vertices = {
			OpenMesh::Vec3d(-12.729, -6.31988, 0),
				OpenMesh::Vec3d(5.51534, -6.20705, 0),
				OpenMesh::Vec3d(6.0044, 9.48202, 0),
				OpenMesh::Vec3d(-4.21192, 10.1169, 0),
				OpenMesh::Vec3d(-12.3981, 4.54636, 0),
			};
			for (int i = 0; i < N; i++) {
				OpenMesh::Vec3d start = square_vertices[i];
				OpenMesh::Vec3d end = square_vertices[(i + 1) % N];

				OpenMesh::Vec3d p1 = start;
				OpenMesh::Vec3d p4 = end;

				// Intermediate control points (simple linear interpolation for demonstration)
				OpenMesh::Vec3d p2 = p1 + (p4 - p1) / 3;
				OpenMesh::Vec3d p3 = p1 + (p4 - p1) * 2 / 3;

				curvecage2[i] = { p1, p4 };

			}
			//通过curvecage2计算cc_points;
			for (int i = 0; i < N; i++) {
				for (int j = 0; j < degree; j++) {
					CC_points.push_back(curvecage2[i][j]);
				}
			}
			CC_points = { OpenMesh::Vec3d(-11.3757, -12.4802, 0),
OpenMesh::Vec3d(15.3167, 7.07601, 0),
OpenMesh::Vec3d(-3.82973, 10.8813, 0),
OpenMesh::Vec3d(-13.1636, 4.25514, 0),
			};
			LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\sheji.obj");

			Set_Texture_coord();//设置纹理
		}
		//poly octopus
		if (1) {
			CC_points = { OpenMesh::Vec3d(-3.64311, -16.5925, 0),
OpenMesh::Vec3d(-2.18002, -12.2574, 0),
OpenMesh::Vec3d(-0.385926, -14.3912, 0),
OpenMesh::Vec3d(-0.196086, -6.4875, 0),
OpenMesh::Vec3d(0.0089644, -9.21506, 0),
OpenMesh::Vec3d(1.14853, -9.85564, 0),
OpenMesh::Vec3d(2.47479, -14.0728, 0),
OpenMesh::Vec3d(5.21456, -6.8191, 0),
OpenMesh::Vec3d(8.26414, -5.47943, 0),
OpenMesh::Vec3d(9.90246, 3.21374, 0),
OpenMesh::Vec3d(7.31046, 3.16547, 0),
OpenMesh::Vec3d(6.55989, -3.50544, 0),
OpenMesh::Vec3d(5.90752, 2.46454, 0),
OpenMesh::Vec3d(7.48071, 3.46206, 0),
OpenMesh::Vec3d(9.82861, 9.93103, 0),
OpenMesh::Vec3d(0.55821, 15.0266, 0),
OpenMesh::Vec3d(-8.44575, 8.29365, 0),
OpenMesh::Vec3d(-0.23566, 2.52598, 0),
OpenMesh::Vec3d(-8.67665, 2.88167, 0),
OpenMesh::Vec3d(-8.2569, -5.6261, 0),
OpenMesh::Vec3d(-8.89145, -10.3379, 0),
OpenMesh::Vec3d(-5.93367, -9.62478, 0),
			};
			LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\octopus.obj");

			Set_Texture_coord();//设置纹理

		}
		if (0) {
			if (1)//zimu_S
			{
				CC_points = { OpenMesh::Vec3d(0.596266, -1.16511, 0),
OpenMesh::Vec3d(-1.37608, -1.16152, 0),
OpenMesh::Vec3d(-1.37802, -2.09268, 0),
OpenMesh::Vec3d(2.72435, -2.06795, 0),
OpenMesh::Vec3d(-0.671918, 1.48669, 0),
OpenMesh::Vec3d(1.02929, 1.4972, 0),
OpenMesh::Vec3d(1.02864, 2.28088, 0),
OpenMesh::Vec3d(-3.07623, 2.24427, 0),
				};
				LoadMesh("S:/duwei/triangle/zimu_S.obj");

				Set_Texture_coord();//设置纹理
			}
		}
		if (0)//elephant
		{
			CC_points = { OpenMesh::Vec3d(-13.9394, -8.55341, 0),
OpenMesh::Vec3d(-7.51717, -9.44683, 0),
OpenMesh::Vec3d(-6.48065, -2.92187, 0),
OpenMesh::Vec3d(-4.55527, -10.4474, 0),
OpenMesh::Vec3d(0.828162, -3.82069, 0),
OpenMesh::Vec3d(0.618974, -9.23841, 0),
OpenMesh::Vec3d(3.4762, -9.05993, 0),
OpenMesh::Vec3d(8.52535, 0.577435, 0),
OpenMesh::Vec3d(7.69601, -8.5859, 0),
OpenMesh::Vec3d(9.71487, -9.77693, 0),
OpenMesh::Vec3d(13.571, -1.24525, 0),
OpenMesh::Vec3d(8.98221, 7.81831, 0),
OpenMesh::Vec3d(0.396896, 9.48434, 0),
OpenMesh::Vec3d(-11.3877, 7.499, 0),
			};
			LoadMesh("E:\\dgp2021\\dgp6\\newproject_BIHC\\project_BiHC\\mesh\\elephant.obj");
			Set_Texture_coord();//设置纹理
		}
		//xiyi
		if (0) {
			CC_points = { OpenMesh::Vec3d(4.92179, 0.652803, 0),
OpenMesh::Vec3d(4.50392, 0.124446, 0),
OpenMesh::Vec3d(2.81631, 0.499364, 0),
OpenMesh::Vec3d(1.27923, 2.41356, 0),
OpenMesh::Vec3d(-5.02458, 1.87722, 0),
OpenMesh::Vec3d(-5.61821, -0.061172, 0),
OpenMesh::Vec3d(-3.73234, -0.87026, 0),
OpenMesh::Vec3d(-3.30993, -2.36024, 0),
OpenMesh::Vec3d(1.63866, -2.07281, 0),
OpenMesh::Vec3d(5.35397, -0.58715, 0),
OpenMesh::Vec3d(5.46569, 1.54269, 0),
OpenMesh::Vec3d(4.2617, 1.58947, 0),
OpenMesh::Vec3d(3.63309, 0.894845, 0),
OpenMesh::Vec3d(4.35335, 0.281506, 0),
OpenMesh::Vec3d(4.90063, 0.675732, 0),
OpenMesh::Vec3d(4.60687, 1.15165, 0),
OpenMesh::Vec3d(4.27292, 1.00052, 0),
OpenMesh::Vec3d(4.33631, 0.822268, 0),
OpenMesh::Vec3d(4.52022, 0.91485, 0),
OpenMesh::Vec3d(4.54631, 0.802294, 0),
OpenMesh::Vec3d(4.33631, 0.749725, 0),
OpenMesh::Vec3d(4.23015, 0.995889, 0),
OpenMesh::Vec3d(4.47919, 1.19713, 0),
OpenMesh::Vec3d(4.77381, 1.09739, 0),
			};
			LoadMesh("E:\\dgp2021\\dgp6\\newproject_BIHC\\project_BiHC\\mesh\\xiyi.obj");
			Set_Texture_coord();//设置纹理
		}
		CC_mesh = createMeshFromCurveCage(CC_points);
		curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
		auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
		for (auto vh : CC_mesh.vertices())
		{
			CagevertexState[vh] = NotSelected;
		}
		useCauchy = true;
		calculate_cauchy_weight121();
		//calculate_green_weight121();//计算3次cage到3次控制点的权重
		auto vertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(mesh, "vertexState");
		for (auto vh : mesh.vertices())
		{
			vertexState[vh] = NotSelected;
		}
		UpdateMesh();
		update();
		return;
	}
	if (degree == 0) {
		degree = 1;
		LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\haixing.obj");
		std::vector<OpenMesh::Vec3d> points = { OpenMesh::Vec3d(-2.13173, -0.13608, 0),
OpenMesh::Vec3d(-0.342821, -0.389381, 0),
OpenMesh::Vec3d(-0.477382, -2.00566, 0),
OpenMesh::Vec3d(0.47484, -0.621889, 0),
OpenMesh::Vec3d(2.1538, -0.984781, 0),
OpenMesh::Vec3d(0.959173, 0.174992, 0),
OpenMesh::Vec3d(1.75911, 1.46569, 0),
OpenMesh::Vec3d(0.375383, 0.827541, 0),
OpenMesh::Vec3d(-0.660919, 1.99844, 0),
OpenMesh::Vec3d(-0.458974, 0.453426, 0),
		};
		for (const auto& point : points) {
			CC_points.emplace_back(point[0], point[1], 0.0); // 将 z 设为 0
		}
		Set_Texture_coord();//设置纹理

		CC_mesh = createMeshFromCurveCage(CC_points);
		curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
		auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
		for (auto vh : CC_mesh.vertices())
		{
			CagevertexState[vh] = NotSelected;
		}
		auto vertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(mesh, "vertexState");
		for (auto vh : mesh.vertices())
		{
			vertexState[vh] = NotSelected;
		}
		UpdateMesh();
		update();
		return;
	}
	if (degree == 1&& usebih) {
		
		linear_cage = { 
			  OpenMesh::Vec2d(-0.080767526797, -1.12594231977),
			  OpenMesh::Vec2d(-0.080767526797, -4.15997046944),
			  OpenMesh::Vec2d(6.05952753800, -4.12385108670),
			  OpenMesh::Vec2d(5.08430420418, 0.932862496076),
			  OpenMesh::Vec2d(5.08430420418, 7.07315756088),
			  OpenMesh::Vec2d(1.00281395523, 2.95554792919),
			  OpenMesh::Vec2d(0.930575189759, 7.03703817814),
			  OpenMesh::Vec2d(-3.11479567646, 3.02778669466),
			  OpenMesh::Vec2d(-7.19628592542, 3.02778669466),
			  OpenMesh::Vec2d(-3.07867629373, -0.0784802204796),
			  OpenMesh::Vec2d(-7.23240530815, -0.0423608377455),
			  OpenMesh::Vec2d(-3.11479567646, -3.11250837015),
			  OpenMesh::Vec2d(-3.06782410430, -7.18387669905)
		};
		//haixing
		if (1)
		{
			linear_cage = {
OpenMesh::Vec2d(-2.13173, -0.13608),
OpenMesh::Vec2d(-0.342821, -0.389381),
OpenMesh::Vec2d(-0.477382, -2.00566),
OpenMesh::Vec2d(0.47484, -0.621889),
OpenMesh::Vec2d(2.1538, -0.984781),
OpenMesh::Vec2d(0.959173, 0.174992),
OpenMesh::Vec2d(1.75911, 1.46569),
OpenMesh::Vec2d(0.375383, 0.827541),
OpenMesh::Vec2d(-0.660919, 1.99844),
OpenMesh::Vec2d(-0.458974, 0.453426),
			};
			linear_cage = {
OpenMesh::Vec2d(-2.13173, -0.13608),
OpenMesh::Vec2d(-0.282235, -0.28219),
OpenMesh::Vec2d(-0.477382, -2.00566),
OpenMesh::Vec2d(0.451538, -0.486735),
OpenMesh::Vec2d(2.1538, -0.984781),
OpenMesh::Vec2d(0.819359, 0.147029),
OpenMesh::Vec2d(1.75911, 1.46569),
OpenMesh::Vec2d(0.366062, 0.780936),
OpenMesh::Vec2d(-0.660919, 1.99844),
OpenMesh::Vec2d(-0.365765, 0.406821),
			};
			/*{OpenMesh::Vec3d(-2.13173, -0.13608, 0),
				OpenMesh::Vec3d(-1.53543, -0.197211, 0),
				OpenMesh::Vec3d(-0.911161, -0.23504, 0),
				OpenMesh::Vec3d(-0.282235, -0.28219, 0),
				OpenMesh::Vec3d(-0.364372, -0.928141, 0),
				OpenMesh::Vec3d(-0.423207, -1.46224, 0),
				OpenMesh::Vec3d(-0.477382, -2.00566, 0),
				OpenMesh::Vec3d(-0.159975, -1.5444, 0),
				OpenMesh::Vec3d(0.138791, -1.0412, 0),
				OpenMesh::Vec3d(0.451538, -0.486735, 0),
				OpenMesh::Vec3d(1.04381, -0.663625, 0),
				OpenMesh::Vec3d(1.59881, -0.845175, 0),
				OpenMesh::Vec3d(2.1538, -0.984781, 0),
				OpenMesh::Vec3d(1.74627, -0.612171, 0),
				OpenMesh::Vec3d(1.33408, -0.253543, 0),
				OpenMesh::Vec3d(0.819359, 0.147029, 0),
				OpenMesh::Vec3d(1.17455, 0.628527, 0),
				OpenMesh::Vec3d(1.46916, 1.04012, 0),
				OpenMesh::Vec3d(1.75911, 1.46569, 0),
				OpenMesh::Vec3d(1.28389, 1.23899, 0),
				OpenMesh::Vec3d(0.859928, 1.02162, 0),
				OpenMesh::Vec3d(0.366062, 0.780936, 0),
				OpenMesh::Vec3d(0.00198618, 1.20852, 0),
				OpenMesh::Vec3d(-0.315485, 1.60814, 0),
				OpenMesh::Vec3d(-0.660919, 1.99844, 0),
				OpenMesh::Vec3d(-0.570302, 1.48344, 0),
				OpenMesh::Vec3d(-0.475024, 0.977752, 0),
				OpenMesh::Vec3d(-0.365765, 0.406821, 0),
				OpenMesh::Vec3d(-1.00258, 0.228961, 0),
				OpenMesh::Vec3d(-1.57414, 0.060422, 0),
			}*/
			auto linearcage1 = subdivideCage123(linear_cage);
			linear_cage = linearcage1;

			for (const auto& point : linear_cage) {
				CC_points.emplace_back(point[0], point[1], 0.0); // 将 z 设为 0
			}

			for (int i = 0; i < dividecages; i++)
			{
				auto linearcage2 = subdivideCage(linear_cage);
				linear_cage = linearcage2;
			}
			LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\haixing1.obj");//见过了的海星
			for (auto vh : mesh.vertices()) {
				auto p = mesh.point(vh);
				p *= 1;
				mesh.set_point(vh, p);
			}
			
			Set_Texture_coord();//设置纹理

			CC_mesh = createMeshFromCurveCage(CC_points);
			curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
			auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
			for (auto vh : CC_mesh.vertices())
			{
				CagevertexState[vh] = NotSelected;
			}
			
			int m = linear_cage.size();
			linear_length.resize(m);
			for (int i = 0; i < m; i++) {
				linear_length[i] = (linear_cage[(i + 1) % m] - linear_cage[i]).length();
			}
			
			ConstructMatrix4OffSetVirtual();
			
			calculate_bih_weight121();
			/*mesh.garbage_collection();
			MeshTools::WriteOBJ(mesh, "E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\haixing1.obj");*/
			//calculate_bih_weight121test();

			Mesh deformedMesh;
			deformedMesh.assign(mesh);
			deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
			MeshTools::AssignPoints(mesh, deformedMesh);

			auto vertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(mesh, "vertexState");
			for (auto vh : mesh.vertices())
			{
				vertexState[vh] = NotSelected;
			}
			update();
			return;
		}
		
		//paris tower
		if (0)
		{
//			linear_cage = { //paris tower
//	OpenMesh::Vec2d(2.21312, -3.64502),
//OpenMesh::Vec2d(0.0729413, -1.26159),
//OpenMesh::Vec2d(0.71968, 2.04631),
//OpenMesh::Vec2d(-0.00294265, 4.30579),
//OpenMesh::Vec2d(-0.533977, 2.06356),
//OpenMesh::Vec2d(0.020478, -1.26554),
//OpenMesh::Vec2d(-2.13172, -3.62273),
//OpenMesh::Vec2d(-1.5717, -3.65431),
//OpenMesh::Vec2d(-0.789005, -3.66778),
//OpenMesh::Vec2d(-0.017268, -3.66608),
//OpenMesh::Vec2d(0.997374, -3.65183),
//OpenMesh::Vec2d(1.73898, -3.63311),
//			};
			linear_cage = { OpenMesh::Vec2d(2.21312, -3.64502),
OpenMesh::Vec2d(0.825116, -0.859017),
OpenMesh::Vec2d(0.550176, 1.91918),
OpenMesh::Vec2d(-0.00294265, 4.30579),
OpenMesh::Vec2d(-0.428037, 1.85168),
OpenMesh::Vec2d(-0.699915, -0.820591),
OpenMesh::Vec2d(-2.13172, -3.62273),
OpenMesh::Vec2d(-1.5717, -3.65431),
OpenMesh::Vec2d(-0.789005, -3.66778),
OpenMesh::Vec2d(-0.017268, -3.66608),
OpenMesh::Vec2d(0.997374, -3.65183),
OpenMesh::Vec2d(1.73898, -3.63311),
			};
			

			for (const auto& point : linear_cage) {
				CC_points.emplace_back(point[0], point[1], 0.0); // 将 z 设为 0
			}

			for (int i = 0; i < dividecages; i++)
			{
				auto linearcage2 = subdivideCage(linear_cage);
				linear_cage = linearcage2;
			}
			LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\paristower.obj");
			Set_Texture_coord();//设置纹理

			CC_mesh = createMeshFromCurveCage(CC_points);
			curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
			auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
			for (auto vh : CC_mesh.vertices())
			{
				CagevertexState[vh] = NotSelected;
			}

			int m = linear_cage.size();
			linear_length.resize(m);
			for (int i = 0; i < m; i++) {
				linear_length[i] = (linear_cage[(i + 1) % m] - linear_cage[i]).length();
			}

			ConstructMatrix4OffSetVirtual();

			calculate_bih_weight121();
			//calculate_bih_weight121test();

			Mesh deformedMesh;
			deformedMesh.assign(mesh);
			deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
			MeshTools::AssignPoints(mesh, deformedMesh);

			auto vertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(mesh, "vertexState");
			for (auto vh : mesh.vertices())
			{
				vertexState[vh] = NotSelected;
			}
			update();
			return;
		}

		std::vector<OpenMesh::Vec2d> offset_cage = offsetCage(linear_cage, -0.01);
		linear_cage = offset_cage;

		for (const auto& point : linear_cage) {
			CC_points.emplace_back(point[0], point[1], 0.0); // 将 z 设为 0
		}

		for (int i = 0; i < dividecages; i++)
		{
			auto linearcage2 = subdivideCage(linear_cage);
			linear_cage = linearcage2;
		}
		
		
		LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\bihexp2.obj");
		Set_Texture_coord();//设置纹理

		CC_mesh = createMeshFromCurveCage(CC_points);
		curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
		auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
		for (auto vh : CC_mesh.vertices())
		{
			CagevertexState[vh] = NotSelected;
		}
		//ConstructMatrix4OffSetTest();
		//ConstructMatrix4();
		int m = linear_cage.size();
		linear_length.resize(m);
		for (int i = 0; i < m; i++) {
			linear_length[i] = (linear_cage[(i + 1) % m] - linear_cage[i]).length();
		}
		/*{
			use_new = true;
			NewConstructMatrix4OffSet();
		}*/
		ConstructMatrix4OffSet();
		//ConstructMatrix4OffSetTest();
		//ConstructMatrix4OffSetTestGauss();//大失败
		//ConstructMatrix4OffSetTestVirtual();
		//ConstructMatrix4OffSetTestVirtual2();
		//ConstructMatrix4OffSetTestVirtualGauss();效果步豪
		//ConstructMatrix4OffSetVirtual();
		//ConstructMatrix4OffSetVirtual2();
		//ConstructMatrix4OffSetVirtual3();
		calculate_bih_weight121();
		//calculate_bih_weight121test();

		Mesh deformedMesh;
		deformedMesh.assign(mesh);
		deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
		MeshTools::AssignPoints(mesh, deformedMesh);

		auto vertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(mesh, "vertexState");
		for (auto vh : mesh.vertices())
		{
			vertexState[vh] = NotSelected;
		}
		update();
	}
	if (degree == 1 && useHandle) {
		int N = 4;//球 4

		//wanqu kuzi
		if (0) {
			CC_points = { OpenMesh::Vec3d(13.1249, 15.7963, 0),
				   OpenMesh::Vec3d(6.60353, 17.588, 0),
				   OpenMesh::Vec3d(-3.63625, 16.2857, 0),
				   OpenMesh::Vec3d(-12.413, 15.4446, 0),
				   OpenMesh::Vec3d(-11.6682, 7.95155, 0),
				   OpenMesh::Vec3d(-11.6854, 0.216769, 0),
				   OpenMesh::Vec3d(-20.2694, -1.26341, 0),
				   OpenMesh::Vec3d(-20.4997, -4.21117, 0),
				   OpenMesh::Vec3d(-20.7351, -7.75053, 0),
				   OpenMesh::Vec3d(-22.2237, -10.5609, 0),
				   OpenMesh::Vec3d(-11.2453, -15.9302, 0),
				   OpenMesh::Vec3d(-1.39037, -9.72281, 0),
				   OpenMesh::Vec3d(1.21752, -0.689923, 0),
				   OpenMesh::Vec3d(1.94593, -0.686233, 0),
				   OpenMesh::Vec3d(2.87239, -0.682543, 0),
				   OpenMesh::Vec3d(3.74934, -0.579826, 0),
				   OpenMesh::Vec3d(6.67731, -4.53932, 0),
				   OpenMesh::Vec3d(9.79138, -12.0879, 0),
				   OpenMesh::Vec3d(12.7915, -18.0178, 0),
				   OpenMesh::Vec3d(17.257, -16.0734, 0),
				   OpenMesh::Vec3d(21.0368, -15.3335, 0),
				   OpenMesh::Vec3d(24.1444, -15.1955, 0),
				   OpenMesh::Vec3d(22.3394, -3.90843, 0),
				   OpenMesh::Vec3d(15.7834, 5.48645, 0),
			};
			LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\kuzi.obj");
			bool read_OK = MeshTools::ReadMesh(mesh_beifen, "E:\\dgp2021\\dgp6\\newproject_BIHC\\project_BiHC\\mesh\\kuzi_polyGreen.obj");
			Set_Texture_coord();//设置纹理
			MeshTools::AssignPoints(mesh, mesh_beifen);
			Handle_points = { OpenMesh::Vec3d(-18.9562, -6.39777, 0),
OpenMesh::Vec3d(-20.5362, 2.98589, 0),
OpenMesh::Vec3d(-8.91635, 13.6366, 0),
OpenMesh::Vec3d(-8.81635, 13.6366, 0),
OpenMesh::Vec3d(10.315, 14.72, 0),
OpenMesh::Vec3d(10.415, 14.72, 0),
OpenMesh::Vec3d(19.6389, -12.1872, 0),
OpenMesh::Vec3d(14.715, -13.314, 0),
			};
			Handle_points = { OpenMesh::Vec3d(-18.9562, -6.39777, 0),
OpenMesh::Vec3d(-20.5362, 2.98589, 0),
OpenMesh::Vec3d(-8.91635, 13.6366, 0),
OpenMesh::Vec3d(-8.81635, 13.6366, 0),
OpenMesh::Vec3d(10.315, 14.72, 0),
OpenMesh::Vec3d(13.074, 14.5729, 0),
OpenMesh::Vec3d(19.6389, -12.1872, 0),
OpenMesh::Vec3d(24.7961, 1.74493, 0),
OpenMesh::Vec3d(1.74828, 3.04121, 0),
OpenMesh::Vec3d(1.84828, 3.04121, 0),
			};
		}
		//xiyi
		if (0)
		{
			CC_points = { OpenMesh::Vec3d(4.92179, 0.652803, 0),
OpenMesh::Vec3d(4.50392, 0.124446, 0),
OpenMesh::Vec3d(2.81631, 0.499364, 0),
OpenMesh::Vec3d(1.27923, 2.41356, 0),
OpenMesh::Vec3d(-5.02458, 1.87722, 0),
OpenMesh::Vec3d(-5.61821, -0.061172, 0),
OpenMesh::Vec3d(-3.73234, -0.87026, 0),
OpenMesh::Vec3d(-3.30993, -2.36024, 0),
OpenMesh::Vec3d(1.63866, -2.07281, 0),
OpenMesh::Vec3d(5.35397, -0.58715, 0),
OpenMesh::Vec3d(5.46569, 1.54269, 0),
OpenMesh::Vec3d(4.2617, 1.58947, 0),
OpenMesh::Vec3d(3.63309, 0.894845, 0),
OpenMesh::Vec3d(4.35335, 0.281506, 0),
OpenMesh::Vec3d(4.90063, 0.675732, 0),
OpenMesh::Vec3d(4.60687, 1.15165, 0),
OpenMesh::Vec3d(4.27292, 1.00052, 0),
OpenMesh::Vec3d(4.33631, 0.822268, 0),
OpenMesh::Vec3d(4.52022, 0.91485, 0),
OpenMesh::Vec3d(4.54631, 0.802294, 0),
OpenMesh::Vec3d(4.33631, 0.749725, 0),
OpenMesh::Vec3d(4.23015, 0.995889, 0),
OpenMesh::Vec3d(4.47919, 1.19713, 0),
OpenMesh::Vec3d(4.77381, 1.09739, 0),
			};
			LoadMesh("E:\\dgp2021\\dgp6\\newproject_BIHC\\project_BiHC\\mesh\\xiyi.obj");
			Set_Texture_coord();//设置纹理
			Handle_points = { OpenMesh::Vec3d(-3.74578, 1.09215, 0),
OpenMesh::Vec3d(-3.03494, 1.68296, 0),
OpenMesh::Vec3d(0.942322, 0.514433, 0),
OpenMesh::Vec3d(1.04232, 0.514433, 0),
OpenMesh::Vec3d(4.43107, 1.00576, 0),
OpenMesh::Vec3d(7.16171, -0.252313, 0),
OpenMesh::Vec3d(3.74204, -0.284248, 0),
OpenMesh::Vec3d(3.84204, -0.284248, 0),
OpenMesh::Vec3d(2.91631, -1.15318, 0),
OpenMesh::Vec3d(3.01631, -1.15318, 0),
OpenMesh::Vec3d(-1.60846, -1.27856, 0),
OpenMesh::Vec3d(-1.50846, -1.27856, 0),
OpenMesh::Vec3d(4.88039, -0.0948673, 0),
OpenMesh::Vec3d(4.98877, -0.490344, 0),
OpenMesh::Vec3d(5.12283, 0.938135, 0),
OpenMesh::Vec3d(5.9563, -0.400087, 0),
OpenMesh::Vec3d(4.20289, 0.646415, 0),
OpenMesh::Vec3d(6.95481, -0.526363, 0),
OpenMesh::Vec3d(-1.07516, 1.71815, 0),
OpenMesh::Vec3d(-0.975162, 1.71815, 0),
OpenMesh::Vec3d(4.22084, 1.21872, 0),
OpenMesh::Vec3d(6.65452, -0.538372, 0),
			};
		}
		if (1) {
			LoadMesh("E:\\dgp2021\\dgp6\\newproject_BIHC\\project_BiHC\\mesh\\rainbow.obj");
			Set_Texture_coord();//设置纹理
			//CC_points = subdivideCage3(CC_points, 15,10);
			CC_points = { OpenMesh::Vec3d(-5.77366, -0.928836, 0),
OpenMesh::Vec3d(-5.27962, 0.0719992, 0),
OpenMesh::Vec3d(-4.65481, 1.01529, 0),
OpenMesh::Vec3d(-3.93627, 1.89913, 0),
OpenMesh::Vec3d(-3.06849, 2.70309, 0),
OpenMesh::Vec3d(-2.13168, 3.38822, 0),
OpenMesh::Vec3d(-1.09502, 3.92793, 0),
OpenMesh::Vec3d(-0.00171669, 4.36967, 0),
OpenMesh::Vec3d(1.14822, 4.66832, 0),
OpenMesh::Vec3d(2.34242, 4.80964, 0),
OpenMesh::Vec3d(3.56855, 4.77936, 0),
OpenMesh::Vec3d(4.81423, 4.56323, 0),
OpenMesh::Vec3d(6.10208, 4.16447, 0),
OpenMesh::Vec3d(7.34981, 3.55134, 0),
OpenMesh::Vec3d(8.56255, 2.67463, 0),
OpenMesh::Vec3d(9.74542, 1.55503, 0),
OpenMesh::Vec3d(9.71409, 1.85648, 0),
OpenMesh::Vec3d(9.72213, 2.09149, 0),
OpenMesh::Vec3d(9.75057, 2.34935, 0),
OpenMesh::Vec3d(8.60027, 3.37459, 0),
OpenMesh::Vec3d(7.36918, 4.18603, 0),
OpenMesh::Vec3d(6.11254, 4.76385, 0),
OpenMesh::Vec3d(4.85674, 5.14585, 0),
OpenMesh::Vec3d(3.59941, 5.35542, 0),
OpenMesh::Vec3d(2.35257, 5.38714, 0),
OpenMesh::Vec3d(1.12823, 5.25001, 0),
OpenMesh::Vec3d(-0.0615898, 4.95302, 0),
OpenMesh::Vec3d(-1.20487, 4.50516, 0),
OpenMesh::Vec3d(-2.26491, 3.95656, 0),
OpenMesh::Vec3d(-3.30374, 3.23392, 0),
OpenMesh::Vec3d(-4.2682, 2.37094, 0),
OpenMesh::Vec3d(-5.10515, 1.4095, 0),
OpenMesh::Vec3d(-5.80256, 0.317467, 0),
OpenMesh::Vec3d(-6.41423, -0.846814, 0),
OpenMesh::Vec3d(-5.84324, 0.307198, 0),
OpenMesh::Vec3d(-5.17486, 1.40202, 0),
OpenMesh::Vec3d(-4.37125, 2.34593, 0),
OpenMesh::Vec3d(-3.4439, 3.19528, 0),
OpenMesh::Vec3d(-2.45369, 3.90771, 0),
OpenMesh::Vec3d(-1.38744, 4.50666, 0),
OpenMesh::Vec3d(-0.256651, 4.96624, 0),
OpenMesh::Vec3d(0.927168, 5.27697, 0),
OpenMesh::Vec3d(2.15251, 5.42939, 0),
OpenMesh::Vec3d(3.40788, 5.41407, 0),
OpenMesh::Vec3d(4.68176, 5.22152, 0),
OpenMesh::Vec3d(5.98425, 4.8927, 0),
OpenMesh::Vec3d(7.26064, 4.30295, 0),
OpenMesh::Vec3d(8.53544, 3.51482, 0),
OpenMesh::Vec3d(9.73233, 2.49004, 0),
OpenMesh::Vec3d(9.72816, 2.82964, 0),
OpenMesh::Vec3d(9.73162, 3.06732, 0),
OpenMesh::Vec3d(9.70073, 3.27175, 0),
OpenMesh::Vec3d(8.69299, 4.11285, 0),
OpenMesh::Vec3d(7.56484, 4.808, 0),
OpenMesh::Vec3d(6.33966, 5.351, 0),
OpenMesh::Vec3d(5.04081, 5.73565, 0),
OpenMesh::Vec3d(3.69165, 5.95574, 0),
OpenMesh::Vec3d(2.31556, 6.00509, 0),
OpenMesh::Vec3d(0.935893, 5.87748, 0),
OpenMesh::Vec3d(-0.423979, 5.56672, 0),
OpenMesh::Vec3d(-1.74069, 5.0666, 0),
OpenMesh::Vec3d(-2.99088, 4.37092, 0),
OpenMesh::Vec3d(-4.15118, 3.47349, 0),
OpenMesh::Vec3d(-5.19821, 2.36809, 0),
OpenMesh::Vec3d(-6.10863, 1.04853, 0),
OpenMesh::Vec3d(-6.92899, -0.491387, 0),
OpenMesh::Vec3d(-7.42613, -2.25787, 0),
OpenMesh::Vec3d(-8.65612, -1.67216, 0),
OpenMesh::Vec3d(-13.1998, -3.81923, 0),
OpenMesh::Vec3d(-6.02623, -6.5032, 0),
OpenMesh::Vec3d(-2.88592, -5.16367, 0),
OpenMesh::Vec3d(-0.978079, -2.18366, 0),
OpenMesh::Vec3d(-4.02564, -1.5895, 0),
OpenMesh::Vec3d(-3.35645, -0.489997, 0),
OpenMesh::Vec3d(-2.59159, 0.46111, 0),
OpenMesh::Vec3d(-1.74514, 1.26141, 0),
OpenMesh::Vec3d(-0.831163, 1.9085, 0),
OpenMesh::Vec3d(0.136276, 2.39997, 0),
OpenMesh::Vec3d(1.14311, 2.73342, 0),
OpenMesh::Vec3d(2.17526, 2.90642, 0),
OpenMesh::Vec3d(3.21868, 2.91658, 0),
OpenMesh::Vec3d(4.25928, 2.76149, 0),
OpenMesh::Vec3d(5.28301, 2.43873, 0),
OpenMesh::Vec3d(6.27579, 1.94591, 0),
OpenMesh::Vec3d(7.22356, 1.28061, 0),
OpenMesh::Vec3d(8.11224, 0.440423, 0),
OpenMesh::Vec3d(8.92778, -0.577058, 0),
OpenMesh::Vec3d(9.6561, -1.77424, 0),
OpenMesh::Vec3d(9.67105, -1.42373, 0),
OpenMesh::Vec3d(9.6996, -1.06183, 0),
OpenMesh::Vec3d(9.74062, -0.738046, 0),
OpenMesh::Vec3d(8.99673, 0.40238, 0),
OpenMesh::Vec3d(8.13782, 1.33809, 0),
OpenMesh::Vec3d(7.19611, 2.09069, 0),
OpenMesh::Vec3d(6.21619, 2.69409, 0),
OpenMesh::Vec3d(5.19327, 3.13288, 0),
OpenMesh::Vec3d(4.14106, 3.41014, 0),
OpenMesh::Vec3d(3.07328, 3.52893, 0),
OpenMesh::Vec3d(2.00367, 3.49235, 0),
OpenMesh::Vec3d(0.945939, 3.30348, 0),
OpenMesh::Vec3d(-0.0861889, 2.96539, 0),
OpenMesh::Vec3d(-1.07899, 2.48117, 0),
OpenMesh::Vec3d(-2.01875, 1.8539, 0),
OpenMesh::Vec3d(-2.89173, 1.08666, 0),
OpenMesh::Vec3d(-3.68423, 0.182521, 0),
OpenMesh::Vec3d(-4.38251, -0.855424, 0),
OpenMesh::Vec3d(-3.72907, 0.202925, 0),
OpenMesh::Vec3d(-2.96513, 1.12097, 0),
OpenMesh::Vec3d(-2.10676, 1.89674, 0),
OpenMesh::Vec3d(-1.17007, 2.52828, 0),
OpenMesh::Vec3d(-0.171147, 3.01364, 0),
OpenMesh::Vec3d(0.87391, 3.35085, 0),
OpenMesh::Vec3d(1.94901, 3.53795, 0),
OpenMesh::Vec3d(3.03805, 3.57299, 0),
OpenMesh::Vec3d(4.12495, 3.454, 0),
OpenMesh::Vec3d(5.19361, 3.17903, 0),
OpenMesh::Vec3d(6.22793, 2.74611, 0),
OpenMesh::Vec3d(7.21183, 2.15329, 0),
OpenMesh::Vec3d(8.12919, 1.39861, 0),
OpenMesh::Vec3d(9.00096, 0.510959, 0),
OpenMesh::Vec3d(9.69998, -0.60418, 0),
OpenMesh::Vec3d(9.70243, -0.18479, 0),
OpenMesh::Vec3d(9.72684, 0.11423, 0),
OpenMesh::Vec3d(9.75569, 0.418196, 0),
OpenMesh::Vec3d(8.76228, 1.61012, 0),
OpenMesh::Vec3d(7.7418, 2.44397, 0),
OpenMesh::Vec3d(6.669, 3.15093, 0),
OpenMesh::Vec3d(5.56797, 3.666, 0),
OpenMesh::Vec3d(4.4505, 3.99823, 0),
OpenMesh::Vec3d(3.32834, 4.15666, 0),
OpenMesh::Vec3d(2.21328, 4.15035, 0),
OpenMesh::Vec3d(1.11707, 3.98833, 0),
OpenMesh::Vec3d(0.0514789, 3.67965, 0),
OpenMesh::Vec3d(-0.971715, 3.23337, 0),
OpenMesh::Vec3d(-1.95052, 2.6976, 0),
OpenMesh::Vec3d(-2.85362, 1.97392, 0),
OpenMesh::Vec3d(-3.66926, 1.15932, 0),
OpenMesh::Vec3d(-4.4052, 0.253054, 0),
OpenMesh::Vec3d(-5.0399, -0.745585, 0),
OpenMesh::Vec3d(-4.49172, 0.202531, 0),
OpenMesh::Vec3d(-3.82685, 1.07788, 0),
OpenMesh::Vec3d(-3.05795, 1.86908, 0),
OpenMesh::Vec3d(-2.19765, 2.56472, 0),
OpenMesh::Vec3d(-1.25858, 3.15343, 0),
OpenMesh::Vec3d(-0.253389, 3.6238, 0),
OpenMesh::Vec3d(0.805287, 3.96445, 0),
OpenMesh::Vec3d(1.90481, 4.16398, 0),
OpenMesh::Vec3d(3.03254, 4.21099, 0),
OpenMesh::Vec3d(4.17584, 4.09411, 0),
OpenMesh::Vec3d(5.32207, 3.80194, 0),
OpenMesh::Vec3d(6.45859, 3.32307, 0),
OpenMesh::Vec3d(7.57277, 2.64613, 0),
OpenMesh::Vec3d(8.65195, 1.7844, 0),
OpenMesh::Vec3d(9.68352, 0.652446, 0),
OpenMesh::Vec3d(9.73424, 0.909529, 0),
OpenMesh::Vec3d(9.75751, 1.17138, 0),
OpenMesh::Vec3d(9.79496, 1.37106, 0),
OpenMesh::Vec3d(8.71283, 2.47403, 0),
OpenMesh::Vec3d(7.58945, 3.31604, 0),
OpenMesh::Vec3d(6.40313, 3.98535, 0),
OpenMesh::Vec3d(5.18465, 4.41288, 0),
OpenMesh::Vec3d(3.97352, 4.67813, 0),
OpenMesh::Vec3d(2.76552, 4.76446, 0),
OpenMesh::Vec3d(1.57394, 4.68146, 0),
OpenMesh::Vec3d(0.412062, 4.4387, 0),
OpenMesh::Vec3d(-0.706828, 4.04577, 0),
OpenMesh::Vec3d(-1.80647, 3.53693, 0),
OpenMesh::Vec3d(-2.76869, 2.8724, 0),
OpenMesh::Vec3d(-3.6851, 2.08028, 0),
OpenMesh::Vec3d(-4.48688, 1.16397, 0),
OpenMesh::Vec3d(-5.19161, 0.163905, 0),
			};
			Handle_points = { OpenMesh::Vec3d(-6.11148, -5.54871, 0),
OpenMesh::Vec3d(-6.01148, -5.54871, 0),
OpenMesh::Vec3d(9.39437, 1.42827, 0),
OpenMesh::Vec3d(6.57567, -6.37755, 0),
OpenMesh::Vec3d(9.33702, 3.22555, 0),
OpenMesh::Vec3d(12.401, -1.6842, 0),
OpenMesh::Vec3d(9.33438, 0.487494, 0),
OpenMesh::Vec3d(2.85034, -7.45408, 0),
OpenMesh::Vec3d(9.39424, -0.703825, 0),
OpenMesh::Vec3d(-3.90009, -8.75852, 0),
OpenMesh::Vec3d(-3.91779, -3.09565, 0),
OpenMesh::Vec3d(-3.81779, -3.09565, 0),
OpenMesh::Vec3d(9.40397, 2.30526, 0),
OpenMesh::Vec3d(9.45872, -4.68604, 0),
OpenMesh::Vec3d(-5.99235, -2.02229, 0),
OpenMesh::Vec3d(-5.89235, -2.02229, 0),
OpenMesh::Vec3d(-8.58844, -3.53215, 0),
OpenMesh::Vec3d(-8.48844, -3.53215, 0),
			};
		}
		CC_mesh = createMeshFromCurveCage(CC_points);
		curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
		auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
		for (auto vh : CC_mesh.vertices())
		{
			CagevertexState[vh] = NotSelected;
		}

		useCauchy = true;
		calculate_cauchy_weight121();//计算2次cage cauchy权重
		//calculate_D2cauchy_weight222();//计算了边界顶点上的二阶导的权重矩阵
		calculate_D2cauchy_weight_CB121();//计算了cage边界顶点上的二阶导的权重矩阵
		
		partion_handles(Handle_points, deform_cps, deform_cps_t);
		//calculate_cauchy_weight222(deform_cps);

		Handle_mesh = createMeshFromCurveCage(Handle_points);
		auto HandlevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(Handle_mesh, "vertexState");
		for (auto vh : Handle_mesh.vertices())
		{
			HandlevertexState[vh] = NotSelected;
		}
		/*deform_cps_t = deform_cps;*/
	}
	if (degree == 2 && useHandle) {
		int N = 4;//球 4
		
		
		//human
		{
			CC_points = { //human
			OpenMesh::Vec3d(2.2434, -4.09831, 0),
            OpenMesh::Vec3d(1.33897, -1.2763, 0),
            OpenMesh::Vec3d(0.168209, 0.44022, 0),
            OpenMesh::Vec3d(1.4294, -0.288948, 0),
            OpenMesh::Vec3d(2.68837, -0.575573, 0),
            OpenMesh::Vec3d(3.60324, 1.3499, 0),
            OpenMesh::Vec3d(5.97756, 1.52252, 0),
            OpenMesh::Vec3d(6.02737, 3.22644, 0),
            OpenMesh::Vec3d(5.81575, 4.86821, 0),
            OpenMesh::Vec3d(4.28753, 5.19497, 0),
            OpenMesh::Vec3d(3.18159, 4.91388, 0),
            OpenMesh::Vec3d(2.91693, 3.88495, 0),
            OpenMesh::Vec3d(3.06766, 3.08017, 0),
            OpenMesh::Vec3d(1.80562, 2.91953, 0),
            OpenMesh::Vec3d(0.929425, 1.2952, 0),
            OpenMesh::Vec3d(0.312689, 3.28967, 0),
            OpenMesh::Vec3d(-0.901575, 4.85807, 0),
            OpenMesh::Vec3d(-1.23977, 3.5368, 0),
            OpenMesh::Vec3d(-1.9027, 4.60764, 0),
            OpenMesh::Vec3d(-2.60159, 4.08557, 0),
            OpenMesh::Vec3d(-3.67377, 2.94282, 0),
            OpenMesh::Vec3d(-4.19734, 1.3431, 0),
            OpenMesh::Vec3d(-2.67894, 0.569752, 0),
            OpenMesh::Vec3d(-4.59146, 0.273326, 0),
            OpenMesh::Vec3d(-5.02472, -2.5631, 0),
            OpenMesh::Vec3d(-3.32428, -1.2692, 0),
            OpenMesh::Vec3d(-2.25433, -1.02231, 0),
            OpenMesh::Vec3d(-2.9142, -1.57256, 0),
            OpenMesh::Vec3d(-3.11938, -1.99522, 0),
            OpenMesh::Vec3d(-2.32945, -2.77795, 0),
            OpenMesh::Vec3d(-2.39632, -3.96978, 0),
            OpenMesh::Vec3d(-0.151571, -4.57271, 0),
			};
			LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\human.obj");
			Set_Texture_coord();//设置纹理
		}

		CC_mesh = createMeshFromCurveCage(CC_points);
		curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
		auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
		for (auto vh : CC_mesh.vertices())
		{
			CagevertexState[vh] = NotSelected;
		}
		
		useCauchy = true;
		calculate_cauchy_weight222();//计算2次cage cauchy权重
		exit(0);
		//calculate_D2cauchy_weight222();//计算了边界顶点上的二阶导的权重矩阵
		calculate_D2cauchy_weight_CB222();//计算了cage边界顶点上的二阶导的权重矩阵


		/*deform_cps = {
	std::complex<double>(-2, -2),
	std::complex<double>(2, -2),
	std::complex<double>(2, 2),
	std::complex<double>(-2, 2)
		};
		deform_cps_t = {
	std::complex<double>(-2, -2),
	std::complex<double>(2, -2),
	std::complex<double>(2, 2),
	std::complex<double>(-2, 2)
		};*/
		/*deform_cps_t = {
	std::complex<double>(-3, -3),
	std::complex<double>(3, -3),
	std::complex<double>(3, 3),
	std::complex<double>(-3, 3)
		};*/
		deform_cps = {
	std::complex<double>(-1.5, -2.3),
	std::complex<double>(-4.49133, -1.61649),
	std::complex<double>(4, 3),
	std::complex<double>(-1, 2.3)
		};
		deform_cps_t = {
	std::complex<double>(-1.51, -2.31),
	std::complex<double>(-4.92462, -0.43723),
	std::complex<double>(1, 3),
	std::complex<double>(-1.1, 2.31)
		};
		deform_cps_t = {
	std::complex<double>(-1.5+0.1, -2.3),
	std::complex<double>(-4.49133+0.1, -1.61649),
	std::complex<double>(4+0.1, 3),
	std::complex<double>(-1+0.1, 2.3)
		};
		Handle_points = { OpenMesh::Vec3d(-1.5, -2.3, 0),
OpenMesh::Vec3d(-1.4, -2.3, 0),
OpenMesh::Vec3d(-4.49133, -1.61649, 0),
OpenMesh::Vec3d(-4.07306, 0.210323, 0),
OpenMesh::Vec3d(4, 3, 0),
OpenMesh::Vec3d(2.28204, 2.91173, 0),
OpenMesh::Vec3d(-1, 2.3, 0),
OpenMesh::Vec3d(-0.9, 2.3, 0),
OpenMesh::Vec3d(2.11811, 0.674796, 0),
OpenMesh::Vec3d(2.21811, 0.674796, 0),
OpenMesh::Vec3d(1.11399, -2.5481, 0),
OpenMesh::Vec3d(1.21399, -2.5481, 0),
		};
		partion_handles(Handle_points, deform_cps, deform_cps_t);
		calculate_cauchy_weight222(deform_cps);

		Handle_mesh = createMeshFromCurveCage(Handle_points);
		auto HandlevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(Handle_mesh, "vertexState");
		for (auto vh : Handle_mesh.vertices())
		{
			HandlevertexState[vh] = NotSelected;
		}
		/*deform_cps_t = deform_cps;*/
	}
	if (degree == 3 && useHandle) {
		int N = 4;//球 4


		//deer
		if(0){
					CC_points = { //deer
					OpenMesh::Vec3d(4.5276, -10.0723, 0),
		OpenMesh::Vec3d(4.89459, -10.0739, 0),
		OpenMesh::Vec3d(5.18646, -10.0632, 0),
		OpenMesh::Vec3d(5.55932, -10.0582, 0),
		OpenMesh::Vec3d(6.25252, -6.75231, 0),
		OpenMesh::Vec3d(6.71007, -5.29668, 0),
		OpenMesh::Vec3d(6.70587, -3.83298, 0),
		OpenMesh::Vec3d(5.83477, -2.3301, 0),
		OpenMesh::Vec3d(7.05116, -0.928495, 0),
		OpenMesh::Vec3d(6.61916, 0.630525, 0),
		OpenMesh::Vec3d(8.02456, 2.09566, 0),
		OpenMesh::Vec3d(8.65167, 3.70863, 0),
		OpenMesh::Vec3d(6.40582, 5.04416, 0),
		OpenMesh::Vec3d(6.37169, 3.87665, 0),
		OpenMesh::Vec3d(5.80833, 2.98216, 0),
		OpenMesh::Vec3d(5.62158, 2.09523, 0),
		OpenMesh::Vec3d(3.23511, 2.54016, 0),
		OpenMesh::Vec3d(0.750374, 1.38221, 0),
		OpenMesh::Vec3d(-1.69483, 2.49143, 0),
		OpenMesh::Vec3d(-3.65702, 4.17105, 0),
		OpenMesh::Vec3d(-2.17201, 6.0254, 0),
		OpenMesh::Vec3d(-3.05934, 7.31317, 0),
		OpenMesh::Vec3d(-1.89982, 8.15725, 0),
		OpenMesh::Vec3d(-1.63298, 9.67336, 0),
		OpenMesh::Vec3d(-2.82579, 10.398, 0),
		OpenMesh::Vec3d(-3.92575, 10.5965, 0),
		OpenMesh::Vec3d(-2.76592, 8.26476, 0),
		OpenMesh::Vec3d(-5.78046, 7.07922, 0),
		OpenMesh::Vec3d(-6.48863, 6.34431, 0),
		OpenMesh::Vec3d(-5.30909, 5.86309, 0),
		OpenMesh::Vec3d(-7.14945, 4.31455, 0),
		OpenMesh::Vec3d(-6.72589, 3.45316, 0),
		OpenMesh::Vec3d(-5.35703, 4.33777, 0),
		OpenMesh::Vec3d(-4.45691, 4.19383, 0),
		OpenMesh::Vec3d(-3.65641, 2.89317, 0),
		OpenMesh::Vec3d(-4.13472, -0.366618, 0),
		OpenMesh::Vec3d(-3.00663, -1.36788, 0),
		OpenMesh::Vec3d(-3.10867, -2.51138, 0),
		OpenMesh::Vec3d(-2.47899, -3.00126, 0),
		OpenMesh::Vec3d(-2.19824, -3.3226, 0),
		OpenMesh::Vec3d(-1.97104, -5.31759, 0),
		OpenMesh::Vec3d(-1.18862, -7.33088, 0),
		OpenMesh::Vec3d(-2.64391, -10.14, 0),
		OpenMesh::Vec3d(-2.4061, -10.1295, 0),
		OpenMesh::Vec3d(-2.13911, -10.1257, 0),
		OpenMesh::Vec3d(-1.8048, -10.1125, 0),
		OpenMesh::Vec3d(-1.04107, -7.68947, 0),
		OpenMesh::Vec3d(-1.53657, -5.56524, 0),
		OpenMesh::Vec3d(-0.549384, -3.05351, 0),
		OpenMesh::Vec3d(0.598589, -3.14832, 0),
		OpenMesh::Vec3d(1.97528, -3.33699, 0),
		OpenMesh::Vec3d(3.40852, -2.90979, 0),
		OpenMesh::Vec3d(4.44002, -4.23804, 0),
		OpenMesh::Vec3d(6.07989, -4.12357, 0),
		OpenMesh::Vec3d(5.53946, -7.39734, 0),
		OpenMesh::Vec3d(5.59344, -8.20186, 0),
		OpenMesh::Vec3d(4.89491, -9.35694, 0),
				};
			LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\deer.obj");
			Set_Texture_coord();//设置纹理
			//		//deer
			Handle_points = {
				OpenMesh::Vec3d(-4.77772, 6.15806, 0),
	OpenMesh::Vec3d(-2.21779, 6.9095, 0),
	OpenMesh::Vec3d(-2.13006, -9.82847, 0),
	OpenMesh::Vec3d(-5.76418, -7.52105, 0),
	OpenMesh::Vec3d(5.20687, -9.75087, 0),
	OpenMesh::Vec3d(10.209, -8.6227, 0),
	OpenMesh::Vec3d(6.69162, 4.45358, 0),
	OpenMesh::Vec3d(8.43355, 4.32146, 0),
	OpenMesh::Vec3d(6.0825, -5.02297, 0),
	OpenMesh::Vec3d(7.59264, -5.14069, 0),
	OpenMesh::Vec3d(-1.49119, -5.10145, 0),
	OpenMesh::Vec3d(-2.76722, -4.74827, 0),
			};
		}
		//xiyi
		if (0)
		{
			CC_points = { //xiyi

		OpenMesh::Vec3d(4.87927, 0.893929, 0),
		OpenMesh::Vec3d(5.09543, -0.452398, 0),
		OpenMesh::Vec3d(2.58026, 0.369127, 0),
		OpenMesh::Vec3d(0.899758, 1.92868, 0),
		OpenMesh::Vec3d(-6.36326, 3.14212, 0),
		OpenMesh::Vec3d(-6.99906, 0.160185, 0),
		OpenMesh::Vec3d(-3.73234, -0.87026, 0),
		OpenMesh::Vec3d(-4.44834, -2.77133, 0),
		OpenMesh::Vec3d(-1.61845, -2.46282, 0),
		OpenMesh::Vec3d(1.3063, -2.28422, 0),
		OpenMesh::Vec3d(7.03627, -1.80929, 0),
		OpenMesh::Vec3d(5.87444, 2.51706, 0),
		OpenMesh::Vec3d(4.08634, 1.48513, 0),
		OpenMesh::Vec3d(3.23814, 0.190855, 0),
		OpenMesh::Vec3d(4.99338, 0.133408, 0),
		OpenMesh::Vec3d(4.78922, 0.868629, 0),
		OpenMesh::Vec3d(4.60864, 1.23347, 0),
		OpenMesh::Vec3d(4.20604, 1.08959, 0),
		OpenMesh::Vec3d(4.34064, 0.844649, 0),
		OpenMesh::Vec3d(4.51878, 1.00467, 0),
		OpenMesh::Vec3d(4.6284, 0.795768, 0),
		OpenMesh::Vec3d(4.43999, 0.739965, 0),
		OpenMesh::Vec3d(3.96868, 0.757685, 0),
		OpenMesh::Vec3d(4.47345, 1.60985, 0),
			};
			LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\xiyi.obj");
			Set_Texture_coord();//设置纹理
			//		//xiyi
			Handle_points = { OpenMesh::Vec3d(-3.74578, 1.09215, 0),
OpenMesh::Vec3d(-3.03494, 1.68296, 0),
OpenMesh::Vec3d(0.942322, 0.514433, 0),
OpenMesh::Vec3d(1.04232, 0.514433, 0),
OpenMesh::Vec3d(4.43107, 1.00576, 0),
OpenMesh::Vec3d(7.16171, -0.252313, 0),
OpenMesh::Vec3d(3.74204, -0.284248, 0),
OpenMesh::Vec3d(3.84204, -0.284248, 0),
OpenMesh::Vec3d(2.91631, -1.15318, 0),
OpenMesh::Vec3d(3.01631, -1.15318, 0),
OpenMesh::Vec3d(-1.60846, -1.27856, 0),
OpenMesh::Vec3d(-1.50846, -1.27856, 0),
OpenMesh::Vec3d(4.88039, -0.0948673, 0),
OpenMesh::Vec3d(4.98877, -0.490344, 0),
OpenMesh::Vec3d(5.12283, 0.938135, 0),
OpenMesh::Vec3d(5.9563, -0.400087, 0),
OpenMesh::Vec3d(4.20289, 0.646415, 0),
OpenMesh::Vec3d(6.95481, -0.526363, 0),
OpenMesh::Vec3d(-1.07516, 1.71815, 0),
OpenMesh::Vec3d(-0.975162, 1.71815, 0),
OpenMesh::Vec3d(4.22084, 1.21872, 0),
OpenMesh::Vec3d(6.65452, -0.538372, 0),
			};
		}
		//flower
		if (1)
		{
			CC_points = { //flower
			OpenMesh::Vec3d(0.060138, -2.34968, 0),
		OpenMesh::Vec3d(0.167533, -1.16113, 0),
		OpenMesh::Vec3d(0.304982, 0.160104, 0),
		OpenMesh::Vec3d(0.231798, 1.08177, 0),
		OpenMesh::Vec3d(0.61252, 2.32314, 0),
		OpenMesh::Vec3d(0.771864, 3.13087, 0),
		OpenMesh::Vec3d(0.855257, 4.5897, 0),
		OpenMesh::Vec3d(2.09554, 4.91859, 0),
		OpenMesh::Vec3d(2.47687, 5.80984, 0),
		OpenMesh::Vec3d(2.67184, 7.06251, 0),
		OpenMesh::Vec3d(1.05076, 8.34497, 0),
		OpenMesh::Vec3d(-1.00333, 8.56513, 0),
		OpenMesh::Vec3d(-3.01162, 7.65609, 0),
		OpenMesh::Vec3d(-2.46392, 6.1255, 0),
		OpenMesh::Vec3d(-1.33722, 5.03078, 0),
		OpenMesh::Vec3d(-0.552003, 4.00657, 0),
		OpenMesh::Vec3d(-0.0860061, 2.21267, 0),
		OpenMesh::Vec3d(0.0878497, 0.616274, 0),
		OpenMesh::Vec3d(-0.0636332, -0.969635, 0),
		OpenMesh::Vec3d(-0.469408, 0.4811, 0),
		OpenMesh::Vec3d(-1.36141, 0.898247, 0),
		OpenMesh::Vec3d(-2.47641, 1.32553, 0),
		OpenMesh::Vec3d(-2.85447, -0.680847, 0),
		OpenMesh::Vec3d(-1.57427, -0.75945, 0),
		OpenMesh::Vec3d(-0.29709, -1.64989, 0),
		OpenMesh::Vec3d(-0.284548, -4.19343, 0),
		OpenMesh::Vec3d(-0.449725, -7.19035, 0),
		OpenMesh::Vec3d(-0.0458234, -9.10946, 0),
		OpenMesh::Vec3d(0.607011, -6.40262, 0),
		OpenMesh::Vec3d(-0.378727, -4.82229, 0),
		OpenMesh::Vec3d(0.125836, -2.84884, 0),
		OpenMesh::Vec3d(0.941884, -1.5343, 0),
		OpenMesh::Vec3d(2.07567, -2.26778, 0),
		OpenMesh::Vec3d(2.4943, -2.94274, 0),
		OpenMesh::Vec3d(4.17284, -0.459165, 0),
		OpenMesh::Vec3d(0.512756, -0.0850323, 0),
		};
			LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\flower.obj");
			Set_Texture_coord();//设置纹理
			//		//xiyi
			Handle_points = { OpenMesh::Vec3d(-1.73999, 0.0995964, 0),
OpenMesh::Vec3d(-3.08419, -2.17772, 0),
OpenMesh::Vec3d(2.3898, -1.78085, 0),
OpenMesh::Vec3d(3.52466, -3.0655, 0),
OpenMesh::Vec3d(-0.0620346, -1.69561, 0),
OpenMesh::Vec3d(0.0379654, -1.69561, 0),
OpenMesh::Vec3d(-0.144747, -4.77666, 0),
OpenMesh::Vec3d(-0.0447474, -4.77666, 0),
OpenMesh::Vec3d(8.43769e-15, -8.08518, 0),
OpenMesh::Vec3d(0.1, -8.08518, 0),
OpenMesh::Vec3d(-1.799, 6.98923, 0),
OpenMesh::Vec3d(-2.49058, 5.43442, 0),
OpenMesh::Vec3d(1.36476, 6.43092, 0),
OpenMesh::Vec3d(2.72982, 5.64528, 0),
OpenMesh::Vec3d(0.0316255, -1.11743, 0),
OpenMesh::Vec3d(0.131625, -1.11743, 0),
OpenMesh::Vec3d(0.0948764, -0.342609, 0),
OpenMesh::Vec3d(0.194876, -0.342609, 0),
OpenMesh::Vec3d(0.11596, 0.86443, 0),
OpenMesh::Vec3d(0.21596, 0.86443, 0),
			};
		}
		//curve kuzi
		if (0) {
			CC_points = { OpenMesh::Vec3d(13.0832, 15.6921, 0),
				   OpenMesh::Vec3d(5.66596, 19.5152, 0),
				   OpenMesh::Vec3d(-3.58416, 15.296, 0),
				   OpenMesh::Vec3d(-12.413, 15.4446, 0),
				   OpenMesh::Vec3d(-11.8453, 5.02946, 0),
				   OpenMesh::Vec3d(-7.05355, -1.56201, 0),
				   OpenMesh::Vec3d(-20.2694, -1.26341, 0),
				   OpenMesh::Vec3d(-20.4997, -4.21117, 0),
				   OpenMesh::Vec3d(-20.7351, -7.75053, 0),
				   OpenMesh::Vec3d(-22.2237, -10.5609, 0),
				   OpenMesh::Vec3d(-10.5812, -17.0813, 0),
				   OpenMesh::Vec3d(-0.062147, -9.45717, 0),
				   OpenMesh::Vec3d(1.21752, -0.689923, 0),
				   OpenMesh::Vec3d(1.94593, -0.686233, 0),
				   OpenMesh::Vec3d(2.87239, -0.682543, 0),
				   OpenMesh::Vec3d(3.74934, -0.579826, 0),
				   OpenMesh::Vec3d(6.85441, -4.18513, 0),
				   OpenMesh::Vec3d(9.79138, -12.0879, 0),
				   OpenMesh::Vec3d(12.7915, -18.0178, 0),
				   OpenMesh::Vec3d(17.4341, -15.5421, 0),
				   OpenMesh::Vec3d(21.0368, -15.245, 0),
				   OpenMesh::Vec3d(24.1444, -15.1955, 0),
				   OpenMesh::Vec3d(23.4905, -0.23368, 0),
				   OpenMesh::Vec3d(12.2415, 5.26508, 0),
			};
			LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\kuzi.obj");
			bool read_OK = MeshTools::ReadMesh(mesh_beifen, "E:\\dgp2021\\dgp6\\newproject_BIHC\\project_BiHC\\mesh\\kuzi_polyGreen.obj");
			Set_Texture_coord();//设置纹理
			MeshTools::AssignPoints(mesh, mesh_beifen);
			Handle_points = { OpenMesh::Vec3d(-18.9562, -6.39777, 0),
OpenMesh::Vec3d(-20.5362, 2.98589, 0),
OpenMesh::Vec3d(-8.91635, 13.6366, 0),
OpenMesh::Vec3d(-8.81635, 13.6366, 0),
OpenMesh::Vec3d(10.315, 14.72, 0),
OpenMesh::Vec3d(10.415, 14.72, 0),
OpenMesh::Vec3d(19.6389, -12.1872, 0),
OpenMesh::Vec3d(14.715, -13.314, 0),
			};
			Handle_points = { OpenMesh::Vec3d(-18.9562, -6.39777, 0),
OpenMesh::Vec3d(-20.5362, 2.98589, 0),
OpenMesh::Vec3d(-8.91635, 13.6366, 0),
OpenMesh::Vec3d(-8.81635, 13.6366, 0),
OpenMesh::Vec3d(10.315, 14.72, 0),
OpenMesh::Vec3d(13.074, 14.5729, 0),
OpenMesh::Vec3d(19.6389, -12.1872, 0),
OpenMesh::Vec3d(24.7961, 1.74493, 0),
OpenMesh::Vec3d(1.74828, 3.04121, 0),
OpenMesh::Vec3d(1.84828, 3.04121, 0),
			};
		}
		//curve sheji
		if (0) {
			CC_points = { //sheji
			OpenMesh::Vec3d(-13.903, -6.69777, 0),
		OpenMesh::Vec3d(1.05228, -8.39994, 0),
		OpenMesh::Vec3d(7.48085, -1.03554, 0),
		OpenMesh::Vec3d(5.9094, 9.53619, 0),
		OpenMesh::Vec3d(2.46234, 8.10173, 0),
		OpenMesh::Vec3d(-1.18305, 8.99174, 0),
		OpenMesh::Vec3d(-4.21192, 10.1169, 0),
		OpenMesh::Vec3d(-4.81756, 4.98018, 0),
		OpenMesh::Vec3d(-7.6985, 4.82465, 0),
		OpenMesh::Vec3d(-12.3981, 4.54636, 0),
		OpenMesh::Vec3d(-12.0119, 0.141044, 0),
		OpenMesh::Vec3d(-12.2488, -2.39566, 0),
		};
			LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\sheji.obj");
			
			Set_Texture_coord();//设置纹理
			
			Handle_points = { OpenMesh::Vec3d(-11.4889, -5.13169, 0),
OpenMesh::Vec3d(-11.3889, -5.13169, 0),
OpenMesh::Vec3d(-11.6778, 4.01504, 0),
OpenMesh::Vec3d(-11.819, 7.05966, 0),
OpenMesh::Vec3d(5.45578, 8.81271, 0),
OpenMesh::Vec3d(9.71575, -4.84286, 0),
OpenMesh::Vec3d(-3.57254, 9.21556, 0),
OpenMesh::Vec3d(7.79244, 7.60443, 0),
OpenMesh::Vec3d(0.916185, -1.13904, 0),
OpenMesh::Vec3d(-0.114238, -4.75641, 0),
OpenMesh::Vec3d(-4.67244, 4.62937, 0),
OpenMesh::Vec3d(-0.500745, 4.94373, 0),
			};
			Handle_points = { OpenMesh::Vec3d(-11.4889, -5.13169, 0),
OpenMesh::Vec3d(-11.3889, -5.13169, 0),
OpenMesh::Vec3d(-11.6778, 4.01504, 0),
OpenMesh::Vec3d(-19.2169, 4.08025, 0),
OpenMesh::Vec3d(5.45578, 8.81271, 0),
OpenMesh::Vec3d(9.71575, -4.84286, 0),
OpenMesh::Vec3d(0.916185, -1.13904, 0),
OpenMesh::Vec3d(-1.2279, -2.9934, 0),
OpenMesh::Vec3d(-4.67244, 4.62937, 0),
OpenMesh::Vec3d(-4.34064, 9.57282, 0),
OpenMesh::Vec3d(-5.31839, -4.47865, 0),
OpenMesh::Vec3d(-5.93864, -2.74445, 0),
OpenMesh::Vec3d(4.32792, 4.00494, 0),
OpenMesh::Vec3d(4.61898, -3.01422, 0),
OpenMesh::Vec3d(-7.23557, 3.51783, 0),
OpenMesh::Vec3d(-8.44844, 8.32986, 0),
OpenMesh::Vec3d(-3.46262, 9.25027, 0),
OpenMesh::Vec3d(5.66573, 10.7478, 0),
			};
			
		}
		//poly sheji
		if(0)
		{
			int N = 4;
			curvecage2.resize(N);
			std::vector<OpenMesh::Vec3d> square_vertices = { OpenMesh::Vec3d(-11.3757, -12.4802, 0),
OpenMesh::Vec3d(15.3167, 7.07601, 0),
OpenMesh::Vec3d(-3.82973, 10.8813, 0),
OpenMesh::Vec3d(-13.1636, 4.25514, 0),
			};
			for (int i = 0; i < N; i++) {
				OpenMesh::Vec3d start = square_vertices[i];
				OpenMesh::Vec3d end = square_vertices[(i + 1) % N];

				OpenMesh::Vec3d p1 = start;
				OpenMesh::Vec3d p4 = end;

				// Intermediate control points (simple linear interpolation for demonstration)
				OpenMesh::Vec3d p2 = p1 + (p4 - p1) / 3;
				OpenMesh::Vec3d p3 = p1 + (p4 - p1) * 2 / 3;

				curvecage2[i] = { p1, p2, p3, p4 };

			}
			//通过curvecage2计算cc_points;
			for (int i = 0; i < N; i++) {
				for (int j = 0; j < degree; j++) {
					CC_points.push_back(curvecage2[i][j]);
				}
			}
			LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\sheji.obj");

			Set_Texture_coord();//设置纹理

			Handle_points = { OpenMesh::Vec3d(-11.4889, -5.13169, 0),
OpenMesh::Vec3d(-11.3889, -5.13169, 0),
OpenMesh::Vec3d(-11.6778, 4.01504, 0),
OpenMesh::Vec3d(-11.819, 7.05966, 0),
OpenMesh::Vec3d(5.45578, 8.81271, 0),
OpenMesh::Vec3d(9.71575, -4.84286, 0),
OpenMesh::Vec3d(-3.57254, 9.21556, 0),
OpenMesh::Vec3d(7.79244, 7.60443, 0),
OpenMesh::Vec3d(0.916185, -1.13904, 0),
OpenMesh::Vec3d(-0.114238, -4.75641, 0),
OpenMesh::Vec3d(-4.67244, 4.62937, 0),
OpenMesh::Vec3d(-0.500745, 4.94373, 0),
			};
		}

		//octopus
		if (0) {
			CC_points = { //octopus
		 OpenMesh::Vec3d(8.57042, 3.297, 0),
		OpenMesh::Vec3d(5.09424, 1.93482, 0),
		OpenMesh::Vec3d(8.81644, -0.913078, 0),
		OpenMesh::Vec3d(6.50689, -3.68536, 0),
		OpenMesh::Vec3d(5.42654, -1.87831, 0),
		OpenMesh::Vec3d(4.92811, 1.19895, 0),
		OpenMesh::Vec3d(5.93302, 3.06514, 0),
		OpenMesh::Vec3d(6.39359, 2.98059, 0),
		OpenMesh::Vec3d(6.76971, 2.94039, 0),
		OpenMesh::Vec3d(7.1323, 3.39599, 0),
		OpenMesh::Vec3d(7.34691, 3.96736, 0),
		OpenMesh::Vec3d(7.36178, 4.91438, 0),
		OpenMesh::Vec3d(6.49071, 5.0889, 0),
		OpenMesh::Vec3d(7.77231, 9.87716, 0),
		OpenMesh::Vec3d(5.30888, 14.7788, 0),
		OpenMesh::Vec3d(-0.841746, 14.3125, 0),
		OpenMesh::Vec3d(-5.90767, 11.3197, 0),
		OpenMesh::Vec3d(-8.86451, 3.55846, 0),
		OpenMesh::Vec3d(-0.246632, 4.78125, 0),
		OpenMesh::Vec3d(1.06736, 1.00327, 0),
		OpenMesh::Vec3d(-4.23325, 0.219585, 0),
		OpenMesh::Vec3d(-8.03561, 3.02382, 0),
		OpenMesh::Vec3d(-8.08751, 2.08127, 0),
		OpenMesh::Vec3d(-7.52196, 0.833628, 0),
		OpenMesh::Vec3d(-6.06773, 0.106026, 0),
		OpenMesh::Vec3d(-7.90343, -1.09784, 0),
		OpenMesh::Vec3d(-9.28057, -2.77283, 0),
		OpenMesh::Vec3d(-7.6208, -5.78163, 0),
		OpenMesh::Vec3d(-8.57419, -6.68359, 0),
		OpenMesh::Vec3d(-8.68614, -8.01901, 0),
		OpenMesh::Vec3d(-8.06132, -10.9547, 0),
		OpenMesh::Vec3d(-6.74283, -6.93736, 0),
		OpenMesh::Vec3d(-4.59648, -5.33218, 0),
		OpenMesh::Vec3d(-2.05936, -4.13197, 0),
		OpenMesh::Vec3d(-3.09482, -7.04246, 0),
		OpenMesh::Vec3d(-9.21992, -12.7162, 0),
		OpenMesh::Vec3d(-2.27186, -13.953, 0),
		OpenMesh::Vec3d(-2.95275, -12.5256, 0),
		OpenMesh::Vec3d(-3.79382, -11.3406, 0),
		OpenMesh::Vec3d(-3.42902, -9.89676, 0),
		OpenMesh::Vec3d(-2.6323, -11.6362, 0),
		OpenMesh::Vec3d(-1.81066, -12.1583, 0),
		OpenMesh::Vec3d(-0.00107587, -12.4131, 0),
		OpenMesh::Vec3d(-2.69772, -8.66487, 0),
		OpenMesh::Vec3d(-1.78497, -7.37903, 0),
		OpenMesh::Vec3d(0.488619, -4.78304, 0),
		OpenMesh::Vec3d(-0.0659694, -6.98257, 0),
		OpenMesh::Vec3d(-0.438017, -8.1058, 0),
		OpenMesh::Vec3d(0.945469, -9.78723, 0),
		OpenMesh::Vec3d(1.71534, -8.54231, 0),
		OpenMesh::Vec3d(1.34671, -7.00428, 0),
		OpenMesh::Vec3d(1.89121, -5.32397, 0),
		OpenMesh::Vec3d(3.61222, -8.87285, 0),
		OpenMesh::Vec3d(2.05656, -8.95106, 0),
		OpenMesh::Vec3d(1.51134, -12.1472, 0),
		OpenMesh::Vec3d(7.13949, -10.1638, 0),
		OpenMesh::Vec3d(2.57694, -5.41496, 0),
		OpenMesh::Vec3d(4.12527, -0.841089, 0),
		OpenMesh::Vec3d(4.43461, -3.18152, 0),
		OpenMesh::Vec3d(5.09308, -5.72131, 0),
		OpenMesh::Vec3d(7.13664, -5.11346, 0),
		OpenMesh::Vec3d(10.4172, -2.70598, 0),
		OpenMesh::Vec3d(6.50459, 2.41615, 0),
		OpenMesh::Vec3d(9.27712, 2.26177, 0),
		OpenMesh::Vec3d(9.67284, 2.20834, 0),
		OpenMesh::Vec3d(9.37983, 3.08828, 0),
		};
			LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\octopus.obj");

			Set_Texture_coord();//设置纹理

			Handle_points = { OpenMesh::Vec3d(3.10872, 0.366967, 0),
OpenMesh::Vec3d(3.20872, 0.366967, 0),
OpenMesh::Vec3d(8.68032, 2.73857, 0),
OpenMesh::Vec3d(12.7786, -3.1469, 0),
OpenMesh::Vec3d(1.16814, 11.3657, 0),
OpenMesh::Vec3d(1.26814, 11.3657, 0),
OpenMesh::Vec3d(2.87207, -10.821, 0),
OpenMesh::Vec3d(6.29864, -9.76545, 0),
OpenMesh::Vec3d(-7.91994, -8.47114, 0),
OpenMesh::Vec3d(-10.6987, -9.23881, 0),
OpenMesh::Vec3d(-7.71686, -2.52394, 0),
OpenMesh::Vec3d(-10.4956, -3.29161, 0),
OpenMesh::Vec3d(-3.86662, -12.729, 0),
OpenMesh::Vec3d(-6.54942, -11.0337, 0),
OpenMesh::Vec3d(-1.14555, 7.00424, 0),
OpenMesh::Vec3d(-1.04555, 7.00424, 0),
OpenMesh::Vec3d(0.818252, -8.28072, 0),
OpenMesh::Vec3d(0.918252, -8.28072, 0),
OpenMesh::Vec3d(6.55718, -4.28616, 0),
OpenMesh::Vec3d(6.65718, -4.28616, 0),
			};

		}
		//poly octopus
		if (0) {
			std::vector<OpenMesh::Vec3d> square_vertices = { OpenMesh::Vec3d(-3.64311, -16.5925, 0),
OpenMesh::Vec3d(-2.18002, -12.2574, 0),
OpenMesh::Vec3d(-0.385926, -14.3912, 0),
OpenMesh::Vec3d(-0.196086, -6.4875, 0),
OpenMesh::Vec3d(0.0089644, -9.21506, 0),
OpenMesh::Vec3d(1.14853, -9.85564, 0),
OpenMesh::Vec3d(2.47479, -14.0728, 0),
OpenMesh::Vec3d(5.21456, -6.8191, 0),
OpenMesh::Vec3d(8.26414, -5.47943, 0),
OpenMesh::Vec3d(9.90246, 3.21374, 0),
OpenMesh::Vec3d(7.31046, 3.16547, 0),
OpenMesh::Vec3d(6.55989, -3.50544, 0),
OpenMesh::Vec3d(5.90752, 2.46454, 0),
OpenMesh::Vec3d(7.48071, 3.46206, 0),
OpenMesh::Vec3d(9.82861, 9.93103, 0),
OpenMesh::Vec3d(0.55821, 15.0266, 0),
OpenMesh::Vec3d(-8.44575, 8.29365, 0),
OpenMesh::Vec3d(-0.23566, 2.52598, 0),
OpenMesh::Vec3d(-8.67665, 2.88167, 0),
OpenMesh::Vec3d(-8.2569, -5.6261, 0),
OpenMesh::Vec3d(-8.89145, -10.3379, 0),
OpenMesh::Vec3d(-5.93367, -9.62478, 0),
			};
			int N = square_vertices.size();
			curvecage2.resize(N);
			for (int i = 0; i < N; i++) {
				OpenMesh::Vec3d start = square_vertices[i];
				OpenMesh::Vec3d end = square_vertices[(i + 1) % N];

				OpenMesh::Vec3d p1 = start;
				OpenMesh::Vec3d p4 = end;

				// Intermediate control points (simple linear interpolation for demonstration)
				OpenMesh::Vec3d p2 = p1 + (p4 - p1) / 3;
				OpenMesh::Vec3d p3 = p1 + (p4 - p1) * 2 / 3;

				curvecage2[i] = { p1, p2, p3, p4 };

			}
			//通过curvecage2计算cc_points;
			for (int i = 0; i < N; i++) {
				for (int j = 0; j < degree; j++) {
					CC_points.push_back(curvecage2[i][j]);
				}
			}
			LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\octopus.obj");

			Set_Texture_coord();//设置纹理

			Handle_points = { OpenMesh::Vec3d(3.10872, 0.366967, 0),
OpenMesh::Vec3d(3.20872, 0.366967, 0),
OpenMesh::Vec3d(8.68032, 2.73857, 0),
OpenMesh::Vec3d(12.7786, -3.1469, 0),
OpenMesh::Vec3d(1.16814, 11.3657, 0),
OpenMesh::Vec3d(1.26814, 11.3657, 0),
OpenMesh::Vec3d(2.87207, -10.821, 0),
OpenMesh::Vec3d(6.29864, -9.76545, 0),
OpenMesh::Vec3d(-7.91994, -8.47114, 0),
OpenMesh::Vec3d(-10.6987, -9.23881, 0),
OpenMesh::Vec3d(-7.71686, -2.52394, 0),
OpenMesh::Vec3d(-10.4956, -3.29161, 0),
OpenMesh::Vec3d(-3.86662, -12.729, 0),
OpenMesh::Vec3d(-6.54942, -11.0337, 0),
OpenMesh::Vec3d(-1.14555, 7.00424, 0),
OpenMesh::Vec3d(-1.04555, 7.00424, 0),
OpenMesh::Vec3d(0.818252, -8.28072, 0),
OpenMesh::Vec3d(0.918252, -8.28072, 0),
OpenMesh::Vec3d(6.55718, -4.28616, 0),
OpenMesh::Vec3d(6.65718, -4.28616, 0),
			};

		}
		if (0)//zimu_S
		{
			std::vector<OpenMesh::Vec3d> square_vertices = { OpenMesh::Vec3d(0.596266, -1.16511, 0),
	OpenMesh::Vec3d(-1.37608, -1.16152, 0),
	OpenMesh::Vec3d(-1.37802, -2.09268, 0),
	OpenMesh::Vec3d(2.72435, -2.06795, 0),
	OpenMesh::Vec3d(-0.671918, 1.48669, 0),
	OpenMesh::Vec3d(1.02929, 1.4972, 0),
	OpenMesh::Vec3d(1.02864, 2.28088, 0),
	OpenMesh::Vec3d(-3.07623, 2.24427, 0),
			};
			LoadMesh("S:/duwei/triangle/zimu_S.obj");
			Set_Texture_coord();//设置纹理
			int N = square_vertices.size();//circle 4
			curvecage2.resize(N);
			for (int i = 0; i < N; i++) {
				OpenMesh::Vec3d start = square_vertices[i];
				OpenMesh::Vec3d end = square_vertices[(i + 1) % N];

				OpenMesh::Vec3d p1 = start;
				OpenMesh::Vec3d p4 = end;

				// Intermediate control points (simple linear interpolation for demonstration)
				OpenMesh::Vec3d p2 = p1 + (p4 - p1) / 3;
				OpenMesh::Vec3d p3 = p1 + (p4 - p1) * 2 / 3;

				curvecage2[i] = { p1, p2, p3, p4 };

			}
			//通过curvecage2计算cc_points;
			for (int i = 0; i < N; i++) {
				for (int j = 0; j < degree; j++) {
					CC_points.push_back(curvecage2[i][j]);
				}
			}
			Handle_points = { OpenMesh::Vec3d(0.15181, 0.0204541, 0),
OpenMesh::Vec3d(0.25181, 0.0204541, 0),
OpenMesh::Vec3d(-0.70001, 1.74972, 0),
OpenMesh::Vec3d(-0.60001, 1.74972, 0),
OpenMesh::Vec3d(0.318581, 1.94975, 0),
OpenMesh::Vec3d(0.418581, 1.94975, 0),
OpenMesh::Vec3d(-1.02174, -1.65284, 0),
OpenMesh::Vec3d(-0.921744, -1.65284, 0),
OpenMesh::Vec3d(0.788045, -1.42688, 0),
OpenMesh::Vec3d(0.888045, -1.42688, 0),
OpenMesh::Vec3d(0.895046, -0.584618, 0),
OpenMesh::Vec3d(0.995046, -0.584618, 0),
OpenMesh::Vec3d(-0.114399, -1.79092, 0),
OpenMesh::Vec3d(-0.0143989, -1.79092, 0),
OpenMesh::Vec3d(-1.01368, 1.00402, 0),
OpenMesh::Vec3d(-0.913679, 1.00402, 0),
OpenMesh::Vec3d(-0.511667, 0.337893, 0),
OpenMesh::Vec3d(-0.411667, 0.337893, 0),
			};
		}
		//elephant
		if (0)//elephant
		{
			CC_points = { OpenMesh::Vec3d(-2.77448, 7.60594, 0),
OpenMesh::Vec3d(-6.76218, 10.3593, 0),
OpenMesh::Vec3d(-12.8974, 7.11545, 0),
OpenMesh::Vec3d(-12.3529, 3.30893, 0),
OpenMesh::Vec3d(-11.0687, -1.99194, 0),
OpenMesh::Vec3d(-14.3517, -3.29966, 0),
OpenMesh::Vec3d(-12.8025, -6.98694, 0),
OpenMesh::Vec3d(-10.9819, -6.07468, 0),
OpenMesh::Vec3d(-12.2449, -2.8801, 0),
OpenMesh::Vec3d(-11.3029, -0.166452, 0),
OpenMesh::Vec3d(-10.6833, -2.07562, 0),
OpenMesh::Vec3d(-11.2618, -4.53112, 0),
OpenMesh::Vec3d(-12.6503, -8.53826, 0),
OpenMesh::Vec3d(-10.7402, -9.39226, 0),
OpenMesh::Vec3d(-9.8436, -9.21843, 0),
OpenMesh::Vec3d(-9.65443, -5.03654, 0),
OpenMesh::Vec3d(-9.36511, -6.95065, 0),
OpenMesh::Vec3d(-10.6334, -9.05767, 0),
OpenMesh::Vec3d(-9.27078, -9.38309, 0),
OpenMesh::Vec3d(-5.17568, -9.48155, 0),
OpenMesh::Vec3d(-9.26313, -5.61169, 0),
OpenMesh::Vec3d(-6.49913, -2.69968, 0),
OpenMesh::Vec3d(-2.62301, -2.881, 0),
OpenMesh::Vec3d(-4.27285, -5.09169, 0),
OpenMesh::Vec3d(-5.71106, -8.70974, 0),
OpenMesh::Vec3d(-2.4367, -10.6219, 0),
OpenMesh::Vec3d(-1.32623, -6.03012, 0),
OpenMesh::Vec3d(0.258683, -2.18621, 0),
OpenMesh::Vec3d(0.94186, -2.47048, 0),
OpenMesh::Vec3d(-1.09657, -7.342, 0),
OpenMesh::Vec3d(1.63086, -9.74263, 0),
OpenMesh::Vec3d(6.98954, -8.54072, 0),
OpenMesh::Vec3d(1.44824, 0.353638, 0),
OpenMesh::Vec3d(7.90863, 0.953709, 0),
OpenMesh::Vec3d(11.0137, -2.6516, 0),
OpenMesh::Vec3d(4.35517, -7.81187, 0),
OpenMesh::Vec3d(9.51941, -9.28153, 0),
OpenMesh::Vec3d(13.7157, -5.16768, 0),
OpenMesh::Vec3d(14.7183, 1.01813, 0),
OpenMesh::Vec3d(8.60708, 7.62994, 0),
OpenMesh::Vec3d(4.04668, 10.208, 0),
OpenMesh::Vec3d(1.29215, 9.48121, 0),
			};
			LoadMesh("E:\\dgp2021\\dgp6\\newproject_BIHC\\project_BiHC\\mesh\\elephant.obj");
			Set_Texture_coord();//设置纹理
			Handle_points = { OpenMesh::Vec3d(-11.1251, -7.91411, 0),
OpenMesh::Vec3d(-13.1131, -7.62808, 0),
OpenMesh::Vec3d(-1.84128, 0.554101, 0),
OpenMesh::Vec3d(-1.74128, 0.554101, 0),
OpenMesh::Vec3d(6.89449, 5.59095, 0),
OpenMesh::Vec3d(6.99449, 5.59095, 0),
OpenMesh::Vec3d(9.54007, -8.0228, 0),
OpenMesh::Vec3d(17.649, -4.04694, 0),
OpenMesh::Vec3d(2.09236, -8.05713, 0),
OpenMesh::Vec3d(7.11213, -6.25512, 0),
OpenMesh::Vec3d(-8.75143, -8.54635, 0),
OpenMesh::Vec3d(-6.24875, -8.57495, 0),
OpenMesh::Vec3d(-3.83712, -7.85053, 0),
OpenMesh::Vec3d(-3.73712, -7.85053, 0),
OpenMesh::Vec3d(-8.4863, 5.92236, 0),
OpenMesh::Vec3d(-8.3863, 5.92236, 0),
OpenMesh::Vec3d(-12.5222, -4.68914, 0),
OpenMesh::Vec3d(-15.0251, -2.22925, 0),
OpenMesh::Vec3d(-10.1084, 2.33689, 0),
OpenMesh::Vec3d(-10.0084, 2.33689, 0),
			};
		}
		//poly elephant
		if (0)
		{
			std::vector<OpenMesh::Vec3d> square_vertices = { OpenMesh::Vec3d(-13.9394, -8.55341, 0),
OpenMesh::Vec3d(-7.51717, -9.44683, 0),
OpenMesh::Vec3d(-6.48065, -2.92187, 0),
OpenMesh::Vec3d(-4.55527, -10.4474, 0),
OpenMesh::Vec3d(0.828162, -3.82069, 0),
OpenMesh::Vec3d(0.618974, -9.23841, 0),
OpenMesh::Vec3d(3.4762, -9.05993, 0),
OpenMesh::Vec3d(8.52535, 0.577435, 0),
OpenMesh::Vec3d(7.69601, -8.5859, 0),
OpenMesh::Vec3d(9.71487, -9.77693, 0),
OpenMesh::Vec3d(13.571, -1.24525, 0),
OpenMesh::Vec3d(8.98221, 7.81831, 0),
OpenMesh::Vec3d(0.396896, 9.48434, 0),
OpenMesh::Vec3d(-11.3877, 7.499, 0),
			};
			LoadMesh("E:\\dgp2021\\dgp6\\newproject_BIHC\\project_BiHC\\mesh\\elephant.obj");
			Set_Texture_coord();//设置纹理
			int N = square_vertices.size();
			curvecage2.resize(N);
			for (int i = 0; i < N; i++) {
				OpenMesh::Vec3d start = square_vertices[i];
				OpenMesh::Vec3d end = square_vertices[(i + 1) % N];

				OpenMesh::Vec3d p1 = start;
				OpenMesh::Vec3d p4 = end;

				// Intermediate control points (simple linear interpolation for demonstration)
				OpenMesh::Vec3d p2 = p1 + (p4 - p1) / 3;
				OpenMesh::Vec3d p3 = p1 + (p4 - p1) * 2 / 3;

				curvecage2[i] = { p1, p2, p3, p4 };

			}
			//通过curvecage2计算cc_points;
			for (int i = 0; i < N; i++) {
				for (int j = 0; j < degree; j++) {
					CC_points.push_back(curvecage2[i][j]);
				}
			}
			Handle_points = { OpenMesh::Vec3d(-11.1251, -7.91411, 0),
				OpenMesh::Vec3d(-13.1131, -7.62808, 0),
				OpenMesh::Vec3d(-1.84128, 0.554101, 0),
				OpenMesh::Vec3d(-1.74128, 0.554101, 0),
				OpenMesh::Vec3d(6.89449, 5.59095, 0),
				OpenMesh::Vec3d(6.99449, 5.59095, 0),
				OpenMesh::Vec3d(9.54007, -8.0228, 0),
				OpenMesh::Vec3d(17.649, -4.04694, 0),
				OpenMesh::Vec3d(2.09236, -8.05713, 0),
				OpenMesh::Vec3d(7.11213, -6.25512, 0),
				OpenMesh::Vec3d(-8.75143, -8.54635, 0),
				OpenMesh::Vec3d(-6.24875, -8.57495, 0),
				OpenMesh::Vec3d(-3.83712, -7.85053, 0),
				OpenMesh::Vec3d(-3.73712, -7.85053, 0),
				OpenMesh::Vec3d(-8.4863, 5.92236, 0),
				OpenMesh::Vec3d(-8.3863, 5.92236, 0),
				OpenMesh::Vec3d(-12.5222, -4.68914, 0),
				OpenMesh::Vec3d(-15.0251, -2.22925, 0),
				OpenMesh::Vec3d(-10.1084, 2.33689, 0),
				OpenMesh::Vec3d(-10.0084, 2.33689, 0),
			};
		}
		//rainbow
		if (0) {
			//rainbow
			if (1) {
				CC_points = { OpenMesh::Vec3d(-5.77366, -0.928836, 0),
	OpenMesh::Vec3d(-3.65098, 4.19543, 0),
	OpenMesh::Vec3d(3.83891, 7.69656, 0),
	OpenMesh::Vec3d(9.74542, 1.55503, 0),
	OpenMesh::Vec3d(9.71409, 1.85648, 0),
	OpenMesh::Vec3d(9.72213, 2.09149, 0),
	OpenMesh::Vec3d(9.75057, 2.34935, 0),
	OpenMesh::Vec3d(3.96906, 7.95307, 0),
	OpenMesh::Vec3d(-3.6725, 5.20192, 0),
	OpenMesh::Vec3d(-6.41423, -0.846814, 0),
	OpenMesh::Vec3d(-3.88359, 5.13772, 0),
	OpenMesh::Vec3d(3.65582, 8.02333, 0),
	OpenMesh::Vec3d(9.73233, 2.49004, 0),
	OpenMesh::Vec3d(9.72816, 2.82964, 0),
	OpenMesh::Vec3d(9.73162, 3.06732, 0),
	OpenMesh::Vec3d(9.70073, 3.27175, 0),
	OpenMesh::Vec3d(5.00196, 7.83177, 0),
	OpenMesh::Vec3d(-5.0881, 7.15129, 0),
	OpenMesh::Vec3d(-7.42613, -2.25787, 0),
	OpenMesh::Vec3d(-8.65612, -1.67216, 0),
	OpenMesh::Vec3d(-13.1998, -3.81923, 0),
	OpenMesh::Vec3d(-6.02623, -6.5032, 0),
	OpenMesh::Vec3d(-2.88592, -5.16367, 0),
	OpenMesh::Vec3d(-0.978079, -2.18366, 0),
	OpenMesh::Vec3d(-4.02564, -1.5895, 0),
	OpenMesh::Vec3d(-0.942283, 4.27499, 0),
	OpenMesh::Vec3d(6.25598, 4.66494, 0),
	OpenMesh::Vec3d(9.6561, -1.77424, 0),
	OpenMesh::Vec3d(9.67105, -1.42373, 0),
	OpenMesh::Vec3d(9.6996, -1.06183, 0),
	OpenMesh::Vec3d(9.74062, -0.738046, 0),
	OpenMesh::Vec3d(6.13106, 5.28046, 0),
	OpenMesh::Vec3d(-1.1495, 4.66369, 0),
	OpenMesh::Vec3d(-4.38251, -0.855424, 0),
	OpenMesh::Vec3d(-1.41844, 4.78383, 0),
	OpenMesh::Vec3d(6.2934, 5.23497, 0),
	OpenMesh::Vec3d(9.69998, -0.60418, 0),
	OpenMesh::Vec3d(9.70243, -0.18479, 0),
	OpenMesh::Vec3d(9.72684, 0.11423, 0),
	OpenMesh::Vec3d(9.75569, 0.418196, 0),
	OpenMesh::Vec3d(4.99936, 6.54761, 0),
	OpenMesh::Vec3d(-2.13908, 4.46348, 0),
	OpenMesh::Vec3d(-5.0399, -0.745585, 0),
	OpenMesh::Vec3d(-2.61174, 4.15792, 0),
	OpenMesh::Vec3d(4.66582, 6.75996, 0),
	OpenMesh::Vec3d(9.68352, 0.652446, 0),
	OpenMesh::Vec3d(9.73424, 0.909529, 0),
	OpenMesh::Vec3d(9.75751, 1.17138, 0),
	OpenMesh::Vec3d(9.79496, 1.37106, 0),
	OpenMesh::Vec3d(4.4877, 7.31385, 0),
	OpenMesh::Vec3d(-3.19225, 4.7506, 0),
				};
				LoadMesh("E:\\dgp2021\\dgp6\\newproject_BIHC\\project_BiHC\\mesh\\rainbow.obj");
				Set_Texture_coord();//设置纹理
				Handle_points = { OpenMesh::Vec3d(-6.11148, -5.54871, 0),
OpenMesh::Vec3d(-6.01148, -5.54871, 0),
OpenMesh::Vec3d(9.39437, 1.42827, 0),
OpenMesh::Vec3d(6.57567, -6.37755, 0),
OpenMesh::Vec3d(9.33702, 3.22555, 0),
OpenMesh::Vec3d(12.401, -1.6842, 0),
OpenMesh::Vec3d(9.33438, 0.487494, 0),
OpenMesh::Vec3d(2.85034, -7.45408, 0),
OpenMesh::Vec3d(9.39424, -0.703825, 0),
OpenMesh::Vec3d(-3.90009, -8.75852, 0),
OpenMesh::Vec3d(-3.91779, -3.09565, 0),
OpenMesh::Vec3d(-3.81779, -3.09565, 0),
OpenMesh::Vec3d(9.40397, 2.30526, 0),
OpenMesh::Vec3d(9.45872, -4.68604, 0),
OpenMesh::Vec3d(-5.99235, -2.02229, 0),
OpenMesh::Vec3d(-5.89235, -2.02229, 0),
OpenMesh::Vec3d(-8.58844, -3.53215, 0),
OpenMesh::Vec3d(-8.48844, -3.53215, 0),
				};
			}
		}
		//car
		if (0) {
			CC_points = {//car
			OpenMesh::Vec3d(17.0636, -3.96522, 0),
		OpenMesh::Vec3d(17.0602, -0.865747, 0),
		OpenMesh::Vec3d(16.9603, 3.13988, 0),
		OpenMesh::Vec3d(13.1047, 2.52286, 0),
		OpenMesh::Vec3d(11.3294, 9.4102, 0),
		OpenMesh::Vec3d(0.0590485, 6.34927, 0),
		OpenMesh::Vec3d(-2.5501, 2.84747, 0),
		OpenMesh::Vec3d(-12.414, 2.59491, 0),
		OpenMesh::Vec3d(-16.5235, 1.10555, 0),
		OpenMesh::Vec3d(-17.0582, -3.72901, 0),
		OpenMesh::Vec3d(-4.71722, -8.88474, 0),
		OpenMesh::Vec3d(6.7265, -7.13234, 0),
		};
			LoadMesh("E:\\dgp2021\\dgp6\\newproject_BIHC\\project_BiHC\\mesh\\car.obj");
			Set_Texture_coord();//设置纹理
			Handle_points = { OpenMesh::Vec3d(-13.3874, -0.539706, 0),
OpenMesh::Vec3d(-13.2874, -0.539706, 0),
OpenMesh::Vec3d(-1.84128, 0.554101, 0),
OpenMesh::Vec3d(-1.74128, 0.554101, 0),
OpenMesh::Vec3d(6.89449, 5.59095, 0),
OpenMesh::Vec3d(6.99449, 5.59095, 0),
OpenMesh::Vec3d(15.0132, -1.23396, 0),
OpenMesh::Vec3d(15.1132, -1.23396, 0),
			};
		}
		CC_mesh = createMeshFromCurveCage(CC_points);
		curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
		auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
		for (auto vh : CC_mesh.vertices())
		{
			CagevertexState[vh] = NotSelected;
		}

		useCauchy = true;
		calculate_cauchy_weight323();
		calculate_D2cauchy_weight_CB323();
		//calculate_cauchy_weight123();//计算3次cage cauchy权重
		//
		//calculate_D2cauchy_weight_CB123();//计算了cage边界顶点上的二阶导的权重矩阵
		
		for (size_t i = 1; i < Handle_points.size(); i += 2)
		{//用于拖动点
			Handle_points[i] = Handle_points[i - 1] + OpenMesh::Vec3d(1.0, 0.0, 0.0);
		}
		
		partion_handles(Handle_points, deform_cps, deform_cps_t);
		//calculate_cauchy_weight323(deform_cps);

		Handle_mesh = createMeshFromCurveCage(Handle_points);
		auto HandlevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(Handle_mesh, "vertexState");
		for (auto vh : Handle_mesh.vertices())
		{
			HandlevertexState[vh] = NotSelected;
		}

		update();
		return;
		
	}
	if (degree==2&&!useHandle)//if mode
	{
		
		int N = 4;//球 4
		curvecage2.resize(N);
		std::vector<OpenMesh::Vec3d> square_vertices = {
			OpenMesh::Vec3d(ptMax[0]+1, ptMin[1]-1, 0),
			ptMax,
			OpenMesh::Vec3d(ptMin[0]-1, ptMax[1]+1, 0),
			ptMin
		};
		int segments_per_side = N / 4;
		for (int i = 0; i < 4; i++) {
			OpenMesh::Vec3d start = square_vertices[i];
			OpenMesh::Vec3d end = square_vertices[(i + 1) % 4];

			for (int j = 0; j < segments_per_side; j++) {
				double t1 = (double)j / segments_per_side;
				double t2 = (double)(j + 1) / segments_per_side;

				// Compute the coordinates for the control points
				OpenMesh::Vec3d p1 = start + (end - start) * t1;
				OpenMesh::Vec3d p4 = start + (end - start) * t2;

				// Intermediate control points (simple linear interpolation for demonstration)
				OpenMesh::Vec3d p2 = p1 + (p4 - p1) *0.3;
				OpenMesh::Vec3d p3 = p1 + (p4 - p1) * 0.6;

				curvecage2[i * segments_per_side + j] = { p1, p2,  p4 };
			}
		}
		//通过curvecage2计算cc_points;
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < degree; j++) {
				CC_points.push_back(curvecage2[i][j]);
			}
		}

		auto filename = "S:/duwei/triangle/test.obj";
		bool read_OK = MeshTools::ReadMesh(mesh, filename);
		mesh_beifen = mesh;
		double rad_R = 12.1;
		double rad_r = 6.9;
		OpenMesh::Vec3d center(rad_R, 0, 0);
		for (int v_id = 0; v_id < mesh.n_vertices(); v_id++)
		{
			auto vh = mesh.vertex_handle(v_id);
			OpenMesh::Vec3d from_center = mesh.point(vh) - center;
			double x = (from_center.length() - rad_r) / (rad_R - rad_r);
			double y = std::asin(from_center[1] / from_center.length()) / (M_PI / 2);
			OpenMesh::Vec3d new_point3(x, y, 0);
			mesh.set_point(vh, new_point3);
		}

		Set_Texture_coord();//设置纹理
		MeshTools::AssignPoints(mesh, mesh_beifen);

		use_rational = true;
		OpenMesh::Vec3d right{ 0.1,0,0 };
		OpenMesh::Vec3d up{ 0,0.1,0 };
		OpenMesh::Vec3d down{ 0,-0.1,0 };
		OpenMesh::Vec3d left{ -0.05,0,0 };
		CC_points = {
			OpenMesh::Vec3d(rad_R, rad_R, 1)+left/*+up*10*/,
			OpenMesh::Vec3d(0, rad_R, sqrt(2)/2)+left,
			OpenMesh::Vec3d(0, 0, 1)+left/*+left*10*/,
			OpenMesh::Vec3d(0, -rad_R, sqrt(2) / 2)+left /*+ left * 10*/,//1
			OpenMesh::Vec3d(rad_R, -rad_R, 1)+left/*+down*10*/,
			OpenMesh::Vec3d(rad_R, ( - rad_R - rad_r)/2, sqrt(2) / 2)+left,//1
			OpenMesh::Vec3d(rad_R, (-rad_r - rad_r) / 2, 1)+left/*+right*10*/,
			OpenMesh::Vec3d(rad_R-rad_r, -rad_r, sqrt(2) / 2)+left,
			OpenMesh::Vec3d(rad_R - rad_r, 0, 1)+left/*+right*10*/,
			OpenMesh::Vec3d(rad_R - rad_r, rad_r, sqrt(2) / 2)+left,
			OpenMesh::Vec3d(rad_R , rad_r, 1)+left/*+right*10*/,
			OpenMesh::Vec3d(rad_R , (rad_R + rad_r)/2, sqrt(2) / 2)+left,//1
		};
		CC_mesh = createMeshFromCurveCage(CC_points);
		curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
		/*int edge_samples = 30;
		Eigen::Matrix2Xd polygon(2, edge_samples*curvecage2.size());
		Eigen::Matrix2Xi polygon_E(2, edge_samples* curvecage2.size());
		
		for (int i = 0; i < curvecage2.size(); i++)
		{
			BezierCurve c_temp(curvecage2[i], true);
			for (int j = 0; j < edge_samples; j++) {
				double para = double(j) / edge_samples;
				auto point = c_temp.Evaluate(para);
				polygon.col(i*edge_samples+j) << point[0], point[1];
				polygon_E.col(i* edge_samples + j) << i * edge_samples + j, (i* edge_samples + j+1)%(curvecage2.size()*edge_samples);
			}
		}
		triangulate(polygon, polygon_E, 0.1, mesh);

		dprint(mesh.n_vertices(), mesh.n_faces());
		OpenMesh::IO::write_mesh(mesh, "S:/duwei/triangle/test.obj");*/
		
		/*for (int v_id = 0; v_id < mesh.n_vertices(); v_id++)
		{
			auto vh = mesh.vertex_handle(v_id);
			OpenMesh::Vec3d new_point3 = mesh.point(vh) * 0.99;
			mesh.set_point(vh, new_point3);
		}*/
		//human
		{
			//CC_points = { //human
			//OpenMesh::Vec3d(2.2434, -4.09831, 0),
   //         OpenMesh::Vec3d(1.33897, -1.2763, 0),
   //         OpenMesh::Vec3d(0.168209, 0.44022, 0),
   //         OpenMesh::Vec3d(1.4294, -0.288948, 0),
   //         OpenMesh::Vec3d(2.68837, -0.575573, 0),
   //         OpenMesh::Vec3d(3.60324, 1.3499, 0),
   //         OpenMesh::Vec3d(5.97756, 1.52252, 0),
   //         OpenMesh::Vec3d(6.02737, 3.22644, 0),
   //         OpenMesh::Vec3d(5.81575, 4.86821, 0),
   //         OpenMesh::Vec3d(4.28753, 5.19497, 0),
   //         OpenMesh::Vec3d(3.18159, 4.91388, 0),
   //         OpenMesh::Vec3d(2.91693, 3.88495, 0),
   //         OpenMesh::Vec3d(3.06766, 3.08017, 0),
   //         OpenMesh::Vec3d(1.80562, 2.91953, 0),
   //         OpenMesh::Vec3d(0.929425, 1.2952, 0),
   //         OpenMesh::Vec3d(0.312689, 3.28967, 0),
   //         OpenMesh::Vec3d(-0.901575, 4.85807, 0),
   //         OpenMesh::Vec3d(-1.23977, 3.5368, 0),
   //         OpenMesh::Vec3d(-1.9027, 4.60764, 0),
   //         OpenMesh::Vec3d(-2.60159, 4.08557, 0),
   //         OpenMesh::Vec3d(-3.67377, 2.94282, 0),
   //         OpenMesh::Vec3d(-4.19734, 1.3431, 0),
   //         OpenMesh::Vec3d(-2.67894, 0.569752, 0),
   //         OpenMesh::Vec3d(-4.59146, 0.273326, 0),
   //         OpenMesh::Vec3d(-5.02472, -2.5631, 0),
   //         OpenMesh::Vec3d(-3.32428, -1.2692, 0),
   //         OpenMesh::Vec3d(-2.25433, -1.02231, 0),
   //         OpenMesh::Vec3d(-2.9142, -1.57256, 0),
   //         OpenMesh::Vec3d(-3.11938, -1.99522, 0),
   //         OpenMesh::Vec3d(-2.32945, -2.77795, 0),
   //         OpenMesh::Vec3d(-2.39632, -3.96978, 0),
   //         OpenMesh::Vec3d(-0.151571, -4.57271, 0),
			//};
			//LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\human.obj");
		}
		
		CC_mesh = createMeshFromCurveCage(CC_points);
		curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
		auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
		for (auto vh : CC_mesh.vertices())
		{
			CagevertexState[vh] = NotSelected;
		}
		useCauchy = true;
		calculate_cauchy_weight222_rational();;//计算2次cage到2次控制点的权重

		auto vertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(mesh, "vertexState");
		for (auto vh : mesh.vertices())
		{
			vertexState[vh] = NotSelected;
		}
		

		Mesh deformedMesh;
		deformedMesh.assign(mesh);
		deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
		MeshTools::AssignPoints(mesh, deformedMesh);
		UpdateMesh();
		update();
		//calculate_cauchy_weight222();//计算2次cage cauchy权重
		//calculate_D2cauchy_weight222();//计算了边界顶点上的二阶导的权重矩阵
		//calculate_D2cauchy_weight_CB222();//计算了cage边界顶点上的二阶导的权重矩阵
		

		/*deform_cps = {
	std::complex<double>(-2, -2),
	std::complex<double>(2, -2),
	std::complex<double>(2, 2),
	std::complex<double>(-2, 2)
		};
		deform_cps_t = {
	std::complex<double>(-2, -2),
	std::complex<double>(2, -2),
	std::complex<double>(2, 2),
	std::complex<double>(-2, 2)
		};*/
		/*deform_cps_t = {
	std::complex<double>(-3, -3),
	std::complex<double>(3, -3),
	std::complex<double>(3, 3),
	std::complex<double>(-3, 3)
		};*/
		/*deform_cps = {
	std::complex<double>(-1.5, -2.3),
	std::complex<double>(-4.49133, -1.61649),
	std::complex<double>(4, 3),
	std::complex<double>(-1, 2.3)
		};
		deform_cps_t = {
	std::complex<double>(-1.51, -2.31),
	std::complex<double>(-4.92462, -0.43723),
	std::complex<double>(1, 3),
	std::complex<double>(-1.1, 2.31)
		};
		for (int i = 0; i < deform_cps.size(); i++) {
			Handle_points.emplace_back(deform_cps[i].real(), deform_cps[i].imag(), 0.0);
			Handle_points.emplace_back(deform_cps_t[i].real(), deform_cps_t[i].imag(), 0.0);
		}
		
		Handle_mesh = createMeshFromCurveCage(Handle_points);
		auto HandlevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(Handle_mesh, "vertexState");
		for (auto vh : Handle_mesh.vertices())
		{
			HandlevertexState[vh] = NotSelected;
		}*/
		//deform_cps_t = deform_cps;
	}
	else if (degree == 3) {

		int N = 4;//deer16球4，giraffe8,tower4,xiyi8,yu4,kuzi 8,car 4,tuzi 8.daizi 4,fish12,choufish12,circle 8,human 16,flower12,octopus16,sheji 4
		curvecage2.resize(N);

		// 定义正方形的四个顶点
		std::vector<OpenMesh::Vec3d> square_vertices = {
			OpenMesh::Vec3d(2, -2, 0),
			OpenMesh::Vec3d(2, 2, 0),
			OpenMesh::Vec3d(-2, 2, 0),
			OpenMesh::Vec3d(-2, -2, 0)
		};
		int segments_per_side = N / 4;
		for (int i = 0; i < 4; i++) {
			OpenMesh::Vec3d start = square_vertices[i];
			OpenMesh::Vec3d end = square_vertices[(i + 1) % 4];

			for (int j = 0; j < segments_per_side; j++) {
				double t1 = (double)j / segments_per_side;
				double t2 = (double)(j + 1) / segments_per_side;

				// Compute the coordinates for the control points
				OpenMesh::Vec3d p1 = start + (end - start) * t1;
				OpenMesh::Vec3d p4 = start + (end - start) * t2;

				// Intermediate control points (simple linear interpolation for demonstration)
				OpenMesh::Vec3d p2 = p1 + (p4 - p1) / 3;
				OpenMesh::Vec3d p3 = p1 + (p4 - p1) * 2 / 3;

				curvecage2[i * segments_per_side + j] = { p1, p2, p3, p4 };
			}
		}
		//通过curvecage2计算cc_points;
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < degree; j++) {
				CC_points.push_back(curvecage2[i][j]);
			}
		}
		//		CC_points = { //deer
		//			OpenMesh::Vec3d(4.5276, -10.0723, 0),
		//OpenMesh::Vec3d(4.89459, -10.0739, 0),
		//OpenMesh::Vec3d(5.18646, -10.0632, 0),
		//OpenMesh::Vec3d(5.55932, -10.0582, 0),
		//OpenMesh::Vec3d(6.25252, -6.75231, 0),
		//OpenMesh::Vec3d(6.71007, -5.29668, 0),
		//OpenMesh::Vec3d(6.70587, -3.83298, 0),
		//OpenMesh::Vec3d(5.83477, -2.3301, 0),
		//OpenMesh::Vec3d(7.05116, -0.928495, 0),
		//OpenMesh::Vec3d(6.61916, 0.630525, 0),
		//OpenMesh::Vec3d(8.02456, 2.09566, 0),
		//OpenMesh::Vec3d(8.65167, 3.70863, 0),
		//OpenMesh::Vec3d(6.40582, 5.04416, 0),
		//OpenMesh::Vec3d(6.37169, 3.87665, 0),
		//OpenMesh::Vec3d(5.80833, 2.98216, 0),
		//OpenMesh::Vec3d(5.62158, 2.09523, 0),
		//OpenMesh::Vec3d(3.23511, 2.54016, 0),
		//OpenMesh::Vec3d(0.750374, 1.38221, 0),
		//OpenMesh::Vec3d(-1.69483, 2.49143, 0),
		//OpenMesh::Vec3d(-3.65702, 4.17105, 0),
		//OpenMesh::Vec3d(-2.17201, 6.0254, 0),
		//OpenMesh::Vec3d(-3.05934, 7.31317, 0),
		//OpenMesh::Vec3d(-1.89982, 8.15725, 0),
		//OpenMesh::Vec3d(-1.63298, 9.67336, 0),
		//OpenMesh::Vec3d(-2.82579, 10.398, 0),
		//OpenMesh::Vec3d(-3.92575, 10.5965, 0),
		//OpenMesh::Vec3d(-2.76592, 8.26476, 0),
		//OpenMesh::Vec3d(-5.78046, 7.07922, 0),
		//OpenMesh::Vec3d(-6.48863, 6.34431, 0),
		//OpenMesh::Vec3d(-5.30909, 5.86309, 0),
		//OpenMesh::Vec3d(-7.14945, 4.31455, 0),
		//OpenMesh::Vec3d(-6.72589, 3.45316, 0),
		//OpenMesh::Vec3d(-5.35703, 4.33777, 0),
		//OpenMesh::Vec3d(-4.45691, 4.19383, 0),
		//OpenMesh::Vec3d(-3.65641, 2.89317, 0),
		//OpenMesh::Vec3d(-4.13472, -0.366618, 0),
		//OpenMesh::Vec3d(-3.00663, -1.36788, 0),
		//OpenMesh::Vec3d(-3.10867, -2.51138, 0),
		//OpenMesh::Vec3d(-2.47899, -3.00126, 0),
		//OpenMesh::Vec3d(-2.19824, -3.3226, 0),
		//OpenMesh::Vec3d(-1.97104, -5.31759, 0),
		//OpenMesh::Vec3d(-1.18862, -7.33088, 0),
		//OpenMesh::Vec3d(-2.64391, -10.14, 0),
		//OpenMesh::Vec3d(-2.4061, -10.1295, 0),
		//OpenMesh::Vec3d(-2.13911, -10.1257, 0),
		//OpenMesh::Vec3d(-1.8048, -10.1125, 0),
		//OpenMesh::Vec3d(-1.04107, -7.68947, 0),
		//OpenMesh::Vec3d(-1.53657, -5.56524, 0),
		//OpenMesh::Vec3d(-0.549384, -3.05351, 0),
		//OpenMesh::Vec3d(0.598589, -3.14832, 0),
		//OpenMesh::Vec3d(1.97528, -3.33699, 0),
		//OpenMesh::Vec3d(3.40852, -2.90979, 0),
		//OpenMesh::Vec3d(4.44002, -4.23804, 0),
		//OpenMesh::Vec3d(6.07989, -4.12357, 0),
		//OpenMesh::Vec3d(5.53946, -7.39734, 0),
		//OpenMesh::Vec3d(5.59344, -8.20186, 0),
		//OpenMesh::Vec3d(4.89491, -9.35694, 0),
		//		};



		//		CC_points = {//ball
		//			OpenMesh::Vec3d(4.77039, -5.28648, 0),
		//OpenMesh::Vec3d(7.50588, -2.64831, 0),
		//OpenMesh::Vec3d(8.28221, 1.94099, 0),
		//OpenMesh::Vec3d(4.89974, 5.07107, 0),
		//OpenMesh::Vec3d(1.63539, 8.05301, 0),
		//OpenMesh::Vec3d(-3.23734, 7.6858, 0),
		//OpenMesh::Vec3d(-5.78844, 4.26243, 0),
		//OpenMesh::Vec3d(-7.71271, 1.69334, 0),
		//OpenMesh::Vec3d(-7.84599, -2.21456, 0),
		//OpenMesh::Vec3d(-4.89242, -5.17084, 0),
		//OpenMesh::Vec3d(-1.80051, -8.01358, 0),
		//OpenMesh::Vec3d(2.59902, -7.54285, 0),
		//		};

		//		CC_points = {//giraffe
		//		OpenMesh::Vec3d(4.26544, -2.08319, 0),
		//OpenMesh::Vec3d(2.14808, -1.76166, 0),
		//OpenMesh::Vec3d(1.05683, 0.58523, 0),
		//OpenMesh::Vec3d(-0.959219, 1.60384, 0),
		//OpenMesh::Vec3d(-2.08942, 6.26007, 0),
		//OpenMesh::Vec3d(1.37963, 11.5202, 0),
		//OpenMesh::Vec3d(5.01997, 9.59617, 0),
		//OpenMesh::Vec3d(5.45668, 12.4244, 0),
		//OpenMesh::Vec3d(2.73499, 14.4063, 0),
		//OpenMesh::Vec3d(0.408011, 13.9141, 0),
		//OpenMesh::Vec3d(-2.38072, 10.0441, 0),
		//OpenMesh::Vec3d(-4.10297, 7.24421, 0),
		//OpenMesh::Vec3d(-4.30619, 1.46692, 0),
		//OpenMesh::Vec3d(-5.6163, -8.3802, 0),
		//OpenMesh::Vec3d(-7.78844, -18.0231, 0),
		//OpenMesh::Vec3d(2.65463, -13.4286, 0),
		//OpenMesh::Vec3d(0.741755, -4.48237, 0),
		//OpenMesh::Vec3d(2.73214, -4.76554, 0),
		//OpenMesh::Vec3d(3.64475, -3.15402, 0),
		//OpenMesh::Vec3d(8.02143, -2.49543, 0),
		//OpenMesh::Vec3d(4.51096, -0.319015, 0),
		//OpenMesh::Vec3d(4.58592, 2.2061, 0),
		//OpenMesh::Vec3d(1.09773, 0.39865, 0),
		//OpenMesh::Vec3d(5.22416, -1.9387, 0),
		//		};

		//CC_points = { //paris tower
		//	OpenMesh::Vec3d(2.21312, -3.64502, 0),
		//OpenMesh::Vec3d(0.0729413, -1.26159, 0),
		//OpenMesh::Vec3d(0.71968, 2.04631, 0),
		//OpenMesh::Vec3d(-0.00294265, 4.30579, 0),
		//OpenMesh::Vec3d(-0.533977, 2.06356, 0),
		//OpenMesh::Vec3d(0.020478, -1.26554, 0),
		//OpenMesh::Vec3d(-2.13172, -3.62273, 0),
		//OpenMesh::Vec3d(-1.5717, -3.65431, 0),
		//OpenMesh::Vec3d(-0.789005, -3.66778, 0),
		//OpenMesh::Vec3d(-0.017268, -3.66608, 0),
		//OpenMesh::Vec3d(0.997374, -3.65183, 0),
		//OpenMesh::Vec3d(1.73898, -3.63311, 0),
		//};

		//CC_points = { //xiyi
		//	
		//OpenMesh::Vec3d(4.87927, 0.893929, 0),
		//OpenMesh::Vec3d(5.09543, -0.452398, 0),
		//OpenMesh::Vec3d(2.58026, 0.369127, 0),
		//OpenMesh::Vec3d(0.899758, 1.92868, 0),
		//OpenMesh::Vec3d(-6.36326, 3.14212, 0),
		//OpenMesh::Vec3d(-6.99906, 0.160185, 0),
		//OpenMesh::Vec3d(-3.73234, -0.87026, 0),
		//OpenMesh::Vec3d(-4.44834, -2.77133, 0),
		//OpenMesh::Vec3d(-1.61845, -2.46282, 0),
		//OpenMesh::Vec3d(1.3063, -2.28422, 0),
		//OpenMesh::Vec3d(7.03627, -1.80929, 0),
		//OpenMesh::Vec3d(5.87444, 2.51706, 0),
		//OpenMesh::Vec3d(4.08634, 1.48513, 0),
		//OpenMesh::Vec3d(3.23814, 0.190855, 0),
		//OpenMesh::Vec3d(4.99338, 0.133408, 0),
		//OpenMesh::Vec3d(4.78922, 0.868629, 0),
		//OpenMesh::Vec3d(4.60864, 1.23347, 0),
		//OpenMesh::Vec3d(4.20604, 1.08959, 0),
		//OpenMesh::Vec3d(4.34064, 0.844649, 0),
		//OpenMesh::Vec3d(4.51878, 1.00467, 0),
		//OpenMesh::Vec3d(4.6284, 0.795768, 0),
		//OpenMesh::Vec3d(4.43999, 0.739965, 0),
		//OpenMesh::Vec3d(3.96868, 0.757685, 0),
		//OpenMesh::Vec3d(4.47345, 1.60985, 0),
		//};

		//CC_points = { //yu
		//	OpenMesh::Vec3d(1.55761, 0.298392, 0),
		//OpenMesh::Vec3d(1.36297, 0.283486, 0),
		//OpenMesh::Vec3d(1.1833, 0.280326, 0),
		//OpenMesh::Vec3d(0.741254, 0.259984, 0),
		//OpenMesh::Vec3d(0.29268, -2.05241, 0),
		//OpenMesh::Vec3d(-1.99653, 0.0359225, 0),
		//OpenMesh::Vec3d(-0.382603, 1.17903, 0),
		//OpenMesh::Vec3d(-0.410516, 1.27791, 0),
		//OpenMesh::Vec3d(-0.449854, 1.40897, 0),
		//OpenMesh::Vec3d(-0.477108, 1.49262, 0),
		//OpenMesh::Vec3d(-3.41672, -0.230562, 0),
		//OpenMesh::Vec3d(1.02345, -3.44974, 0),
		//
		//};

		//CC_points = {//kuzi
		//	OpenMesh::Vec3d(0.677801, 1.2003, 0),
		//OpenMesh::Vec3d(0.780243, -3.25194, 0),
		//OpenMesh::Vec3d(0.81439, -9.3091, 0),
		//OpenMesh::Vec3d(0.81439, -15.1614, 0),
		//OpenMesh::Vec3d(3.80227, -15.1916, 0),
		//OpenMesh::Vec3d(6.17551, -15.2559, 0),
		//OpenMesh::Vec3d(11.5537, -15.2348, 0),
		//OpenMesh::Vec3d(11.5672, -5.14217, 0),
		//OpenMesh::Vec3d(11.6845, 9.43102, 0),
		//OpenMesh::Vec3d(11.6459, 14.9842, 0),
		//OpenMesh::Vec3d(-2.88771, 15.2544, 0),
		//OpenMesh::Vec3d(-7.15668, 14.971, 0),
		//OpenMesh::Vec3d(-11.383, 15.0709, 0),
		//OpenMesh::Vec3d(-11.5878, -8.03373, 0),
		//OpenMesh::Vec3d(-11.5878, -11.3671, 0),
		//OpenMesh::Vec3d(-11.4171, -15.2809, 0),
		//OpenMesh::Vec3d(-9.16339, -15.3532, 0),
		//OpenMesh::Vec3d(-6.09014, -15.2718, 0),
		//OpenMesh::Vec3d(-0.62658, -15.2758, 0),
		//OpenMesh::Vec3d(-0.776266, -11.2293, 0),
		//OpenMesh::Vec3d(-0.738142, -5.45842, 0),
		//OpenMesh::Vec3d(-0.751239, 1.18322, 0),
		//OpenMesh::Vec3d(-0.422864, 1.2003, 0),
		//OpenMesh::Vec3d(-0.0432679, 1.2003, 0),
		//};
          
		//CC_points = {//car
		//	OpenMesh::Vec3d(17.0636, -3.96522, 0),
		//OpenMesh::Vec3d(17.0602, -0.865747, 0),
		//OpenMesh::Vec3d(16.9603, 3.13988, 0),
		//OpenMesh::Vec3d(13.1047, 2.52286, 0),
		//OpenMesh::Vec3d(11.3294, 9.4102, 0),
		//OpenMesh::Vec3d(0.0590485, 6.34927, 0),
		//OpenMesh::Vec3d(-2.5501, 2.84747, 0),
		//OpenMesh::Vec3d(-12.414, 2.59491, 0),
		//OpenMesh::Vec3d(-16.5235, 1.10555, 0),
		//OpenMesh::Vec3d(-17.0582, -3.72901, 0),
		//OpenMesh::Vec3d(-4.71722, -8.88474, 0),
		//OpenMesh::Vec3d(6.7265, -7.13234, 0),
		//};

		//CC_points = {//tuzi
		//	OpenMesh::Vec3d(1.2338, -0.872146, 0),
		//OpenMesh::Vec3d(0.848741, -0.488863, 0),
		//OpenMesh::Vec3d(0.900976, -0.193908, 0),
		//OpenMesh::Vec3d(0.789363, 0.186805, 0),
		//OpenMesh::Vec3d(1.20989, 0.53253, 0),
		//OpenMesh::Vec3d(1.40575, 1.25384, 0),
		//OpenMesh::Vec3d(0.776231, 1.62091, 0),
		//OpenMesh::Vec3d(-0.294722, 1.55362, 0),
		//OpenMesh::Vec3d(0.952108, 0.857486, 0),
		//OpenMesh::Vec3d(0.145927, 0.50355, 0),
		//OpenMesh::Vec3d(-0.335255, 0.525864, 0),
		//OpenMesh::Vec3d(-0.896345, 0.022467, 0),
		//OpenMesh::Vec3d(-0.979956, -0.381595, 0),
		//OpenMesh::Vec3d(-1.03288, -0.89268, 0),
		//OpenMesh::Vec3d(-1.25456, -0.83442, 0),
		//OpenMesh::Vec3d(-1.21265, -1.61744, 0),
		//OpenMesh::Vec3d(-0.690139, -1.62269, 0),
		//OpenMesh::Vec3d(-0.28394, -1.64832, 0),
		//OpenMesh::Vec3d(0.223731, -1.65626, 0),
		//OpenMesh::Vec3d(0.416271, -1.6679, 0),
		//OpenMesh::Vec3d(0.533081, -1.66271, 0),
		//OpenMesh::Vec3d(0.753259, -1.66561, 0),
		//OpenMesh::Vec3d(0.811291, -1.37615, 0),
		//OpenMesh::Vec3d(1.19484, -1.34047, 0),
		//};

		//CC_points = { //daizi
		//	OpenMesh::Vec3d(31.4678, -3.60352, 0),
		//OpenMesh::Vec3d(31.4678, -0.717967, 0),
		//OpenMesh::Vec3d(31.4678, 0.615366, 0),
		//OpenMesh::Vec3d(31.4549, 3.54117, 0),
		//OpenMesh::Vec3d(0.653732, 3.59247, 0),
		//OpenMesh::Vec3d(-0.679602, 3.59247, 0),
		//OpenMesh::Vec3d(-31.6356, 3.56382, 0),
		//OpenMesh::Vec3d(-31.6226, 0.638025, 0),
		//OpenMesh::Vec3d(-31.6226, -0.695309, 0),
		//OpenMesh::Vec3d(-31.6226, -3.58087, 0),
		//OpenMesh::Vec3d(-0.666667, -3.55222, 0),
		//OpenMesh::Vec3d(0.666667, -3.55222, 0),
		//};
		// 

		//xiyi
		//{
		//	CC_points = { //xiyi
		//OpenMesh::Vec3d(4.86648, 0.875661, 0),
		//OpenMesh::Vec3d(4.92171, 0.341636, 0),
		//OpenMesh::Vec3d(4.44507, 0.0967474, 0),
		//OpenMesh::Vec3d(3.96134, 0.159551, 0),
		//OpenMesh::Vec3d(3.47603, 0.311732, 0),
		//OpenMesh::Vec3d(2.88748, 0.628007, 0),
		//OpenMesh::Vec3d(2.29758, 0.985943, 0),
		//OpenMesh::Vec3d(1.85205, 1.32421, 0),
		//OpenMesh::Vec3d(1.40636, 1.68818, 0),
		//OpenMesh::Vec3d(0.899758, 1.92868, 0),
		//OpenMesh::Vec3d(-6.36326, 3.14212, 0),
		//OpenMesh::Vec3d(-6.99906, 0.160185, 0),
		//OpenMesh::Vec3d(-3.73234, -0.87026, 0),
		//OpenMesh::Vec3d(-4.44834, -2.77133, 0),
		//OpenMesh::Vec3d(-1.61845, -2.46282, 0),
		//OpenMesh::Vec3d(1.3063, -2.28422, 0),
		//OpenMesh::Vec3d(2.40598, -1.75447, 0),
		//OpenMesh::Vec3d(3.4009, -1.70409, 0),
		//OpenMesh::Vec3d(3.97396, -0.721832, 0),
		//OpenMesh::Vec3d(4.74744, -0.557083, 0),
		//OpenMesh::Vec3d(5.70762, -0.28611, 0),
		//OpenMesh::Vec3d(5.52196, 0.803965, 0),
		//OpenMesh::Vec3d(5.36836, 1.28816, 0),
		//OpenMesh::Vec3d(5.04465, 1.54012, 0),
		//OpenMesh::Vec3d(4.5651, 1.57992, 0),
		//OpenMesh::Vec3d(4.14418, 1.59494, 0),
		//OpenMesh::Vec3d(3.87688, 1.28838, 0),
		//OpenMesh::Vec3d(3.82461, 0.978126, 0),
		//OpenMesh::Vec3d(3.8078, 0.639398, 0),
		//OpenMesh::Vec3d(4.06674, 0.303346, 0),
		//OpenMesh::Vec3d(4.57554, 0.389388, 0),
		//OpenMesh::Vec3d(4.80811, 0.544107, 0),
		//OpenMesh::Vec3d(4.8452, 0.822595, 0),
		//OpenMesh::Vec3d(4.78568, 0.938214, 0),
		//OpenMesh::Vec3d(4.59935, 1.18666, 0),
		//OpenMesh::Vec3d(4.20859, 1.13957, 0),
		//OpenMesh::Vec3d(4.32079, 0.832109, 0),
		//OpenMesh::Vec3d(4.41925, 0.892305, 0),
		//OpenMesh::Vec3d(4.47836, 0.901803, 0),
		//OpenMesh::Vec3d(4.50694, 0.852756, 0),
		//OpenMesh::Vec3d(4.51046, 0.806951, 0),
		//OpenMesh::Vec3d(4.4966, 0.764481, 0),
		//OpenMesh::Vec3d(4.45023, 0.728632, 0),
		//OpenMesh::Vec3d(4.30353, 0.72234, 0),
		//OpenMesh::Vec3d(4.24795, 0.847824, 0),
		//OpenMesh::Vec3d(4.25476, 0.941717, 0),
		//OpenMesh::Vec3d(4.25256, 1.06728, 0),
		//OpenMesh::Vec3d(4.38782, 1.18284, 0),
		//OpenMesh::Vec3d(4.53972, 1.18326, 0),
		//OpenMesh::Vec3d(4.69637, 1.15446, 0),
		//OpenMesh::Vec3d(4.7939, 1.04411, 0),
		//	};
		//}

		{ // seahorse
//			CC_points = { // seahorse
//OpenMesh::Vec3d(3.61019, -5.53027, 0),
//OpenMesh::Vec3d(3.60908, -3.95251, 0),
//OpenMesh::Vec3d(3.72919, -1.53567, 0),
//OpenMesh::Vec3d(3.84245, -0.278068, 0),
//OpenMesh::Vec3d(3.82146, 1.48578, 0),
//OpenMesh::Vec3d(4.98234, 3.07104, 0),
//OpenMesh::Vec3d(4.83917, 6.5945, 0),
//OpenMesh::Vec3d(4.69292, 9.47414, 0),
//OpenMesh::Vec3d(3.09747, 10.8991, 0),
//OpenMesh::Vec3d(-0.273063, 9.57201, 0),
//OpenMesh::Vec3d(-1.93806, 8.70603, 0),
//OpenMesh::Vec3d(-0.993479, 5.67479, 0),
//OpenMesh::Vec3d(-4.05513, 6.09394, 0),
//OpenMesh::Vec3d(-5.00754, 6.23271, 0),
//OpenMesh::Vec3d(-6.41301, 6.73317, 0),
//OpenMesh::Vec3d(-4.92627, 2.78679, 0),
//OpenMesh::Vec3d(-3.68057, 4.54012, 0),
//OpenMesh::Vec3d(0.37544, 4.99386, 0),
//OpenMesh::Vec3d(-0.112873, 4.07275, 0),
//OpenMesh::Vec3d(-1.75945, 2.67492, 0),
//OpenMesh::Vec3d(-2.1299, 0.621476, 0),
//OpenMesh::Vec3d(-1.29587, -0.0891098, 0),
//OpenMesh::Vec3d(-0.720383, -0.684836, 0),
//OpenMesh::Vec3d(0.965407, -1.92763, 0),
//OpenMesh::Vec3d(1.08476, -4.15547, 0),
//OpenMesh::Vec3d(1.15867, -5.02685, 0),
//OpenMesh::Vec3d(1.19137, -6.2054, 0),
//OpenMesh::Vec3d(1.16041, -7.17045, 0),
//OpenMesh::Vec3d(1.10901, -8.05413, 0),
//OpenMesh::Vec3d(1.05779, -8.89826, 0),
//OpenMesh::Vec3d(1.48802, -10.2238, 0),
//OpenMesh::Vec3d(3.02485, -10.4425, 0),
//OpenMesh::Vec3d(3.65898, -9.51771, 0),
//OpenMesh::Vec3d(3.61107, -8.61301, 0),
//OpenMesh::Vec3d(3.62334, -8.0092, 0),
//OpenMesh::Vec3d(3.6258, -7.31019, 0),
//			};
		}


		//CC_points = { //fish
		//	OpenMesh::Vec3d(7.88917, -4.19279, 0),
		//OpenMesh::Vec3d(7.47304, -1.84145, 0),
		//OpenMesh::Vec3d(7.60398, -0.916129, 0),
		//OpenMesh::Vec3d(10.1018, -0.0975394, 0),
		//OpenMesh::Vec3d(8.99175, 1.64069, 0),
		//OpenMesh::Vec3d(4.941, 0.121658, 0),
		//OpenMesh::Vec3d(3.34918, 1.5249, 0),
		//OpenMesh::Vec3d(3.69759, 2.6337, 0),
		//OpenMesh::Vec3d(2.35008, 3.81885, 0),
		//OpenMesh::Vec3d(0.921122, 3.08854, 0),
		//OpenMesh::Vec3d(-1.81225, 4.09559, 0),
		//OpenMesh::Vec3d(-5.65018, 4.77371, 0),
		//OpenMesh::Vec3d(-8.65683, 3.24567, 0),
		//OpenMesh::Vec3d(-10.3053, 3.09553, 0),
		//OpenMesh::Vec3d(-10.0761, 2.09196, 0),
		//OpenMesh::Vec3d(-9.00522, 1.38062, 0),
		//OpenMesh::Vec3d(-8.98836, 1.07329, 0),
		//OpenMesh::Vec3d(-8.99063, 0.702774, 0),
		//OpenMesh::Vec3d(-8.75359, 0.482605, 0),
		//OpenMesh::Vec3d(-8.63689, 0.763358, 0),
		//OpenMesh::Vec3d(-8.78799, 1.02137, 0),
		//OpenMesh::Vec3d(-8.72299, 1.21815, 0),
		//OpenMesh::Vec3d(-7.24225, -0.0052856, 0),
		//OpenMesh::Vec3d(-4.19355, -1.06031, 0),
		//OpenMesh::Vec3d(-2.08033, -0.944584, 0),
		//OpenMesh::Vec3d(-1.63804, -1.50076, 0),
		//OpenMesh::Vec3d(-0.235829, -2.02419, 0),
		//OpenMesh::Vec3d(-0.37616, -0.737527, 0),
		//OpenMesh::Vec3d(-0.207549, -0.699108, 0),
		//OpenMesh::Vec3d(0.0779521, -0.665316, 0),
		//OpenMesh::Vec3d(0.427525, -0.621636, 0),
		//OpenMesh::Vec3d(1.40535, -1.90493, 0),
		//OpenMesh::Vec3d(2.01614, -2.07862, 0),
		//OpenMesh::Vec3d(3.86555, -0.802197, 0),
		//OpenMesh::Vec3d(5.24685, -1.85539, 0),
		//OpenMesh::Vec3d(6.49604, -3.83112, 0),
		//};

		//CC_points = { //choufish
		//	OpenMesh::Vec3d(0.621947, -3.00053, 0),
		//	OpenMesh::Vec3d(1.19422, -3.24356, 0),
		//	OpenMesh::Vec3d(1.76649, -3.4866, 0),
		//	OpenMesh::Vec3d(2.33876, -3.72963, 0),
		//	OpenMesh::Vec3d(3.48501, -2.98653, 0),
		//	OpenMesh::Vec3d(4.63127, -2.24344, 0),
		//	OpenMesh::Vec3d(5.77752, -1.50034, 0),
		//	OpenMesh::Vec3d(4.8046, -0.0228433, 0),
		//	OpenMesh::Vec3d(3.83168, 1.45465, 0),
		//	OpenMesh::Vec3d(2.85876, 2.93215, 0),
		//	OpenMesh::Vec3d(0.10979, 3.08279, 0),
		//	OpenMesh::Vec3d(-2.63918, 3.23342, 0),
		//	OpenMesh::Vec3d(-5.38815, 3.38406, 0),
		//	OpenMesh::Vec3d(-5.43681, 3.13371, 0),
		//	OpenMesh::Vec3d(-5.48547, 2.88337, 0),
		//	OpenMesh::Vec3d(-5.53413, 2.63302, 0),
		//	OpenMesh::Vec3d(-3.58597, 2.51262, 0),
		//	OpenMesh::Vec3d(-1.63781, 2.39221, 0),
		//	OpenMesh::Vec3d(0.310345, 2.27181, 0),
		//	OpenMesh::Vec3d(-0.884167, 1.77491, 0),
		//	OpenMesh::Vec3d(-2.07868, 1.27801, 0),
		//	OpenMesh::Vec3d(-3.27319, 0.781111, 0),
		//	OpenMesh::Vec3d(-3.36141, -0.046006, 0),
		//	OpenMesh::Vec3d(-3.44963, -0.873123, 0),
		//	OpenMesh::Vec3d(-3.53785, -1.70024, 0),
		//	OpenMesh::Vec3d(-3.00611, -2.34053, 0),
		//	OpenMesh::Vec3d(-2.47437, -2.98081, 0),
		//	OpenMesh::Vec3d(-1.94263, -3.6211, 0),
		//	OpenMesh::Vec3d(-1.12739, -3.40618, 0),
		//	OpenMesh::Vec3d(-0.312145, -3.19127, 0),
		//	OpenMesh::Vec3d(0.503098, -2.97635, 0),
		//	OpenMesh::Vec3d(0.930805, -2.94226, 0),
		//	OpenMesh::Vec3d(1.35851, -2.90816, 0),
		//	OpenMesh::Vec3d(1.78622, -2.87407, 0),
		//	OpenMesh::Vec3d(1.39813, -2.91622, 0),
		//	OpenMesh::Vec3d(1.01004, -2.95838, 0),
		//};

		//CC_points = { //circle
		//	OpenMesh::Vec3d(3.45289, 1.63941, 0),
		//OpenMesh::Vec3d(4.48355, 0.137393, 0),
		//OpenMesh::Vec3d(4.01564, -1.4928, 0),
		//OpenMesh::Vec3d(3.44068, -3.85162, 0),
		//OpenMesh::Vec3d(6.55334, -0.345064, 0),
		//OpenMesh::Vec3d(3.90656, 6.20451, 0),
		//OpenMesh::Vec3d(-1.69168, 3.85054, 0),
		//OpenMesh::Vec3d(-0.0258138, 5.08684, 0),
		//OpenMesh::Vec3d(1.91392, 4.70734, 0),
		//OpenMesh::Vec3d(3.83488, 3.89295, 0),
		//OpenMesh::Vec3d(1.07448, 7.12438, 0),
		//OpenMesh::Vec3d(-5.90614, 4.59064, 0),
		//OpenMesh::Vec3d(-3.65812, -1.22062, 0),
		//OpenMesh::Vec3d(-4.84896, 1.04082, 0),
		//OpenMesh::Vec3d(-4.17104, 2.38932, 0),
		//OpenMesh::Vec3d(-3.86462, 4.22689, 0),
		//OpenMesh::Vec3d(-6.53473, 1.87253, 0),
		//OpenMesh::Vec3d(-4.64774, -5.87751, 0),
		//OpenMesh::Vec3d(1.34646, -3.2845, 0),
		//OpenMesh::Vec3d(-0.105171, -4.56524, 0),
		//OpenMesh::Vec3d(-2.44788, -4.06556, 0),
		//OpenMesh::Vec3d(-4.21109, -3.22378, 0),
		//OpenMesh::Vec3d(-1.36415, -6.68839, 0),
		//OpenMesh::Vec3d(5.46868, -4.0388, 0),
		//};

		//CC_points = { //flower
		//	OpenMesh::Vec3d(0.060138, -2.34968, 0),
		//OpenMesh::Vec3d(0.167533, -1.16113, 0),
		//OpenMesh::Vec3d(0.304982, 0.160104, 0),
		//OpenMesh::Vec3d(0.231798, 1.08177, 0),
		//OpenMesh::Vec3d(0.61252, 2.32314, 0),
		//OpenMesh::Vec3d(0.771864, 3.13087, 0),
		//OpenMesh::Vec3d(0.855257, 4.5897, 0),
		//OpenMesh::Vec3d(2.09554, 4.91859, 0),
		//OpenMesh::Vec3d(2.47687, 5.80984, 0),
		//OpenMesh::Vec3d(2.67184, 7.06251, 0),
		//OpenMesh::Vec3d(1.05076, 8.34497, 0),
		//OpenMesh::Vec3d(-1.00333, 8.56513, 0),
		//OpenMesh::Vec3d(-3.01162, 7.65609, 0),
		//OpenMesh::Vec3d(-2.46392, 6.1255, 0),
		//OpenMesh::Vec3d(-1.33722, 5.03078, 0),
		//OpenMesh::Vec3d(-0.552003, 4.00657, 0),
		//OpenMesh::Vec3d(-0.0860061, 2.21267, 0),
		//OpenMesh::Vec3d(0.0878497, 0.616274, 0),
		//OpenMesh::Vec3d(-0.0636332, -0.969635, 0),
		//OpenMesh::Vec3d(-0.469408, 0.4811, 0),
		//OpenMesh::Vec3d(-1.36141, 0.898247, 0),
		//OpenMesh::Vec3d(-2.47641, 1.32553, 0),
		//OpenMesh::Vec3d(-2.85447, -0.680847, 0),
		//OpenMesh::Vec3d(-1.57427, -0.75945, 0),
		//OpenMesh::Vec3d(-0.29709, -1.64989, 0),
		//OpenMesh::Vec3d(-0.284548, -4.19343, 0),
		//OpenMesh::Vec3d(-0.449725, -7.19035, 0),
		//OpenMesh::Vec3d(-0.0458234, -9.10946, 0),
		//OpenMesh::Vec3d(0.607011, -6.40262, 0),
		//OpenMesh::Vec3d(-0.378727, -4.82229, 0),
		//OpenMesh::Vec3d(0.125836, -2.84884, 0),
		//OpenMesh::Vec3d(0.941884, -1.5343, 0),
		//OpenMesh::Vec3d(2.07567, -2.26778, 0),
		//OpenMesh::Vec3d(2.4943, -2.94274, 0),
		//OpenMesh::Vec3d(4.17284, -0.459165, 0),
		//OpenMesh::Vec3d(0.512756, -0.0850323, 0),
		//};

		//CC_points = { //octopus
		// OpenMesh::Vec3d(8.57042, 3.297, 0),
		//OpenMesh::Vec3d(5.09424, 1.93482, 0),
		//OpenMesh::Vec3d(8.81644, -0.913078, 0),
		//OpenMesh::Vec3d(6.50689, -3.68536, 0),
		//OpenMesh::Vec3d(5.42654, -1.87831, 0),
		//OpenMesh::Vec3d(4.92811, 1.19895, 0),
		//OpenMesh::Vec3d(5.93302, 3.06514, 0),
		//OpenMesh::Vec3d(6.39359, 2.98059, 0),
		//OpenMesh::Vec3d(6.76971, 2.94039, 0),
		//OpenMesh::Vec3d(7.1323, 3.39599, 0),
		//OpenMesh::Vec3d(7.34691, 3.96736, 0),
		//OpenMesh::Vec3d(7.36178, 4.91438, 0),
		//OpenMesh::Vec3d(6.49071, 5.0889, 0),
		//OpenMesh::Vec3d(7.77231, 9.87716, 0),
		//OpenMesh::Vec3d(5.30888, 14.7788, 0),
		//OpenMesh::Vec3d(-0.841746, 14.3125, 0),
		//OpenMesh::Vec3d(-5.90767, 11.3197, 0),
		//OpenMesh::Vec3d(-8.86451, 3.55846, 0),
		//OpenMesh::Vec3d(-0.246632, 4.78125, 0),
		//OpenMesh::Vec3d(1.06736, 1.00327, 0),
		//OpenMesh::Vec3d(-4.23325, 0.219585, 0),
		//OpenMesh::Vec3d(-8.03561, 3.02382, 0),
		//OpenMesh::Vec3d(-8.08751, 2.08127, 0),
		//OpenMesh::Vec3d(-7.52196, 0.833628, 0),
		//OpenMesh::Vec3d(-6.06773, 0.106026, 0),
		//OpenMesh::Vec3d(-7.90343, -1.09784, 0),
		//OpenMesh::Vec3d(-9.28057, -2.77283, 0),
		//OpenMesh::Vec3d(-7.6208, -5.78163, 0),
		//OpenMesh::Vec3d(-8.57419, -6.68359, 0),
		//OpenMesh::Vec3d(-8.68614, -8.01901, 0),
		//OpenMesh::Vec3d(-8.06132, -10.9547, 0),
		//OpenMesh::Vec3d(-6.74283, -6.93736, 0),
		//OpenMesh::Vec3d(-4.59648, -5.33218, 0),
		//OpenMesh::Vec3d(-2.05936, -4.13197, 0),
		//OpenMesh::Vec3d(-3.09482, -7.04246, 0),
		//OpenMesh::Vec3d(-9.21992, -12.7162, 0),
		//OpenMesh::Vec3d(-2.27186, -13.953, 0),
		//OpenMesh::Vec3d(-2.95275, -12.5256, 0),
		//OpenMesh::Vec3d(-3.79382, -11.3406, 0),
		//OpenMesh::Vec3d(-3.42902, -9.89676, 0),
		//OpenMesh::Vec3d(-2.6323, -11.6362, 0),
		//OpenMesh::Vec3d(-1.81066, -12.1583, 0),
		//OpenMesh::Vec3d(-0.00107587, -12.4131, 0),
		//OpenMesh::Vec3d(-2.69772, -8.66487, 0),
		//OpenMesh::Vec3d(-1.78497, -7.37903, 0),
		//OpenMesh::Vec3d(0.488619, -4.78304, 0),
		//OpenMesh::Vec3d(-0.0659694, -6.98257, 0),
		//OpenMesh::Vec3d(-0.438017, -8.1058, 0),
		//OpenMesh::Vec3d(0.945469, -9.78723, 0),
		//OpenMesh::Vec3d(1.71534, -8.54231, 0),
		//OpenMesh::Vec3d(1.34671, -7.00428, 0),
		//OpenMesh::Vec3d(1.89121, -5.32397, 0),
		//OpenMesh::Vec3d(3.61222, -8.87285, 0),
		//OpenMesh::Vec3d(2.05656, -8.95106, 0),
		//OpenMesh::Vec3d(1.51134, -12.1472, 0),
		//OpenMesh::Vec3d(7.13949, -10.1638, 0),
		//OpenMesh::Vec3d(2.57694, -5.41496, 0),
		//OpenMesh::Vec3d(4.12527, -0.841089, 0),
		//OpenMesh::Vec3d(4.43461, -3.18152, 0),
		//OpenMesh::Vec3d(5.09308, -5.72131, 0),
		//OpenMesh::Vec3d(7.13664, -5.11346, 0),
		//OpenMesh::Vec3d(10.4172, -2.70598, 0),
		//OpenMesh::Vec3d(6.50459, 2.41615, 0),
		//OpenMesh::Vec3d(9.27712, 2.26177, 0),
		//OpenMesh::Vec3d(9.67284, 2.20834, 0),
		//OpenMesh::Vec3d(9.37983, 3.08828, 0),
		//};

		//CC_points = { //sheji
		//	OpenMesh::Vec3d(-13.903, -6.69777, 0),
		//OpenMesh::Vec3d(1.05228, -8.39994, 0),
		//OpenMesh::Vec3d(7.48085, -1.03554, 0),
		//OpenMesh::Vec3d(5.9094, 9.53619, 0),
		//OpenMesh::Vec3d(2.46234, 8.10173, 0),
		//OpenMesh::Vec3d(-1.18305, 8.99174, 0),
		//OpenMesh::Vec3d(-4.21192, 10.1169, 0),
		//OpenMesh::Vec3d(-4.81756, 4.98018, 0),
		//OpenMesh::Vec3d(-7.6985, 4.82465, 0),
		//OpenMesh::Vec3d(-12.3981, 4.54636, 0),
		//OpenMesh::Vec3d(-12.0119, 0.141044, 0),
		//OpenMesh::Vec3d(-12.2488, -2.39566, 0),
		//};
		
		{
			//sharp
			/*CC_points = { OpenMesh::Vec3d(-4.99776, -3.50134, 0),
			OpenMesh::Vec3d(-3.31352, -4.5456, 0),
			OpenMesh::Vec3d(-2.92706, -6.73494, 0),
			OpenMesh::Vec3d(-0.886575, -6.91403, 0),
			OpenMesh::Vec3d(4.46194, -5.99892, 0),
			OpenMesh::Vec3d(7.35647, -4.73043, 0),
			OpenMesh::Vec3d(10.2255, -1.73158, 0),
			OpenMesh::Vec3d(9.72775, 3.72571, 0),
			OpenMesh::Vec3d(5.31121, 5.06069, 0),
			OpenMesh::Vec3d(-0.835682, 6.95549, 0),
			OpenMesh::Vec3d(-1.68973, 4.37172, 0),
			OpenMesh::Vec3d(-2.91115, 3.46577, 0),
			OpenMesh::Vec3d(-5.04865, 1.69464, 0),
			OpenMesh::Vec3d(-6.15297, 4.36651, 0),
			OpenMesh::Vec3d(-8.32603, 4.69732, 0),
			OpenMesh::Vec3d(-10.6009, 4.57009, 0),
			OpenMesh::Vec3d(-7.42008, 0.310417, 0),
			OpenMesh::Vec3d(-8.05624, -2.168, 0),
			OpenMesh::Vec3d(-9.99017, -5.81696, 0),
			OpenMesh::Vec3d(-7.79166, -6.91115, 0),
			OpenMesh::Vec3d(-5.84761, -5.12991, 0),
			};*/
		}
		//pangxie
		if (0) {
			CC_points = {//pangxie
			OpenMesh::Vec3d(7.71977, -2.05287, 0),
		OpenMesh::Vec3d(16.1661, 2.5924, 0),
		OpenMesh::Vec3d(22.5491, -0.870733, 0),
		OpenMesh::Vec3d(15.6577, -8.58216, 0),
		OpenMesh::Vec3d(26.8967, -7.59486, 0),
		OpenMesh::Vec3d(21.084, 11.3199, 0),
		OpenMesh::Vec3d(7.68061, 1.27629, 0),
		OpenMesh::Vec3d(11.5959, 6.63227, 0),
		OpenMesh::Vec3d(24.6401, 7.52288, 0),
		OpenMesh::Vec3d(21.7966, -5.4645, 0),
		OpenMesh::Vec3d(31.1961, 2.17972, 0),
		OpenMesh::Vec3d(15.6549, 13.7466, 0),
		OpenMesh::Vec3d(7.82502, 4.58309, 0),
		OpenMesh::Vec3d(11.8374, 11.0923, 0),
		OpenMesh::Vec3d(20.9685, 10.4649, 0),
		OpenMesh::Vec3d(24.9294, 1.87976, 0),
		OpenMesh::Vec3d(27.8247, 9.55625, 0),
		OpenMesh::Vec3d(14.2738, 16.6223, 0),
		OpenMesh::Vec3d(5.4765, 7.35184, 0),
		OpenMesh::Vec3d(8.64119, 11.865, 0),
		OpenMesh::Vec3d(14.7017, 15.1746, 0),
		OpenMesh::Vec3d(23.1277, 9.7121, 0),
		OpenMesh::Vec3d(19.424, 19.1598, 0),
		OpenMesh::Vec3d(6.83002, 15.4013, 0),
		OpenMesh::Vec3d(2.16398, 7.18829, 0),
		OpenMesh::Vec3d(-0.0248164, 9.29763, 0),
		OpenMesh::Vec3d(-1.17408, 9.21065, 0),
		OpenMesh::Vec3d(-3.33054, 6.62634, 0),
		OpenMesh::Vec3d(-8.85175, 14.7474, 0),
		OpenMesh::Vec3d(-24.3841, 17.0936, 0),
		OpenMesh::Vec3d(-23.6175, 7.39743, 0),
		OpenMesh::Vec3d(-18.8441, 13.6221, 0),
		OpenMesh::Vec3d(-10.5837, 11.5502, 0),
		OpenMesh::Vec3d(-5.13643, 5.07839, 0),
		OpenMesh::Vec3d(-5.27052, 4.97835, 0),
		OpenMesh::Vec3d(-5.46014, 4.84129, 0),
		OpenMesh::Vec3d(-5.64977, 4.70424, 0),
		OpenMesh::Vec3d(-12.9059, 15.3053, 0),
		OpenMesh::Vec3d(-28.4601, 9.29942, 0),
		OpenMesh::Vec3d(-24.863, 0.0668226, 0),
		OpenMesh::Vec3d(-22.7747, 8.29837, 0),
		OpenMesh::Vec3d(-14.3986, 9.84779, 0),
		OpenMesh::Vec3d(-7.0058, 3.14714, 0),
		OpenMesh::Vec3d(-18.5345, 12.5865, 0),
		OpenMesh::Vec3d(-30.6453, -0.223078, 0),
		OpenMesh::Vec3d(-21.5541, -7.27411, 0),
		OpenMesh::Vec3d(-24.3589, 0.197288, 0),
		OpenMesh::Vec3d(-18.8381, 7.34974, 0),
		OpenMesh::Vec3d(-7.4344, 0.51362, 0),
		OpenMesh::Vec3d(-24.585, 8.96755, 0),
		OpenMesh::Vec3d(-25.4714, -12.1974, 0),
		OpenMesh::Vec3d(-13.6432, -10.1693, 0),
		OpenMesh::Vec3d(-22.614, -4.87779, 0),
		OpenMesh::Vec3d(-17.811, 3.67923, 0),
		OpenMesh::Vec3d(-7.53781, -3.00233, 0),
		OpenMesh::Vec3d(-23.8508, 3.73205, 0),
		OpenMesh::Vec3d(-18.0268, -14.6281, 0),
		OpenMesh::Vec3d(0.581672, -14.6728, 0),
		OpenMesh::Vec3d(-1.23569, -8.99517, 0),
		OpenMesh::Vec3d(-10.3154, -6.40558, 0),
		OpenMesh::Vec3d(-14.2051, -5.46234, 0),
		OpenMesh::Vec3d(-10.7249, -5.26371, 0),
		OpenMesh::Vec3d(-4.0724, -6.50565, 0),
		OpenMesh::Vec3d(0.270762, -12.5408, 0),
		OpenMesh::Vec3d(6.57959, -7.9814, 0),
		OpenMesh::Vec3d(9.1306, -3.60342, 0),
		OpenMesh::Vec3d(13.4053, -3.81022, 0),
		OpenMesh::Vec3d(11.9635, -6.90228, 0),
		OpenMesh::Vec3d(4.07802, -8.25055, 0),
		OpenMesh::Vec3d(0.654098, -13.3543, 0),
		OpenMesh::Vec3d(3.50707, -16.7318, 0),
		OpenMesh::Vec3d(8.3762, -13.8882, 0),
		OpenMesh::Vec3d(12.9466, -9.91377, 0),
		OpenMesh::Vec3d(19.5164, -2.8494, 0),
		OpenMesh::Vec3d(19.745, 1.90087, 0),
			};
			LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\pangxie.obj");
			Set_Texture_coord();//设置纹理
		}
		if (0)//弯曲kuzi
		{
			CC_points = { OpenMesh::Vec3d(13.0832, 15.6921, 0),
                   OpenMesh::Vec3d(5.66596, 19.5152, 0),
                   OpenMesh::Vec3d(-3.58416, 15.296, 0),
                   OpenMesh::Vec3d(-12.413, 15.4446, 0),
                   OpenMesh::Vec3d(-11.8453, 5.02946, 0),
                   OpenMesh::Vec3d(-7.05355, -1.56201, 0),
                   OpenMesh::Vec3d(-20.2694, -1.26341, 0),
                   OpenMesh::Vec3d(-20.4997, -4.21117, 0),
                   OpenMesh::Vec3d(-20.7351, -7.75053, 0),
                   OpenMesh::Vec3d(-22.2237, -10.5609, 0),
                   OpenMesh::Vec3d(-10.5812, -17.0813, 0),
                   OpenMesh::Vec3d(-0.062147, -9.45717, 0),
                   OpenMesh::Vec3d(1.21752, -0.689923, 0),
                   OpenMesh::Vec3d(1.94593, -0.686233, 0),
                   OpenMesh::Vec3d(2.87239, -0.682543, 0),
                   OpenMesh::Vec3d(3.74934, -0.579826, 0),
                   OpenMesh::Vec3d(6.85441, -4.18513, 0),
                   OpenMesh::Vec3d(9.79138, -12.0879, 0),
                   OpenMesh::Vec3d(12.7915, -18.0178, 0),
                   OpenMesh::Vec3d(17.4341, -15.5421, 0),
                   OpenMesh::Vec3d(21.0368, -15.245, 0),
                   OpenMesh::Vec3d(24.1444, -15.1955, 0),
                   OpenMesh::Vec3d(23.4905, -0.23368, 0),
                   OpenMesh::Vec3d(12.2415, 5.26508, 0),
			};
			LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\kuzi.obj");
			bool read_OK = MeshTools::ReadMesh(mesh_beifen, "E:\\dgp2021\\dgp6\\newproject_BIHC\\project_BiHC\\mesh\\kuzi_polyGreen.obj");
			Set_Texture_coord();//设置纹理
			MeshTools::AssignPoints(mesh, mesh_beifen);
		}
		if (1)//zimu_S
		{
			OpenMesh::Vec3d up(0, 1e-3, 0);
			CC_points = { OpenMesh::Vec3d(-0.462802, 0.0195753, 0),
OpenMesh::Vec3d(1.67972, -0.8985, 0),
OpenMesh::Vec3d(0.269475, -2.23354, 0),
OpenMesh::Vec3d(-1.3528, -1.17542, 0)+up,
OpenMesh::Vec3d(-1.36174, -1.39735, 0),
OpenMesh::Vec3d(-1.35988, -1.64304, 0),
OpenMesh::Vec3d(-1.369, -1.80708, 0),
OpenMesh::Vec3d(0.951718, -2.85684, 0),
OpenMesh::Vec3d(2.20763, -0.542902, 0),
OpenMesh::Vec3d(0.205124, 0.259164, 0),
OpenMesh::Vec3d(-1.70295, 0.974712, 0),
OpenMesh::Vec3d(-0.571699, 2.32499, 0),
OpenMesh::Vec3d(1.00319, 1.49733, 0)-up,
OpenMesh::Vec3d(1.01068, 1.6999, 0),
OpenMesh::Vec3d(1.00507, 1.93938, 0),
OpenMesh::Vec3d(0.992243, 2.11998, 0),
OpenMesh::Vec3d(-0.960925, 2.78616, 0),
OpenMesh::Vec3d(-2.45907, 0.908404, 0),
			};

			
			/*auto ccp_temp= { OpenMesh::Vec2d(-0.462802, 0.0195753),
OpenMesh::Vec2d(1.67972, -0.8985),
OpenMesh::Vec2d(0.269475, -2.23354),
OpenMesh::Vec2d(-1.3528, -1.17542),
OpenMesh::Vec2d(-1.36174, -1.39735),
OpenMesh::Vec2d(-1.35988, -1.64304),
OpenMesh::Vec2d(-1.369, -1.80708),
OpenMesh::Vec2d(0.951718, -2.85684),
OpenMesh::Vec2d(2.20763, -0.542902),
OpenMesh::Vec2d(0.205124, 0.259164),
OpenMesh::Vec2d(-1.70295, 0.974712),
OpenMesh::Vec2d(-0.571699, 2.32499),
OpenMesh::Vec2d(1.00319, 1.49733),
OpenMesh::Vec2d(1.01068, 1.6999),
OpenMesh::Vec2d(1.00507, 1.93938),
OpenMesh::Vec2d(0.992243, 2.11998),
OpenMesh::Vec2d(-0.960925, 2.78616),
OpenMesh::Vec2d(-2.45907, 0.908404),
			};
			auto sam_p = offsetCage_samples(ccp_temp, 1e-3, 80);
			Eigen::Matrix2Xd polygon(2, sam_p.size());
			Eigen::Matrix2Xi polygon_E(2, sam_p.size());
			for (int i = 0; i < sam_p.size(); i++)
			{
				auto point = sam_p[i];
				polygon.col(i) << point[0], point[1];
				polygon_E.col(i) << i, (i + 1) % (sam_p.size());

			}
			triangulate(polygon, polygon_E, 0.001, mesh);

			dprint(mesh.n_vertices(), mesh.n_faces());
			OpenMesh::IO::write_mesh(mesh, "S:/duwei/triangle/zimu_S1.obj");*/
			LoadMesh("S:/duwei/triangle/zimu_S1.obj");
			Set_Texture_coord();//设置纹理
		}
		if (0)//elephant
		{
			CC_points = { OpenMesh::Vec3d(-2.77448, 7.60594, 0),
OpenMesh::Vec3d(-6.76218, 10.3593, 0),
OpenMesh::Vec3d(-12.8974, 7.11545, 0),
OpenMesh::Vec3d(-12.3529, 3.30893, 0),
OpenMesh::Vec3d(-11.0687, -1.99194, 0),
OpenMesh::Vec3d(-14.3517, -3.29966, 0),
OpenMesh::Vec3d(-12.8025, -6.98694, 0),
OpenMesh::Vec3d(-10.9819, -6.07468, 0),
OpenMesh::Vec3d(-12.2449, -2.8801, 0),
OpenMesh::Vec3d(-11.3029, -0.166452, 0),
OpenMesh::Vec3d(-10.6833, -2.07562, 0),
OpenMesh::Vec3d(-11.2618, -4.53112, 0),
OpenMesh::Vec3d(-12.6503, -8.53826, 0),
OpenMesh::Vec3d(-10.7402, -9.39226, 0),
OpenMesh::Vec3d(-9.8436, -9.21843, 0),
OpenMesh::Vec3d(-9.65443, -5.03654, 0),
OpenMesh::Vec3d(-9.36511, -6.95065, 0),
OpenMesh::Vec3d(-10.6334, -9.05767, 0),
OpenMesh::Vec3d(-9.27078, -9.38309, 0),
OpenMesh::Vec3d(-5.17568, -9.48155, 0),
OpenMesh::Vec3d(-9.26313, -5.61169, 0),
OpenMesh::Vec3d(-6.49913, -2.69968, 0),
OpenMesh::Vec3d(-2.62301, -2.881, 0),
OpenMesh::Vec3d(-4.27285, -5.09169, 0),
OpenMesh::Vec3d(-5.71106, -8.70974, 0),
OpenMesh::Vec3d(-2.4367, -10.6219, 0),
OpenMesh::Vec3d(-1.32623, -6.03012, 0),
OpenMesh::Vec3d(0.258683, -2.18621, 0),
OpenMesh::Vec3d(0.94186, -2.47048, 0),
OpenMesh::Vec3d(-1.09657, -7.342, 0),
OpenMesh::Vec3d(1.63086, -9.74263, 0),
OpenMesh::Vec3d(6.98954, -8.54072, 0),
OpenMesh::Vec3d(1.44824, 0.353638, 0),
OpenMesh::Vec3d(7.90863, 0.953709, 0),
OpenMesh::Vec3d(11.0137, -2.6516, 0),
OpenMesh::Vec3d(4.35517, -7.81187, 0),
OpenMesh::Vec3d(9.51941, -9.28153, 0),
OpenMesh::Vec3d(13.7157, -5.16768, 0),
OpenMesh::Vec3d(14.7183, 1.01813, 0),
OpenMesh::Vec3d(8.60708, 7.62994, 0),
OpenMesh::Vec3d(4.04668, 10.208, 0),
OpenMesh::Vec3d(1.29215, 9.48121, 0),
			};
			LoadMesh("E:\\dgp2021\\dgp6\\newproject_BIHC\\project_BiHC\\mesh\\elephant.obj");
			Set_Texture_coord();//设置纹理
		}
		//rainbow
		if (0) {
			CC_points = { OpenMesh::Vec3d(-5.77366, -0.928836, 0),
OpenMesh::Vec3d(-3.65098, 4.19543, 0),
OpenMesh::Vec3d(3.83891, 7.69656, 0),
OpenMesh::Vec3d(9.74542, 1.55503, 0),
OpenMesh::Vec3d(9.71409, 1.85648, 0),
OpenMesh::Vec3d(9.72213, 2.09149, 0),
OpenMesh::Vec3d(9.75057, 2.34935, 0),
OpenMesh::Vec3d(3.96906, 7.95307, 0),
OpenMesh::Vec3d(-3.6725, 5.20192, 0),
OpenMesh::Vec3d(-6.41423, -0.846814, 0),
OpenMesh::Vec3d(-3.88359, 5.13772, 0),
OpenMesh::Vec3d(3.65582, 8.02333, 0),
OpenMesh::Vec3d(9.73233, 2.49004, 0),
OpenMesh::Vec3d(9.72816, 2.82964, 0),
OpenMesh::Vec3d(9.73162, 3.06732, 0),
OpenMesh::Vec3d(9.70073, 3.27175, 0),
OpenMesh::Vec3d(5.00196, 7.83177, 0),
OpenMesh::Vec3d(-5.0881, 7.15129, 0),
OpenMesh::Vec3d(-7.42613, -2.25787, 0),
OpenMesh::Vec3d(-8.65612, -1.67216, 0),
OpenMesh::Vec3d(-13.1998, -3.81923, 0),
OpenMesh::Vec3d(-6.02623, -6.5032, 0),
OpenMesh::Vec3d(-2.88592, -5.16367, 0),
OpenMesh::Vec3d(-0.978079, -2.18366, 0),
OpenMesh::Vec3d(-4.02564, -1.5895, 0),
OpenMesh::Vec3d(-0.942283, 4.27499, 0),
OpenMesh::Vec3d(6.25598, 4.66494, 0),
OpenMesh::Vec3d(9.6561, -1.77424, 0),
OpenMesh::Vec3d(9.67105, -1.42373, 0),
OpenMesh::Vec3d(9.6996, -1.06183, 0),
OpenMesh::Vec3d(9.74062, -0.738046, 0),
OpenMesh::Vec3d(6.13106, 5.28046, 0),
OpenMesh::Vec3d(-1.1495, 4.66369, 0),
OpenMesh::Vec3d(-4.38251, -0.855424, 0),
OpenMesh::Vec3d(-1.41844, 4.78383, 0),
OpenMesh::Vec3d(6.2934, 5.23497, 0),
OpenMesh::Vec3d(9.69998, -0.60418, 0),
OpenMesh::Vec3d(9.70243, -0.18479, 0),
OpenMesh::Vec3d(9.72684, 0.11423, 0),
OpenMesh::Vec3d(9.75569, 0.418196, 0),
OpenMesh::Vec3d(4.99936, 6.54761, 0),
OpenMesh::Vec3d(-2.13908, 4.46348, 0),
OpenMesh::Vec3d(-5.0399, -0.745585, 0),
OpenMesh::Vec3d(-2.61174, 4.15792, 0),
OpenMesh::Vec3d(4.66582, 6.75996, 0),
OpenMesh::Vec3d(9.68352, 0.652446, 0),
OpenMesh::Vec3d(9.73424, 0.909529, 0),
OpenMesh::Vec3d(9.75751, 1.17138, 0),
OpenMesh::Vec3d(9.79496, 1.37106, 0),
OpenMesh::Vec3d(4.4877, 7.31385, 0),
OpenMesh::Vec3d(-3.19225, 4.7506, 0),
			};
			LoadMesh("E:\\dgp2021\\dgp6\\newproject_BIHC\\project_BiHC\\mesh\\rainbow.obj");
			Set_Texture_coord();//设置纹理
		}
		CC_mesh = createMeshFromCurveCage(CC_points);
		curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
		auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
		for (auto vh : CC_mesh.vertices())
		{
			CagevertexState[vh] = NotSelected;
		}


//		//deer
//		Handle_points = { 
//			OpenMesh::Vec3d(-4.77772, 6.15806, 0),
//OpenMesh::Vec3d(-2.21779, 6.9095, 0),
//OpenMesh::Vec3d(-2.13006, -9.82847, 0),
//OpenMesh::Vec3d(-5.76418, -7.52105, 0),
//OpenMesh::Vec3d(5.20687, -9.75087, 0),
//OpenMesh::Vec3d(10.209, -8.6227, 0),
//OpenMesh::Vec3d(6.69162, 4.45358, 0),
//OpenMesh::Vec3d(8.43355, 4.32146, 0),
//OpenMesh::Vec3d(6.0825, -5.02297, 0),
//OpenMesh::Vec3d(7.59264, -5.14069, 0),
//OpenMesh::Vec3d(-1.49119, -5.10145, 0),
//OpenMesh::Vec3d(-2.76722, -4.74827, 0),
//		};
//		//deer test
//		Handle_points = {
//			OpenMesh::Vec3d(-4.77772, 6.15806, 0),
//OpenMesh::Vec3d(-4.77772, 6.15806, 0),
//OpenMesh::Vec3d(-2.13006, -9.82847, 0),
//OpenMesh::Vec3d(-2.13006, -9.82847, 0),
////OpenMesh::Vec3d(5.20687, -9.75087, 0),
////OpenMesh::Vec3d(5.20687, -9.75087, 0),
//OpenMesh::Vec3d(6.69162, 4.45358, 0),
//OpenMesh::Vec3d(6.69162, 4.45358, 0),
////OpenMesh::Vec3d(6.0825, -5.02297, 0),
////OpenMesh::Vec3d(6.0825, -5.02297, 0),
//OpenMesh::Vec3d(-1.49119, -5.10145, 0),
//OpenMesh::Vec3d(-1.49119, -5.10145, 0),
//		};
//		////sheji
//		//Handle_points =
//		//{ OpenMesh::Vec3d(-11.4868, 3.75227, 0),
//		//	OpenMesh::Vec3d(-11.4868, 3.75227, 0),
//		//	OpenMesh::Vec3d(-11.9029, -5.44321, 0),
//		//	OpenMesh::Vec3d(-11.9029, -5.44321, 0),
//		//	OpenMesh::Vec3d(5.33216, 8.45841, 0),
//		//	OpenMesh::Vec3d(5.33216, 8.45841, 0),
//		//	OpenMesh::Vec3d(-5.0166, 5.1423, 0),
//		//	OpenMesh::Vec3d(-5.0166, 5.1423, 0),
//		//	OpenMesh::Vec3d(-3.49179, 9.20057, 0),
//		//	OpenMesh::Vec3d(-3.49179, 9.20057, 0),
//		//	OpenMesh::Vec3d(1.01467, -1.30089, 0),
//		//	OpenMesh::Vec3d(1.01467, -1.30089, 0),
//		//};
//		Handle_mesh = createMeshFromCurveCage(Handle_points);
//		auto HandlevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(Handle_mesh, "vertexState");
//		for (auto vh : Handle_mesh.vertices())
//		{
//			HandlevertexState[vh] = NotSelected;
//		}

		useCauchy = true;
		calculate_cauchy_weight323();//计算3次cage cauchy权重
		calculate_cauchy_weight323();//计算3次cage cauchy权重
		calculate_cauchy_weight323();//计算3次cage cauchy权重
		calculate_cauchy_weight323();//计算3次cage cauchy权重
		//calculate_cauchy_weight323();//计算3次cage cauchy权重
		//calculate_cauchy_weight323();//计算3次cage cauchy权重
		//calculate_cauchy_weight323();//计算3次cage cauchy权重
		//exit(0);
		//calculate_green_weight323();//计算3次cage到3次控制点的权重
		//calculate_D2cauchy_weight_CB323();//计算了cage边界顶点上的二阶导的权重矩阵

		Mesh deformedMesh;
	    deformedMesh.assign(mesh);
	    deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
	    MeshTools::AssignPoints(mesh, deformedMesh);
	    update();
	}

	//Set_Texture_coord();//设置纹理
}
//void MeshViewerWidget::Biharmonic3D_Test(void) {
//	std::cout << "3DBihormonic!" << std::endl;
//	drawmode = CURVECAGE;
//	degree = 2;
//	//读取物体网格与cage网格
//	LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\Fine_cube.obj");
//	bool read_OK = MeshTools::ReadMesh(CC_mesh, "E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\cube.obj");
//	std::cout << "Load mesh finish " << std::endl;
//	// 遍历所有cage顶点并缩放坐标
//	for (auto vh : CC_mesh.vertices()) {
//		auto point = CC_mesh.point(vh); // 获取顶点的坐标
//		point *= 1.01;                  // 缩放顶点坐标
//		CC_mesh.set_point(vh, point);   // 更新顶点的坐标
//	}
//	//3D的cage构造与
//	ConstructMatrix3DOffset();
//	calculate_bih_weight1213D();
//
//	auto vertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(mesh, "vertexState");
//	for (auto vh : mesh.vertices())
//	{
//		vertexState[vh] = NotSelected;
//	}
//	Set_Texture_coord();//设置纹理
//
//	Mesh deformedMesh;
//	deformedMesh.assign(mesh);
//	deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
//	MeshTools::AssignPoints(mesh, deformedMesh);
//	update();
//}

//曲边的双调和坐标
void MeshViewerWidget::BiharmonicCurve_Test(void)
{
	drawmode = CURVECAGE;
	usebih = true;
	degree = 3;

	currentHistoryPos = 0;
	moveHistories.clear();
	
	if (degree == 2)//if mode
	{
		//2 to 2
		if (1) {
			int N = 4;//球 4
			curvecage2.resize(N);
			//通过curvecage2计算cc_points;

			CC_points = {//ball
				6.5 * OpenMesh::Vec3d(0,-1,0),
				6.5 * OpenMesh::Vec3d(1,-1,0),
				6.5 * OpenMesh::Vec3d(1,0,0),
				6.5 * OpenMesh::Vec3d(1,1,0),
				6.5 * OpenMesh::Vec3d(0,1,0),
				6.5 * OpenMesh::Vec3d(-1,1,0),
				6.5 * OpenMesh::Vec3d(-1,0,0),
				6.5 * OpenMesh::Vec3d(-1,-1,0),
			};
			//human
			CC_points = {
				OpenMesh::Vec3d(2.2434, -4.09831, 0),
				OpenMesh::Vec3d(1.33897, -1.2763, 0),
				OpenMesh::Vec3d(0.168209, 0.44022, 0),
				OpenMesh::Vec3d(1.4294, -0.288948, 0),
				OpenMesh::Vec3d(2.68837, -0.575573, 0),
				OpenMesh::Vec3d(3.60324, 1.3499, 0),
				OpenMesh::Vec3d(5.97756, 1.52252, 0),
				OpenMesh::Vec3d(6.02737, 3.22644, 0),
				OpenMesh::Vec3d(5.81575, 4.86821, 0),
				OpenMesh::Vec3d(4.28753, 5.19497, 0),
				OpenMesh::Vec3d(3.18159, 4.91388, 0),
				OpenMesh::Vec3d(2.91693, 3.88495, 0),
				OpenMesh::Vec3d(3.06766, 3.08017, 0),
				OpenMesh::Vec3d(1.80562, 2.91953, 0),
				OpenMesh::Vec3d(0.929425, 1.2952, 0),
				OpenMesh::Vec3d(0.312689, 3.28967, 0),
				OpenMesh::Vec3d(-0.901575, 4.85807, 0),
				OpenMesh::Vec3d(-1.23977, 3.5368, 0),
				OpenMesh::Vec3d(-1.9027, 4.60764, 0),
				OpenMesh::Vec3d(-2.60159, 4.08557, 0),
				OpenMesh::Vec3d(-3.67377, 2.94282, 0),
				OpenMesh::Vec3d(-4.19734, 1.3431, 0),
				OpenMesh::Vec3d(-2.67894, 0.569752, 0),
				OpenMesh::Vec3d(-4.59146, 0.273326, 0),
				OpenMesh::Vec3d(-5.02472, -2.5631, 0),
				OpenMesh::Vec3d(-3.32428, -1.2692, 0),
				OpenMesh::Vec3d(-2.25433, -1.02231, 0),
				OpenMesh::Vec3d(-2.9142, -1.57256, 0),
				OpenMesh::Vec3d(-3.11938, -1.99522, 0),
				OpenMesh::Vec3d(-2.32945, -2.77795, 0),
				OpenMesh::Vec3d(-2.39632, -3.96978, 0),
				OpenMesh::Vec3d(-0.151571, -4.57271, 0),
			};
			//pang_fish
			CC_points = { OpenMesh::Vec3d(4.01339, -0.289042, 0),
	OpenMesh::Vec3d(3.85961, 0.141488, 0),
	OpenMesh::Vec3d(3.93366, 0.753776, 0),
	OpenMesh::Vec3d(0.117864, 1.30315, 0),
	OpenMesh::Vec3d(-3.8418, 0.664261, 0),
	OpenMesh::Vec3d(-3.92619, -0.0525603, 0),
	OpenMesh::Vec3d(-3.80339, -0.709607, 0),
	OpenMesh::Vec3d(0.293412, -1.60183, 0),
			};
			auto CC_pointsreal = CC_points;
			for (int i = 0; i < dividecages; i++)
			{
				auto linearcage1 = subdivideCage2(CC_pointsreal);
				CC_pointsreal = linearcage1;
			}

			for (const auto& point : CC_pointsreal) {
				CC_points2d.emplace_back(point[0], point[1]); // 保留 x 和 y 分量
			}
			//LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\ball.obj");
			//LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\human.obj");
			//LoadMesh("E:\\codes\\project_BiHC\\mesh\\xiyi.obj");
			LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\pang_fish.obj");

			CC_mesh = createMeshFromCurveCage(CC_points);
			curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);//操作的cage

			auto CC_mesh_real = createMeshFromCurveCage(CC_pointsreal);
			curvecage2_real = CCpoints_fromCCmesh(CC_mesh_real, degree);//实际 的网格

			auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
			for (auto vh : CC_mesh.vertices())
			{
				CagevertexState[vh] = NotSelected;
			}
			std::cout << "test1" << std::endl;
			auto start_timek = std::chrono::high_resolution_clock::now();
			//BH2ConstructMatrix4OffSet();
			//BH2ConstructMatrix4OffSetVirtual();
			BH2ConstructMatrix4OffSetVirtual_edge();
			auto end_timek = std::chrono::high_resolution_clock::now();
			auto durationk = std::chrono::duration_cast<std::chrono::milliseconds>(end_timek - start_timek).count();
			std::cout << "算矩阵运行时间: " << durationk << " 毫秒" << std::endl;

			auto start_timec = std::chrono::high_resolution_clock::now();
			calculate_bih_weight222New();
			auto end_timec = std::chrono::high_resolution_clock::now();
			auto durationc = std::chrono::duration_cast<std::chrono::milliseconds>(end_timec - start_timec).count();
			std::cout << "算坐标运行时间: " << durationc << " 毫秒" << std::endl;

			auto vertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(mesh, "vertexState");
			for (auto vh : mesh.vertices())
			{
				vertexState[vh] = NotSelected;
			}
			Set_Texture_coord();//设置纹理

			Mesh deformedMesh;
			deformedMesh.assign(mesh);
			deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
			MeshTools::AssignPoints(mesh, deformedMesh);
			update();
		}
		if (0) {
			int N = 4;//球 4
			curvecage2.resize(N);
			//通过curvecage2计算cc_points;
			//pang_fish
			CC_points = { OpenMesh::Vec3d(4.01339, -0.289042, 0),
	OpenMesh::Vec3d(3.85961, 0.141488, 0),
	OpenMesh::Vec3d(3.93366, 0.753776, 0),
	OpenMesh::Vec3d(0.117864, 1.30315, 0),
	OpenMesh::Vec3d(-3.8418, 0.664261, 0),
	OpenMesh::Vec3d(-3.92619, -0.0525603, 0),
	OpenMesh::Vec3d(-3.80339, -0.709607, 0),
	OpenMesh::Vec3d(0.293412, -1.60183, 0),
			};
			auto CC_pointsreal = CC_points;
			for (int i = 0; i < dividecages; i++)
			{
				auto linearcage1 = subdivideCage2(CC_pointsreal);
				CC_pointsreal = linearcage1;
			}

			for (const auto& point : CC_pointsreal) {
				CC_points2d.emplace_back(point[0], point[1]); // 保留 x 和 y 分量
			}
			LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\pang_fish.obj");

			CC_mesh = createMeshFromCurveCage(CC_points);
			curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);//操作的cage

			auto CC_mesh_real = createMeshFromCurveCage(CC_pointsreal);
			curvecage2_real = CCpoints_fromCCmesh(CC_mesh_real, degree);//实际 的网格

			auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
			for (auto vh : CC_mesh.vertices())
			{
				CagevertexState[vh] = NotSelected;
			}
			std::cout << "test1" << std::endl;
			auto start_timek = std::chrono::high_resolution_clock::now();
			//BH2ConstructMatrix4OffSet();
			//BH2ConstructMatrix4OffSetVirtual();
			BH2ConstructMatrix4OffSetVirtual_edge();
			auto end_timek = std::chrono::high_resolution_clock::now();
			auto durationk = std::chrono::duration_cast<std::chrono::milliseconds>(end_timek - start_timek).count();
			std::cout << "算矩阵运行时间: " << durationk << " 毫秒" << std::endl;

			auto start_timec = std::chrono::high_resolution_clock::now();
			calculate_bih_weight222New();
			auto end_timec = std::chrono::high_resolution_clock::now();
			auto durationc = std::chrono::duration_cast<std::chrono::milliseconds>(end_timec - start_timec).count();
			std::cout << "算坐标运行时间: " << durationc << " 毫秒" << std::endl;

			auto vertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(mesh, "vertexState");
			for (auto vh : mesh.vertices())
			{
				vertexState[vh] = NotSelected;
			}
			Set_Texture_coord();//设置纹理

			Mesh deformedMesh;
			deformedMesh.assign(mesh);
			deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
			MeshTools::AssignPoints(mesh, deformedMesh);
			update();
		}
	}
	else if (degree == 3) {

		int N = 4;//球 4
		curvecage2.resize(N);
		//通过curvecage2计算cc_points;

		//ball+3
		/*CC_points = {
			6.5 * OpenMesh::Vec3d(0,-1,0),
			6.5 * OpenMesh::Vec3d(0.6,-1,0),
			6.5 * OpenMesh::Vec3d(1,-0.6,0),
			6.5 * OpenMesh::Vec3d(1,0,0),
			6.5 * OpenMesh::Vec3d(1,0.6,0),
			6.5 * OpenMesh::Vec3d(0.6,1,0),
			6.5 * OpenMesh::Vec3d(0,1,0),
			6.5 * OpenMesh::Vec3d(-0.6,1,0),
			6.5 * OpenMesh::Vec3d(-1,0.6,0),
			6.5 * OpenMesh::Vec3d(-1,0,0),
			6.5 * OpenMesh::Vec3d(-1,-0.6,0),
			6.5 * OpenMesh::Vec3d(-0.6,-1,0),
		};*/
		{
			//CC_points = {//pangxie
	  //           OpenMesh::Vec3d(7.71977, -2.05287, 0),
   //              OpenMesh::Vec3d(16.1661, 2.5924, 0),
   //              OpenMesh::Vec3d(22.5491, -0.870733, 0),
   //              OpenMesh::Vec3d(15.6577, -8.58216, 0),
   //              OpenMesh::Vec3d(26.8967, -7.59486, 0),
   //              OpenMesh::Vec3d(21.084, 11.3199, 0),
   //              OpenMesh::Vec3d(7.68061, 1.27629, 0),
   //              OpenMesh::Vec3d(11.5959, 6.63227, 0),
   //              OpenMesh::Vec3d(24.6401, 7.52288, 0),
   //              OpenMesh::Vec3d(21.7966, -5.4645, 0),
   //              OpenMesh::Vec3d(31.1961, 2.17972, 0),
   //              OpenMesh::Vec3d(15.6549, 13.7466, 0),
   //              OpenMesh::Vec3d(7.82502, 4.58309, 0),
   //              OpenMesh::Vec3d(11.8374, 11.0923, 0),
   //              OpenMesh::Vec3d(20.9685, 10.4649, 0),
   //              OpenMesh::Vec3d(24.9294, 1.87976, 0),
   //              OpenMesh::Vec3d(27.8247, 9.55625, 0),
   //              OpenMesh::Vec3d(14.2738, 16.6223, 0),
   //              OpenMesh::Vec3d(5.4765, 7.35184, 0),
   //              OpenMesh::Vec3d(8.64119, 11.865, 0),
   //              OpenMesh::Vec3d(14.7017, 15.1746, 0),
   //              OpenMesh::Vec3d(23.1277, 9.7121, 0),
   //              OpenMesh::Vec3d(19.424, 19.1598, 0),
   //              OpenMesh::Vec3d(6.83002, 15.4013, 0),
   //              OpenMesh::Vec3d(2.16398, 7.18829, 0),
   //              OpenMesh::Vec3d(-0.0248164, 9.29763, 0),
   //              OpenMesh::Vec3d(-1.17408, 9.21065, 0),
   //              OpenMesh::Vec3d(-3.33054, 6.62634, 0),
   //              OpenMesh::Vec3d(-8.85175, 14.7474, 0),
   //              OpenMesh::Vec3d(-24.3841, 17.0936, 0),
   //              OpenMesh::Vec3d(-23.6175, 7.39743, 0),
   //              OpenMesh::Vec3d(-18.8441, 13.6221, 0),
   //              OpenMesh::Vec3d(-10.5837, 11.5502, 0),
   //              OpenMesh::Vec3d(-5.13643, 5.07839, 0),
   //              OpenMesh::Vec3d(-5.27052, 4.97835, 0),
   //              OpenMesh::Vec3d(-5.46014, 4.84129, 0),
   //              OpenMesh::Vec3d(-5.64977, 4.70424, 0),
   //              OpenMesh::Vec3d(-12.9059, 15.3053, 0),
   //              OpenMesh::Vec3d(-28.4601, 9.29942, 0),
   //              OpenMesh::Vec3d(-24.863, 0.0668226, 0),
   //              OpenMesh::Vec3d(-22.7747, 8.29837, 0),
   //              OpenMesh::Vec3d(-14.3986, 9.84779, 0),
   //              OpenMesh::Vec3d(-7.0058, 3.14714, 0),
   //              OpenMesh::Vec3d(-18.5345, 12.5865, 0),
   //              OpenMesh::Vec3d(-30.6453, -0.223078, 0),
   //              OpenMesh::Vec3d(-21.5541, -7.27411, 0),
   //              OpenMesh::Vec3d(-24.3589, 0.197288, 0),
   //              OpenMesh::Vec3d(-18.8381, 7.34974, 0),
   //              OpenMesh::Vec3d(-7.4344, 0.51362, 0),
   //              OpenMesh::Vec3d(-24.585, 8.96755, 0),
   //              OpenMesh::Vec3d(-25.4714, -12.1974, 0),
   //              OpenMesh::Vec3d(-13.6432, -10.1693, 0),
   //              OpenMesh::Vec3d(-22.614, -4.87779, 0),
   //              OpenMesh::Vec3d(-17.811, 3.67923, 0),
   //              OpenMesh::Vec3d(-7.53781, -3.00233, 0),
   //              OpenMesh::Vec3d(-23.8508, 3.73205, 0),
   //              OpenMesh::Vec3d(-18.0268, -14.6281, 0),
   //              OpenMesh::Vec3d(0.581672, -14.6728, 0),
   //              OpenMesh::Vec3d(-1.23569, -8.99517, 0),
   //              OpenMesh::Vec3d(-10.3154, -6.40558, 0),
   //              OpenMesh::Vec3d(-14.2051, -5.46234, 0),
   //              OpenMesh::Vec3d(-10.7249, -5.26371, 0),
   //              OpenMesh::Vec3d(-4.0724, -6.50565, 0),
   //              OpenMesh::Vec3d(0.270762, -12.5408, 0),
   //              OpenMesh::Vec3d(6.57959, -7.9814, 0),
   //              OpenMesh::Vec3d(9.1306, -3.60342, 0),
   //              OpenMesh::Vec3d(13.4053, -3.81022, 0),
   //              OpenMesh::Vec3d(11.9635, -6.90228, 0),
   //              OpenMesh::Vec3d(4.07802, -8.25055, 0),
   //              OpenMesh::Vec3d(0.654098, -13.3543, 0),
   //              OpenMesh::Vec3d(3.50707, -16.7318, 0),
   //              OpenMesh::Vec3d(8.3762, -13.8882, 0),
   //              OpenMesh::Vec3d(12.9466, -9.91377, 0),
   //              OpenMesh::Vec3d(19.5164, -2.8494, 0),
   //              OpenMesh::Vec3d(19.745, 1.90087, 0),
			//};
		}
		{
			//CC_points = { //circle
			//OpenMesh::Vec3d(3.45289, 1.63941, 0),
			//OpenMesh::Vec3d(4.48355, 0.137393, 0),
			//OpenMesh::Vec3d(4.01564, -1.4928, 0),
			//OpenMesh::Vec3d(3.44068, -3.85162, 0),
			//OpenMesh::Vec3d(6.55334, -0.345064, 0),
			//OpenMesh::Vec3d(3.90656, 6.20451, 0),
			//OpenMesh::Vec3d(-1.69168, 3.85054, 0),
			//OpenMesh::Vec3d(-0.0258138, 5.08684, 0),
			//OpenMesh::Vec3d(1.91392, 4.70734, 0),
			//OpenMesh::Vec3d(3.83488, 3.89295, 0),
			//OpenMesh::Vec3d(1.07448, 7.12438, 0),
			//OpenMesh::Vec3d(-5.90614, 4.59064, 0),
			//OpenMesh::Vec3d(-3.65812, -1.22062, 0),
			//OpenMesh::Vec3d(-4.84896, 1.04082, 0),
			//OpenMesh::Vec3d(-4.17104, 2.38932, 0),
			//OpenMesh::Vec3d(-3.86462, 4.22689, 0),
			//OpenMesh::Vec3d(-6.53473, 1.87253, 0),
			//OpenMesh::Vec3d(-4.64774, -5.87751, 0),
			//OpenMesh::Vec3d(1.34646, -3.2845, 0),
			//OpenMesh::Vec3d(-0.105171, -4.56524, 0),
			//OpenMesh::Vec3d(-2.44788, -4.06556, 0),
			//OpenMesh::Vec3d(-4.21109, -3.22378, 0),
			//OpenMesh::Vec3d(-1.36415, -6.68839, 0),
			//OpenMesh::Vec3d(5.46868, -4.0388, 0),
			//};
		}
		//flower
		{
			/*CC_points = {
					OpenMesh::Vec3d(0.060138, -2.34968, 0),
OpenMesh::Vec3d(0.167533, -1.16113, 0),
OpenMesh::Vec3d(0.304982, 0.160104, 0),
OpenMesh::Vec3d(0.231798, 1.08177, 0),
OpenMesh::Vec3d(0.61252, 2.32314, 0),
OpenMesh::Vec3d(0.771864, 3.13087, 0),
OpenMesh::Vec3d(0.855257, 4.5897, 0),
OpenMesh::Vec3d(2.09554, 4.91859, 0),
OpenMesh::Vec3d(2.47687, 5.80984, 0),
OpenMesh::Vec3d(2.67184, 7.06251, 0),
OpenMesh::Vec3d(1.05076, 8.34497, 0),
OpenMesh::Vec3d(-1.00333, 8.56513, 0),
OpenMesh::Vec3d(-3.01162, 7.65609, 0),
OpenMesh::Vec3d(-2.46392, 6.1255, 0),
OpenMesh::Vec3d(-1.33722, 5.03078, 0),
OpenMesh::Vec3d(-0.552003, 4.00657, 0),
OpenMesh::Vec3d(-0.0860061, 2.21267, 0),
OpenMesh::Vec3d(0.0878497, 0.616274, 0),
OpenMesh::Vec3d(-0.0636332, -0.969635, 0),
OpenMesh::Vec3d(-0.469408, 0.4811, 0),
OpenMesh::Vec3d(-1.36141, 0.898247, 0),
OpenMesh::Vec3d(-2.47641, 1.32553, 0),
OpenMesh::Vec3d(-2.85447, -0.680847, 0),
OpenMesh::Vec3d(-1.57427, -0.75945, 0),
OpenMesh::Vec3d(-0.29709, -1.64989, 0),
OpenMesh::Vec3d(-0.284548, -4.19343, 0),
OpenMesh::Vec3d(-0.449725, -7.19035, 0),
OpenMesh::Vec3d(-0.0458234, -9.10946, 0),
OpenMesh::Vec3d(0.607011, -6.40262, 0),
OpenMesh::Vec3d(-0.378727, -4.82229, 0),
OpenMesh::Vec3d(0.125836, -2.84884, 0),
OpenMesh::Vec3d(0.941884, -1.5343, 0),
OpenMesh::Vec3d(2.07567, -2.26778, 0),
OpenMesh::Vec3d(2.4943, -2.94274, 0),
OpenMesh::Vec3d(4.17284, -0.459165, 0),
OpenMesh::Vec3d(0.512756, -0.0850323, 0),
			};*/
		}

		//xiyi
//		{
//			CC_points = { //xiyi
//OpenMesh::Vec3d(4.8757, 0.872087, 0),
//OpenMesh::Vec3d(5.03271, 0.36652, 0),
//OpenMesh::Vec3d(4.43626, 0.0627833, 0),
//OpenMesh::Vec3d(3.96134, 0.159551, 0),
//OpenMesh::Vec3d(3.47603, 0.311732, 0),
//OpenMesh::Vec3d(2.88748, 0.628007, 0),
//OpenMesh::Vec3d(2.29758, 0.985943, 0),
//OpenMesh::Vec3d(1.85205, 1.32421, 0),
//OpenMesh::Vec3d(1.40636, 1.68818, 0),
//OpenMesh::Vec3d(0.899758, 1.92868, 0),
//OpenMesh::Vec3d(-6.36326, 3.14212, 0),
//OpenMesh::Vec3d(-6.99906, 0.160185, 0),
//OpenMesh::Vec3d(-3.73234, -0.87026, 0),
//OpenMesh::Vec3d(-4.44834, -2.77133, 0),
//OpenMesh::Vec3d(-1.61845, -2.46282, 0),
//OpenMesh::Vec3d(1.3063, -2.28422, 0),
//OpenMesh::Vec3d(2.40598, -1.75447, 0),
//OpenMesh::Vec3d(3.4009, -1.70409, 0),
//OpenMesh::Vec3d(3.97396, -0.721832, 0),
//OpenMesh::Vec3d(4.74744, -0.557083, 0),
//OpenMesh::Vec3d(5.70762, -0.28611, 0),
//OpenMesh::Vec3d(5.46999, 0.883595, 0),
//OpenMesh::Vec3d(5.36836, 1.28816, 0),
//OpenMesh::Vec3d(5.04465, 1.54012, 0),
//OpenMesh::Vec3d(4.5651, 1.57992, 0),
//OpenMesh::Vec3d(4.14418, 1.59494, 0),
//OpenMesh::Vec3d(3.87688, 1.28838, 0),
//OpenMesh::Vec3d(3.82461, 0.978126, 0),
//OpenMesh::Vec3d(3.8078, 0.639398, 0),
//OpenMesh::Vec3d(4.06674, 0.303346, 0),
//OpenMesh::Vec3d(4.48767, 0.409093, 0),
//OpenMesh::Vec3d(4.81358, 0.524081, 0),
//OpenMesh::Vec3d(4.8452, 0.822595, 0),
//OpenMesh::Vec3d(4.78568, 0.938214, 0),
//OpenMesh::Vec3d(4.59935, 1.18666, 0),
//OpenMesh::Vec3d(4.20859, 1.13957, 0),
//OpenMesh::Vec3d(4.32079, 0.832109, 0),
//OpenMesh::Vec3d(4.41925, 0.892305, 0),
//OpenMesh::Vec3d(4.47836, 0.901803, 0),
//OpenMesh::Vec3d(4.50694, 0.852756, 0),
//OpenMesh::Vec3d(4.51046, 0.806951, 0),
//OpenMesh::Vec3d(4.4966, 0.764481, 0),
//OpenMesh::Vec3d(4.45023, 0.728632, 0),
//OpenMesh::Vec3d(4.30353, 0.72234, 0),
//OpenMesh::Vec3d(4.24795, 0.847824, 0),
//OpenMesh::Vec3d(4.25476, 0.941717, 0),
//OpenMesh::Vec3d(4.25256, 1.06728, 0),
//OpenMesh::Vec3d(4.38782, 1.18284, 0),
//OpenMesh::Vec3d(4.53972, 1.18326, 0),
//OpenMesh::Vec3d(4.69637, 1.15446, 0),
//OpenMesh::Vec3d(4.79747, 1.05328, 0)
//};
			//{
			//	CC_points = { //dol
			//OpenMesh::Vec3d(0.63761, -0.660277, 0),
			//OpenMesh::Vec3d(3.14003, -0.732556, 0),
			//OpenMesh::Vec3d(3.0645, 1.3484, 0),
			//OpenMesh::Vec3d(4.38427, 2.42837, 0),
			//OpenMesh::Vec3d(5.56291, 3.20101, 0),
			//OpenMesh::Vec3d(7.65234, 4.09488, 0),
			//OpenMesh::Vec3d(7.27868, 6.14083, 0),
			//OpenMesh::Vec3d(6.2098, 7.90869, 0),
			//OpenMesh::Vec3d(3.90938, 9.23955, 0),
			//OpenMesh::Vec3d(-0.0891882, 9.18919, 0),
			//OpenMesh::Vec3d(-4.56112, 8.60392, 0),
			//OpenMesh::Vec3d(-6.77834, 6.79633, 0),
			//OpenMesh::Vec3d(-8.20011, 1.86613, 0),
			//OpenMesh::Vec3d(-8.71747, -1.29677, 0),
			//OpenMesh::Vec3d(-8.08676, -3.87649, 0),
			//OpenMesh::Vec3d(-5.88127, -6.36403, 0),
			//OpenMesh::Vec3d(-2.82217, -9.70667, 0),
			//OpenMesh::Vec3d(-0.626853, -11.4433, 0),
			//OpenMesh::Vec3d(1.39634, -8.54625, 0),
			//OpenMesh::Vec3d(5.22708, -1.15903, 0),
			//OpenMesh::Vec3d(-1.20747, -3.39995, 0),
			//OpenMesh::Vec3d(-2.09824, -2.36111, 0),
			//OpenMesh::Vec3d(-1.84791, -1.38715, 0),
			//OpenMesh::Vec3d(-0.190255, -0.48011, 0),
			//	};
			//}
//			{
//				CC_points = { //chong
//OpenMesh::Vec3d(2.59384, -2.414, 0),
//OpenMesh::Vec3d(3.47135, -2.24444, 0),
//OpenMesh::Vec3d(3.37897, -1.0907, 0),
//OpenMesh::Vec3d(2.60176, -1.10587, 0),
//OpenMesh::Vec3d(1.79845, -1.03601, 0),
//OpenMesh::Vec3d(1.52883, 0.611184, 0),
//OpenMesh::Vec3d(1.02797, 0.973675, 0),
//OpenMesh::Vec3d(0.40327, 1.50463, 0),
//OpenMesh::Vec3d(-0.84313, 1.48853, 0),
//OpenMesh::Vec3d(-1.63302, 0.406693, 0),
//OpenMesh::Vec3d(-2.18769, -0.252838, 0),
//OpenMesh::Vec3d(-1.72495, -1.37995, 0),
//OpenMesh::Vec3d(-2.92386, -1.22219, 0),
//OpenMesh::Vec3d(-3.43279, -1.19293, 0),
//OpenMesh::Vec3d(-3.55276, -2.29937, 0),
//OpenMesh::Vec3d(-2.99887, -2.37095, 0),
//OpenMesh::Vec3d(-0.550955, -2.40795, 0),
//OpenMesh::Vec3d(-0.912559, -0.896285, 0),
//OpenMesh::Vec3d(-0.720669, -0.424833, 0),
//OpenMesh::Vec3d(-0.579261, -0.0283064, 0),
//OpenMesh::Vec3d(0.177964, -0.0227886, 0),
//OpenMesh::Vec3d(0.254243, -0.368519, 0),
//OpenMesh::Vec3d(0.854219, -2.70714, 0),
//OpenMesh::Vec3d(1.89469, -2.51623, 0),
//				};
//			}
//			{
//				CC_points = { //yezi
//OpenMesh::Vec3d(1.28005, 0.747643, 0),
//OpenMesh::Vec3d(1.44043, 0.844831, 0),
//OpenMesh::Vec3d(2.78489, 2.0156, 0),
//OpenMesh::Vec3d(0.599109, 1.41282, 0),
//OpenMesh::Vec3d(0.19442, 1.61294, 0),
//OpenMesh::Vec3d(-0.419939, 3.77188, 0),
//OpenMesh::Vec3d(-0.572, 1.67275, 0),
//OpenMesh::Vec3d(-1.0034, 1.50038, 0),
//OpenMesh::Vec3d(-2.86634, 2.46019, 0),
//OpenMesh::Vec3d(-1.10456, 0.78307, 0),
//OpenMesh::Vec3d(-2.62032, 0.228932, 0),
//OpenMesh::Vec3d(-1.9933, -0.408598, 0),
//OpenMesh::Vec3d(-1.28621, -0.174901, 0),
//OpenMesh::Vec3d(-0.201279, 0.516323, 0),
//OpenMesh::Vec3d(-1.58054, -0.456919, 0),
//OpenMesh::Vec3d(-1.65371, -2.05498, 0),
//OpenMesh::Vec3d(-1.63645, -3.24779, 0),
//OpenMesh::Vec3d(-0.569404, -3.38407, 0),
//OpenMesh::Vec3d(-0.795787, -1.94973, 0),
//OpenMesh::Vec3d(-1.15888, -0.451575, 0),
//OpenMesh::Vec3d(-0.131823, 0.466649, 0),
//OpenMesh::Vec3d(0.0213392, -0.514306, 0),
//OpenMesh::Vec3d(0.269251, -1.93744, 0),
//OpenMesh::Vec3d(1.23303, -1.42498, 0),
//OpenMesh::Vec3d(0.763523, -0.0912654, 0),
//OpenMesh::Vec3d(1.84378, -0.351189, 0),
//OpenMesh::Vec3d(2.87188, 0.308658, 0),
// };
//			}
		//{
		//	CC_points = { // hat
		//		OpenMesh::Vec3d(0.804892, -0.32719, 0),
		//		OpenMesh::Vec3d(0.692015, 0.231539, 0),
		//		OpenMesh::Vec3d(0.547193, 0.7767, 0),
		//		OpenMesh::Vec3d(0.476686, 1.26844, 0),
		//		OpenMesh::Vec3d(0.382696, 1.7116, 0),
		//		OpenMesh::Vec3d(0.325819, 2.07537, 0),
		//		OpenMesh::Vec3d(-0.00352344, 2.70196, 0),
		//		OpenMesh::Vec3d(-0.410277, 2.13397, 0),
		//		OpenMesh::Vec3d(-0.374559, 1.70114, 0),
		//		OpenMesh::Vec3d(-0.434512, 1.19587, 0),
		//		OpenMesh::Vec3d(-0.508936, 0.621879, 0),
		//		OpenMesh::Vec3d(-0.647465, 0.0773967, 0),
		//		OpenMesh::Vec3d(-0.799976, -0.459321, 0),
		//		OpenMesh::Vec3d(-0.88359, -0.8571, 0),
		//		OpenMesh::Vec3d(-1.43117, -2.31645, 0),
		//		OpenMesh::Vec3d(-0.862172, -2.63141, 0),
		//		OpenMesh::Vec3d(-0.42769, -2.76733, 0),
		//		OpenMesh::Vec3d(-0.174053, -2.76644, 0),
		//		OpenMesh::Vec3d(0.0921805, -2.76908, 0),
		//		OpenMesh::Vec3d(0.296833, -2.7896, 0),
		//		OpenMesh::Vec3d(0.544134, -2.79181, 0),
		//		OpenMesh::Vec3d(0.949696, -2.61659, 0),
		//		OpenMesh::Vec3d(1.4252, -2.32336, 0),
		//		OpenMesh::Vec3d(0.895589, -0.782844, 0)
		//	};
		//}
//		{ // seahorse
//			CC_points = { // seahorse
//OpenMesh::Vec3d(3.61019, -5.53027, 0),
//OpenMesh::Vec3d(3.60908, -3.95251, 0),
//OpenMesh::Vec3d(3.72919, -1.53567, 0),
//OpenMesh::Vec3d(3.84245, -0.278068, 0),
//OpenMesh::Vec3d(3.82146, 1.48578, 0),
//OpenMesh::Vec3d(4.98234, 3.07104, 0),
//OpenMesh::Vec3d(4.83917, 6.5945, 0),
//OpenMesh::Vec3d(4.69292, 9.47414, 0),
//OpenMesh::Vec3d(3.09747, 10.8991, 0),
//OpenMesh::Vec3d(-0.273063, 9.57201, 0),
//OpenMesh::Vec3d(-1.93806, 8.70603, 0),
//OpenMesh::Vec3d(-0.993479, 5.67479, 0),
//OpenMesh::Vec3d(-4.05513, 6.09394, 0),
//OpenMesh::Vec3d(-5.00754, 6.23271, 0),
//OpenMesh::Vec3d(-6.41301, 6.73317, 0),
//OpenMesh::Vec3d(-4.92627, 2.78679, 0),
//OpenMesh::Vec3d(-3.68057, 4.54012, 0),
//OpenMesh::Vec3d(0.37544, 4.99386, 0),
//OpenMesh::Vec3d(-0.112873, 4.07275, 0),
//OpenMesh::Vec3d(-1.75945, 2.67492, 0),
//OpenMesh::Vec3d(-2.1299, 0.621476, 0),
//OpenMesh::Vec3d(-1.29587, -0.0891098, 0),
//OpenMesh::Vec3d(-0.720383, -0.684836, 0),
//OpenMesh::Vec3d(0.965407, -1.92763, 0),
//OpenMesh::Vec3d(1.08476, -4.15547, 0),
//OpenMesh::Vec3d(1.15867, -5.02685, 0),
//OpenMesh::Vec3d(1.19137, -6.2054, 0),
//OpenMesh::Vec3d(1.16041, -7.17045, 0),
//OpenMesh::Vec3d(1.10901, -8.05413, 0),
//OpenMesh::Vec3d(1.05779, -8.89826, 0),
//OpenMesh::Vec3d(1.48802, -10.2238, 0),
//OpenMesh::Vec3d(3.02485, -10.4425, 0),
//OpenMesh::Vec3d(3.65898, -9.51771, 0),
//OpenMesh::Vec3d(3.61107, -8.61301, 0),
//OpenMesh::Vec3d(3.62334, -8.0092, 0),
//OpenMesh::Vec3d(3.6258, -7.31019, 0),
//			};
//		}
		{ // jinglin
//			CC_points = { // jinglin
//OpenMesh::Vec3d(2.52675, 0.119248, 0),
//OpenMesh::Vec3d(6.53328, -0.766661, 0),
//OpenMesh::Vec3d(7.21162, 3.11061, 0),
//OpenMesh::Vec3d(1.51942, 2.44505, 0),
//OpenMesh::Vec3d(3.83561, 2.7719, 0),
//OpenMesh::Vec3d(3.17645, 3.40348, 0),
//OpenMesh::Vec3d(1.86607, 3.85958, 0),
//OpenMesh::Vec3d(1.43134, 4.69589, 0),
//OpenMesh::Vec3d(0.739275, 5.87505, 0),
//OpenMesh::Vec3d(0.109111, 7.07222, 0),
//OpenMesh::Vec3d(-0.947615, 5.67795, 0),
//OpenMesh::Vec3d(-1.62956, 4.58536, 0),
//OpenMesh::Vec3d(-1.80535, 3.94374, 0),
//OpenMesh::Vec3d(-3.27374, 3.39316, 0),
//OpenMesh::Vec3d(-3.77685, 2.75569, 0),
//OpenMesh::Vec3d(-1.4922, 2.62727, 0),
//OpenMesh::Vec3d(-4.11956, 2.51026, 0),
//OpenMesh::Vec3d(-4.1844, 1.86593, 0),
//OpenMesh::Vec3d(-2.31662, 1.44614, 0),
//OpenMesh::Vec3d(-3.16347, 1.1252, 0),
//OpenMesh::Vec3d(-4.38799, 1.41574, 0),
//OpenMesh::Vec3d(-6.67361, 2.35372, 0),
//OpenMesh::Vec3d(-6.49779, 0.0348338, 0),
//OpenMesh::Vec3d(-4.45218, -0.343947, 0),
//OpenMesh::Vec3d(-2.31602, 0.254836, 0),
//OpenMesh::Vec3d(-3.48275, -0.399644, 0),
//OpenMesh::Vec3d(-4.15186, -1.13327, 0),
//OpenMesh::Vec3d(-4.4047, -3.61056, 0),
//OpenMesh::Vec3d(-2.65125, -2.75862, 0),
//OpenMesh::Vec3d(-1.98806, -2.28102, 0),
//OpenMesh::Vec3d(-1.6909, -3.68632, 0),
//OpenMesh::Vec3d(-1.6105, -5.08009, 0),
//OpenMesh::Vec3d(-1.686, -6.03777, 0),
//OpenMesh::Vec3d(-2.18741, -8.09184, 0),
//OpenMesh::Vec3d(-0.328675, -8.19098, 0),
//OpenMesh::Vec3d(-0.0389428, -7.00424, 0),
//OpenMesh::Vec3d(-0.232178, -5.09547, 0),
//OpenMesh::Vec3d(-0.23406, -3.13166, 0),
//OpenMesh::Vec3d(0.323718, -4.1617, 0),
//OpenMesh::Vec3d(0.246207, -4.94521, 0),
//OpenMesh::Vec3d(0.128781, -6.16547, 0),
//OpenMesh::Vec3d(0.637838, -10.1118, 0),
//OpenMesh::Vec3d(2.27445, -6.96023, 0),
//OpenMesh::Vec3d(1.8335, -4.91977, 0),
//OpenMesh::Vec3d(1.72692, -3.58434, 0),
//OpenMesh::Vec3d(2.22187, -2.52686, 0),
//OpenMesh::Vec3d(4.38364, -4.85402, 0),
//OpenMesh::Vec3d(5.97979, -2.01225, 0),
//			};
		}
		//Octopos
		{
//			CC_points = { //octopus
// OpenMesh::Vec3d(8.57042, 3.297, 0),
//OpenMesh::Vec3d(5.09424, 1.93482, 0),
//OpenMesh::Vec3d(8.81644, -0.913078, 0),
//OpenMesh::Vec3d(6.50689, -3.68536, 0),
//OpenMesh::Vec3d(5.42654, -1.87831, 0),
//OpenMesh::Vec3d(4.92811, 1.19895, 0),
//OpenMesh::Vec3d(5.93302, 3.06514, 0),
//OpenMesh::Vec3d(6.39359, 2.98059, 0),
//OpenMesh::Vec3d(6.76971, 2.94039, 0),
//OpenMesh::Vec3d(7.1323, 3.39599, 0),
//OpenMesh::Vec3d(7.34691, 3.96736, 0),
//OpenMesh::Vec3d(7.36178, 4.91438, 0),
//OpenMesh::Vec3d(6.49071, 5.0889, 0),
//OpenMesh::Vec3d(7.77231, 9.87716, 0),
//OpenMesh::Vec3d(5.30888, 14.7788, 0),
//OpenMesh::Vec3d(-0.841746, 14.3125, 0),
//OpenMesh::Vec3d(-5.90767, 11.3197, 0),
//OpenMesh::Vec3d(-8.86451, 3.55846, 0),
//OpenMesh::Vec3d(-0.246632, 4.78125, 0),
//OpenMesh::Vec3d(1.06736, 1.00327, 0),
//OpenMesh::Vec3d(-4.23325, 0.219585, 0),
//OpenMesh::Vec3d(-8.03561, 3.02382, 0),
//OpenMesh::Vec3d(-8.08751, 2.08127, 0),
//OpenMesh::Vec3d(-7.52196, 0.833628, 0),
//OpenMesh::Vec3d(-6.06773, 0.106026, 0),
//OpenMesh::Vec3d(-7.90343, -1.09784, 0),
//OpenMesh::Vec3d(-9.28057, -2.77283, 0),
//OpenMesh::Vec3d(-7.6208, -5.78163, 0),
//OpenMesh::Vec3d(-8.57419, -6.68359, 0),
//OpenMesh::Vec3d(-8.68614, -8.01901, 0),
//OpenMesh::Vec3d(-8.06132, -10.9547, 0),
//OpenMesh::Vec3d(-6.74283, -6.93736, 0),
//OpenMesh::Vec3d(-4.59648, -5.33218, 0),
//OpenMesh::Vec3d(-2.05936, -4.13197, 0),
//OpenMesh::Vec3d(-3.09482, -7.04246, 0),
//OpenMesh::Vec3d(-9.21992, -12.7162, 0),
//OpenMesh::Vec3d(-2.27186, -13.953, 0),
//OpenMesh::Vec3d(-2.95275, -12.5256, 0),
//OpenMesh::Vec3d(-3.79382, -11.3406, 0),
//OpenMesh::Vec3d(-3.42902, -9.89676, 0),
//OpenMesh::Vec3d(-2.6323, -11.6362, 0),
//OpenMesh::Vec3d(-1.81066, -12.1583, 0),
//OpenMesh::Vec3d(-0.00107587, -12.4131, 0),
//OpenMesh::Vec3d(-2.69772, -8.66487, 0),
//OpenMesh::Vec3d(-1.78497, -7.37903, 0),
//OpenMesh::Vec3d(0.488619, -4.78304, 0),
//OpenMesh::Vec3d(-0.0659694, -6.98257, 0),
//OpenMesh::Vec3d(-0.438017, -8.1058, 0),
//OpenMesh::Vec3d(0.945469, -9.78723, 0),
//OpenMesh::Vec3d(1.71534, -8.54231, 0),
//OpenMesh::Vec3d(1.34671, -7.00428, 0),
//OpenMesh::Vec3d(1.89121, -5.32397, 0),
//OpenMesh::Vec3d(3.61222, -8.87285, 0),
//OpenMesh::Vec3d(2.05656, -8.95106, 0),
//OpenMesh::Vec3d(1.51134, -12.1472, 0),
//OpenMesh::Vec3d(7.13949, -10.1638, 0),
//OpenMesh::Vec3d(2.57694, -5.41496, 0),
//OpenMesh::Vec3d(4.12527, -0.841089, 0),
//OpenMesh::Vec3d(4.43461, -3.18152, 0),
//OpenMesh::Vec3d(5.09308, -5.72131, 0),
//OpenMesh::Vec3d(7.13664, -5.11346, 0),
//OpenMesh::Vec3d(10.4172, -2.70598, 0),
//OpenMesh::Vec3d(6.50459, 2.41615, 0),
//OpenMesh::Vec3d(9.27712, 2.26177, 0),
//OpenMesh::Vec3d(9.67284, 2.20834, 0),
//OpenMesh::Vec3d(9.37983, 3.08828, 0),
//};
		}
	//	{//pangfish2,要改
	//		CC_points = {10* OpenMesh::Vec3d(4.01339, -0.289042, 0),
	//			10 * OpenMesh::Vec3d(3.85961, 0.041488, 0),
	//10 * OpenMesh::Vec3d(3.85961, 0.341488, 0),
	//10*OpenMesh::Vec3d(3.93366, 0.753776, 0),
	//			10 * OpenMesh::Vec3d(1.117864, 1.30315, 0),
	//10*OpenMesh::Vec3d(0.117864, 1.30315, 0),
	//10*OpenMesh::Vec3d(-3.8418, 0.664261, 0),
	//10*OpenMesh::Vec3d(-3.92619, -0.0525603, 0),
	//			10 * OpenMesh::Vec3d(-3.92619, 0.3525603, 0),
	//10*OpenMesh::Vec3d(-3.80339, -0.709607, 0),
	//10*OpenMesh::Vec3d(0.293412, -1.60183, 0),
	//			10 * OpenMesh::Vec3d(1.293412, -1.60183, 0),
	//		};
	//	}
		{ 
			// tree
//			CC_points = { // tree
//OpenMesh::Vec3d(1.86615, -0.62309, 0),
//OpenMesh::Vec3d(1.70078, -0.325945, 0),
//OpenMesh::Vec3d(1.40397, 0.2341, 0),
//OpenMesh::Vec3d(1.30427, 0.40987, 0),
//OpenMesh::Vec3d(1.37965, 0.412058, 0),
//OpenMesh::Vec3d(1.46979, 0.407353, 0),
//OpenMesh::Vec3d(1.59441, 0.398753, 0),
//OpenMesh::Vec3d(1.40912, 0.73623, 0),
//OpenMesh::Vec3d(0.593814, 2.18964, 0),
//OpenMesh::Vec3d(0.338398, 2.61315, 0),
//OpenMesh::Vec3d(0.101003, 2.2063, 0),
//OpenMesh::Vec3d(-0.726498, 0.739979, 0),
//OpenMesh::Vec3d(-0.924111, 0.401181, 0),
//OpenMesh::Vec3d(-0.789357, 0.407254, 0),
//OpenMesh::Vec3d(-0.7013, 0.399603, 0),
//OpenMesh::Vec3d(-0.573548, 0.410087, 0),
//OpenMesh::Vec3d(-0.733134, 0.153825, 0),
//OpenMesh::Vec3d(-0.942978, -0.206076, 0),
//OpenMesh::Vec3d(-1.19767, -0.629409, 0),
//OpenMesh::Vec3d(-1.09202, -0.621438, 0),
//OpenMesh::Vec3d(-1.00905, -0.62615, 0),
//OpenMesh::Vec3d(-0.883788, -0.63228, 0),
//OpenMesh::Vec3d(-1.14018, -1.08032, 0),
//OpenMesh::Vec3d(-1.33011, -1.42578, 0),
//OpenMesh::Vec3d(-1.51314, -1.71908, 0),
//OpenMesh::Vec3d(-1.0402, -1.70736, 0),
//OpenMesh::Vec3d(-0.655682, -1.703, 0),
//OpenMesh::Vec3d(-0.113223, -1.71689, 0),
//OpenMesh::Vec3d(-0.111229, -1.83346, 0),
//OpenMesh::Vec3d(-0.118549, -2.00999, 0),
//OpenMesh::Vec3d(-0.132176, -2.20222, 0),
//OpenMesh::Vec3d(0.215863, -2.19158, 0),
//OpenMesh::Vec3d(0.47987, -2.20167, 0),
//OpenMesh::Vec3d(0.864429, -2.22463, 0),
//OpenMesh::Vec3d(0.872264, -2.0404, 0),
//OpenMesh::Vec3d(0.888873, -1.84137, 0),
//OpenMesh::Vec3d(0.894361, -1.69082, 0),
//OpenMesh::Vec3d(1.38696, -1.68668, 0),
//OpenMesh::Vec3d(1.76987, -1.69009, 0),
//OpenMesh::Vec3d(2.20807, -1.6862, 0),
//OpenMesh::Vec3d(2.00336, -1.33808, 0),
//OpenMesh::Vec3d(1.82472, -1.05024, 0),
//OpenMesh::Vec3d(1.54771, -0.617916, 0),
//OpenMesh::Vec3d(1.66459, -0.625906, 0),
//OpenMesh::Vec3d(1.73573, -0.62592, 0),
//			};
		}


		//fengzheng
		{
			/*CC_points = { OpenMesh::Vec3d(0.388225, -10.5142, 0),
OpenMesh::Vec3d(1.75888, -8.81692, 0),
OpenMesh::Vec3d(-1.36528, -8.22171, 0),
OpenMesh::Vec3d(0.850407, -5.88293, 0),
OpenMesh::Vec3d(3.80741, -3.94645, 0),
OpenMesh::Vec3d(-0.204184, -1.46383, 0),
OpenMesh::Vec3d(1.18098, 0.937381, 0),
OpenMesh::Vec3d(2.84992, 2.52361, 0),
OpenMesh::Vec3d(5, 4, 0),
OpenMesh::Vec3d(8.1875, 5.61703, 0),
OpenMesh::Vec3d(6.34164, 7.08648, 0),
OpenMesh::Vec3d(5.63632, 8.60161, 0),
OpenMesh::Vec3d(4.01908, 10.202, 0),
OpenMesh::Vec3d(0.894286, 10.6119, 0),
OpenMesh::Vec3d(-0.822737, 9.11781, 0),
OpenMesh::Vec3d(-2.38437, 7.59575, 0),
OpenMesh::Vec3d(-0.76012, 5.23217, 0),
OpenMesh::Vec3d(0.0196744, 3.32361, 0),
OpenMesh::Vec3d(-0.115682, 1.27079, 0),
OpenMesh::Vec3d(-3.91057, -0.822718, 0),
OpenMesh::Vec3d(1.17431, -3.97851, 0),
OpenMesh::Vec3d(-1.8103, -6.39287, 0),
OpenMesh::Vec3d(-2.45253, -7.73236, 0),
OpenMesh::Vec3d(-0.54667, -8.8532, 0),
			};*/
		}
		//{
		//	CC_points = { //xiyi
		//		OpenMesh::Vec3d(30, -4, 0),
		//		OpenMesh::Vec3d(30, -1.33333, 0),
		//		OpenMesh::Vec3d(30, 1.33333, 0),
		//		OpenMesh::Vec3d(30, 4, 0),
		//		OpenMesh::Vec3d(25, 4, 0),
		//		OpenMesh::Vec3d(20, 4, 0),
		//		OpenMesh::Vec3d(15, 4, 0),
		//		OpenMesh::Vec3d(10, 4, 0),
		//		OpenMesh::Vec3d(3.01053, 3.60416, 0),
		//		OpenMesh::Vec3d(-1.66561, 3.77381, 0),
		//		OpenMesh::Vec3d(-3.66824, 3.63372, 0),
		//		OpenMesh::Vec3d(-5.77882, 3.75581, 0),
		//		OpenMesh::Vec3d(-7.88941, 3.87791, 0),
		//		OpenMesh::Vec3d(-10, 4, 0),
		//		OpenMesh::Vec3d(-20, 4, 0),
		//		OpenMesh::Vec3d(-30, 4, 0),
		//		OpenMesh::Vec3d(-30, 1.33333, 0),
		//		OpenMesh::Vec3d(-30, -1.33333, 0),
		//		OpenMesh::Vec3d(-30, -4, 0),
		//		OpenMesh::Vec3d(-20, -4, 0),
		//		OpenMesh::Vec3d(-10, -4, 0),
		//		OpenMesh::Vec3d(0, -4, 0),
		//		OpenMesh::Vec3d(5, -4, 0),
		//		OpenMesh::Vec3d(10, -4, 0),
		//		OpenMesh::Vec3d(15, -4, 0),
		//		OpenMesh::Vec3d(20, -4, 0),
		//		OpenMesh::Vec3d(25, -4, 0),
		//	};
		//}

		{ // seahorse
			CC_points = { // seahorse
OpenMesh::Vec3d(3.61019, -5.53027, 0),
OpenMesh::Vec3d(3.60908, -3.95251, 0),
OpenMesh::Vec3d(3.72919, -1.53567, 0),
OpenMesh::Vec3d(3.84245, -0.278068, 0),
OpenMesh::Vec3d(3.82146, 1.48578, 0),
OpenMesh::Vec3d(4.98234, 3.07104, 0),
OpenMesh::Vec3d(4.83917, 6.5945, 0),
OpenMesh::Vec3d(4.69292, 9.47414, 0),
OpenMesh::Vec3d(3.09747, 10.8991, 0),
OpenMesh::Vec3d(-0.273063, 9.57201, 0),
OpenMesh::Vec3d(-1.93806, 8.70603, 0),
OpenMesh::Vec3d(-0.993479, 5.67479, 0),
OpenMesh::Vec3d(-4.05513, 6.09394, 0),
OpenMesh::Vec3d(-5.00754, 6.23271, 0),
OpenMesh::Vec3d(-6.41301, 6.73317, 0),
OpenMesh::Vec3d(-4.92627, 2.78679, 0),
OpenMesh::Vec3d(-3.68057, 4.54012, 0),
OpenMesh::Vec3d(0.37544, 4.99386, 0),
OpenMesh::Vec3d(-0.112873, 4.07275, 0),
OpenMesh::Vec3d(-1.75945, 2.67492, 0),
OpenMesh::Vec3d(-2.1299, 0.621476, 0),
OpenMesh::Vec3d(-1.29587, -0.0891098, 0),
OpenMesh::Vec3d(-0.720383, -0.684836, 0),
OpenMesh::Vec3d(0.965407, -1.92763, 0),
OpenMesh::Vec3d(1.08476, -4.15547, 0),
OpenMesh::Vec3d(1.15867, -5.02685, 0),
OpenMesh::Vec3d(1.19137, -6.2054, 0),
OpenMesh::Vec3d(1.16041, -7.17045, 0),
OpenMesh::Vec3d(1.10901, -8.05413, 0),
OpenMesh::Vec3d(1.05779, -8.89826, 0),
OpenMesh::Vec3d(1.48802, -10.2238, 0),
OpenMesh::Vec3d(3.02485, -10.4425, 0),
OpenMesh::Vec3d(3.65898, -9.51771, 0),
OpenMesh::Vec3d(3.61107, -8.61301, 0),
OpenMesh::Vec3d(3.62334, -8.0092, 0),
OpenMesh::Vec3d(3.6258, -7.31019, 0),
			};
		}

//		CC_points = { //paris tower
//	OpenMesh::Vec3d(2.21312, -3.64502, 0),
//OpenMesh::Vec3d(0.0729413, -1.26159, 0),
//OpenMesh::Vec3d(0.71968, 2.04631, 0),
//OpenMesh::Vec3d(-0.00294265, 4.30579, 0),
//OpenMesh::Vec3d(-0.533977, 2.06356, 0),
//OpenMesh::Vec3d(0.020478, -1.26554, 0),
//OpenMesh::Vec3d(-2.13172, -3.62273, 0),
//OpenMesh::Vec3d(-1.5717, -3.65431, 0),
//OpenMesh::Vec3d(-0.789005, -3.66778, 0),
//OpenMesh::Vec3d(-0.017268, -3.66608, 0),
//OpenMesh::Vec3d(0.997374, -3.65183, 0),
//OpenMesh::Vec3d(1.73898, -3.63311, 0),
//};

		auto CC_pointsreal = CC_points;
		for (int i = 0; i < dividecages; i++)
		{
			auto linearcage1 = subdivideCage3(CC_pointsreal);
			CC_pointsreal = linearcage1;
		}
		for (const auto& point : CC_pointsreal) {
			CC_points2d.emplace_back(point[0], point[1]); // 保留 x 和 y 分量
		}
		//LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\ball.obj");
		//LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\pangxie.obj");
		//LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\circle.obj");
		//LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\octopus.obj");
		//LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\fengzheng.obj");
		//LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\pang_fish.obj");
		//LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\paristower.obj");
		//LoadMesh("E:\\codes\\project_BiHC\\mesh\\dol.obj");
		//LoadMesh("..\\mesh\\yezi.obj");
		//LoadMesh("..\\mesh\\hat.obj");
		LoadMesh("..\\mesh\\seahorse.obj");
		//LoadMesh("..\\mesh\\octopus.obj");
		//LoadMesh("..\\mesh\\tree.obj");
		//LoadMesh("..\\mesh\\jinglin.obj");
		mesh_beifen = mesh;
		CC_mesh = createMeshFromCurveCage(CC_points);
		curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);//绘制操作的网格

		auto CC_mesh_real = createMeshFromCurveCage(CC_pointsreal);
		curvecage2_real = CCpoints_fromCCmesh(CC_mesh_real, degree);//实际 的网格
		auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
		for (auto vh : CC_mesh.vertices())
		{
			CagevertexState[vh] = NotSelected;
		}
		std::cout << "test1" << std::endl;
		auto start_timek = std::chrono::high_resolution_clock::now();
		//BH3ConstructMatrix4OffSet();
		BH3ConstructMatrix4OffSetVirtual();
		auto end_timek = std::chrono::high_resolution_clock::now();
		auto durationk = std::chrono::duration_cast<std::chrono::milliseconds>(end_timek - start_timek).count();
		std::cout << "矩阵构造运行时间: " << durationk << " 毫秒" << std::endl;
		/*exit(0);*/
		auto start_timec = std::chrono::high_resolution_clock::now();
		calculate_bih_weight323New();
		auto end_timec = std::chrono::high_resolution_clock::now();
		auto durationc = std::chrono::duration_cast<std::chrono::milliseconds>(end_timec - start_timec).count();
		std::cout << "坐标计算运行时间: " << durationc << " 毫秒" << std::endl;
		//exit(1);
		auto vertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(mesh, "vertexState");
		for (auto vh : mesh.vertices())
		{
			vertexState[vh] = NotSelected;
		}
		Set_Texture_coord();//设置纹理

		Mesh deformedMesh;
		deformedMesh.assign(mesh);
		deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
		MeshTools::AssignPoints(mesh, deformedMesh);
		update();
		
	}

}


//实际上是直边双调和
void MeshViewerWidget::straight_Bih_Test(void)
{
	std::cout << "CurveBihormonic!" << std::endl;
	drawmode = CURVECAGE;
	usebih = true;
	degree = 3;
	auto arthono = [](const OpenMesh::Vec3d& p) -> OpenMesh::Vec3d {//left( -y, x)
		return OpenMesh::Vec3d(p[1], -p[0], p[2]);
	};
	
	linear_cage = {//bih文章里的星星
			  OpenMesh::Vec2d(-0.080767526797, -1.12594231977),
			  OpenMesh::Vec2d(-0.080767526797, -4.15997046944),
			  OpenMesh::Vec2d(6.05952753800, -4.12385108670  ),
			  OpenMesh::Vec2d(5.08430420418, 0.932862496076   ),
			  OpenMesh::Vec2d(5.08430420418, 7.07315756088    ),
			  OpenMesh::Vec2d(1.00281395523, 2.95554792919    ),
			  OpenMesh::Vec2d(0.930575189759, 7.03703817814   ),
			  OpenMesh::Vec2d(-3.11479567646, 3.02778669466   ),
			  OpenMesh::Vec2d(-7.19628592542, 3.02778669466   ),
			  OpenMesh::Vec2d(-3.07867629373, -0.0784802204796),
			  OpenMesh::Vec2d(-7.23240530815, -0.0423608377455),
			  OpenMesh::Vec2d(-3.11479567646, -3.11250837015  ),
			  OpenMesh::Vec2d(-3.06782410430, -7.18387669905  )
	};
	/*linear_cage = { OpenMesh::Vec2d(-1, -1),
					OpenMesh::Vec2d(3, -1),
					OpenMesh::Vec2d(1, 1),
					OpenMesh::Vec2d(-1, 0),
	};*/
	if (degree == 2) {

		//裤子
		if (1) {
			LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\kuzi.obj");
			// 逆时针定义8个顶点
			linear_cage = {
				OpenMesh::Vec2d(11.4393 + 0.01, 14.8404 + 0.01),
				OpenMesh::Vec2d(-11.3137 - 0.01, 14.8404 + 0.01),
				OpenMesh::Vec2d(-11.3137 - 0.01, -15.0839 - 0.01),
				OpenMesh::Vec2d(-0.822533 + 0.01, -15.0839 - 0.01),
				OpenMesh::Vec2d(-0.822533 + 0.01, 1.35013 - 0.01),
				OpenMesh::Vec2d(0.937067 - 0.01, 1.36120 - 0.01),
				OpenMesh::Vec2d(0.948133 - 0.01, -15.0839 - 0.01),
				OpenMesh::Vec2d(11.4393 + 0.01, -15.0839 - 0.01)
			};
		}
		if (0) {
			createSimpleMesh();
			std::cout <<"点数"<< mesh.n_vertices() << std::endl;
			linear_cage = {
				OpenMesh::Vec2d(0., 0.),
				OpenMesh::Vec2d(5., 0.),
				OpenMesh::Vec2d(5.,5.),
				OpenMesh::Vec2d(0., 5.)
			};
			Set_Texture_coord();//设置纹理
			update();
		}

		std::vector<OpenMesh::Vec2d> offset_cage = offsetCage(linear_cage, -0.01);
		linear_cage = offset_cage;
		//LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\bihexp.obj");

		auto linearcage4 = subdivideCage(linear_cage);
		for (const auto& point : linearcage4) {
			CC_points.emplace_back(point[0], point[1], 0.0); // 将 z 设为 0
		}
		for (int i = 0; i < dividecages; i++)
		{
			auto linearcage2 = subdivideCage(linear_cage);
			linear_cage = linearcage2;
		}
		


		CC_mesh = createMeshFromCurveCage(CC_points);
		curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
		auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
		for (auto vh : CC_mesh.vertices())
		{
			CagevertexState[vh] = NotSelected;
		}
		{//AAAP
			use_aaap = false;
		}
		auto start_timek = std::chrono::high_resolution_clock::now();
		//ConstructMatrix4OffSetTwice();
		//ConstructMatrix4OffSetTwiceVirtual();
		ConstructMatrix4OffSetTwiceVirtualNew();
		//ConstructMatrix4OffSetTwiceVirtualNewWithDer();//aaap
		//ConstructMatrix4OffSetTwiceVirtual2();
		//calculate_bih_weight122();
		calculate_bih_weight122New();
		
		auto end_timek = std::chrono::high_resolution_clock::now();
		auto durationk = std::chrono::duration_cast<std::chrono::milliseconds>(end_timek - start_timek).count();
		std::cout << "运行时间: " << durationk << " 毫秒" << std::endl;

		auto vertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(mesh, "vertexState");
		for (auto vh : mesh.vertices())
		{
			vertexState[vh] = NotSelected;
		}
		Set_Texture_coord();//设置纹理

		Mesh deformedMesh;
		deformedMesh.assign(mesh);
		deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
		MeshTools::AssignPoints(mesh, deformedMesh);
		update();
	}
	if (degree == 3) {
		//裤子的变形
		if (0) {
			int N = 8;//kuzi 8
			curvecage2.resize(N);
			LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\kuzi.obj");
			mesh_beifen = mesh;
			// 逆时针定义8个顶点
			linear_cage = {
				OpenMesh::Vec2d(11.4393 + 0.01, 14.8404 + 0.01),
				OpenMesh::Vec2d(-11.3137 - 0.01, 14.8404 + 0.01),
				OpenMesh::Vec2d(-11.3137 - 0.01, -15.0839 - 0.01),
				OpenMesh::Vec2d(-0.822533 + 0.01, -15.0839 - 0.01),
				OpenMesh::Vec2d(-0.822533 + 0.01, 1.35013 - 0.01),
				OpenMesh::Vec2d(0.937067 - 0.01, 1.36120 - 0.01),
				OpenMesh::Vec2d(0.948133 - 0.01, -15.0839 - 0.01),
				OpenMesh::Vec2d(11.4393 + 0.01, -15.0839 - 0.01)
			};
			auto linearcage4 = subdivideCage123(linear_cage);
			for (const auto& point : linearcage4) {
				CC_points.emplace_back(point[0], point[1], 0.0); // 将 z 设为 0
			}
			auto CC_pointsreal = CC_points;
			for (int i = 0; i < dividecages; i++)
			{
				auto linearcage1sub = subdivideCage(linear_cage);
				linear_cage = linearcage1sub;
				auto linearcage1 = subdivideCage3(CC_pointsreal);
				CC_pointsreal = linearcage1;
			}
			for (const auto& point : CC_pointsreal) {
				CC_points2d.emplace_back(point[0], point[1]); // 保留 x 和 y 分量
			}
			

			CC_mesh = createMeshFromCurveCage(CC_points);
			curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);//操作的网格
			auto CC_mesh_real = createMeshFromCurveCage(CC_pointsreal);
			curvecage2_real = CCpoints_fromCCmesh(CC_mesh_real, degree);//实际 的网格
			auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
			for (auto vh : CC_mesh.vertices())
			{
				CagevertexState[vh] = NotSelected;
			}
			//createSimpleMesh();
			//ConstructMatrix4OffSetTwice();
			//ConstructMatrix4OffSetThird();
			ConstructMatrix4OffSetThirdVirtualNew();
			calculate_bih_weight123New();
			auto vertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(mesh, "vertexState");
			for (auto vh : mesh.vertices())
			{
				vertexState[vh] = NotSelected;
			}
			Set_Texture_coord();//设置纹理

			Mesh deformedMesh;
			deformedMesh.assign(mesh);
			deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
			MeshTools::AssignPoints(mesh, deformedMesh);
			update();
			return;
		}
		//haixing
		if (1) {
			int N = 8;//kuzi 8
			curvecage2.resize(N);
			LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\haixing1.obj");
			mesh_beifen = mesh;
			// 逆时针定义10个顶点
			/*linear_cage = { 
OpenMesh::Vec2d(-2.13173, -0.13608),
OpenMesh::Vec2d(-0.342821, -0.389381),
OpenMesh::Vec2d(-0.477382, -2.00566),
OpenMesh::Vec2d(0.47484, -0.621889),
OpenMesh::Vec2d(2.1538, -0.984781),
OpenMesh::Vec2d(0.959173, 0.174992),
OpenMesh::Vec2d(1.75911, 1.46569),
OpenMesh::Vec2d(0.375383, 0.827541),
OpenMesh::Vec2d(-0.660919, 1.99844),
OpenMesh::Vec2d(-0.458974, 0.453426),
			};*/
			//haixing jianqu了的
			linear_cage = {
OpenMesh::Vec2d(-2.13173, -0.13608),
OpenMesh::Vec2d(-0.282235, -0.28219),
OpenMesh::Vec2d(-0.477382, -2.00566),
OpenMesh::Vec2d(0.451538, -0.486735),
OpenMesh::Vec2d(2.1538, -0.984781),
OpenMesh::Vec2d(0.819359, 0.147029),
OpenMesh::Vec2d(1.75911, 1.46569),
OpenMesh::Vec2d(0.366062, 0.780936),
OpenMesh::Vec2d(-0.660919, 1.99844),
OpenMesh::Vec2d(-0.365765, 0.406821),
			};
			auto linearcage4 = subdivideCage123(linear_cage);
			for (const auto& point : linearcage4) {
				CC_points.emplace_back(point[0], point[1], 0.0); // 将 z 设为 0
			}
			auto CC_pointsreal = CC_points;
			for (int i = 0; i < dividecages; i++)
			{
				auto linearcage1sub = subdivideCage(linear_cage);
				linear_cage = linearcage1sub;
				auto linearcage1 = subdivideCage3(CC_pointsreal);
				CC_pointsreal = linearcage1;
			}
			for (const auto& point : CC_pointsreal) {
				CC_points2d.emplace_back(point[0], point[1]); // 保留 x 和 y 分量
			}


			CC_mesh = createMeshFromCurveCage(CC_points);
			curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);//操作的网格
			auto CC_mesh_real = createMeshFromCurveCage(CC_pointsreal);
			curvecage2_real = CCpoints_fromCCmesh(CC_mesh_real, degree);//实际 的网格
			auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
			for (auto vh : CC_mesh.vertices())
			{
				CagevertexState[vh] = NotSelected;
			}
			//createSimpleMesh();
			//ConstructMatrix4OffSetTwice();
			//ConstructMatrix4OffSetThird();
			ConstructMatrix4OffSetThirdVirtualNew();
			calculate_bih_weight123New();
			auto vertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(mesh, "vertexState");
			for (auto vh : mesh.vertices())
			{
				vertexState[vh] = NotSelected;
			}
			Set_Texture_coord();//设置纹理

			Mesh deformedMesh;
			deformedMesh.assign(mesh);
			deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
			MeshTools::AssignPoints(mesh, deformedMesh);
			update();
			return;
		}
		//Green Cube
		if (0) {
			createSimpleMesh();
			linear_cage = {
				OpenMesh::Vec2d(0., 0.),
				OpenMesh::Vec2d(5., 0.),
				OpenMesh::Vec2d(5.,5.),
				OpenMesh::Vec2d(0., 5.)
			};
			auto linearcage4 = subdivideCage123(linear_cage);
			for (const auto& point : linearcage4) {
				CC_points.emplace_back(point[0], point[1], 0.0); // 将 z 设为 0
			}
			auto CC_pointsreal = CC_points;
			for (int i = 0; i < dividecages; i++)
			{
				auto linearcage1sub = subdivideCage(linear_cage);
				linear_cage = linearcage1sub;
				auto linearcage1 = subdivideCage3(CC_pointsreal);
				CC_pointsreal = linearcage1;
			}
			for (const auto& point : CC_pointsreal) {
				CC_points2d.emplace_back(point[0], point[1]); // 保留 x 和 y 分量
			}


			CC_mesh = createMeshFromCurveCage(CC_points);
			curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);//操作的网格
			auto CC_mesh_real = createMeshFromCurveCage(CC_pointsreal);
			curvecage2_real = CCpoints_fromCCmesh(CC_mesh_real, degree);//实际 的网格
			auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
			for (auto vh : CC_mesh.vertices())
			{
				CagevertexState[vh] = NotSelected;
			}
			//createSimpleMesh();
			//ConstructMatrix4OffSetTwice();
			//ConstructMatrix4OffSetThird();
			ConstructMatrix4OffSetThirdVirtualNew();
			calculate_bih_weight123New();
			auto vertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(mesh, "vertexState");
			for (auto vh : mesh.vertices())
			{
				vertexState[vh] = NotSelected;
			}
			Set_Texture_coord();//设置纹理

			Mesh deformedMesh;
			deformedMesh.assign(mesh);
			deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
			MeshTools::AssignPoints(mesh, deformedMesh);
			update();
			return;
		}
		//daizi
		if (0) {
			int N = 8;//kuzi 8
			curvecage2.resize(N);
			LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\daizi.obj");
			mesh_beifen = mesh;
			//createSimpleMesh();
			{
				/*ptMin = OpenMesh::Vec3d(0, 0, 0);
				ptMax = OpenMesh::Vec3d(5, 5, 0);*/
				const Eigen::Vector3d targetMin(-30.0, -4.0, 0.0);
				const Eigen::Vector3d targetMax(30.0, 4.0, 0.0);

				// 计算缩放比例
				Eigen::Vector3d scale;
				scale.x() = (targetMax.x() - targetMin.x()) / (ptMax[0] - ptMin[0]);
				scale.y() = (targetMax.y() - targetMin.y()) / (ptMax[1] - ptMin[1]);
				scale.z() = 0.0; // 保持 z 为常数

				// 更新顶点坐标
				for (auto& vh : mesh.vertices()) {
					OpenMesh::Vec3d pt = mesh.point(vh);
					pt[0] = ((pt[0] - ptMin[0]) * scale.x() + targetMin.x())*0.999;
					pt[1] = ((pt[1] - ptMin[1]) * scale.y() + targetMin.y())*0.999;
					pt[2] = 0; // 保持 z 为常数
					mesh.set_point(vh, pt);
				}
			}
			// 逆时针定义8个顶点
			linear_cage = {
				OpenMesh::Vec2d(30, -4),
				OpenMesh::Vec2d(30, 4),
				OpenMesh::Vec2d(15, 4),
				OpenMesh::Vec2d(0, 4),
				OpenMesh::Vec2d(-15, 4),
				OpenMesh::Vec2d(-30, 4),
				OpenMesh::Vec2d(-30, -4),
				OpenMesh::Vec2d(-15, -4),
				OpenMesh::Vec2d(0, -4),
				OpenMesh::Vec2d(15, -4),
			};
			//CC_points = { //daizi
//	OpenMesh::Vec3d(31.4678, -3.60352, 0),
//OpenMesh::Vec3d(31.4678, -0.717967, 0),
//OpenMesh::Vec3d(31.4678, 0.615366, 0),
//OpenMesh::Vec3d(31.4549, 3.54117, 0),
//OpenMesh::Vec3d(0.653732, 3.59247, 0),
//OpenMesh::Vec3d(-0.679602, 3.59247, 0),
//OpenMesh::Vec3d(-31.6356, 3.56382, 0),
//OpenMesh::Vec3d(-31.6226, 0.638025, 0),
//OpenMesh::Vec3d(-31.6226, -0.695309, 0),
//OpenMesh::Vec3d(-31.6226, -3.58087, 0),
//OpenMesh::Vec3d(-0.666667, -3.55222, 0),
//OpenMesh::Vec3d(0.666667, -3.55222, 0),
//};
			auto linearcage4 = subdivideCage123(linear_cage);
			for (const auto& point : linearcage4) {
				CC_points.emplace_back(point[0], point[1], 0.0); // 将 z 设为 0
			}
			auto CC_pointsreal = CC_points;
			for (int i = 0; i < dividecages; i++)
			{
				auto linearcage1sub = subdivideCage(linear_cage);
				linear_cage = linearcage1sub;
				auto linearcage1 = subdivideCage3(CC_pointsreal);
				CC_pointsreal = linearcage1;
			}
			for (const auto& point : CC_pointsreal) {
				CC_points2d.emplace_back(point[0], point[1]); // 保留 x 和 y 分量
			}


			CC_mesh = createMeshFromCurveCage(CC_points);
			curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);//操作的网格
			auto CC_mesh_real = createMeshFromCurveCage(CC_pointsreal);
			curvecage2_real = CCpoints_fromCCmesh(CC_mesh_real, degree);//实际 的网格
			auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
			for (auto vh : CC_mesh.vertices())
			{
				CagevertexState[vh] = NotSelected;
			}
			//createSimpleMesh();
			//ConstructMatrix4OffSetTwice();
			//ConstructMatrix4OffSetThird();
			ConstructMatrix4OffSetThirdVirtualNew();
			calculate_bih_weight123New();
			auto vertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(mesh, "vertexState");
			for (auto vh : mesh.vertices())
			{
				vertexState[vh] = NotSelected;
			}
			Set_Texture_coord();//设置纹理

			Mesh deformedMesh;
			deformedMesh.assign(mesh);
			deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
			MeshTools::AssignPoints(mesh, deformedMesh);
			update();
			return;
		}
		//tree
		if (0) {
			int N = 8;//kuzi 8
			curvecage2.resize(N);
			LoadMesh("..\\mesh\\tree.obj");
			
			// 逆时针定义8个顶点
			linear_cage = {
				OpenMesh::Vec2d(1.86615, -0.62309),
				
				OpenMesh::Vec2d(1.30427, 0.40987),
				
				OpenMesh::Vec2d(1.59441, 0.398753),
				
				OpenMesh::Vec2d(0.338398, 2.61315),
				
				OpenMesh::Vec2d(-0.924111, 0.401181),
				
				OpenMesh::Vec2d(-0.573548, 0.410087),
				
				OpenMesh::Vec2d(-1.19767, -0.629409),
				
				OpenMesh::Vec2d(-0.883788, -0.63228),
				
				OpenMesh::Vec2d(-1.51314, -1.71908),
				
				OpenMesh::Vec2d(-0.113223, -1.71689),
				
				OpenMesh::Vec2d(-0.132176, -2.20222),
				
				OpenMesh::Vec2d(0.864429, -2.22463),
				
				OpenMesh::Vec2d(0.894361, -1.69082),
				
				OpenMesh::Vec2d(2.20807, -1.6862),
				
				OpenMesh::Vec2d(1.54771, -0.617916),
				
			};
			//CC_points = { //daizi
//	OpenMesh::Vec3d(31.4678, -3.60352, 0),
//OpenMesh::Vec3d(31.4678, -0.717967, 0),
//OpenMesh::Vec3d(31.4678, 0.615366, 0),
//OpenMesh::Vec3d(31.4549, 3.54117, 0),
//OpenMesh::Vec3d(0.653732, 3.59247, 0),
//OpenMesh::Vec3d(-0.679602, 3.59247, 0),
//OpenMesh::Vec3d(-31.6356, 3.56382, 0),
//OpenMesh::Vec3d(-31.6226, 0.638025, 0),
//OpenMesh::Vec3d(-31.6226, -0.695309, 0),
//OpenMesh::Vec3d(-31.6226, -3.58087, 0),
//OpenMesh::Vec3d(-0.666667, -3.55222, 0),
//OpenMesh::Vec3d(0.666667, -3.55222, 0),
//};
			auto linearcage4 = subdivideCage123(linear_cage);
			for (const auto& point : linearcage4) {
				CC_points.emplace_back(point[0], point[1], 0.0); // 将 z 设为 0
			}
			auto CC_pointsreal = CC_points;
			for (int i = 0; i < dividecages; i++)
			{
				auto linearcage1sub = subdivideCage(linear_cage);
				linear_cage = linearcage1sub;
				auto linearcage1 = subdivideCage3(CC_pointsreal);
				CC_pointsreal = linearcage1;
			}
			for (const auto& point : CC_pointsreal) {
				CC_points2d.emplace_back(point[0], point[1]); // 保留 x 和 y 分量
			}


			CC_mesh = createMeshFromCurveCage(CC_points);
			curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);//操作的网格
			auto CC_mesh_real = createMeshFromCurveCage(CC_pointsreal);
			curvecage2_real = CCpoints_fromCCmesh(CC_mesh_real, degree);//实际 的网格
			auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
			for (auto vh : CC_mesh.vertices())
			{
				CagevertexState[vh] = NotSelected;
			}
			//createSimpleMesh();
			//ConstructMatrix4OffSetTwice();
			//ConstructMatrix4OffSetThird();
			ConstructMatrix4OffSetThirdVirtualNew();
			calculate_bih_weight123New();
			auto vertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(mesh, "vertexState");
			for (auto vh : mesh.vertices())
			{
				vertexState[vh] = NotSelected;
			}
			Set_Texture_coord();//设置纹理

			Mesh deformedMesh;
			deformedMesh.assign(mesh);
			deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
			MeshTools::AssignPoints(mesh, deformedMesh);
			update();
			return;
		}
		//sheji
		if (0) {
			int N = 8;//kuzi 8
			curvecage2.resize(N);
			LoadMesh("..\\mesh\\sheji.obj");
			mesh_beifen = mesh;
			// 逆时针定义8个顶点
			linear_cage = {
OpenMesh::Vec2d(-19.97,-12.93),

OpenMesh::Vec2d(19.97,-12.93),

OpenMesh::Vec2d(19.97,12.93),

OpenMesh::Vec2d(-19.97,12.93),
			};
			//CC_points = { //daizi
//	OpenMesh::Vec3d(31.4678, -3.60352, 0),
//OpenMesh::Vec3d(31.4678, -0.717967, 0),
//OpenMesh::Vec3d(31.4678, 0.615366, 0),
//OpenMesh::Vec3d(31.4549, 3.54117, 0),
//OpenMesh::Vec3d(0.653732, 3.59247, 0),
//OpenMesh::Vec3d(-0.679602, 3.59247, 0),
//OpenMesh::Vec3d(-31.6356, 3.56382, 0),
//OpenMesh::Vec3d(-31.6226, 0.638025, 0),
//OpenMesh::Vec3d(-31.6226, -0.695309, 0),
//OpenMesh::Vec3d(-31.6226, -3.58087, 0),
//OpenMesh::Vec3d(-0.666667, -3.55222, 0),
//OpenMesh::Vec3d(0.666667, -3.55222, 0),
//};
			auto linearcage4 = subdivideCage123(linear_cage);
			for (const auto& point : linearcage4) {
				CC_points.emplace_back(point[0], point[1], 0.0); // 将 z 设为 0
			}
			auto CC_pointsreal = CC_points;
			for (int i = 0; i < dividecages; i++)
			{
				auto linearcage1sub = subdivideCage(linear_cage);
				linear_cage = linearcage1sub;
				auto linearcage1 = subdivideCage3(CC_pointsreal);
				CC_pointsreal = linearcage1;
			}
			for (const auto& point : CC_pointsreal) {
				CC_points2d.emplace_back(point[0], point[1]); // 保留 x 和 y 分量
			}


			CC_mesh = createMeshFromCurveCage(CC_points);
			curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);//操作的网格
			auto CC_mesh_real = createMeshFromCurveCage(CC_pointsreal);
			curvecage2_real = CCpoints_fromCCmesh(CC_mesh_real, degree);//实际 的网格
			auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
			for (auto vh : CC_mesh.vertices())
			{
				CagevertexState[vh] = NotSelected;
			}
			//createSimpleMesh();
			//ConstructMatrix4OffSetTwice();
			//ConstructMatrix4OffSetThird();
			ConstructMatrix4OffSetThirdVirtualNew();
			calculate_bih_weight123New();
			auto vertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(mesh, "vertexState");
			for (auto vh : mesh.vertices())
			{
				vertexState[vh] = NotSelected;
			}
			Set_Texture_coord();//设置纹理

			Mesh deformedMesh;
			deformedMesh.assign(mesh);
			deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
			MeshTools::AssignPoints(mesh, deformedMesh);
			update();
			return;
		}
		//L
		if (0) {
			int N = 8;//kuzi 8
			curvecage2.resize(N);
			LoadMesh("E:\\dgp2021\\dgp6\\newproject_BIHC\\project_BiHC\\mesh\\L_zimu.obj");
			mesh_beifen = mesh;
			// 逆时针定义8个顶点
			linear_cage = {
				OpenMesh::Vec2d(-2.77 - 0.01, -2.58 - 0.01),
				OpenMesh::Vec2d(1.99 + 0.01, -2.58 - 0.01),
				OpenMesh::Vec2d(1.99 + 0.01, -0.61 + 0.01),
				OpenMesh::Vec2d(-0.9 + 0.01, -0.61 + 0.01),
				OpenMesh::Vec2d(-0.9 + 0.01, 2.70 + 0.01),
				OpenMesh::Vec2d(-2.77 - 0.01, 2.70 + 0.01),
			};
			auto linearcage4 = subdivideCage123(linear_cage);
			for (const auto& point : linearcage4) {
				CC_points.emplace_back(point[0], point[1], 0.0); // 将 z 设为 0
			}
			auto CC_pointsreal = CC_points;
			for (int i = 0; i < dividecages; i++)
			{
				auto linearcage1sub = subdivideCage(linear_cage);
				linear_cage = linearcage1sub;
				auto linearcage1 = subdivideCage3(CC_pointsreal);
				CC_pointsreal = linearcage1;
			}
			for (const auto& point : CC_pointsreal) {
				CC_points2d.emplace_back(point[0], point[1]); // 保留 x 和 y 分量
			}


			CC_mesh = createMeshFromCurveCage(CC_points);
			curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);//操作的网格
			auto CC_mesh_real = createMeshFromCurveCage(CC_pointsreal);
			curvecage2_real = CCpoints_fromCCmesh(CC_mesh_real, degree);//实际 的网格
			auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
			for (auto vh : CC_mesh.vertices())
			{
				CagevertexState[vh] = NotSelected;
			}
			//createSimpleMesh();
			//ConstructMatrix4OffSetTwice();
			//ConstructMatrix4OffSetThird();
			ConstructMatrix4OffSetThirdVirtualNew();
			calculate_bih_weight123New();
			auto vertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(mesh, "vertexState");
			for (auto vh : mesh.vertices())
			{
				vertexState[vh] = NotSelected;
			}
			Set_Texture_coord();//设置纹理

			Mesh deformedMesh;
			deformedMesh.assign(mesh);
			deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
			MeshTools::AssignPoints(mesh, deformedMesh);
			update();
			return;
		}
		std::vector<OpenMesh::Vec2d> offset_cage = offsetCage(linear_cage, -0.01);
		linear_cage = offset_cage;

		auto linearcage4 = subdivideCage123(linear_cage);
		for (const auto& point : linearcage4) {
			CC_points.emplace_back(point[0], point[1], 0.0); // 将 z 设为 0
		}
		auto linearcage2 = subdivideCage(linear_cage);
		linear_cage = linearcage2;
		/*auto linearcage3 = subdivideCage(linear_cage);
		linear_cage = linearcage3;
		auto linearcage5 = subdivideCage(linear_cage);
		linear_cage = linearcage5;*/

		CC_mesh = createMeshFromCurveCage(CC_points);
		curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
		auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
		for (auto vh : CC_mesh.vertices())
		{
			CagevertexState[vh] = NotSelected;
		}
		//createSimpleMesh();
		if (degree != 3) {
			LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\bihexp.obj");
		}
		//ConstructMatrix4OffSetTwice();
		//ConstructMatrix4OffSetThird();
		ConstructMatrix4OffSetThirdVirtual();
		calculate_bih_weight123();
		auto vertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(mesh, "vertexState");
		for (auto vh : mesh.vertices())
		{
			vertexState[vh] = NotSelected;
		}
		Set_Texture_coord();//设置纹理

		Mesh deformedMesh;
		deformedMesh.assign(mesh);
		deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
		MeshTools::AssignPoints(mesh, deformedMesh);
		update();
	}
	if (degree == 4) {
		//sheji
		if (0) {
			int N = 8;//kuzi 8
			curvecage2.resize(N);
			LoadMesh("..\\mesh\\sheji.obj");

			// 逆时针定义8个顶点
			linear_cage = {
OpenMesh::Vec2d(-19.97,-12.93),

OpenMesh::Vec2d(19.97,-12.93),

OpenMesh::Vec2d(19.97,12.93),

OpenMesh::Vec2d(-19.97,12.93),
			};
		}
		//zoom fish
		if (1) {
			int N = 4;//kuzi 8
			curvecage2.resize(N);
			LoadMesh("..\\mesh\\zoom_fish.obj");

			// 逆时针定义8个顶点
			linear_cage = {
				OpenMesh::Vec2d(15.9365 + 0.01,  1.25963 + 0.01),
				OpenMesh::Vec2d(-16.3751 - 0.01,  1.25963 + 0.01),
				OpenMesh::Vec2d(-16.3751 - 0.01, -1.86695 - 0.01),
				OpenMesh::Vec2d(15.9365 + 0.01, -1.86695 - 0.01),

			};
		}

		auto linearcage4 = subdivideCage124(linear_cage);
		for (const auto& point : linearcage4) {
			CC_points.emplace_back(point[0], point[1], 0.0); // 将 z 设为 0
		}
		auto CC_pointsreal = CC_points;
		for (int i = 0; i < dividecages; i++)
		{
			auto linearcage1sub = subdivideCage(linear_cage);
			linear_cage = linearcage1sub;
			auto linearcage1 = subdivideCage4(CC_pointsreal);
			CC_pointsreal = linearcage1;
		}
		for (const auto& point : CC_pointsreal) {
			CC_points2d.emplace_back(point[0], point[1]); // 保留 x 和 y 分量
		}


		CC_mesh = createMeshFromCurveCage(CC_points);
		curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);//操作的网格
		auto CC_mesh_real = createMeshFromCurveCage(CC_pointsreal);
		curvecage2_real = CCpoints_fromCCmesh(CC_mesh_real, degree);//实际 的网格
		auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
		for (auto vh : CC_mesh.vertices())
		{
			CagevertexState[vh] = NotSelected;
		}
		//createSimpleMesh();
		//ConstructMatrix4OffSetTwice();
		//ConstructMatrix4OffSetThird();
		ConstructMatrix4OffSetFourthVirtualNew();
		calculate_bih_weight124New();
		auto vertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(mesh, "vertexState");
		for (auto vh : mesh.vertices())
		{
			vertexState[vh] = NotSelected;
		}
		Set_Texture_coord();//设置纹理

		Mesh deformedMesh;
		deformedMesh.assign(mesh);
		deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
		MeshTools::AssignPoints(mesh, deformedMesh);
		update();
		return;

	}
}

void MeshViewerWidget::DrawVideo1(void)
{
	std::cout << "draw video1" << std::endl;
	std::cout << "StraightBihormonic!" << std::endl;
	drawmode = CURVECAGE;
	usebih = true;
	degree = 1;
	auto arthono = [](const OpenMesh::Vec3d& p) -> OpenMesh::Vec3d {//left( -y, x)
		return OpenMesh::Vec3d(p[1], -p[0], p[2]);
	};

	
	if (degree == 3) {
		
		//haixing
		if (1) {
			int N = 8;//kuzi 8
			curvecage2.resize(N);
			LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\haixing1.obj");
			mesh_beifen = mesh;
			//haixing jianqu了的
			linear_cage = {
OpenMesh::Vec2d(-2.13173, -0.13608),
OpenMesh::Vec2d(-0.282235, -0.28219),
OpenMesh::Vec2d(-0.477382, -2.00566),
OpenMesh::Vec2d(0.451538, -0.486735),
OpenMesh::Vec2d(2.1538, -0.984781),
OpenMesh::Vec2d(0.819359, 0.147029),
OpenMesh::Vec2d(1.75911, 1.46569),
OpenMesh::Vec2d(0.366062, 0.780936),
OpenMesh::Vec2d(-0.660919, 1.99844),
OpenMesh::Vec2d(-0.365765, 0.406821),
			};
			auto linearcage4 = subdivideCage123(linear_cage);
			for (const auto& point : linearcage4) {
				CC_points.emplace_back(point[0], point[1], 0.0); // 将 z 设为 0
			}
			auto CC_pointsreal = CC_points;
			for (int i = 0; i < dividecages; i++)
			{
				auto linearcage1sub = subdivideCage(linear_cage);
				linear_cage = linearcage1sub;
				auto linearcage1 = subdivideCage3(CC_pointsreal);
				CC_pointsreal = linearcage1;
			}
			for (const auto& point : CC_pointsreal) {
				CC_points2d.emplace_back(point[0], point[1]); // 保留 x 和 y 分量
			}


			CC_mesh = createMeshFromCurveCage(CC_points);
			curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);//操作的网格
			auto CC_mesh_real = createMeshFromCurveCage(CC_pointsreal);
			curvecage2_real = CCpoints_fromCCmesh(CC_mesh_real, degree);//实际 的网格
			auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
			for (auto vh : CC_mesh.vertices())
			{
				CagevertexState[vh] = NotSelected;
			}
			//createSimpleMesh();
			//ConstructMatrix4OffSetTwice();
			//ConstructMatrix4OffSetThird();
			ConstructMatrix4OffSetThirdVirtualNew();
			calculate_bih_weight123New();
			auto vertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(mesh, "vertexState");
			for (auto vh : mesh.vertices())
			{
				vertexState[vh] = NotSelected;
			}
			Set_Texture_coord();//设置纹理

			Mesh deformedMesh;
			deformedMesh.assign(mesh);
			deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
			MeshTools::AssignPoints(mesh, deformedMesh);
			update();

			if (1) {
				std::vector<OpenMesh::Vec3d> CC_points_source = CC_points;
				std::vector<OpenMesh::Vec3d> CC_points_target = { OpenMesh::Vec3d(-2.25375, 0.541636, 0),
	OpenMesh::Vec3d(-1.5692, -0.0704777, 0),
	OpenMesh::Vec3d(-0.939124, -0.304947, 0),
	OpenMesh::Vec3d(-0.342821, -0.389381, 0),
	OpenMesh::Vec3d(-0.305095, -0.980101, 0),
	OpenMesh::Vec3d(-0.192065, -1.52177, 0),
	OpenMesh::Vec3d(0.266718, -2.03271, 0),
	OpenMesh::Vec3d(0.356279, -1.45354, 0),
	OpenMesh::Vec3d(0.28072, -1.12409, 0),
	OpenMesh::Vec3d(0.47484, -0.621889, 0),
	OpenMesh::Vec3d(1.03449, -0.742853, 0),
	OpenMesh::Vec3d(1.61279, -0.742645, 0),
	OpenMesh::Vec3d(2.18771, -0.566004, 0),
	OpenMesh::Vec3d(1.77086, -0.300585, 0),
	OpenMesh::Vec3d(1.35738, -0.211599, 0),
	OpenMesh::Vec3d(0.959173, 0.174992, 0),
	OpenMesh::Vec3d(1.22582, 0.605225, 0),
	OpenMesh::Vec3d(1.52043, 0.937587, 0),
	OpenMesh::Vec3d(2.03408, 1.04625, 0),
	OpenMesh::Vec3d(1.29787, 1.25297, 0),
	OpenMesh::Vec3d(0.836625, 1.04026, 0),
	OpenMesh::Vec3d(0.375383, 0.827541, 0),
	OpenMesh::Vec3d(-0.039958, 1.16658, 0),
	OpenMesh::Vec3d(-0.315485, 1.60814, 0),
	OpenMesh::Vec3d(-0.222835, 2.14291, 0),
	OpenMesh::Vec3d(-0.607585, 1.51606, 0),
	OpenMesh::Vec3d(-0.54027, 1.00105, 0),
	OpenMesh::Vec3d(-0.458974, 0.453426, 0),
	OpenMesh::Vec3d(-1.05033, 0.40696, 0),
	OpenMesh::Vec3d(-1.62709, 0.335766, 0),
				};
				for (int t = 0; t < 100; t++)
				{
					std::vector<OpenMesh::Vec3d> interpolated_points;
					interpolated_points.resize(CC_points.size());
					double alpha = static_cast<double>(t) / 99.0; // 正确归一化 t 范围 [0,1]
					for (size_t i = 0; i < CC_points.size(); ++i) {
						interpolated_points[i] = (1.0 - alpha) * CC_points_source[i] + alpha * CC_points_target[i];
					}
					CC_points = interpolated_points;

					CC_mesh = createMeshFromCurveCage(CC_points);
					auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
					for (auto vh : CC_mesh.vertices())
					{
						CagevertexState[vh] = NotSelected;
					}
					curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);

					deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
					MeshTools::AssignPoints(mesh, deformedMesh);
					update();
					QString filename = QString("S:/SIG25/BIHC/haixing/step_%1.png").arg(t);
					QImage image = grabFramebuffer();
					image.save(filename);
				}
			}
		}

	}
	//haixing
	if (degree==1)
	{
		linear_cage = {
OpenMesh::Vec2d(-2.13173, -0.13608),
OpenMesh::Vec2d(-0.342821, -0.389381),
OpenMesh::Vec2d(-0.477382, -2.00566),
OpenMesh::Vec2d(0.47484, -0.621889),
OpenMesh::Vec2d(2.1538, -0.984781),
OpenMesh::Vec2d(0.959173, 0.174992),
OpenMesh::Vec2d(1.75911, 1.46569),
OpenMesh::Vec2d(0.375383, 0.827541),
OpenMesh::Vec2d(-0.660919, 1.99844),
OpenMesh::Vec2d(-0.458974, 0.453426),
		};
		linear_cage = {
OpenMesh::Vec2d(-2.13173, -0.13608),
OpenMesh::Vec2d(-0.282235, -0.28219),
OpenMesh::Vec2d(-0.477382, -2.00566),
OpenMesh::Vec2d(0.451538, -0.486735),
OpenMesh::Vec2d(2.1538, -0.984781),
OpenMesh::Vec2d(0.819359, 0.147029),
OpenMesh::Vec2d(1.75911, 1.46569),
OpenMesh::Vec2d(0.366062, 0.780936),
OpenMesh::Vec2d(-0.660919, 1.99844),
OpenMesh::Vec2d(-0.365765, 0.406821),
		};
		auto linearcage1 = subdivideCage123(linear_cage);
		linear_cage = linearcage1;
		std::vector<OpenMesh::Vec2d> CC_points_source = linear_cage;//初始状态

		for (const auto& point : linear_cage) {
			CC_points.emplace_back(point[0], point[1], 0.0); // 将 z 设为 0
		}

		for (int i = 0; i < dividecages; i++)
		{
			auto linearcage2 = subdivideCage(linear_cage);
			linear_cage = linearcage2;
		}
		LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\haixing1.obj");//见过了的海星
		for (auto vh : mesh.vertices()) {
			auto p = mesh.point(vh);
			p *= 1;
			mesh.set_point(vh, p);
		}

		Set_Texture_coord();//设置纹理

		CC_mesh = createMeshFromCurveCage(CC_points);
		curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
		auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
		for (auto vh : CC_mesh.vertices())
		{
			CagevertexState[vh] = NotSelected;
		}

		int m = linear_cage.size();
		linear_length.resize(m);
		for (int i = 0; i < m; i++) {
			linear_length[i] = (linear_cage[(i + 1) % m] - linear_cage[i]).length();
		}

		ConstructMatrix4OffSetVirtual();

		calculate_bih_weight121();
		/*mesh.garbage_collection();
		MeshTools::WriteOBJ(mesh, "E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\haixing1.obj");*/
		//calculate_bih_weight121test();

		Mesh deformedMesh;
		deformedMesh.assign(mesh);
		deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
		MeshTools::AssignPoints(mesh, deformedMesh);

		auto vertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(mesh, "vertexState");
		for (auto vh : mesh.vertices())
		{
			vertexState[vh] = NotSelected;
		}
		update();
		
		if (1) {
			
			std::vector<OpenMesh::Vec2d> CC_points_target = { OpenMesh::Vec2d(-2.06111, 0.479614),
			OpenMesh::Vec2d(-1.4976, -0.0331412),
			OpenMesh::Vec2d(-0.939124, -0.304947),
			OpenMesh::Vec2d(-0.342821, -0.389381),
			OpenMesh::Vec2d(-0.387675, -0.928141),
			OpenMesh::Vec2d(-0.119345, -1.59902),
			OpenMesh::Vec2d(0.00218024, -2.15736),
			OpenMesh::Vec2d(0.128741, -1.41717),
			OpenMesh::Vec2d(0.157433, -1.08315),
			OpenMesh::Vec2d(0.47484, -0.621889),
			OpenMesh::Vec2d(1.03449, -0.742853),
			OpenMesh::Vec2d(1.68745, -0.69492),
			OpenMesh::Vec2d(2.43657, -0.456263),
			OpenMesh::Vec2d(1.77807, -0.298051),
			OpenMesh::Vec2d(1.35738, -0.211599),
			OpenMesh::Vec2d(0.959173, 0.174992),
			OpenMesh::Vec2d(1.22582, 0.605225),
			OpenMesh::Vec2d(1.38993, 0.918946),
			OpenMesh::Vec2d(2.12729, 1.09285),
			OpenMesh::Vec2d(1.42836, 1.26229),
			OpenMesh::Vec2d(0.836625, 1.04026),
			OpenMesh::Vec2d(0.375383, 0.827541),
			OpenMesh::Vec2d(0.029949, 1.21784),
			OpenMesh::Vec2d(-0.222276, 1.62678),
			OpenMesh::Vec2d(-0.330026, 2.08233),
			OpenMesh::Vec2d(-0.505055, 1.56266),
			OpenMesh::Vec2d(-0.526289, 0.968431),
			OpenMesh::Vec2d(-0.458974, 0.453426),
			OpenMesh::Vec2d(-1.01656, 0.256924),
			OpenMesh::Vec2d(-1.53632, 0.247794),
			};
			for (int t = 0; t < 100; t++)
			{
				std::vector<OpenMesh::Vec2d> interpolated_points;
				interpolated_points.resize(CC_points_target.size());
				double alpha = static_cast<double>(t) / 99.0; // 正确归一化 t 范围 [0,1]
				for (size_t i = 0; i < CC_points_target.size(); ++i) {
					interpolated_points[i] = (1.0 - alpha) * CC_points_source[i] + alpha * CC_points_target[i];
				}
				linear_cage = interpolated_points;

				
				CC_points.clear();
				for (const auto& vec2 : linear_cage) {
					OpenMesh::Vec3d vec3(vec2[0], vec2[1], 0.0);  // 将第三个维度设为 0.0
					CC_points.push_back(vec3);
				}
				for (int i = 0; i < dividecages; i++) {
					auto linearcage3 = subdivideCage(linear_cage);
					linear_cage = linearcage3;
				}


				CC_mesh = createMeshFromCurveCage(CC_points);
				auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
				for (auto vh : CC_mesh.vertices())
				{
					CagevertexState[vh] = NotSelected;
				}
				curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
				//linear_cage[1] = linear_cage[1] - OpenMesh::Vec2d(0.1, 0.);
				/*auto linearcage2 = subdivideCage(linear_cage);
				linear_cage = linearcage2;
				auto linearcage3 = subdivideCage(linear_cage);
				linear_cage = linearcage3;*/
				deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
				MeshTools::AssignPoints(mesh, deformedMesh);
				update();
				QString filename = QString("S:/SIG25/BIHC/haixing1/step_%1.png").arg(t);
				QImage image = grabFramebuffer();
				image.save(filename);
			}
		}
	}
}


void MeshViewerWidget::DrawVideo2(void)
{
	std::cout << "draw video2" << std::endl;
	std::cout << "CurveBihormonic!" << std::endl;
	drawmode = CURVECAGE;
	usebih = true;
	degree = 3;
	auto arthono = [](const OpenMesh::Vec3d& p) -> OpenMesh::Vec3d {//left( -y, x)
		return OpenMesh::Vec3d(p[1], -p[0], p[2]);
	};


	if (degree == 3) {

		//haixing
		if (1) {
			int N = 8;//kuzi 8
			curvecage2.resize(N);
			LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\octopus.obj");
			mesh_beifen = mesh;
			//haixing jianqu了的
			{
							CC_points = { //octopus
				 OpenMesh::Vec3d(8.57042, 3.297, 0),
				OpenMesh::Vec3d(5.09424, 1.93482, 0),
				OpenMesh::Vec3d(8.81644, -0.913078, 0),
				OpenMesh::Vec3d(6.50689, -3.68536, 0),
				OpenMesh::Vec3d(5.42654, -1.87831, 0),
				OpenMesh::Vec3d(4.92811, 1.19895, 0),
				OpenMesh::Vec3d(5.93302, 3.06514, 0),
				OpenMesh::Vec3d(6.39359, 2.98059, 0),
				OpenMesh::Vec3d(6.76971, 2.94039, 0),
				OpenMesh::Vec3d(7.1323, 3.39599, 0),
				OpenMesh::Vec3d(7.34691, 3.96736, 0),
				OpenMesh::Vec3d(7.36178, 4.91438, 0),
				OpenMesh::Vec3d(6.49071, 5.0889, 0),
				OpenMesh::Vec3d(7.77231, 9.87716, 0),
				OpenMesh::Vec3d(5.30888, 14.7788, 0),
				OpenMesh::Vec3d(-0.841746, 14.3125, 0),
				OpenMesh::Vec3d(-5.90767, 11.3197, 0),
				OpenMesh::Vec3d(-8.86451, 3.55846, 0),
				OpenMesh::Vec3d(-0.246632, 4.78125, 0),
				OpenMesh::Vec3d(1.06736, 1.00327, 0),
				OpenMesh::Vec3d(-4.23325, 0.219585, 0),
				OpenMesh::Vec3d(-8.03561, 3.02382, 0),
				OpenMesh::Vec3d(-8.08751, 2.08127, 0),
				OpenMesh::Vec3d(-7.52196, 0.833628, 0),
				OpenMesh::Vec3d(-6.06773, 0.106026, 0),
				OpenMesh::Vec3d(-7.90343, -1.09784, 0),
				OpenMesh::Vec3d(-9.28057, -2.77283, 0),
				OpenMesh::Vec3d(-7.6208, -5.78163, 0),
				OpenMesh::Vec3d(-8.57419, -6.68359, 0),
				OpenMesh::Vec3d(-8.68614, -8.01901, 0),
				OpenMesh::Vec3d(-8.06132, -10.9547, 0),
				OpenMesh::Vec3d(-6.74283, -6.93736, 0),
				OpenMesh::Vec3d(-4.59648, -5.33218, 0),
				OpenMesh::Vec3d(-2.05936, -4.13197, 0),
				OpenMesh::Vec3d(-3.09482, -7.04246, 0),
				OpenMesh::Vec3d(-9.21992, -12.7162, 0),
				OpenMesh::Vec3d(-2.27186, -13.953, 0),
				OpenMesh::Vec3d(-2.95275, -12.5256, 0),
				OpenMesh::Vec3d(-3.79382, -11.3406, 0),
				OpenMesh::Vec3d(-3.42902, -9.89676, 0),
				OpenMesh::Vec3d(-2.6323, -11.6362, 0),
				OpenMesh::Vec3d(-1.81066, -12.1583, 0),
				OpenMesh::Vec3d(-0.00107587, -12.4131, 0),
				OpenMesh::Vec3d(-2.69772, -8.66487, 0),
				OpenMesh::Vec3d(-1.78497, -7.37903, 0),
				OpenMesh::Vec3d(0.488619, -4.78304, 0),
				OpenMesh::Vec3d(-0.0659694, -6.98257, 0),
				OpenMesh::Vec3d(-0.438017, -8.1058, 0),
				OpenMesh::Vec3d(0.945469, -9.78723, 0),
				OpenMesh::Vec3d(1.71534, -8.54231, 0),
				OpenMesh::Vec3d(1.34671, -7.00428, 0),
				OpenMesh::Vec3d(1.89121, -5.32397, 0),
				OpenMesh::Vec3d(3.61222, -8.87285, 0),
				OpenMesh::Vec3d(2.05656, -8.95106, 0),
				OpenMesh::Vec3d(1.51134, -12.1472, 0),
				OpenMesh::Vec3d(7.13949, -10.1638, 0),
				OpenMesh::Vec3d(2.57694, -5.41496, 0),
				OpenMesh::Vec3d(4.12527, -0.841089, 0),
				OpenMesh::Vec3d(4.43461, -3.18152, 0),
				OpenMesh::Vec3d(5.09308, -5.72131, 0),
				OpenMesh::Vec3d(7.13664, -5.11346, 0),
				OpenMesh::Vec3d(10.4172, -2.70598, 0),
				OpenMesh::Vec3d(6.50459, 2.41615, 0),
				OpenMesh::Vec3d(9.27712, 2.26177, 0),
				OpenMesh::Vec3d(9.67284, 2.20834, 0),
				OpenMesh::Vec3d(9.37983, 3.08828, 0),
				};
			}
			auto CC_pointsreal = CC_points;
			for (int i = 0; i < dividecages; i++)
			{
				auto linearcage1sub = subdivideCage(linear_cage);
				linear_cage = linearcage1sub;
				auto linearcage1 = subdivideCage3(CC_pointsreal);
				CC_pointsreal = linearcage1;
			}
			for (const auto& point : CC_pointsreal) {
				CC_points2d.emplace_back(point[0], point[1]); // 保留 x 和 y 分量
			}


			CC_mesh = createMeshFromCurveCage(CC_points);
			curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);//操作的网格
			auto CC_mesh_real = createMeshFromCurveCage(CC_pointsreal);
			curvecage2_real = CCpoints_fromCCmesh(CC_mesh_real, degree);//实际 的网格
			auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
			for (auto vh : CC_mesh.vertices())
			{
				CagevertexState[vh] = NotSelected;
			}
			BH3ConstructMatrix4OffSetVirtual();
			calculate_bih_weight323New();
			
			auto vertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(mesh, "vertexState");
			for (auto vh : mesh.vertices())
			{
				vertexState[vh] = NotSelected;
			}
			Set_Texture_coord();//设置纹理

			Mesh deformedMesh;
			deformedMesh.assign(mesh);
			deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
			MeshTools::AssignPoints(mesh, deformedMesh);
			update();

			if (1) {
				std::vector<OpenMesh::Vec3d> CC_points_source = CC_points;
				std::vector<OpenMesh::Vec3d> CC_points_target = { OpenMesh::Vec3d(12.3864, 1.30865, 0),
OpenMesh::Vec3d(8.54005, 0.408923, 0),
OpenMesh::Vec3d(9.88238, -2.27053, 0),
OpenMesh::Vec3d(6.50689, -3.68536, 0),
OpenMesh::Vec3d(5.42654, -1.87831, 0),
OpenMesh::Vec3d(4.92811, 1.19895, 0),
OpenMesh::Vec3d(5.93302, 3.06514, 0),
OpenMesh::Vec3d(6.30168, 2.45448, 0),
OpenMesh::Vec3d(6.96742, 2.46364, 0),
OpenMesh::Vec3d(7.48735, 2.9549, 0),
OpenMesh::Vec3d(8.28608, 4.10443, 0),
OpenMesh::Vec3d(7.36178, 4.91438, 0),
OpenMesh::Vec3d(6.49071, 5.0889, 0),
OpenMesh::Vec3d(7.77231, 9.87716, 0),
OpenMesh::Vec3d(5.30888, 14.7788, 0),
OpenMesh::Vec3d(-0.841746, 14.3125, 0),
OpenMesh::Vec3d(-5.90767, 11.3197, 0),
OpenMesh::Vec3d(-8.86451, 3.55846, 0),
OpenMesh::Vec3d(-0.246632, 4.78125, 0),
OpenMesh::Vec3d(1.06736, 1.00327, 0),
OpenMesh::Vec3d(-4.23325, 0.219585, 0),
OpenMesh::Vec3d(-9.87861, 1.2831, 0),
OpenMesh::Vec3d(-9.93051, 0.340549, 0),
OpenMesh::Vec3d(-9.36496, -0.907093, 0),
OpenMesh::Vec3d(-7.91073, -1.6347, 0),
OpenMesh::Vec3d(-9.74643, -2.83856, 0),
OpenMesh::Vec3d(-11.1236, -4.51355, 0),
OpenMesh::Vec3d(-9.4638, -7.52235, 0),
OpenMesh::Vec3d(-10.4172, -8.42431, 0),
OpenMesh::Vec3d(-10.5291, -9.75973, 0),
OpenMesh::Vec3d(-9.90432, -12.6954, 0),
OpenMesh::Vec3d(-8.16579, -7.67258, 0),
OpenMesh::Vec3d(-5.05235, -5.10958, 0),
OpenMesh::Vec3d(-2.05936, -4.13197, 0),
OpenMesh::Vec3d(-3.00349, -7.3811, 0),
OpenMesh::Vec3d(-9.9766, -8.65238, 0),
OpenMesh::Vec3d(-6.91464, -13.3494, 0),
OpenMesh::Vec3d(-6.11135, -11.8783, 0),
OpenMesh::Vec3d(-5.67153, -10.2482, 0),
OpenMesh::Vec3d(-4.3495, -9.482, 0),
OpenMesh::Vec3d(-4.35228, -10.333, 0),
OpenMesh::Vec3d(-3.93815, -11.6564, 0),
OpenMesh::Vec3d(-2.84812, -12.3313, 0),
OpenMesh::Vec3d(-2.69772, -8.66487, 0),
OpenMesh::Vec3d(-1.78497, -7.37903, 0),
OpenMesh::Vec3d(0.488619, -4.78304, 0),
OpenMesh::Vec3d(-0.0659694, -6.98257, 0),
OpenMesh::Vec3d(-0.438017, -8.1058, 0),
OpenMesh::Vec3d(0.945469, -9.78723, 0),
OpenMesh::Vec3d(1.71534, -8.54231, 0),
OpenMesh::Vec3d(1.34671, -7.00428, 0),
OpenMesh::Vec3d(1.89121, -5.32397, 0),
OpenMesh::Vec3d(3.59191, -8.62094, 0),
OpenMesh::Vec3d(3.23889, -9.70184, 0),
OpenMesh::Vec3d(7.02884, -11.7123, 0),
OpenMesh::Vec3d(5.53764, -7.20535, 0),
OpenMesh::Vec3d(3.33795, -6.95713, 0),
OpenMesh::Vec3d(4.12527, -0.841089, 0),
OpenMesh::Vec3d(4.43461, -3.18152, 0),
OpenMesh::Vec3d(5.09308, -5.72131, 0),
OpenMesh::Vec3d(7.13664, -5.11346, 0),
OpenMesh::Vec3d(10.9394, -3.89096, 0),
OpenMesh::Vec3d(9.9504, 0.890253, 0),
OpenMesh::Vec3d(13.0931, 0.273418, 0),
OpenMesh::Vec3d(13.4889, 0.219988, 0),
OpenMesh::Vec3d(13.1959, 1.09993, 0),
				};
				for (int t = 0; t < 100; t++)
				{
					std::vector<OpenMesh::Vec3d> interpolated_points;
					interpolated_points.resize(CC_points.size());
					double alpha = static_cast<double>(t) / 99.0; // 正确归一化 t 范围 [0,1]
					for (size_t i = 0; i < CC_points.size(); ++i) {
						interpolated_points[i] = (1.0 - alpha) * CC_points_source[i] + alpha * CC_points_target[i];
					}
					CC_points = interpolated_points;

					CC_mesh = createMeshFromCurveCage(CC_points);
					auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
					for (auto vh : CC_mesh.vertices())
					{
						CagevertexState[vh] = NotSelected;
					}
					curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);

					deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
					MeshTools::AssignPoints(mesh, deformedMesh);
					update();
					QString filename = QString("S:/SIG25/BIHC/octopus/step_%1.png").arg(t);
					QImage image = grabFramebuffer();
					image.save(filename);
				}
				//bezierPointSize权重为0
				bezierPointSize = 0;
				for (int t = 0; t < 100; t++)
				{
					std::vector<OpenMesh::Vec3d> interpolated_points;
					interpolated_points.resize(CC_points.size());
					double alpha = static_cast<double>(t) / 99.0; // 正确归一化 t 范围 [0,1]
					for (size_t i = 0; i < CC_points.size(); ++i) {
						interpolated_points[i] = (1.0 - alpha) * CC_points_source[i] + alpha * CC_points_target[i];
					}
					CC_points = interpolated_points;

					CC_mesh = createMeshFromCurveCage(CC_points);
					auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
					for (auto vh : CC_mesh.vertices())
					{
						CagevertexState[vh] = NotSelected;
					}
					curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);

					deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
					MeshTools::AssignPoints(mesh, deformedMesh);
					update();
					QString filename = QString("S:/SIG25/BIHC/octopus/stepG_%1.png").arg(t);
					QImage image = grabFramebuffer();
					image.save(filename);
				}
				for (int t = 0; t < 100; t++)
				{
					std::vector<OpenMesh::Vec3d> interpolated_points;
					interpolated_points.resize(CC_points.size());
					double alpha = static_cast<double>(t) / 99.0; // 正确归一化 t 范围 [0,1]
					for (size_t i = 0; i < CC_points.size(); ++i) {
						interpolated_points[i] =  CC_points_target[i];
					}
					CC_points = interpolated_points;
					bezierPointSize = alpha;
					CC_mesh = createMeshFromCurveCage(CC_points);
					auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
					for (auto vh : CC_mesh.vertices())
					{
						CagevertexState[vh] = NotSelected;
					}
					curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);

					deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
					MeshTools::AssignPoints(mesh, deformedMesh);
					update();
					QString filename = QString("S:/SIG25/BIHC/octopus/stepGB_%1.png").arg(t);
					QImage image = grabFramebuffer();
					image.save(filename);
				}
			}
		}

	}
}



void MeshViewerWidget::DrawVideo3(void)
{
	std::cout << "draw video3" << std::endl;
	std::cout << "StraightBihormonic!" << std::endl;
	drawmode = CURVECAGE;
	usebih = true;
	degree = 1;
	auto arthono = [](const OpenMesh::Vec3d& p) -> OpenMesh::Vec3d {//left( -y, x)
		return OpenMesh::Vec3d(p[1], -p[0], p[2]);
	};


	if (degree == 3) {

		//haixing
		if (1) {
			int N = 8;//kuzi 8
			curvecage2.resize(N);
			LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\daizi.obj");
			mesh_beifen = mesh;
			//createSimpleMesh();
			{
				/*ptMin = OpenMesh::Vec3d(0, 0, 0);
				ptMax = OpenMesh::Vec3d(5, 5, 0);*/
				const Eigen::Vector3d targetMin(-30.0, -4.0, 0.0);
				const Eigen::Vector3d targetMax(30.0, 4.0, 0.0);

				// 计算缩放比例
				Eigen::Vector3d scale;
				scale.x() = (targetMax.x() - targetMin.x()) / (ptMax[0] - ptMin[0]);
				scale.y() = (targetMax.y() - targetMin.y()) / (ptMax[1] - ptMin[1]);
				scale.z() = 0.0; // 保持 z 为常数

				// 更新顶点坐标
				for (auto& vh : mesh.vertices()) {
					OpenMesh::Vec3d pt = mesh.point(vh);
					pt[0] = ((pt[0] - ptMin[0]) * scale.x() + targetMin.x()) * 0.999;
					pt[1] = ((pt[1] - ptMin[1]) * scale.y() + targetMin.y()) * 0.999;
					pt[2] = 0; // 保持 z 为常数
					mesh.set_point(vh, pt);
				}
				Set_Texture_coord();//设置纹理
				OpenMesh::Vec2d move_S(-30, 4);
				for (auto& vh : mesh.vertices()) {
					OpenMesh::Vec3d pt = mesh.point(vh);
					pt[0] += move_S[0];
					pt[1] += move_S[1];
					pt[2] = 0; // 保持 z 为常数
					mesh.set_point(vh, pt);
				}
				ptMax += OpenMesh::Vec3d(move_S[0], move_S[1], 0);
				ptMin += OpenMesh::Vec3d(move_S[0], move_S[1], 0);
			}
			// 逆时针定义8个顶点
			linear_cage = {
				OpenMesh::Vec2d(30, -4),
				OpenMesh::Vec2d(30, 4),
				OpenMesh::Vec2d(15, 4),
				OpenMesh::Vec2d(0, 4),
				OpenMesh::Vec2d(-15, 4),
				OpenMesh::Vec2d(-30, 4),
				OpenMesh::Vec2d(-30, -4),
				OpenMesh::Vec2d(-15, -4),
				OpenMesh::Vec2d(0, -4),
				OpenMesh::Vec2d(15, -4),
			};
			linear_cage = {
				OpenMesh::Vec2d(30, -4)+OpenMesh::Vec2d(-30,4),
				OpenMesh::Vec2d(30, 4) + OpenMesh::Vec2d(-30,4),
				OpenMesh::Vec2d(15, 4) + OpenMesh::Vec2d(-30,4),
				OpenMesh::Vec2d(0, 4) + OpenMesh::Vec2d(-30,4),
				OpenMesh::Vec2d(-15, 4) + OpenMesh::Vec2d(-30,4),
				OpenMesh::Vec2d(-30, 4) + OpenMesh::Vec2d(-30,4),
				OpenMesh::Vec2d(-30, -4) + OpenMesh::Vec2d(-30,4),
				OpenMesh::Vec2d(-15, -4) + OpenMesh::Vec2d(-30,4),
				OpenMesh::Vec2d(0, -4) + OpenMesh::Vec2d(-30,4),
				OpenMesh::Vec2d(15, -4) + OpenMesh::Vec2d(-30,4),
			};
			auto linearcage4 = subdivideCage123(linear_cage);
			for (const auto& point : linearcage4) {
				CC_points.emplace_back(point[0], point[1], 0.0); // 将 z 设为 0
			}
			auto CC_pointsreal = CC_points;
			for (int i = 0; i < dividecages; i++)
			{
				auto linearcage1sub = subdivideCage(linear_cage);
				linear_cage = linearcage1sub;
				auto linearcage1 = subdivideCage3(CC_pointsreal);
				CC_pointsreal = linearcage1;
			}
			for (const auto& point : CC_pointsreal) {
				CC_points2d.emplace_back(point[0], point[1]); // 保留 x 和 y 分量
			}


			CC_mesh = createMeshFromCurveCage(CC_points);
			curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);//操作的网格
			auto CC_mesh_real = createMeshFromCurveCage(CC_pointsreal);
			curvecage2_real = CCpoints_fromCCmesh(CC_mesh_real, degree);//实际 的网格
			auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
			for (auto vh : CC_mesh.vertices())
			{
				CagevertexState[vh] = NotSelected;
			}
			//createSimpleMesh();
			//ConstructMatrix4OffSetTwice();
			//ConstructMatrix4OffSetThird();
			ConstructMatrix4OffSetThirdVirtualNew();
			calculate_bih_weight123New();
			auto vertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(mesh, "vertexState");
			for (auto vh : mesh.vertices())
			{
				vertexState[vh] = NotSelected;
			}
			

			Mesh deformedMesh;
			deformedMesh.assign(mesh);
			deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
			MeshTools::AssignPoints(mesh, deformedMesh);
			update();

			std::cout << "std::vector<OpenMesh::Vec3d> CC_points_source = {\n";
			for (size_t i = 0; i < CC_points.size(); ++i) {
				const auto& p = CC_points[i];
				std::cout << "    OpenMesh::Vec3d("
					<< p[0] << ", " << p[1] << ", " << p[2] << ")";
				if (i + 1 != CC_points.size()) std::cout << ",";
				std::cout << "\n";
			}
			std::cout << "};\n";

			if (1) {
				std::vector<OpenMesh::Vec3d> CC_points_source = CC_points;
				//新的袋子
				std::vector<OpenMesh::Vec3d> CC_points_target = { OpenMesh::Vec3d(-0, 6, 0),
OpenMesh::Vec3d(-0.0, 7.03417, 0),
OpenMesh::Vec3d(-0.0, 9.22533, 0),
OpenMesh::Vec3d(-0, 12, 0),
OpenMesh::Vec3d(-6.6, 12, 0),
OpenMesh::Vec3d(-12, 6.6, 0),
OpenMesh::Vec3d(-12, 0, 0),
OpenMesh::Vec3d(-12, -6.6, 0),
OpenMesh::Vec3d(-6.6, -12, 0),
OpenMesh::Vec3d(0, -12, 0),
OpenMesh::Vec3d(6.6, -12, 0),
OpenMesh::Vec3d(12, -6.6, 0),
OpenMesh::Vec3d(12, 0, 0),
OpenMesh::Vec3d(12, 6.6, 0),
OpenMesh::Vec3d(6.6, 12, 0),
OpenMesh::Vec3d(0.1, 12, 0),
OpenMesh::Vec3d(0.1, 9.22533, 0),
OpenMesh::Vec3d(0.1, 7.03417, 0),
OpenMesh::Vec3d(0.1, 6, 0),
OpenMesh::Vec3d(3.3, 6, 0),
OpenMesh::Vec3d(6, 3.3, 0),
OpenMesh::Vec3d(6, 0, 0),
OpenMesh::Vec3d(6, -3.3, 0),
OpenMesh::Vec3d(3.3, -6, 0),
OpenMesh::Vec3d(0, -6, 0),
OpenMesh::Vec3d(-3.3, -6, 0),
OpenMesh::Vec3d(-6, -3.3, 0),
OpenMesh::Vec3d(-6, 0, 0),
OpenMesh::Vec3d(-6, 3.3, 0),
OpenMesh::Vec3d(-3.3, 6, 0),
				};
				std::vector<OpenMesh::Vec3d> CC_points_target1_4 = { OpenMesh::Vec3d(-0, 6, 0),
OpenMesh::Vec3d(-0.0, 7.03417, 0),
OpenMesh::Vec3d(-0.0, 9.22533, 0),
OpenMesh::Vec3d(-0, 12, 0),
OpenMesh::Vec3d(-6.6, 12, 0),
OpenMesh::Vec3d(-12, 6.6, 0),
OpenMesh::Vec3d(-12, 0, 0),
OpenMesh::Vec3d(-12, -6.6, 0),
OpenMesh::Vec3d(-6.6, -12, 0),
OpenMesh::Vec3d(0, -12, 0),
OpenMesh::Vec3d(6.6, -12, 0),
OpenMesh::Vec3d(12, -6.6, 0),
OpenMesh::Vec3d(12, 0, 0),
OpenMesh::Vec3d(12, 6.6, 0),
OpenMesh::Vec3d(6.6, 12, 0),
OpenMesh::Vec3d(0.1, 12, 0),
OpenMesh::Vec3d(0.1, 9.22533, 0),
OpenMesh::Vec3d(0.1, 7.03417, 0),
OpenMesh::Vec3d(-6.000000, 0.000000, 0),//
OpenMesh::Vec3d(-6.000000, 0.787931, 0),
OpenMesh::Vec3d(-5.844805, 1.568147, 0),
OpenMesh::Vec3d(-5.543277, 2.296101, 0),
OpenMesh::Vec3d(-5.198072, 2.981889, 0),
OpenMesh::Vec3d(-4.713371, 3.605789, 0),
OpenMesh::Vec3d(-4.242641, 4.242641, 0),
OpenMesh::Vec3d(-3.605789, 4.713371, 0),
OpenMesh::Vec3d(-2.981889, 5.198072, 0),
OpenMesh::Vec3d(-2.296101, 5.543277, 0),
OpenMesh::Vec3d(-1.568147, 5.844805, 0),
OpenMesh::Vec3d(-0.787931, 6.000000, 0),
				};
				
				

				for (int t = 0; t < 100; t++)
				{
					std::vector<OpenMesh::Vec3d> interpolated_points;
					interpolated_points.resize(CC_points.size());
					double alpha = static_cast<double>(t) / 99.0; // 正确归一化 t 范围 [0,1]
					for (size_t i = 0; i < CC_points.size(); ++i) {
						interpolated_points[i] = (1.0 - alpha) * CC_points_source[i] + alpha * CC_points_target[i];
					}
					CC_points = interpolated_points;
					CC_points = CC_points_target1_4;
					
					
					CC_mesh = createMeshFromCurveCage(CC_points);
					auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
					for (auto vh : CC_mesh.vertices())
					{
						CagevertexState[vh] = NotSelected;
					}
					curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);

					deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
					MeshTools::AssignPoints(mesh, deformedMesh);
					update();
					QString filename = QString("S:/SIG25/BIHC/daizi/step_%1.png").arg(t);
					QImage image = grabFramebuffer();
					image.save(filename);
				}
			}
		}

	}
	//haixing
	if (degree == 1)
	{
		//paris tower

			//			linear_cage = { //paris tower
			//	OpenMesh::Vec2d(2.21312, -3.64502),
			//OpenMesh::Vec2d(0.0729413, -1.26159),
			//OpenMesh::Vec2d(0.71968, 2.04631),
			//OpenMesh::Vec2d(-0.00294265, 4.30579),
			//OpenMesh::Vec2d(-0.533977, 2.06356),
			//OpenMesh::Vec2d(0.020478, -1.26554),
			//OpenMesh::Vec2d(-2.13172, -3.62273),
			//OpenMesh::Vec2d(-1.5717, -3.65431),
			//OpenMesh::Vec2d(-0.789005, -3.66778),
			//OpenMesh::Vec2d(-0.017268, -3.66608),
			//OpenMesh::Vec2d(0.997374, -3.65183),
			//OpenMesh::Vec2d(1.73898, -3.63311),
			//			};
		linear_cage = { OpenMesh::Vec2d(2.21312, -3.64502),
OpenMesh::Vec2d(0.825116, -0.859017),
OpenMesh::Vec2d(0.550176, 1.91918),
OpenMesh::Vec2d(-0.00294265, 4.30579),
OpenMesh::Vec2d(-0.428037, 1.85168),
OpenMesh::Vec2d(-0.699915, -0.820591),
OpenMesh::Vec2d(-2.13172, -3.62273),
OpenMesh::Vec2d(-1.5717, -3.65431),
OpenMesh::Vec2d(-0.789005, -3.66778),
OpenMesh::Vec2d(-0.017268, -3.66608),
OpenMesh::Vec2d(0.997374, -3.65183),
OpenMesh::Vec2d(1.73898, -3.63311),
		};
		auto CC_points_source = linear_cage;

		for (const auto& point : linear_cage) {
			CC_points.emplace_back(point[0], point[1], 0.0); // 将 z 设为 0
		}

		for (int i = 0; i < dividecages; i++)
		{
			auto linearcage2 = subdivideCage(linear_cage);
			linear_cage = linearcage2;
		}
		LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\paristower.obj");
		Set_Texture_coord();//设置纹理

		CC_mesh = createMeshFromCurveCage(CC_points);
		curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
		auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
		for (auto vh : CC_mesh.vertices())
		{
			CagevertexState[vh] = NotSelected;
		}

		int m = linear_cage.size();
		linear_length.resize(m);
		for (int i = 0; i < m; i++) {
			linear_length[i] = (linear_cage[(i + 1) % m] - linear_cage[i]).length();
		}

		ConstructMatrix4OffSetVirtual();

		calculate_bih_weight121();
		//calculate_bih_weight121test();

		Mesh deformedMesh;
		deformedMesh.assign(mesh);
		deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
		MeshTools::AssignPoints(mesh, deformedMesh);

		auto vertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(mesh, "vertexState");
		for (auto vh : mesh.vertices())
		{
			vertexState[vh] = NotSelected;
		}
		update();
		

		if (1) {
			//这是曲边的目标cage
			/*std::vector<OpenMesh::Vec2d> CC_points_target =  { OpenMesh::Vec2d(2.21312, -3.64502),
OpenMesh::Vec2d(-0.200273, -1.09766),
OpenMesh::Vec2d(0.410037, 1.70935),
OpenMesh::Vec2d(-2.93953, 2.89046),
OpenMesh::Vec2d(-0.707013, 1.49892),
OpenMesh::Vec2d(0.147978, -1.42036),
OpenMesh::Vec2d(-2.13172, -3.62273),
OpenMesh::Vec2d(-1.5717, -3.65431),
OpenMesh::Vec2d(-0.789005, -3.66778),
OpenMesh::Vec2d(-0.017268, -3.66608),
OpenMesh::Vec2d(0.997374, -3.65183),
OpenMesh::Vec2d(1.73898, -3.63311),
			};*/
			std::vector<OpenMesh::Vec2d> CC_points_target  = { OpenMesh::Vec2d(2.21312, -3.64502),
OpenMesh::Vec2d(0.825116, -0.859017),
OpenMesh::Vec2d(0.550176, 1.91918),
OpenMesh::Vec2d(-0.00294265, 4.30579),
OpenMesh::Vec2d(-0.428037, 1.85168),
OpenMesh::Vec2d(-0.699915, -0.820591),
OpenMesh::Vec2d(-2.13172, -3.62273),
OpenMesh::Vec2d(-1.5717, -3.65431),
OpenMesh::Vec2d(-0.789005, -3.66778),
OpenMesh::Vec2d(-0.017268, -3.66608),
OpenMesh::Vec2d(0.997374, -3.65183),
OpenMesh::Vec2d(1.73898, -3.63311),
			};
			for (int t = 0; t < 100; t++)
			{
				std::vector<OpenMesh::Vec2d> interpolated_points;
				interpolated_points.resize(CC_points_target.size());
				double alpha = static_cast<double>(t) / 99.0; // 正确归一化 t 范围 [0,1]
				for (size_t i = 0; i < CC_points_target.size(); ++i) {
					interpolated_points[i] = (1.0 - alpha) * CC_points_source[i] + alpha * CC_points_target[i];
				}
				linear_cage = interpolated_points;


				CC_points.clear();
				for (const auto& vec2 : linear_cage) {
					OpenMesh::Vec3d vec3(vec2[0], vec2[1], 0.0);  // 将第三个维度设为 0.0
					CC_points.push_back(vec3);
				}
				for (int i = 0; i < dividecages; i++) {
					auto linearcage3 = subdivideCage(linear_cage);
					linear_cage = linearcage3;
				}


				CC_mesh = createMeshFromCurveCage(CC_points);
				auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
				for (auto vh : CC_mesh.vertices())
				{
					CagevertexState[vh] = NotSelected;
				}
				curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
				//linear_cage[1] = linear_cage[1] - OpenMesh::Vec2d(0.1, 0.);
				/*auto linearcage2 = subdivideCage(linear_cage);
				linear_cage = linearcage2;
				auto linearcage3 = subdivideCage(linear_cage);
				linear_cage = linearcage3;*/
				deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
				MeshTools::AssignPoints(mesh, deformedMesh);
				update();
				QString filename = QString("S:/SIG25/BIHC/tower1/step_%1.png").arg(t);
				QImage image = grabFramebuffer();
				image.save(filename);
			}
		}
	}
}
//
void MeshViewerWidget::DrawVideo_cauchy(void)
{
	std::cout << "draw video cauchy!" << std::endl;
	drawmode = CURVECAGE;
	usebih = false;
	degree = 3;
	auto arthono = [](const OpenMesh::Vec3d& p) -> OpenMesh::Vec3d {//left( -y, x)
		return OpenMesh::Vec3d(p[1], -p[0], p[2]);
	};


	if (degree == 3&&!useHandle) {

		//haixing
		if (1) {
			int N = 8;//kuzi 8
			curvecage2.resize(N);
			string filename = "E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\paristower.obj";
			LoadMesh(filename);
			for (auto vh : mesh.vertices())
			{
				OpenMesh::Vec3d p = mesh.point(vh);
				p[2] += 0.01;               // z 坐标提升 0.01
				mesh.set_point(vh, p);      // 写回 mesh
			}
			/*bool read_ok=MeshTools::ReadMesh(mesh2, filename);
			cout << "read 2 meshs!" << read_ok << endl;*/
			mesh_beifen = mesh;
			Set_Texture_coord();//设置纹理
			
			CC_points = { //paris tower
			OpenMesh::Vec3d(2.21312, -3.64502, 0),
		    OpenMesh::Vec3d(0.0729413, -1.26159, 0),
		    OpenMesh::Vec3d(0.71968, 2.04631, 0),
		    OpenMesh::Vec3d(-0.00294265, 4.30579, 0),
		    OpenMesh::Vec3d(-0.533977, 2.06356, 0),
		    OpenMesh::Vec3d(0.020478, -1.26554, 0),
		    OpenMesh::Vec3d(-2.13172, -3.62273, 0),
		    /*OpenMesh::Vec3d(-1.5717, -3.65431, 0),
		    OpenMesh::Vec3d(-0.789005, -3.66778, 0),
		    OpenMesh::Vec3d(-0.017268, -3.66608, 0),
		    OpenMesh::Vec3d(0.997374, -3.65183, 0),
		    OpenMesh::Vec3d(1.73898, -3.63311, 0),*/
				OpenMesh::Vec3d(-0.68344, -3.63016, 0),
				OpenMesh::Vec3d(0.76484, -3.63759, 0),
			};
			

			{
				N = 3;
				// 逆时针定义3个顶点
				std::vector<OpenMesh::Vec3d> square_vertices = {


					OpenMesh::Vec3d(2.21312, -3.64502, 0),
					OpenMesh::Vec3d(-0.00294265, 4.30579, 0),
					OpenMesh::Vec3d(-2.13172, -3.62273, 0),
				};
				curvecage22.resize(N);
				for (int i = 0; i < N; i++) {
					OpenMesh::Vec3d start = square_vertices[i];
					OpenMesh::Vec3d end = square_vertices[(i + 1) % N];

					OpenMesh::Vec3d p1 = start;
					OpenMesh::Vec3d p4 = end;

					// Intermediate control points (simple linear interpolation for demonstration)
					OpenMesh::Vec3d p2 = p1 + (p4 - p1) / 3;
					OpenMesh::Vec3d p3 = p1 + (p4 - p1) * 2 / 3;

					curvecage22[i] = { p1, p2, p3, p4 };

				}
				//通过curvecage2计算cc_points;
				CC_points22.clear();
				for (int i = 0; i < N; i++) {
					for (int j = 0; j < degree; j++) {
						CC_points22.push_back(curvecage22[i][j]);
					}
				}
				CC_mesh22 = createMeshFromCurveCage(CC_points22);
				curvecage22 = CCpoints_fromCCmesh(CC_mesh22, degree);//操作的网格
				auto CagevertexState22 = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh22, "vertexState");
				for (auto vh : CC_mesh22.vertices())
				{
					CagevertexState22[vh] = NotSelected;
				}
				calculate_cauchy_weight123(curvecage22,cauchyweights_2);//计算3次cage到3次控制点的权重
			}
			//线性到线性的cauchy坐标
			{
				linear_cage = { OpenMesh::Vec2d(2.21312, -3.64502),
                    OpenMesh::Vec2d(0.825116, -0.859017),
                    OpenMesh::Vec2d(0.550176, 1.91918),
                    OpenMesh::Vec2d(-0.00294265, 4.30579),
                    OpenMesh::Vec2d(-0.428037, 1.85168),
                    OpenMesh::Vec2d(-0.699915, -0.820591),
                    OpenMesh::Vec2d(-2.13172, -3.62273),
                    /*OpenMesh::Vec2d(-1.5717, -3.65431),
                    OpenMesh::Vec2d(-0.789005, -3.66778),
                    OpenMesh::Vec2d(-0.017268, -3.66608),
                    OpenMesh::Vec2d(0.997374, -3.65183),
                    OpenMesh::Vec2d(1.73898, -3.63311),*/
					OpenMesh::Vec2d(-0.68344, -3.63016),
				    OpenMesh::Vec2d(0.76484, -3.63759),
				};
				for (const auto& point : linear_cage) {
					CC_points33.emplace_back(point[0], point[1], 0.0); // 将 z 设为 0
				}
				CC_mesh33 = createMeshFromCurveCage(CC_points33);

				curvecage33 = CCpoints_fromCCmesh(CC_mesh33, 1);
				calculate_cauchy_weight121(curvecage33, cauchyweights_3);//计算3次cage到3次控制点的权重
			}

			CC_mesh = createMeshFromCurveCage(CC_points);
			curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);//操作的网格
			
			auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
			for (auto vh : CC_mesh.vertices())
			{
				CagevertexState[vh] = NotSelected;
			}
			useCauchy = true;
			calculate_cauchy_weight323();
			

			auto vertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(mesh, "vertexState");
			for (auto vh : mesh.vertices())
			{
				vertexState[vh] = NotSelected;
			}


			Mesh deformedMesh;
			deformedMesh.assign(mesh);
			deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
			MeshTools::AssignPoints(mesh, deformedMesh);
			update();

			

			if (0) {
				std::vector<OpenMesh::Vec3d> CC_points_source = CC_points;
				//新的袋子
				std::vector<OpenMesh::Vec3d> CC_points_target = { OpenMesh::Vec3d(-0, 6, 0),
OpenMesh::Vec3d(-0.0, 7.03417, 0),
OpenMesh::Vec3d(-0.0, 9.22533, 0),
OpenMesh::Vec3d(-0, 12, 0),
OpenMesh::Vec3d(-6.6, 12, 0),
OpenMesh::Vec3d(-12, 6.6, 0),
OpenMesh::Vec3d(-12, 0, 0),
OpenMesh::Vec3d(-12, -6.6, 0),
OpenMesh::Vec3d(-6.6, -12, 0),
OpenMesh::Vec3d(0, -12, 0),
OpenMesh::Vec3d(6.6, -12, 0),
OpenMesh::Vec3d(12, -6.6, 0),
OpenMesh::Vec3d(12, 0, 0),
OpenMesh::Vec3d(12, 6.6, 0),
OpenMesh::Vec3d(6.6, 12, 0),
OpenMesh::Vec3d(0.1, 12, 0),
OpenMesh::Vec3d(0.1, 9.22533, 0),
OpenMesh::Vec3d(0.1, 7.03417, 0),
OpenMesh::Vec3d(0.1, 6, 0),
OpenMesh::Vec3d(3.3, 6, 0),
OpenMesh::Vec3d(6, 3.3, 0),
OpenMesh::Vec3d(6, 0, 0),
OpenMesh::Vec3d(6, -3.3, 0),
OpenMesh::Vec3d(3.3, -6, 0),
OpenMesh::Vec3d(0, -6, 0),
OpenMesh::Vec3d(-3.3, -6, 0),
OpenMesh::Vec3d(-6, -3.3, 0),
OpenMesh::Vec3d(-6, 0, 0),
OpenMesh::Vec3d(-6, 3.3, 0),
OpenMesh::Vec3d(-3.3, 6, 0),
				};
				std::vector<OpenMesh::Vec3d> CC_points_target1_4 = { OpenMesh::Vec3d(-0, 6, 0),
OpenMesh::Vec3d(-0.0, 7.03417, 0),
OpenMesh::Vec3d(-0.0, 9.22533, 0),
OpenMesh::Vec3d(-0, 12, 0),
OpenMesh::Vec3d(-6.6, 12, 0),
OpenMesh::Vec3d(-12, 6.6, 0),
OpenMesh::Vec3d(-12, 0, 0),
OpenMesh::Vec3d(-12, -6.6, 0),
OpenMesh::Vec3d(-6.6, -12, 0),
OpenMesh::Vec3d(0, -12, 0),
OpenMesh::Vec3d(6.6, -12, 0),
OpenMesh::Vec3d(12, -6.6, 0),
OpenMesh::Vec3d(12, 0, 0),
OpenMesh::Vec3d(12, 6.6, 0),
OpenMesh::Vec3d(6.6, 12, 0),
OpenMesh::Vec3d(0.1, 12, 0),
OpenMesh::Vec3d(0.1, 9.22533, 0),
OpenMesh::Vec3d(0.1, 7.03417, 0),
OpenMesh::Vec3d(-6.000000, 0.000000, 0),//
OpenMesh::Vec3d(-6.000000, 0.787931, 0),
OpenMesh::Vec3d(-5.844805, 1.568147, 0),
OpenMesh::Vec3d(-5.543277, 2.296101, 0),
OpenMesh::Vec3d(-5.198072, 2.981889, 0),
OpenMesh::Vec3d(-4.713371, 3.605789, 0),
OpenMesh::Vec3d(-4.242641, 4.242641, 0),
OpenMesh::Vec3d(-3.605789, 4.713371, 0),
OpenMesh::Vec3d(-2.981889, 5.198072, 0),
OpenMesh::Vec3d(-2.296101, 5.543277, 0),
OpenMesh::Vec3d(-1.568147, 5.844805, 0),
OpenMesh::Vec3d(-0.787931, 6.000000, 0),
				};



				for (int t = 0; t < 100; t++)
				{
					std::vector<OpenMesh::Vec3d> interpolated_points;
					interpolated_points.resize(CC_points.size());
					double alpha = static_cast<double>(t) / 99.0; // 正确归一化 t 范围 [0,1]
					for (size_t i = 0; i < CC_points.size(); ++i) {
						interpolated_points[i] = (1.0 - alpha) * CC_points_source[i] + alpha * CC_points_target[i];
					}
					CC_points = interpolated_points;
					CC_points = CC_points_target1_4;


					CC_mesh = createMeshFromCurveCage(CC_points);
					auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
					for (auto vh : CC_mesh.vertices())
					{
						CagevertexState[vh] = NotSelected;
					}
					curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);

					deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
					MeshTools::AssignPoints(mesh, deformedMesh);
					update();
					QString filename = QString("S:/SIG25/BIHC/daizi/step_%1.png").arg(t);
					QImage image = grabFramebuffer();
					image.save(filename);
				}
			}
		}

	}
	if (degree == 3 && useHandle) {

	}
	//haixing
	if (degree == 1)
	{
		//paris tower

			//			linear_cage = { //paris tower
			//	OpenMesh::Vec2d(2.21312, -3.64502),
			//OpenMesh::Vec2d(0.0729413, -1.26159),
			//OpenMesh::Vec2d(0.71968, 2.04631),
			//OpenMesh::Vec2d(-0.00294265, 4.30579),
			//OpenMesh::Vec2d(-0.533977, 2.06356),
			//OpenMesh::Vec2d(0.020478, -1.26554),
			//OpenMesh::Vec2d(-2.13172, -3.62273),
			//OpenMesh::Vec2d(-1.5717, -3.65431),
			//OpenMesh::Vec2d(-0.789005, -3.66778),
			//OpenMesh::Vec2d(-0.017268, -3.66608),
			//OpenMesh::Vec2d(0.997374, -3.65183),
			//OpenMesh::Vec2d(1.73898, -3.63311),
			//			};
		linear_cage = { OpenMesh::Vec2d(2.21312, -3.64502),
OpenMesh::Vec2d(0.825116, -0.859017),
OpenMesh::Vec2d(0.550176, 1.91918),
OpenMesh::Vec2d(-0.00294265, 4.30579),
OpenMesh::Vec2d(-0.428037, 1.85168),
OpenMesh::Vec2d(-0.699915, -0.820591),
OpenMesh::Vec2d(-2.13172, -3.62273),
OpenMesh::Vec2d(-1.5717, -3.65431),
OpenMesh::Vec2d(-0.789005, -3.66778),
OpenMesh::Vec2d(-0.017268, -3.66608),
OpenMesh::Vec2d(0.997374, -3.65183),
OpenMesh::Vec2d(1.73898, -3.63311),
		};
		auto CC_points_source = linear_cage;

		for (const auto& point : linear_cage) {
			CC_points.emplace_back(point[0], point[1], 0.0); // 将 z 设为 0
		}

		for (int i = 0; i < dividecages; i++)
		{
			auto linearcage2 = subdivideCage(linear_cage);
			linear_cage = linearcage2;
		}
		LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\paristower.obj");
		Set_Texture_coord();//设置纹理

		CC_mesh = createMeshFromCurveCage(CC_points);
		curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
		auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
		for (auto vh : CC_mesh.vertices())
		{
			CagevertexState[vh] = NotSelected;
		}

		int m = linear_cage.size();
		linear_length.resize(m);
		for (int i = 0; i < m; i++) {
			linear_length[i] = (linear_cage[(i + 1) % m] - linear_cage[i]).length();
		}

		ConstructMatrix4OffSetVirtual();

		calculate_bih_weight121();
		//calculate_bih_weight121test();

		Mesh deformedMesh;
		deformedMesh.assign(mesh);
		deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
		MeshTools::AssignPoints(mesh, deformedMesh);

		auto vertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(mesh, "vertexState");
		for (auto vh : mesh.vertices())
		{
			vertexState[vh] = NotSelected;
		}
		update();


		if (1) {
			//这是曲边的目标cage
			
			std::vector<OpenMesh::Vec2d> CC_points_target = { OpenMesh::Vec2d(2.21312, -3.64502),
OpenMesh::Vec2d(0.825116, -0.859017),
OpenMesh::Vec2d(0.550176, 1.91918),
OpenMesh::Vec2d(-0.00294265, 4.30579),
OpenMesh::Vec2d(-0.428037, 1.85168),
OpenMesh::Vec2d(-0.699915, -0.820591),
OpenMesh::Vec2d(-2.13172, -3.62273),
OpenMesh::Vec2d(-1.5717, -3.65431),
OpenMesh::Vec2d(-0.789005, -3.66778),
OpenMesh::Vec2d(-0.017268, -3.66608),
OpenMesh::Vec2d(0.997374, -3.65183),
OpenMesh::Vec2d(1.73898, -3.63311),
			};
			for (int t = 0; t < 100; t++)
			{
				std::vector<OpenMesh::Vec2d> interpolated_points;
				interpolated_points.resize(CC_points_target.size());
				double alpha = static_cast<double>(t) / 99.0; // 正确归一化 t 范围 [0,1]
				for (size_t i = 0; i < CC_points_target.size(); ++i) {
					interpolated_points[i] = (1.0 - alpha) * CC_points_source[i] + alpha * CC_points_target[i];
				}
				linear_cage = interpolated_points;


				CC_points.clear();
				for (const auto& vec2 : linear_cage) {
					OpenMesh::Vec3d vec3(vec2[0], vec2[1], 0.0);  // 将第三个维度设为 0.0
					CC_points.push_back(vec3);
				}
				for (int i = 0; i < dividecages; i++) {
					auto linearcage3 = subdivideCage(linear_cage);
					linear_cage = linearcage3;
				}


				CC_mesh = createMeshFromCurveCage(CC_points);
				auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
				for (auto vh : CC_mesh.vertices())
				{
					CagevertexState[vh] = NotSelected;
				}
				curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
				//linear_cage[1] = linear_cage[1] - OpenMesh::Vec2d(0.1, 0.);
				/*auto linearcage2 = subdivideCage(linear_cage);
				linear_cage = linearcage2;
				auto linearcage3 = subdivideCage(linear_cage);
				linear_cage = linearcage3;*/
				deform_mesh_from_cc(deformedMesh);//通过重心坐标改变mesh的顶点位置
				MeshTools::AssignPoints(mesh, deformedMesh);
				update();
				QString filename = QString("S:/SIG25/BIHC/tower1/step_%1.png").arg(t);
				QImage image = grabFramebuffer();
				image.save(filename);
			}
		}
	}
}
void MeshViewerWidget::PolyGC_Test(void)
{
	drawmode = CURVECAGE;
	moveHistories.clear();
	currentHistoryPos = 0;
	double test = F2_n(Mesh::Point(0, 0, 0), Mesh::Point(0, 2, 0), Mesh::Point(-2, -2, 0), Mesh::Point(1, 0, 0), 1);

	//daizi
	if (0) {
		LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\daizi.obj");
		//createSimpleMesh();
		{
			/*ptMin = OpenMesh::Vec3d(0, 0, 0);
			ptMax = OpenMesh::Vec3d(5, 5, 0);*/
			const Eigen::Vector3d targetMin(-30.0, -4.0, 0.0);
			const Eigen::Vector3d targetMax(30.0, 4.0, 0.0);

			// 计算缩放比例
			Eigen::Vector3d scale;
			scale.x() = (targetMax.x() - targetMin.x()) / (ptMax[0] - ptMin[0]);
			scale.y() = (targetMax.y() - targetMin.y()) / (ptMax[1] - ptMin[1]);
			scale.z() = 0.0; // 保持 z 为常数

			// 更新顶点坐标
			for (auto& vh : mesh.vertices()) {
				OpenMesh::Vec3d pt = mesh.point(vh);
				pt[0] = ((pt[0] - ptMin[0]) * scale.x() + targetMin.x()) * 0.999;
				pt[1] = ((pt[1] - ptMin[1]) * scale.y() + targetMin.y()) * 0.999;
				pt[2] = 0; // 保持 z 为常数
				mesh.set_point(vh, pt);
			}
		}
		// 逆时针定义8个顶点
		linear_cage = {
			OpenMesh::Vec2d(30, -4),
			OpenMesh::Vec2d(30, 4),
			OpenMesh::Vec2d(15, 4),
			OpenMesh::Vec2d(0, 4),
			OpenMesh::Vec2d(-15, 4),
			OpenMesh::Vec2d(-30, 4),
			OpenMesh::Vec2d(-30, -4),
			OpenMesh::Vec2d(-15, -4),
			OpenMesh::Vec2d(0, -4),
			OpenMesh::Vec2d(15, -4),
		};
		auto linearcage4 = subdivideCage123(linear_cage);
		for (const auto& point : linearcage4) {
			CC_points.emplace_back(point[0], point[1], 0.0); // 将 z 设为 0
		}
		CC_mesh = createMeshFromCurveCage(CC_points);
		curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
		auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
		for (auto vh : CC_mesh.vertices())
		{
			CagevertexState[vh] = NotSelected;
		}
		calculate_green_weight123();//计算3次cage到3次控制点的权重
	}
	//fengzheng
	if (0) {
		LoadMesh("E:\\codes\\project_BiHC\\mesh\\xiyi.obj");
		//createSimpleMesh();
		
		// 逆时针定义8个顶点
		linear_cage = {
			OpenMesh::Vec2d(30, -4),
			OpenMesh::Vec2d(30, 4),
			OpenMesh::Vec2d(15, 4),
			OpenMesh::Vec2d(0, 4),
			
			OpenMesh::Vec2d(-30, 4),
			OpenMesh::Vec2d(-30, -4),
			
			OpenMesh::Vec2d(0, -4),
			OpenMesh::Vec2d(15, -4),
		};
		auto linearcage4 = subdivideCage123(linear_cage);
		for (const auto& point : linearcage4) {
			CC_points.emplace_back(point[0], point[1], 0.0); // 将 z 设为 0
		}
		CC_mesh = createMeshFromCurveCage(CC_points);
		curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
		auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
		for (auto vh : CC_mesh.vertices())
		{
			CagevertexState[vh] = NotSelected;
		}
		calculate_green_weight123();//计算3次cage到3次控制点的权重
	}
	//xiyi
	if (0) {
		LoadMesh("E:\\codes\\project_BiHC\\mesh\\dol.obj");
		//createSimpleMesh();

		// 逆时针定义8个顶点
		linear_cage = {
			OpenMesh::Vec2d(20, -15),
			OpenMesh::Vec2d(20, 15),
			OpenMesh::Vec2d(10, 15),
			OpenMesh::Vec2d(0, 15),

			OpenMesh::Vec2d(-20, 15),
			OpenMesh::Vec2d(-20, -15),

			OpenMesh::Vec2d(0, -15),
			OpenMesh::Vec2d(10, -15),
		};
		auto linearcage4 = subdivideCage123(linear_cage);
		for (const auto& point : linearcage4) {
			CC_points.emplace_back(point[0], point[1], 0.0); // 将 z 设为 0
		}
		CC_mesh = createMeshFromCurveCage(CC_points);
		curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
		auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
		for (auto vh : CC_mesh.vertices())
		{
			CagevertexState[vh] = NotSelected;
		}
		calculate_green_weight123();//计算3次cage到3次控制点的权重
	}
	//dol
	if (0) {
		LoadMesh("E:\\codes\\project_BiHC\\mesh\\chong.obj");
		//createSimpleMesh();

		// 逆时针定义8个顶点
		linear_cage = {
			OpenMesh::Vec2d(20, -15),
			OpenMesh::Vec2d(20, 15),
			OpenMesh::Vec2d(10, 15),
			OpenMesh::Vec2d(0, 15),

			OpenMesh::Vec2d(-20, 15),
			OpenMesh::Vec2d(-20, -15),

			OpenMesh::Vec2d(0, -15),
			OpenMesh::Vec2d(10, -15),
		};
		auto linearcage4 = subdivideCage123(linear_cage);
		for (const auto& point : linearcage4) {
			CC_points.emplace_back(point[0], point[1], 0.0); // 将 z 设为 0
		}
		CC_mesh = createMeshFromCurveCage(CC_points);
		curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
		auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
		for (auto vh : CC_mesh.vertices())
		{
			CagevertexState[vh] = NotSelected;
		}
		calculate_green_weight123();//计算3次cage到3次控制点的权重
	}
	//chong
	if (0) {
		LoadMesh("..\\mesh\\yezi.obj");
		//createSimpleMesh();

		// 逆时针定义8个顶点
		linear_cage = {
			OpenMesh::Vec2d(20, -15),
			OpenMesh::Vec2d(20, 15),
			OpenMesh::Vec2d(10, 15),
			OpenMesh::Vec2d(0, 15),

			OpenMesh::Vec2d(-20, 15),
			OpenMesh::Vec2d(-20, -15),

			OpenMesh::Vec2d(0, -15),
			OpenMesh::Vec2d(10, -15),
		};
		auto linearcage4 = subdivideCage123(linear_cage);
		for (const auto& point : linearcage4) {
			CC_points.emplace_back(point[0], point[1], 0.0); // 将 z 设为 0
		}
		CC_mesh = createMeshFromCurveCage(CC_points);
		curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
		auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
		for (auto vh : CC_mesh.vertices())
		{
			CagevertexState[vh] = NotSelected;
		}
		calculate_green_weight123();//计算3次cage到3次控制点的权重
	}
	//yezi
	if (0) {
	LoadMesh("..\\mesh\\hat.obj");
	//createSimpleMesh();

	// 逆时针定义8个顶点
	linear_cage = {
		OpenMesh::Vec2d(10, -5),
		OpenMesh::Vec2d(10, 5),
		OpenMesh::Vec2d(5, 5),
		OpenMesh::Vec2d(0, 5),

		OpenMesh::Vec2d(-10, 5),
		OpenMesh::Vec2d(-10, -5),

		OpenMesh::Vec2d(0, -5),
		OpenMesh::Vec2d(5, -5),
	};
	auto linearcage4 = subdivideCage123(linear_cage);
	for (const auto& point : linearcage4) {
		CC_points.emplace_back(point[0], point[1], 0.0); // 将 z 设为 0
	}
	CC_mesh = createMeshFromCurveCage(CC_points);
	curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
	auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
	for (auto vh : CC_mesh.vertices())
	{
		CagevertexState[vh] = NotSelected;
	}
	calculate_green_weight123();//计算3次cage到3次控制点的权重
	}
	//hat
	if (0) {
		LoadMesh("..\\mesh\\seahorse.obj");
		//createSimpleMesh();

		// 逆时针定义8个顶点
		linear_cage = {
			OpenMesh::Vec2d(20, -15),
			OpenMesh::Vec2d(20, 15),
			OpenMesh::Vec2d(10, 15),
			OpenMesh::Vec2d(0, 15),

			OpenMesh::Vec2d(-20, 15),
			OpenMesh::Vec2d(-20, -15),

			OpenMesh::Vec2d(0, -15),
			OpenMesh::Vec2d(10, -15),
		};
		auto linearcage4 = subdivideCage123(linear_cage);
		for (const auto& point : linearcage4) {
			CC_points.emplace_back(point[0], point[1], 0.0); // 将 z 设为 0
		}
		CC_mesh = createMeshFromCurveCage(CC_points);
		curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
		auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
		for (auto vh : CC_mesh.vertices())
		{
			CagevertexState[vh] = NotSelected;
		}
		calculate_green_weight123();//计算3次cage到3次控制点的权重
	}
	//seahorse
	if (0) {
		LoadMesh("..\\mesh\\jinglin.obj");
		//createSimpleMesh();

		// 逆时针定义8个顶点
		linear_cage = {
			OpenMesh::Vec2d(20, -15),
			OpenMesh::Vec2d(20, 15),
			OpenMesh::Vec2d(10, 15),
			OpenMesh::Vec2d(0, 15),

			OpenMesh::Vec2d(-20, 15),
			OpenMesh::Vec2d(-20, -15),

			OpenMesh::Vec2d(0, -15),
			OpenMesh::Vec2d(10, -15),
		};
		auto linearcage4 = subdivideCage123(linear_cage);
		for (const auto& point : linearcage4) {
			CC_points.emplace_back(point[0], point[1], 0.0); // 将 z 设为 0
		}
		CC_mesh = createMeshFromCurveCage(CC_points);
		curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
		auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
		for (auto vh : CC_mesh.vertices())
		{
			CagevertexState[vh] = NotSelected;
		}
		calculate_green_weight123();//计算3次cage到3次控制点的权重
	}
	//seahorse
	if (0) {
		LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\fengzheng.obj");
		//createSimpleMesh();

		// 逆时针定义8个顶点
		linear_cage = {
			OpenMesh::Vec2d(30, -4),
			OpenMesh::Vec2d(30, 4),
			OpenMesh::Vec2d(15, 4),
			OpenMesh::Vec2d(0, 4),

			OpenMesh::Vec2d(-30, 4),
			OpenMesh::Vec2d(-30, -4),

			OpenMesh::Vec2d(0, -4),
			OpenMesh::Vec2d(15, -4),
		};
		auto linearcage4 = subdivideCage123(linear_cage);
		for (const auto& point : linearcage4) {
			CC_points.emplace_back(point[0], point[1], 0.0); // 将 z 设为 0
		}
		CC_mesh = createMeshFromCurveCage(CC_points);
		curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
		auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
		for (auto vh : CC_mesh.vertices())
		{
			CagevertexState[vh] = NotSelected;
		}
		calculate_green_weight123();//计算3次cage到3次控制点的权重
	}
	//正儿八经的GC kuzi
	if (0) {
		int N = 8;//kuzi 8
		curvecage2.resize(N);
		LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\kuzi.obj");
		// 逆时针定义8个顶点
		std::vector<OpenMesh::Vec3d> square_vertices = {
			OpenMesh::Vec3d(11.4393 + 0.01, 14.8404 + 0.01, 0),
			OpenMesh::Vec3d(-11.3137 - 0.01, 14.8404 + 0.01, 0),
			OpenMesh::Vec3d(-11.3137 - 0.01, -15.0839 - 0.01, 0),
			OpenMesh::Vec3d(-0.822533 + 0.01, -15.0839 - 0.01, 0),
			OpenMesh::Vec3d(-0.822533 + 0.01, 1.35013 - 0.01, 0),
			OpenMesh::Vec3d(0.937067 - 0.01, 1.36120 - 0.01, 0),
			OpenMesh::Vec3d(0.948133 - 0.01, -15.0839 - 0.01, 0),
			OpenMesh::Vec3d(11.4393 + 0.01, -15.0839 - 0.01, 0)
		};
		for (int i = 0; i < 8; i++) {
			OpenMesh::Vec3d start = square_vertices[i];
			OpenMesh::Vec3d end = square_vertices[(i + 1) % 8];

			OpenMesh::Vec3d p1 = start;
			OpenMesh::Vec3d p4 = end;

			// Intermediate control points (simple linear interpolation for demonstration)
			OpenMesh::Vec3d p2 = p1 + (p4 - p1) / 3;
			OpenMesh::Vec3d p3 = p1 + (p4 - p1) * 2 / 3;

			curvecage2[i] = { p1, p2, p3, p4 };

		}
		//通过curvecage2计算cc_points;
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < degree; j++) {
				CC_points.push_back(curvecage2[i][j]);
			}
		}
		//auto sub_points = subdivideCage3(CC_points);//测试细分是否对结果有影响
		//CC_points = sub_points;

		CC_mesh = createMeshFromCurveCage(CC_points);
		curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
		auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
		for (auto vh : CC_mesh.vertices())
		{
			CagevertexState[vh] = NotSelected;
		}
		calculate_green_weight123();//计算3次cage到3次控制点的权重
	}
	//choufish的GC
	if (0) {
		int N = 12;
		curvecage2.resize(N);
		std::vector<OpenMesh::Vec3d> polygon_vertices = {
			OpenMesh::Vec3d(0.621947, -3.00053, 0),
			OpenMesh::Vec3d(2.33876, -3.72963, 0),
			OpenMesh::Vec3d(5.77752, -1.50034, 0),
			OpenMesh::Vec3d(2.85876, 2.93215, 0),
			OpenMesh::Vec3d(-5.38815, 3.38406, 0),
			OpenMesh::Vec3d(-5.53413, 2.63302, 0),
			OpenMesh::Vec3d(0.310345, 2.27181, 0),
			OpenMesh::Vec3d(-3.27319, 0.781111, 0),
			OpenMesh::Vec3d(-3.53785, -1.70024, 0),
			OpenMesh::Vec3d(-1.94263, -3.6211, 0),
			OpenMesh::Vec3d(0.503098, -2.97635, 0),
			OpenMesh::Vec3d(1.78622, -2.87407, 0),
		};
		for (int i = 0; i < N; i++) {
			OpenMesh::Vec3d start = polygon_vertices[i];
			OpenMesh::Vec3d end = polygon_vertices[(i + 1) % N];

			OpenMesh::Vec3d p1 = start;
			OpenMesh::Vec3d p4 = end;

			// Intermediate control points (simple linear interpolation for demonstration)
			OpenMesh::Vec3d p2 = p1 + (p4 - p1) / 3;
			OpenMesh::Vec3d p3 = p1 + (p4 - p1) * 2 / 3;

			curvecage2[i] = { p1, p2, p3, p4 };

		}
		//通过curvecage2计算cc_points;
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < degree; j++) {
				CC_points.push_back(curvecage2[i][j]);
			}
		}


		CC_mesh = createMeshFromCurveCage(CC_points);
		curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
		auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
		for (auto vh : CC_mesh.vertices())
		{
			CagevertexState[vh] = NotSelected;
		}
		calculate_green_weight123();//计算3次cage到3次控制点的权重
	}
	//第一条边特殊的GCkuzi
	if (0)
	{
		int N = 8;//kuzi 8
		curvecage2.resize(N);

		// 逆时针定义8个顶点
		std::vector<OpenMesh::Vec3d> square_vertices = {
			OpenMesh::Vec3d(11.4393 + 0.01, 14.8404 + 0.01, 0),
			OpenMesh::Vec3d(-11.3137 - 0.01, 14.8404 + 0.01, 0),
			OpenMesh::Vec3d(-11.3137 - 0.01, -15.0839 - 0.01, 0),
			OpenMesh::Vec3d(-0.822533 + 0.01, -15.0839 - 0.01, 0),
			OpenMesh::Vec3d(-0.822533 + 0.01, 1.35013 - 0.01, 0),
			OpenMesh::Vec3d(0.937067 - 0.01, 1.36120 - 0.01, 0),
			OpenMesh::Vec3d(0.948133 - 0.01, -15.0839 - 0.01, 0),
			OpenMesh::Vec3d(11.4393 + 0.01, -15.0839 - 0.01, 0)
		};
		{//0特殊设置控制点
			int i = 0;
			OpenMesh::Vec3d start = square_vertices[i];
			OpenMesh::Vec3d end = square_vertices[(i + 1) % 8];

			OpenMesh::Vec3d p1 = start;
			OpenMesh::Vec3d p4 = end;

			// Intermediate control points (simple linear interpolation for demonstration)
			OpenMesh::Vec3d p2 = p1 + (p4 - p1) / 2;
			OpenMesh::Vec3d p3 = p1 + (p4 - p1) /3;

			curvecage2[i] = { p1, p2, p3, p4 };

		}
		for (int i = 1; i < 8; i++) {
			OpenMesh::Vec3d start = square_vertices[i];
			OpenMesh::Vec3d end = square_vertices[(i + 1) % 8];

			OpenMesh::Vec3d p1 = start;
			OpenMesh::Vec3d p4 = end;

			// Intermediate control points (simple linear interpolation for demonstration)
			OpenMesh::Vec3d p2 = p1 + (p4 - p1) / 3;
			OpenMesh::Vec3d p3 = p1 + (p4 - p1) * 2 / 3;

			curvecage2[i] = { p1, p2, p3, p4 };

		}
		//通过curvecage2计算cc_points;
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < degree; j++) {
				CC_points.push_back(curvecage2[i][j]);
			}
		}


		CC_mesh = createMeshFromCurveCage(CC_points);
		curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
		auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
		for (auto vh : CC_mesh.vertices())
		{
			CagevertexState[vh] = NotSelected;
		}
		calculate_specialgreen_weight123({0});//计算3次cage到3次控制点的权重
	}

	//第3,5条边特殊的GCfish,chousifh
	if (0)
	{
		int N = 12;
		curvecage2.resize(N);
		std::vector<OpenMesh::Vec3d> polygon_vertices = {
			OpenMesh::Vec3d(0.621947, -3.00053, 0),
			OpenMesh::Vec3d(2.33876, -3.72963, 0),
			OpenMesh::Vec3d(5.77752, -1.50034, 0),
			OpenMesh::Vec3d(2.85876, 2.93215, 0),
			OpenMesh::Vec3d(-5.38815, 3.38406, 0),
			OpenMesh::Vec3d(-5.53413, 2.63302, 0),
			OpenMesh::Vec3d(0.310345, 2.27181, 0),
			OpenMesh::Vec3d(-3.27319, 0.781111, 0),
			OpenMesh::Vec3d(-3.53785, -1.70024, 0),
			OpenMesh::Vec3d(-1.94263, -3.6211, 0),
			OpenMesh::Vec3d(0.503098, -2.97635, 0),
			OpenMesh::Vec3d(1.78622, -2.87407, 0),
		};
		if (1)
		{//3特殊设置控制点
			int i = 3;
			OpenMesh::Vec3d start = polygon_vertices[i];
			OpenMesh::Vec3d end = polygon_vertices[(i + 1) % N];

			OpenMesh::Vec3d p1 = start;
			OpenMesh::Vec3d p4 = end;

			// Intermediate control points (simple linear interpolation for demonstration)
			OpenMesh::Vec3d p2 = p1 + (p4 - p1) / 1.2;
			OpenMesh::Vec3d p3 = p1 + (p4 - p1) / 8;

			curvecage2[i] = { p1, p2, p3, p4 };

		}
		if(1)
		{//3特殊设置控制点
			int i = 7;
			OpenMesh::Vec3d start = polygon_vertices[i];
			OpenMesh::Vec3d end = polygon_vertices[(i + 1) % N];

			OpenMesh::Vec3d p1 = start;
			OpenMesh::Vec3d p4 = end;

			// Intermediate control points (simple linear interpolation for demonstration)
			OpenMesh::Vec3d p2 = p1 + (p4 - p1) / 1.2;
			OpenMesh::Vec3d p3 = p1 + (p4 - p1) / 2;

			curvecage2[i] = { p1, p2, p3, p4 };

		}
		{//5特殊设置控制点
			int i =5;
			OpenMesh::Vec3d start = polygon_vertices[i];
			OpenMesh::Vec3d end = polygon_vertices[(i + 1) % N];

			OpenMesh::Vec3d p1 = start;
			OpenMesh::Vec3d p4 = end;

			// Intermediate control points (simple linear interpolation for demonstration)
			OpenMesh::Vec3d p2 = p1 + (p4 - p1) / 1.2;//2
			OpenMesh::Vec3d p3 = p1 + (p4 - p1) / 8;//3

			curvecage2[i] = { p1, p2, p3, p4 };

		}
		for (int i = 0; i < N; i++) {
			if (i==3||i == 7 || i == 5)
				continue;
			OpenMesh::Vec3d start = polygon_vertices[i];
			OpenMesh::Vec3d end = polygon_vertices[(i + 1) % N];

			OpenMesh::Vec3d p1 = start;
			OpenMesh::Vec3d p4 = end;

			// Intermediate control points (simple linear interpolation for demonstration)
			OpenMesh::Vec3d p2 = p1 + (p4 - p1) / 3;
			OpenMesh::Vec3d p3 = p1 + (p4 - p1) * 2 / 3;

			curvecage2[i] = { p1, p2, p3, p4 };

		}
		//通过curvecage2计算cc_points;
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < degree; j++) {
				CC_points.push_back(curvecage2[i][j]);
			}
		}


		CC_mesh = createMeshFromCurveCage(CC_points);
		curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
		auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
		for (auto vh : CC_mesh.vertices())
		{
			CagevertexState[vh] = NotSelected;
		}
		calculate_specialgreen_weight123({3,5,7});//计算3次cage到3次控制点的权重
	}

	//正儿八经的GC,zoom fish
	if (0) {
		int N = 4;//zoom_fish 4
		curvecage2.resize(N);

		// 逆时针定义4个顶点
		std::vector<OpenMesh::Vec3d> square_vertices = {
			OpenMesh::Vec3d(15.9365 + 0.01,  1.25963 + 0.01, 0),
			OpenMesh::Vec3d(-16.3751 - 0.01,  1.25963 + 0.01, 0),
			OpenMesh::Vec3d(-16.3751 - 0.01, -1.86695 - 0.01, 0),
			OpenMesh::Vec3d(15.9365 + 0.01, -1.86695 - 0.01, 0),
			
		};
		for (int i = 0; i < N; i++) {
			OpenMesh::Vec3d start = square_vertices[i];
			OpenMesh::Vec3d end = square_vertices[(i + 1) % N];

			OpenMesh::Vec3d p1 = start;
			OpenMesh::Vec3d p4 = end;

			// Intermediate control points (simple linear interpolation for demonstration)
			OpenMesh::Vec3d p2 = p1 + (p4 - p1) / 3;
			OpenMesh::Vec3d p3 = p1 + (p4 - p1) * 2 / 3;

			curvecage2[i] = { p1, p2, p3, p4 };

		}
		//通过curvecage2计算cc_points;
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < degree; j++) {
				CC_points.push_back(curvecage2[i][j]);
			}
		}


		CC_mesh = createMeshFromCurveCage(CC_points);
		curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
		auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
		for (auto vh : CC_mesh.vertices())
		{
			CagevertexState[vh] = NotSelected;
		}
		calculate_green_weight123();//计算3次cage到3次控制点的权重
	}
	//第0条边特殊的GCfish,zoomfifh
	if (0)
	{
		int N = 4;//zoom_fish 4
		curvecage2.resize(N);

		// 逆时针定义4个顶点
		std::vector<OpenMesh::Vec3d> polygon_vertices = {
			OpenMesh::Vec3d(15.9365 + 0.01,  1.25963 + 0.01, 0),
			OpenMesh::Vec3d(-16.3751 - 0.01,  1.25963 + 0.01, 0),
			OpenMesh::Vec3d(-16.3751 - 0.01, -1.86695 - 0.01, 0),
			OpenMesh::Vec3d(15.9365 + 0.01, -1.86695 - 0.01, 0),

		};
		if (0)
		{//0特殊设置控制点
			int i = 0;
			OpenMesh::Vec3d start = polygon_vertices[i];
			OpenMesh::Vec3d end = polygon_vertices[(i + 1) % N];

			OpenMesh::Vec3d p1 = start;
			OpenMesh::Vec3d p4 = end;

			// Intermediate control points (simple linear interpolation for demonstration)
			OpenMesh::Vec3d p2 = p1 + (p4 - p1) *2/ 3;
			OpenMesh::Vec3d p3 = p1 + (p4 - p1) / 3;

			curvecage2[i] = { p1, p2, p3, p4 };

		}
		if (0)
		{//0特殊设置控制点
			int i = 0;
			OpenMesh::Vec3d start = polygon_vertices[i];
			OpenMesh::Vec3d end = polygon_vertices[(i + 1) % N];

			OpenMesh::Vec3d p1 = start;
			OpenMesh::Vec3d p4 = end;

			// Intermediate control points (simple linear interpolation for demonstration)
			OpenMesh::Vec3d p2 = p1 + (p4 - p1) * 0.6;
			OpenMesh::Vec3d p3 = p1 + (p4 - p1) *0.9;

			curvecage2[i] = { p1, p2, p3, p4 };

		}
		if (1)
		{//0特殊设置控制点
			int i = 0;
			OpenMesh::Vec3d start = polygon_vertices[i];
			OpenMesh::Vec3d end = polygon_vertices[(i + 1) % N];

			OpenMesh::Vec3d p1 = start;
			OpenMesh::Vec3d p4 = end;

			// Intermediate control points (simple linear interpolation for demonstration)
			OpenMesh::Vec3d p2 = p1 + (p4 - p1) * 0.2;
			OpenMesh::Vec3d p3 = p1 + (p4 - p1) * 0.8;

			curvecage2[i] = { p1, p2, p3, p4 };

		}
		if(0)
		{//5特殊设置控制点
			int i = 5;
			OpenMesh::Vec3d start = polygon_vertices[i];
			OpenMesh::Vec3d end = polygon_vertices[(i + 1) % N];

			OpenMesh::Vec3d p1 = start;
			OpenMesh::Vec3d p4 = end;

			// Intermediate control points (simple linear interpolation for demonstration)
			OpenMesh::Vec3d p2 = p1 + (p4 - p1) / 1.2;//2
			OpenMesh::Vec3d p3 = p1 + (p4 - p1) / 8;//3

			curvecage2[i] = { p1, p2, p3, p4 };

		}
		for (int i = 0; i < N; i++) {
			if (i == 0)
				continue;
			OpenMesh::Vec3d start = polygon_vertices[i];
			OpenMesh::Vec3d end = polygon_vertices[(i + 1) % N];

			OpenMesh::Vec3d p1 = start;
			OpenMesh::Vec3d p4 = end;

			// Intermediate control points (simple linear interpolation for demonstration)
			OpenMesh::Vec3d p2 = p1 + (p4 - p1) / 3;
			OpenMesh::Vec3d p3 = p1 + (p4 - p1) * 2 / 3;

			curvecage2[i] = { p1, p2, p3, p4 };

		}
		//通过curvecage2计算cc_points;
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < degree; j++) {
				CC_points.push_back(curvecage2[i][j]);
			}
		}


		CC_mesh = createMeshFromCurveCage(CC_points);
		curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
		auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
		for (auto vh : CC_mesh.vertices())
		{
			CagevertexState[vh] = NotSelected;
		}
		calculate_specialgreen_weight123({ 0 });//计算3次cage到3次控制点的权重
	}

	//正儿八经的GC,circle
	if (0) {
		int N = 8;//circle 4
		curvecage2.resize(N);

		// 逆时针定义8个顶点
		std::vector<OpenMesh::Vec3d> square_vertices = {
			OpenMesh::Vec3d(4.96702, 1.64565, 0),
			OpenMesh::Vec3d(2.85338, 4.94866, 0),
			OpenMesh::Vec3d(-0.779829, 5.71698, 0),
OpenMesh::Vec3d(-4.53453, 3.86186, 0),
OpenMesh::Vec3d(-5.43369, -0.358081, 0),
OpenMesh::Vec3d(-3.93307, -4.14067, 0),
OpenMesh::Vec3d(0.472388, -5.10482, 0),
OpenMesh::Vec3d(4.43436, -3.03273, 0),


		};
		for (int i = 0; i < N; i++) {
			OpenMesh::Vec3d start = square_vertices[i];
			OpenMesh::Vec3d end = square_vertices[(i + 1) % N];

			OpenMesh::Vec3d p1 = start;
			OpenMesh::Vec3d p4 = end;

			// Intermediate control points (simple linear interpolation for demonstration)
			OpenMesh::Vec3d p2 = p1 + (p4 - p1) / 3;
			OpenMesh::Vec3d p3 = p1 + (p4 - p1) * 2 / 3;

			curvecage2[i] = { p1, p2, p3, p4 };

		}
		//通过curvecage2计算cc_points;
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < degree; j++) {
				CC_points.push_back(curvecage2[i][j]);
			}
		}


		CC_mesh = createMeshFromCurveCage(CC_points);
		curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
		auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
		for (auto vh : CC_mesh.vertices())
		{
			CagevertexState[vh] = NotSelected;
		}
		calculate_green_weight123();//计算3次cage到3次控制点的权重
	}
	//线性cage
	if (0) {
		int N = 8*3;//circle 
		degree = 1;
		curvecage2.resize(N);
		std::vector<OpenMesh::Vec3d>square_vertices = {
			OpenMesh::Vec3d(3.87407, 0.191556, 0),
OpenMesh::Vec3d(4.09041, -1.15695, 0),
OpenMesh::Vec3d(3.90557, -1.76057, 0),
OpenMesh::Vec3d(3.44068, -3.85162, 0),
OpenMesh::Vec3d(5.42266, -1.35024, 0),
OpenMesh::Vec3d(3.33319, 4.06603, 0),
OpenMesh::Vec3d(-0.485222, 4.40195, 0),
OpenMesh::Vec3d(0.747137, 4.73402, 0),
OpenMesh::Vec3d(2.05847, 4.4998, 0),
OpenMesh::Vec3d(3.83488, 3.89295, 0),
OpenMesh::Vec3d(1.39062, 6.04187, 0),
OpenMesh::Vec3d(-3.94472, 3.75008, 0),
OpenMesh::Vec3d(-4.09774, 0.129278, 0),
OpenMesh::Vec3d(-4.37443, 1.31151, 0),
OpenMesh::Vec3d(-4.17104, 2.38932, 0),
OpenMesh::Vec3d(-3.86462, 4.22689, 0),
OpenMesh::Vec3d(-5.74373, 1.56731, 0),
OpenMesh::Vec3d(-3.57387, -3.48392, 0),
OpenMesh::Vec3d(0.194383, -3.81429, 0),
OpenMesh::Vec3d(-0.758251, -4.06885, 0),
OpenMesh::Vec3d(-2.37286, -3.93278, 0),
OpenMesh::Vec3d(-4.21109, -3.22378, 0),
OpenMesh::Vec3d(-1.77591, -5.4711, 0),
OpenMesh::Vec3d(3.56099, -3.33112, 0),
		};
		/*{OpenMesh::Vec3d(3.87407, 0.191556, 0),
			OpenMesh::Vec3d(5.79932, -0.8039, 0),
			OpenMesh::Vec3d(6.87269, -0.0378885, 0),
			OpenMesh::Vec3d(7.54488, 1.72362, 0),
			OpenMesh::Vec3d(5.75912, 0.547401, 0),
			OpenMesh::Vec3d(3.33319, 4.06603, 0),
			OpenMesh::Vec3d(-0.485222, 4.40195, 0),
			OpenMesh::Vec3d(0.42163, 6.0035, 0),
			OpenMesh::Vec3d(0.190249, 7.34517, 0),
			OpenMesh::Vec3d(-1.22957, 7.85349, 0),
			OpenMesh::Vec3d(-0.500449, 6.15799, 0),
			OpenMesh::Vec3d(-3.94472, 3.75008, 0),
			OpenMesh::Vec3d(-4.09774, 0.129278, 0),
			OpenMesh::Vec3d(-5.63014, 1.21918, 0),
			OpenMesh::Vec3d(-7.03331, 0.985885, 0),
			OpenMesh::Vec3d(-7.98259, -1.01753, 0),
			OpenMesh::Vec3d(-5.89146, 0.256206, 0),
			OpenMesh::Vec3d(-3.57387, -3.48392, 0),
			OpenMesh::Vec3d(0.194383, -3.81429, 0),
			OpenMesh::Vec3d(-0.924447, -5.26916, 0),
			OpenMesh::Vec3d(-0.6001, -6.86891, 0),
			OpenMesh::Vec3d(1.23645, -7.72955, 0),
			OpenMesh::Vec3d(0.14458, -5.74809, 0),
			OpenMesh::Vec3d(3.56099, -3.33112, 0),
		}*/
		for (int i = 0; i < N; i++) {
			OpenMesh::Vec3d start = square_vertices[i];
			OpenMesh::Vec3d end = square_vertices[(i + 1) % N];

			OpenMesh::Vec3d p1 = start;
			OpenMesh::Vec3d p4 = end;

			

			curvecage2[i] = { p1, p4 };

		}
		//通过curvecage2计算cc_points;
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < degree; j++) {
				CC_points.push_back(curvecage2[i][j]);
			}
		}


		CC_mesh = createMeshFromCurveCage(CC_points);
		curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
		auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
		for (auto vh : CC_mesh.vertices())
		{
			CagevertexState[vh] = NotSelected;
		}
		calculate_green_weight121();//计算3次cage到3次控制点的权重
	}
	//paristower
	if (1) {
		LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\paristower.obj");
		int N = 3;//circle 4
		curvecage2.resize(N);

		// 逆时针定义3个顶点
		std::vector<OpenMesh::Vec3d> square_vertices = {
			
			
			OpenMesh::Vec3d(2.21312, -3.64502, 0),
			OpenMesh::Vec3d(-0.00294265, 4.30579, 0),
			OpenMesh::Vec3d(-2.13172, -3.62273, 0),
		};
		for (int i = 0; i < N; i++) {
			OpenMesh::Vec3d start = square_vertices[i];
			OpenMesh::Vec3d end = square_vertices[(i + 1) % N];

			OpenMesh::Vec3d p1 = start;
			OpenMesh::Vec3d p4 = end;

			// Intermediate control points (simple linear interpolation for demonstration)
			OpenMesh::Vec3d p2 = p1 + (p4 - p1) / 3;
			OpenMesh::Vec3d p3 = p1 + (p4 - p1) * 2 / 3;

			curvecage2[i] = { p1, p2, p3, p4 };

		}
		//通过curvecage2计算cc_points;
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < degree; j++) {
				CC_points.push_back(curvecage2[i][j]);
			}
		}


		CC_mesh = createMeshFromCurveCage(CC_points);
		curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
		auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
		for (auto vh : CC_mesh.vertices())
		{
			CagevertexState[vh] = NotSelected;
		}
		calculate_green_weight123();//计算3次cage到3次控制点的权重
	}
	//sheji
	if (0) {
		LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\paristower.obj");
		int N = 5;//circle 4
		curvecage2.resize(N);

		// 逆时针定义3个顶点
		std::vector<OpenMesh::Vec3d> square_vertices = {
			OpenMesh::Vec3d(-12.729, -6.31988, 0),
				OpenMesh::Vec3d(5.51534, -6.20705, 0),
                OpenMesh::Vec3d(6.0044, 9.48202, 0),
				OpenMesh::Vec3d(-4.21192, 10.1169, 0),
				OpenMesh::Vec3d(-12.3981, 4.54636, 0),
		};
		for (int i = 0; i < N; i++) {
			OpenMesh::Vec3d start = square_vertices[i];
			OpenMesh::Vec3d end = square_vertices[(i + 1) % N];

			OpenMesh::Vec3d p1 = start;
			OpenMesh::Vec3d p4 = end;

			// Intermediate control points (simple linear interpolation for demonstration)
			OpenMesh::Vec3d p2 = p1 + (p4 - p1) / 3;
			OpenMesh::Vec3d p3 = p1 + (p4 - p1) * 2 / 3;

			curvecage2[i] = { p1, p2, p3, p4 };

		}
		//通过curvecage2计算cc_points;
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < degree; j++) {
				CC_points.push_back(curvecage2[i][j]);
			}
		}


		CC_mesh = createMeshFromCurveCage(CC_points);
		curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
		auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
		for (auto vh : CC_mesh.vertices())
		{
			CagevertexState[vh] = NotSelected;
		}
		calculate_green_weight123();//计算3次cage到3次控制点的权重
	}
	if (0)//zimu_S
	{
		std::vector<OpenMesh::Vec3d> square_vertices = { OpenMesh::Vec3d(0.596266, -1.16511, 0),
OpenMesh::Vec3d(-1.37608, -1.16152, 0),
OpenMesh::Vec3d(-1.37802, -2.09268, 0),
OpenMesh::Vec3d(2.72435, -2.06795, 0),
OpenMesh::Vec3d(-0.671918, 1.48669, 0),
OpenMesh::Vec3d(1.02929, 1.4972, 0),
OpenMesh::Vec3d(1.02864, 2.28088, 0),
OpenMesh::Vec3d(-3.07623, 2.24427, 0),
		};
		//LoadMesh("S:/duwei/triangle/zimu_S.obj");
		LoadMesh("S:/duwei/triangle/zimu_S1.obj");

		int N = square_vertices.size();//circle 4
		curvecage2.resize(N);
		for (int i = 0; i < N; i++) {
			OpenMesh::Vec3d start = square_vertices[i];
			OpenMesh::Vec3d end = square_vertices[(i + 1) % N];

			OpenMesh::Vec3d p1 = start;
			OpenMesh::Vec3d p4 = end;

			// Intermediate control points (simple linear interpolation for demonstration)
			OpenMesh::Vec3d p2 = p1 + (p4 - p1) / 3;
			OpenMesh::Vec3d p3 = p1 + (p4 - p1) * 2 / 3;

			curvecage2[i] = { p1, p2, p3, p4 };

		}
		//通过curvecage2计算cc_points;
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < degree; j++) {
				CC_points.push_back(curvecage2[i][j]);
			}
		}
		CC_mesh = createMeshFromCurveCage(CC_points);
		curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
		auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
		for (auto vh : CC_mesh.vertices())
		{
			CagevertexState[vh] = NotSelected;
		}
		useCauchy = true;
		calculate_cauchy_weight123();
		calculate_cauchy_weight123();
		calculate_cauchy_weight123();
		calculate_cauchy_weight123();
		calculate_cauchy_weight123();
		calculate_cauchy_weight123();
		calculate_cauchy_weight123();
		calculate_cauchy_weight123();
		calculate_cauchy_weight123();
		degree = 1;
		calculate_cauchy_weight121();
		calculate_cauchy_weight121();
		calculate_cauchy_weight121();
		calculate_cauchy_weight121();
		calculate_cauchy_weight121();
		calculate_cauchy_weight121();
		calculate_cauchy_weight121();
		calculate_cauchy_weight121();
		calculate_cauchy_weight121();
		calculate_cauchy_weight121();
		calculate_cauchy_weight121();
		calculate_cauchy_weight121();
		calculate_green_weight123();//计算3次cage到3次控制点的权重
	}
	Set_Texture_coord();//设置纹理
}

void MeshViewerWidget::CalculateCMVCWeight_Test(void)
{
	std::cout << "CubicMVC!" << std::endl;
	drawmode = CURVECAGE;
	usecvm = true;
	auto arthono = [](const OpenMesh::Vec3d& p) -> OpenMesh::Vec3d {//left( -y, x)
		return OpenMesh::Vec3d(p[1], -p[0], p[2]);
	};
	//正儿八经的MVC
	if (1) {
		int N;
		std::vector<OpenMesh::Vec3d> polygon_vertices;
		//四边形
		if (0) {
			N = 4;
			curvecage2.resize(N);

			for (int v_it = 0; v_it < mesh.n_vertices(); v_it++) {
				auto vh = mesh.vertex_handle(v_it);
				auto point = mesh.point(vh);
				Mesh::Point pointuni;
				pointuni[0] = (point[0] - ptMin[0]) / (ptMax[0] - ptMin[0]); // Normalize x
				pointuni[1] = (point[1] - ptMin[1]) / (ptMax[1] - ptMin[1]); // Normalize y
				pointuni[0] *= (1 + pointuni[1]);
				pointuni[2] = 0;
				//std::cout << pointuni[0]<<" " << pointuni[1] << std::endl;
				mesh.set_point(vh, pointuni);
			}
			// 逆时针定义8个顶点
			polygon_vertices = {
				OpenMesh::Vec3d(2,1,0),
				OpenMesh::Vec3d(0,1,0),
				OpenMesh::Vec3d(0,0,0),
				OpenMesh::Vec3d(1,0,0)
			};
		}
		//choufish
		if (0) {
			N = 12;
			curvecage2.resize(N);
			polygon_vertices = {
				OpenMesh::Vec3d(0.621947, -3.00053, 0),
				OpenMesh::Vec3d(2.33876, -3.72963, 0),
				OpenMesh::Vec3d(5.77752, -1.50034, 0),
				OpenMesh::Vec3d(2.85876, 2.93215, 0),
				OpenMesh::Vec3d(-5.38815, 3.38406, 0),
				OpenMesh::Vec3d(-5.53413, 2.63302, 0),
				OpenMesh::Vec3d(0.310345, 2.27181, 0),
				OpenMesh::Vec3d(-3.27319, 0.781111, 0),
				OpenMesh::Vec3d(-3.53785, -1.70024, 0),
				OpenMesh::Vec3d(-1.94263, -3.6211, 0),
				OpenMesh::Vec3d(0.503098, -2.97635, 0),
				OpenMesh::Vec3d(1.78622, -2.87407, 0),
			};
			for (int v_it = 0; v_it < mesh.n_vertices(); v_it++) {
				auto vh = mesh.vertex_handle(v_it);
				auto point = mesh.point(vh);
				Mesh::Point pointuni;
				pointuni[0] = (point[0]); // Normalize x
				pointuni[1] = (point[1]); // Normalize y

				pointuni[2] = point[0] / 10000;
				//std::cout << pointuni[0]<<" " << pointuni[1] << std::endl;
				mesh.set_point(vh, pointuni);
			}
		}
		//kuzi
		if (0) {
			N = 8;//kuzi 8
			curvecage2.resize(N);
			// 逆时针定义8个顶点
			polygon_vertices = {
				OpenMesh::Vec3d(11.4393 + 0.01, 14.8404 + 0.01, 0),
				OpenMesh::Vec3d(-11.3137 - 0.01, 14.8404 + 0.01, 0),
				OpenMesh::Vec3d(-11.3137 - 0.01, -15.0839 - 0.01, 0),
				OpenMesh::Vec3d(-0.822533 + 0.01, -15.0839 - 0.01, 0),
				OpenMesh::Vec3d(-0.822533 + 0.01, 1.35013 - 0.01, 0),
				OpenMesh::Vec3d(0.937067 - 0.01, 1.36120 - 0.01, 0),
				OpenMesh::Vec3d(0.948133 - 0.01, -15.0839 - 0.01, 0),
				OpenMesh::Vec3d(11.4393 + 0.01, -15.0839 - 0.01, 0)
			};
			
			LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\kuzi.obj");
			mesh_beifen = mesh;
			for (int v_it = 0; v_it < mesh.n_vertices(); v_it++) {
				auto vh = mesh.vertex_handle(v_it);
				auto point = mesh.point(vh);
				Mesh::Point pointuni;
				pointuni[0] = (point[0]); // Normalize x
				pointuni[1] = (point[1]); // Normalize y

				pointuni[2] = std::copysign(1.0, point[0]) * point[0] / (-50);
				//std::cout << pointuni[0]<<" " << pointuni[1] << std::endl;
				mesh.set_point(vh, pointuni);
			}

		}
		//zoomfish
		if (0) {
			N = 4;//zoom fish 4
			curvecage2.resize(N);

			// 逆时针定义4个顶点
			polygon_vertices = {
				OpenMesh::Vec3d(15.9365 + 0.01,  1.25963 + 0.01, 0),
				OpenMesh::Vec3d(-16.3751 - 0.01,  1.25963 + 0.01, 0),
				OpenMesh::Vec3d(-16.3751 - 0.01, -1.86695 - 0.01, 0),
				OpenMesh::Vec3d(15.9365 + 0.01, -1.86695 - 0.01, 0),

			};


		}
		//sheji
		if (0) {
			N = 5;//circle 4
			curvecage2.resize(N);
			
			// 逆时针定义3个顶点
			polygon_vertices = {
				OpenMesh::Vec3d(-12.729, -6.31988, 0),
					OpenMesh::Vec3d(5.51534, -6.20705, 0),
					OpenMesh::Vec3d(6.0044, 9.48202, 0),
					OpenMesh::Vec3d(-4.21192, 10.1169, 0),
					OpenMesh::Vec3d(-12.3981, 4.54636, 0),
			};
		}
		//daizi
		if (0) {
			N = 10;//kuzi 8
			curvecage2.resize(N);
			LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\daizi.obj");
			mesh_beifen = mesh;
			//createSimpleMesh();
			{
				/*ptMin = OpenMesh::Vec3d(0, 0, 0);
				ptMax = OpenMesh::Vec3d(5, 5, 0);*/
				const Eigen::Vector3d targetMin(-30.0, -4.0, 0.0);
				const Eigen::Vector3d targetMax(30.0, 4.0, 0.0);

				// 计算缩放比例
				Eigen::Vector3d scale;
				scale.x() = (targetMax.x() - targetMin.x()) / (ptMax[0] - ptMin[0]);
				scale.y() = (targetMax.y() - targetMin.y()) / (ptMax[1] - ptMin[1]);
				scale.z() = 0.0; // 保持 z 为常数

				// 更新顶点坐标
				for (auto& vh : mesh.vertices()) {
					OpenMesh::Vec3d pt = mesh.point(vh);
					pt[0] = ((pt[0] - ptMin[0]) * scale.x() + targetMin.x()) * 0.999;
					pt[1] = ((pt[1] - ptMin[1]) * scale.y() + targetMin.y()) * 0.999;
					pt[2] = 0; // 保持 z 为常数
					mesh.set_point(vh, pt);
				}
			}
			// 逆时针定义8个顶点
			polygon_vertices = {
				OpenMesh::Vec3d(30, -4,0),
				OpenMesh::Vec3d(30, 4,0),
				OpenMesh::Vec3d(15, 4,0),
				OpenMesh::Vec3d(0, 4,0),
				OpenMesh::Vec3d(-15, 4,0),
				OpenMesh::Vec3d(-30, 4,0),
				OpenMesh::Vec3d(-30, -4,0),
				OpenMesh::Vec3d(-15, -4,0),
				OpenMesh::Vec3d(0, -4,0),
				OpenMesh::Vec3d(15, -4,0),
			};
		}
		//直的设计
		if (1) {
			N = 4;//kuzi 8
			curvecage2.resize(N);
			LoadMesh("..\\mesh\\sheji.obj");
			mesh_beifen = mesh;
			// 逆时针定义8个顶点
			polygon_vertices = {
OpenMesh::Vec3d(-19.97,-12.93,0),

OpenMesh::Vec3d(19.97,-12.93,0),

OpenMesh::Vec3d(19.97,12.93,0),

OpenMesh::Vec3d(-19.97,12.93,0),
			};
		}

		for (int i = 0; i < N; i++) {
			OpenMesh::Vec3d start = polygon_vertices[i];
			OpenMesh::Vec3d end = polygon_vertices[(i + 1) % N];

			OpenMesh::Vec3d p1 = start;
			OpenMesh::Vec3d p4 = end;

			// Intermediate control points (simple linear interpolation for demonstration)
			OpenMesh::Vec3d p2 = p1 + (p4 - p1) / 3;
			OpenMesh::Vec3d p3 = p1 + (p4 - p1) * 2 / 3;

			curvecage2[i] = { p1, p2, p3, p4 };

		}
		//通过curvecage2计算cc_points;
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < degree; j++) {
				CC_points.push_back(curvecage2[i][j]);
			}
		}


		CC_mesh = createMeshFromCurveCage(CC_points);
		curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
		auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
		for (auto vh : CC_mesh.vertices())
		{
			CagevertexState[vh] = NotSelected;
		}

		std::vector<OpenMesh::Vec3d> t_e(N);
		std::vector<OpenMesh::Vec3d> n_e(N);
		mvcGn.resize(2 * N);
		mvcGt.resize(2 * N);
		mvcL.resize(N);

		std::vector<double> vc(N);
		std::vector<double> gnc(2 * N);
		std::vector<double> gtc(2 * N);
		OpenMesh::Vec3d ptest = OpenMesh::Vec3d(1.1, 1, 0);
		MVC::cubicMVCs(polygon_vertices, ptest, vc, gnc, gtc);
		OpenMesh::Vec3d r_test = OpenMesh::Vec3d(0, 0, 0);

		std::vector<double> L(N);
		for (int i = 0; i < N; i++)
		{
			mvcGt[2 * i] = 3 * (curvecage2[i][1] - curvecage2[i][0]) / norm(curvecage2[i][3] - curvecage2[i][0]);
			mvcGt[2 * i + 1] = 3 * (curvecage2[i][2] - curvecage2[i][3]) / norm(curvecage2[i][3] - curvecage2[i][0]);
			mvcL[i] = (curvecage2[i][3] - curvecage2[i][0]).norm();//每条边的长度
			n_e[i] = arthono((curvecage2[i][3] - curvecage2[i][0])).normalized();//每条边的单位法向
			t_e[i] = (curvecage2[i][3] - curvecage2[i][0]).normalized();//每条边的单位切向
		}
		auto f = polygon_vertices;
		auto df = mvcGt;
		auto h = mvcGt;
		//求解h
		for (int i = 0; i < N; i++)
		{
			int index = (i - 1) % N;
			if (index < 0) {
				index += N;
			}
			Eigen::Matrix2d A;
			Eigen::Matrix2d B;
			OpenMesh::Vec3d Bx = -mvcGt[2 * index + 1][0] * t_e[index] - mvcGt[2 * i][0] * t_e[i];
			OpenMesh::Vec3d By = -mvcGt[2 * index + 1][1] * t_e[index] - mvcGt[2 * i][1] * t_e[i];
			// 为矩阵A和B赋值
			A << n_e[i][0], -n_e[index][0],
				n_e[i][1], -n_e[index][1];
			B << Bx[0], By[0],
				Bx[1], By[1];
			//solve gn
			Eigen::Matrix2d X = A.inverse() * B;
			//std::cout << X << std::endl;
			mvcGn[2 * index + 1] = OpenMesh::Vec3d(X(1, 0), X(1, 1), 0);
			mvcGn[2 * i] = OpenMesh::Vec3d(X(0, 0), X(0, 1), 0);
			/*std::cout <<"x的梯度" << gt[2 * i][0] * t_e[i] + gn[2 * i][0] * n_e[i] << std::endl;
			std::cout << "y的梯度" << gt[2 * i][1] * t_e[i] + gn[2 * i][1] * n_e[i] << std::endl;
			std::cout << gt[2 * i][0] * t_e[i] + gn[2 * i][0] * n_e[i] - (-gt[2 * index + 1][0] * t_e[index] + gn[2 * index + 1][0] * n_e[index]) << std::endl;
			std::cout << gt[2 * i][1] * t_e[i] + gn[2 * i][1] * n_e[i] - (-gt[2 * index + 1][1] * t_e[index] + gn[2 * index + 1][1] * n_e[index]) << std::endl;*/

		}

		for (int i = 0; i < N; i++)
		{
			r_test += vc[i] * polygon_vertices[i];
			r_test += gtc[2 * i] * mvcGt[2 * i];
			r_test += gtc[2 * i + 1] * mvcGt[2 * i + 1];
			r_test += gnc[2 * i] * mvcGn[2 * i];
			r_test += gnc[2 * i + 1] * mvcGn[2 * i + 1];
		}
		std::cout << r_test - ptest << std::endl;
		//通过curvecage2计算cc_points;
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < degree; j++) {
				CC_points.push_back(curvecage2[i][j]);
			}
		}

		//calculate_green_weight123();//计算3次cage到3次控制点的权重
		weights.resize(mesh.n_vertices(), std::vector<double>(5 * curvecage2.size(), 0.0));
		for (int v_id = 0; v_id < mesh.n_vertices(); v_id++) {
			N = curvecage2.size();
			std::vector<double> vc(N);
			std::vector<double> gnc(2 * N);
			std::vector<double> gtc(2 * N);
			auto vh = mesh.vertex_handle(v_id);
			Mesh::Point eta = mesh.point(vh);
			MVC::cubicMVCs(polygon_vertices, eta, vc, gnc, gtc);
			for (int i = 0; i < curvecage2.size(); i++)
			{
				weights[v_id][5 * i] = vc[i];
				weights[v_id][5 * i + 1] = gtc[2 * i];
				weights[v_id][5 * i + 2] = gtc[2 * i + 1];
				weights[v_id][5 * i + 3] = gnc[2 * i];
				weights[v_id][5 * i + 4] = gnc[2 * i + 1];
			}

		}
		Set_Texture_coord();//设置纹理

	}
}


void MeshViewerWidget::CoonsWeight_Test(void)
{
	std::cout << "Coons!" << std::endl;
	drawmode = CURVECAGE;
	useGBC = true;

	int N;
	std::vector<OpenMesh::Vec3d> polygon_vertices;
	//sheji
	if (0) {
		N = 4;//kuzi 8
		curvecage2.resize(N);
		LoadMesh("..\\mesh\\sheji.obj");
		mesh_beifen = mesh;
		// 逆时针定义8个顶点
		polygon_vertices = {
OpenMesh::Vec3d(-19.97,-12.93,0),

OpenMesh::Vec3d(19.97,-12.93,0),

OpenMesh::Vec3d(19.97,12.93,0),

OpenMesh::Vec3d(-19.97,12.93,0),
		};
	}
	//kuzi
	if (0) {
		N = 8;//kuzi 8
		curvecage2.resize(N);
		// 逆时针定义8个顶点
		polygon_vertices = {
			OpenMesh::Vec3d(11.4393 + 0.01, 14.8404 + 0.01, 0),
			OpenMesh::Vec3d(-11.3137 - 0.01, 14.8404 + 0.01, 0),
			OpenMesh::Vec3d(-11.3137 - 0.01, -15.0839 - 0.01, 0),
			OpenMesh::Vec3d(-0.822533 + 0.01, -15.0839 - 0.01, 0),
			OpenMesh::Vec3d(-0.822533 + 0.01, 1.35013 - 0.01, 0),
			OpenMesh::Vec3d(0.937067 - 0.01, 1.36120 - 0.01, 0),
			OpenMesh::Vec3d(0.948133 - 0.01, -15.0839 - 0.01, 0),
			OpenMesh::Vec3d(11.4393 + 0.01, -15.0839 - 0.01, 0)
		};

		LoadMesh("E:\\dgp2021\\dgp6\\bihormonic coordinates\\mesh\\kuzi.obj");
		mesh_beifen = mesh;
		for (int v_it = 0; v_it < mesh.n_vertices(); v_it++) {
			auto vh = mesh.vertex_handle(v_it);
			auto point = mesh.point(vh);
			Mesh::Point pointuni;
			pointuni[0] = (point[0]); // Normalize x
			pointuni[1] = (point[1]); // Normalize y

			pointuni[2] = std::copysign(1.0, point[0]) * point[0] / (-100);
			//std::cout << pointuni[0]<<" " << pointuni[1] << std::endl;
			mesh.set_point(vh, pointuni);
		}

	}
	//L_zimu
	if (1) {
		N = 6;//kuzi 8
		curvecage2.resize(N);

		
		LoadMesh("E:\\dgp2021\\dgp6\\newproject_BIHC\\project_BiHC\\mesh\\L_zimu.obj");
		mesh_beifen = mesh;
		// 逆时针定义8个顶点
		polygon_vertices = {
			OpenMesh::Vec3d(-2.77 - 0.01, -2.58 - 0.01,0),
			OpenMesh::Vec3d(1.99 + 0.01, -2.58 - 0.01,0),
			OpenMesh::Vec3d(1.99 + 0.01, -0.61 + 0.01,0),
			OpenMesh::Vec3d(-0.9 + 0.01, -0.61 + 0.01,0),
			OpenMesh::Vec3d(-0.9 + 0.01, 2.70 + 0.01,0),
			OpenMesh::Vec3d(-2.77 - 0.01, 2.70 + 0.01,0),
		};
		for (int v_it = 0; v_it < mesh.n_vertices(); v_it++) {
			auto vh = mesh.vertex_handle(v_it);
			auto point = mesh.point(vh);
			Mesh::Point pointuni;
			pointuni[0] = (point[0]); // Normalize x
			pointuni[1] = (point[1]); // Normalize y

			pointuni[2] = std::copysign(1.0, point[0]) * point[0] / (-100);
			//std::cout << pointuni[0]<<" " << pointuni[1] << std::endl;
			mesh.set_point(vh, pointuni);
		}

	}
	for (int i = 0; i < N; i++) {
		OpenMesh::Vec3d start = polygon_vertices[i];
		OpenMesh::Vec3d end = polygon_vertices[(i + 1) % N];

		OpenMesh::Vec3d p1 = start;
		OpenMesh::Vec3d p4 = end;

		// Intermediate control points (simple linear interpolation for demonstration)
		OpenMesh::Vec3d p2 = p1 + (p4 - p1) / 3;
		OpenMesh::Vec3d p3 = p1 + (p4 - p1) * 2 / 3;

		curvecage2[i] = { p1, p2, p3, p4 };

	}
	//通过curvecage2计算cc_points;
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < degree; j++) {
			CC_points.push_back(curvecage2[i][j]);
		}
	}


	CC_mesh = createMeshFromCurveCage(CC_points);
	curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
	auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
	for (auto vh : CC_mesh.vertices())
	{
		CagevertexState[vh] = NotSelected;
	}

	// 定义三次Bernstein基函数 (i=0,1,2,3)
	auto B0 = [](double t) { return 1.0 * std::pow(1 - t, 3); };         // B₀³(t) = (1-t)³
	auto B1 = [](double t) { return 3.0 * t * std::pow(1 - t, 2); };     // B₁³(t) = 3t(1-t)²
	auto B2 = [](double t) { return 3.0 * t * t * (1 - t); };            // B₂³(t) = 3t²(1-t)
	auto B3 = [](double t) { return 1.0 * std::pow(t, 3); };             // B₃³(t) = t³
	int n = CC_points.size() / degree;//polygon 顶点个数
	N = CC_points.size();//升阶后顶点个数
	weights.resize(mesh.n_vertices(), std::vector<double>( N, 0.0));
	for (int v_id = 0; v_id < mesh.n_vertices(); v_id++) {
		std::vector<double> lambda(n);
		auto vh = mesh.vertex_handle(v_id);
		Mesh::Point eta = mesh.point(vh);
		MVC::MVCs(polygon_vertices, eta, lambda);
		for (int i = 0; i < n; i++)
		{
			weights[v_id][3 * i] -= lambda[i];
		}
		for (int i = 0; i < n; i++)
		{
			double t = lambda[(i + 1) % n] / (lambda[i] + lambda[(i + 1) % n]);
			weights[v_id][3 * i] += (lambda[i] + lambda[(i + 1) % n]) * B0(t);
			weights[v_id][3 * i + 1] += (lambda[i] + lambda[(i + 1) % n]) * B1(t);
			weights[v_id][3 * i + 2] += (lambda[i] + lambda[(i + 1) % n]) * B2(t);
			weights[v_id][(3 * i + 3) % N] += (lambda[i] + lambda[(i + 1) % n]) * B3(t);
		}

		auto weight = weights[v_id];


		OpenMesh::Vec3d new_point(0, 0, 0);
		for (int j = 0; j < weight.size(); j++)
		{
			new_point += weight[j] * CC_points[j];
		}
		//std::cout << eta << "to" << new_point << std::endl;
		/*for (int j = 0; j < n; j++)
		{
			new_point += lambda[j] * CC_points[3 * j];
		}*/
		//std::cout << eta << "to" << new_point << std::endl;
		mesh.set_point(vh, new_point);
	}
	Set_Texture_coord();//设置纹理
	
}
void DrawPoints3d(const vector<OpenMesh::Vec3d>& Points, float r, float g, float b, float pointsize) {
	if (!Points.empty())
	{
		glEnable(GL_POINT_SMOOTH);
		glPointSize(pointsize);
		glColor3f(r, g, b);
		
		glBegin(GL_POINTS);
		for (const auto& p : Points)
		{
			glVertex3d(p[0], p[1], p[2]);
		}
		glEnd();
	}
}

std::vector<OpenMesh::Vec2d> MeshViewerWidget::offsetCage(const std::vector<OpenMesh::Vec2d>& linear_cage, double displacement) {
	// Move each vertex along the angle bisector by the given displacement
	auto arthono2d = [](const OpenMesh::Vec2d& p) -> OpenMesh::Vec2d {
		return OpenMesh::Vec2d(-p[1], p[0]);
	};
	size_t n = linear_cage.size();
	std::vector<OpenMesh::Vec2d> re_linear_cage = linear_cage;
	for (size_t i = 0; i < n; ++i) {
		// Get the current vertex and its neighboring vertices
		const OpenMesh::Vec2d& prev = linear_cage[(i + n - 1) % n];
		const OpenMesh::Vec2d& current = linear_cage[i];
		const OpenMesh::Vec2d& next = linear_cage[(i + 1) % n];

		// Calculate direction vectors to neighboring vertices
		OpenMesh::Vec2d dir_to_prev = (prev - current).normalize();
		OpenMesh::Vec2d dir_to_next = (next - current).normalize();
		OpenMesh::Vec2d bisector;
		if (fabs(dir_to_prev.dot (dir_to_next )+ 1.0) < 1e-6) { // If dot product is close to -1, they are opposite
			// Set bisector as dir_to_next rotated 90° counterclockwise
			bisector = arthono2d(dir_to_next);
			re_linear_cage[i] += bisector * displacement;
		}
		else if (dir_to_next[0] * dir_to_prev[1] - dir_to_next[1] * dir_to_prev[0] < 0) {
			bisector = -(dir_to_prev + dir_to_next).normalize();
			// Move the vertex along the bisector by the specified displacement
			re_linear_cage[i] += bisector * displacement;
		}
		else {
			// Calculate the angle bisector
			bisector = (dir_to_prev + dir_to_next).normalize();
			// Move the vertex along the bisector by the specified displacement
			re_linear_cage[i] += bisector * displacement;
		}

		// Move the vertex along the bisector by the specified displacement
		re_linear_cage[i] += bisector * displacement;
	}
	return re_linear_cage;
}
//对一个2次的curvecage构造offset点，为顶点和边中间点向着内部位移一个displacement
std::vector<OpenMesh::Vec2d> MeshViewerWidget::offsetCage2(const std::vector<OpenMesh::Vec2d>& Curve_cage2, double displacement) {
	// Move each vertex along the angle bisector by the given displacement
	auto arthono2d = [](const OpenMesh::Vec2d& p) -> OpenMesh::Vec2d {
		return OpenMesh::Vec2d(-p[1], p[0]);
	};
	size_t n = Curve_cage2.size();
	int m = n / 2;
	std::vector<OpenMesh::Vec2d> off_Points(n);
	for (size_t i = 0; i < m; ++i) {
		off_Points[2 * i] = Curve_cage2[2 * i];
		// Calculate direction vectors to neighboring vertices
		OpenMesh::Vec2d dir_to_prev = (Curve_cage2[(2 * i - 1 + n) % n]-Curve_cage2[2*i]).normalized();
		OpenMesh::Vec2d dir_to_next = (Curve_cage2[(2 * i + 1) % n] - Curve_cage2[2 * i]).normalized();
		OpenMesh::Vec2d bisector;
		if (fabs(dir_to_prev.dot(dir_to_next) + 1.0) < 1e-6) { // If dot product is close to -1, they are opposite
			// Set bisector as dir_to_next rotated 90° counterclockwise
			bisector = arthono2d(dir_to_next);
		}
		else if (dir_to_next[0] * dir_to_prev[1] - dir_to_next[1] * dir_to_prev[0] < 0) {
			bisector = -(dir_to_prev + dir_to_next).normalize();
		}
		else {
			// Calculate the angle bisector
			bisector = (dir_to_prev + dir_to_next).normalize();		
		}
		// Move the vertex along the bisector by the specified displacement
		off_Points[2 * i] += bisector * displacement;		
	}
	//边中间的点
	for (size_t i = 0; i < m; ++i) {
		OpenMesh::Vec3d v0 = Vec223(Curve_cage2[2 * i]);
		OpenMesh::Vec3d v1 = Vec223(Curve_cage2[2 * i + 1]);
		OpenMesh::Vec3d v2 = Vec223(Curve_cage2[(2 * i + 2)%n]);
		BezierCurve c1({ v0, v1, v2 },false);
		auto midpoint = c1.Evaluate(0.5);
		off_Points[2 * i + 1] = Vec322(midpoint);
		// Calculate direction vectors to neighboring vertices
		OpenMesh::Vec2d dir_to_next = (Curve_cage2[(2 * i + 2) % n] - Curve_cage2[2 * i]).normalized();
		OpenMesh::Vec2d bisector;
		
		bisector = arthono2d(dir_to_next);
		// Move the vertex along the bisector by the specified displacement
		off_Points[2 * i + 1] += bisector * displacement;
	}
	return off_Points;
}

//对一个3次的curvecage构造offset点，为顶点和边三等分点向着内部位移一个displacement
std::vector<OpenMesh::Vec2d> MeshViewerWidget::offsetCage3(const std::vector<OpenMesh::Vec2d>& Curve_cage3, double displacement) {
	// Move each vertex along the angle bisector by the given displacement
	auto arthono2d = [](const OpenMesh::Vec2d& p) -> OpenMesh::Vec2d {
		return OpenMesh::Vec2d(-p[1], p[0]);
	};
	size_t n = Curve_cage3.size();
	int m = n / 3;
	std::vector<OpenMesh::Vec2d> off_Points(n);
	for (size_t i = 0; i < m; ++i) {
		off_Points[3 * i] = Curve_cage3[3 * i];
		// Calculate direction vectors to neighboring vertices
		OpenMesh::Vec2d dir_to_prev = (Curve_cage3[(3 * i - 1 + n) % n] - Curve_cage3[3 * i]).normalized();
		OpenMesh::Vec2d dir_to_next = (Curve_cage3[(3 * i + 1) % n] - Curve_cage3[3 * i]).normalized();
		OpenMesh::Vec2d bisector;
		if (fabs(dir_to_prev.dot(dir_to_next) + 1.0) < 1e-6) { // If dot product is close to -1, they are opposite
			// Set bisector as dir_to_next rotated 90° counterclockwise
			bisector = arthono2d(dir_to_next);
		}
		else if (dir_to_next[0] * dir_to_prev[1] - dir_to_next[1] * dir_to_prev[0] < 0) {
			bisector = -(dir_to_prev + dir_to_next).normalize();
		}
		else {
			// Calculate the angle bisector
			bisector = (dir_to_prev + dir_to_next).normalize();
		}
		// Move the vertex along the bisector by the specified displacement
		off_Points[3 * i] += bisector * displacement;
	}
	//边中间的点
	for (size_t i = 0; i < m; ++i) {
		OpenMesh::Vec3d v0 = Vec223(Curve_cage3[3 * i]);
		OpenMesh::Vec3d v1 = Vec223(Curve_cage3[3 * i + 1]);
		OpenMesh::Vec3d v2 = Vec223(Curve_cage3[(3 * i + 2) % n]);
		OpenMesh::Vec3d v3 = Vec223(Curve_cage3[(3 * i + 3) % n]);
		BezierCurve c1({ v0, v1, v2,v3 },false);
		auto midpoint31 = c1.Evaluate(1./3);
		auto midpoint32 = c1.Evaluate(2. / 3);
		off_Points[3 * i + 1] = Vec322(midpoint31);
		off_Points[3 * i + 2] = Vec322(midpoint32);
		// Calculate direction vectors to neighboring vertices
		OpenMesh::Vec2d dir_to_next1 = Vec322(4. / 3 * (v1 - v0) + 4. / 3 * (v2 - v1) + 1. / 3 * (v3 - v2)).normalized();
		OpenMesh::Vec2d dir_to_next2 = Vec322(1. / 3 * (v1 - v0) + 4. / 3 * (v2 - v1) + 4. / 3 * (v3 - v2)).normalized();
		OpenMesh::Vec2d bisector1;
		OpenMesh::Vec2d bisector2;

		bisector1 = arthono2d(dir_to_next1);
		bisector2 = arthono2d(dir_to_next2);
		// Move the vertex along the bisector by the specified displacement
		off_Points[3 * i + 1] += bisector1 * displacement;
		off_Points[3 * i + 2] += bisector2 * displacement;
	}
	return off_Points;
}


//对一个3次的curvecage构造offset点，为顶点和边三等分点向着内部位移一个displacement
std::vector<OpenMesh::Vec2d> MeshViewerWidget::offsetCage_samples(const std::vector<OpenMesh::Vec2d>& Curve_cage3, double displacement, int n_samples)
{
	// Move each vertex along the angle bisector by the given displacement
	auto arthono2d = [](const OpenMesh::Vec2d& p) -> OpenMesh::Vec2d {
		return OpenMesh::Vec2d(-p[1], p[0]);
	};
	size_t n = Curve_cage3.size();
	int m = n / degree;
	std::vector<OpenMesh::Vec2d> off_Points(m*n_samples);
	for (size_t i = 0; i < m; ++i) {
		off_Points[n_samples * i] = Curve_cage3[degree * i];
		// Calculate direction vectors to neighboring vertices
		OpenMesh::Vec2d dir_to_prev = (Curve_cage3[(degree * i - 1 + n) % n] - Curve_cage3[degree * i]).normalized();
		OpenMesh::Vec2d dir_to_next = (Curve_cage3[(degree * i + 1) % n] - Curve_cage3[degree * i]).normalized();
		OpenMesh::Vec2d bisector;
		if (fabs(dir_to_prev.dot(dir_to_next) + 1.0) < 1e-6) { // If dot product is close to -1, they are opposite
			// Set bisector as dir_to_next rotated 90° counterclockwise
			bisector = arthono2d(dir_to_next);
		}
		else if (dir_to_next[0] * dir_to_prev[1] - dir_to_next[1] * dir_to_prev[0] < 0) {
			bisector = -(dir_to_prev + dir_to_next).normalize();
		}
		else {
			// Calculate the angle bisector
			bisector = (dir_to_prev + dir_to_next).normalize();
		}
		// Move the vertex along the bisector by the specified displacement
		off_Points[n_samples * i] += bisector * displacement;
	}
	//对每条边
	for (size_t i = 0; i < m; ++i) {
		OpenMesh::Vec3d v0 = Vec223(Curve_cage3[3 * i]);
		OpenMesh::Vec3d v1 = Vec223(Curve_cage3[3 * i + 1]);
		OpenMesh::Vec3d v2 = Vec223(Curve_cage3[(3 * i + 2) % n]);
		OpenMesh::Vec3d v3 = Vec223(Curve_cage3[(3 * i + 3) % n]);
		BezierCurve c1({ v0, v1, v2,v3 }, false);
		BezierCurve dc1({ v1 - v0,v2 - v1,v3 - v2 }, false);
		for (int j = 1; j < n_samples; j++)
		{
			double t = double(j) / n_samples;
			auto point = Vec322(c1.Evaluate(t));
			auto tangent = Vec322(dc1.Evaluate(t)).normalized();
			OpenMesh::Vec2d bisectort = arthono2d(tangent);
			off_Points[n_samples * i + j] = point + bisectort * displacement;
		}
	}
	return off_Points;
}

//自适应采样
std::vector<OpenMesh::Vec2d> MeshViewerWidget::offsetCage_samples_adapt(const std::vector<OpenMesh::Vec2d>& Curve_cage3, double displacement, std::vector<int> n_samples)
{
	// Move each vertex along the angle bisector by the given displacement
	auto arthono2d = [](const OpenMesh::Vec2d& p) -> OpenMesh::Vec2d {
		return OpenMesh::Vec2d(-p[1], p[0]);
	};
	size_t n = Curve_cage3.size();
	int m_segs = n / degree;
	
	std::vector<OpenMesh::Vec2d> off_Points;
	for (size_t i = 0; i < m_segs; ++i) {
		auto off_Point = Curve_cage3[degree * i];
		// Calculate direction vectors to neighboring vertices
		OpenMesh::Vec2d dir_to_prev = (Curve_cage3[(degree * i - 1 + n) % n] - Curve_cage3[degree * i]).normalized();
		OpenMesh::Vec2d dir_to_next = (Curve_cage3[(degree * i + 1) % n] - Curve_cage3[degree * i]).normalized();
		OpenMesh::Vec2d bisector;
		if (fabs(dir_to_prev.dot(dir_to_next) + 1.0) < 1e-6) { // If dot product is close to -1, they are opposite
			// Set bisector as dir_to_next rotated 90° counterclockwise
			bisector = arthono2d(dir_to_next);
		}
		else if (dir_to_next[0] * dir_to_prev[1] - dir_to_next[1] * dir_to_prev[0] < 0) {
			bisector = -(dir_to_prev + dir_to_next).normalize();
		}
		else {
			// Calculate the angle bisector
			bisector = (dir_to_prev + dir_to_next).normalize();
		}
		// Move the vertex along the bisector by the specified displacement
		off_Points.push_back(off_Point + bisector * displacement) ;
	}
	//对每条边
	for (size_t i = 0; i < m_segs; ++i) {
		OpenMesh::Vec3d v0 = Vec223(Curve_cage3[3 * i]);
		OpenMesh::Vec3d v1 = Vec223(Curve_cage3[3 * i + 1]);
		OpenMesh::Vec3d v2 = Vec223(Curve_cage3[(3 * i + 2) % n]);
		OpenMesh::Vec3d v3 = Vec223(Curve_cage3[(3 * i + 3) % n]);
		BezierCurve c1({ v0, v1, v2,v3 }, false);
		BezierCurve dc1({ v1 - v0,v2 - v1,v3 - v2 }, false);
		for (int j = 1; j < n_samples[i]; j++)
		{
			double t = double(j) / n_samples[i];
			auto point = Vec322(c1.Evaluate(t));
			auto tangent = Vec322(dc1.Evaluate(t)).normalized();
			OpenMesh::Vec2d bisectort = arthono2d(tangent);
			off_Points.push_back(point + bisectort * displacement) ;
		}
	}
	return off_Points;
}

std::vector<OpenMesh::Vec3d> MeshViewerWidget::rationalPtsfrom5points(const std::vector<OpenMesh::Vec2d>& points_on_arc)
{
	auto cross_product_z = [](const OpenMesh::Vec2d& v1, const OpenMesh::Vec2d& v2) -> double {
		return v1[0] * v2[1] - v1[1] * v2[0];
	};
	array<double, 4> r_weights;
	array<OpenMesh::Vec2d, 4> control_points;
	OpenMesh::Vec2d p_start_orig = points_on_arc[0];
	OpenMesh::Vec2d p_mid_orig = points_on_arc[2]; // 使用中间的采样点
	OpenMesh::Vec2d p_end_orig = points_on_arc[4];

	OpenMesh::Vec2d C;
	double R;

	OpenMesh::Vec2d d_start_mid = p_mid_orig - p_start_orig;
	OpenMesh::Vec2d d_mid_end = p_end_orig - p_mid_orig;
	// 计算垂直平分线交点 (圆心)
	OpenMesh::Vec2d m1 = (p_start_orig + p_mid_orig) * 0.5;
	OpenMesh::Vec2d perp_d1(d_start_mid[1], -d_start_mid[0]); // 垂直于 d_start_mid

	OpenMesh::Vec2d m2 = (p_mid_orig + p_end_orig) * 0.5;
	OpenMesh::Vec2d perp_d2(d_mid_end[1], -d_mid_end[0]);   // 垂直于 d_mid_end

	double det = cross_product_z(perp_d1, -perp_d2); // perp_d1.x * (-perp_d2.y) - perp_d1.y * (-perp_d2.x)
	OpenMesh::Vec2d rhs = m2 - m1;
	double t = cross_product_z(rhs, -perp_d2) / det;

	C = m1 + t * perp_d1;
	R = (p_start_orig - C).length();

	// 3. 将原始起点和终点投影到拟合的圆上，得到 S_proj 和 E_proj
	OpenMesh::Vec2d vec_S_orig = p_start_orig - C;
	OpenMesh::Vec2d vec_E_orig = p_end_orig - C;

	OpenMesh::Vec2d S_proj = C + vec_S_orig.normalized() * R;
	OpenMesh::Vec2d E_proj = C + vec_E_orig.normalized() * R;

	// 4. 计算圆弧角 A_abs (绝对值, 0 到 PI) 和 A_oriented (方向性, -PI 到 PI)
	OpenMesh::Vec2d vec_S = S_proj - C;
	OpenMesh::Vec2d vec_E = E_proj - C;

	double dot_product = vec_S | vec_E; // OpenMesh 的点积运算符
	double cos_A_abs = dot_product / (R * R); // vec_S.length() * vec_E.length() == R*R
	cos_A_abs = std::max(-1.0, std::min(1.0, cos_A_abs)); // 钳位以防浮点误差
	double A_abs = std::acos(cos_A_abs); // A_abs 在 [0, PI]


	// 5. 计算标准位置下的参数
	//    旋转角 phi_S_rot，使得 S_proj 变换到 (R,0)
	double phi_S_rot = std::atan2(vec_S[1], vec_S[0]);

	// 将 vec_E 旋转 -phi_S_rot
	double cos_minus_phi = std::cos(-phi_S_rot);
	double sin_minus_phi = std::sin(-phi_S_rot);
	OpenMesh::Vec2d E_std_prime(
		vec_E[0] * cos_minus_phi - vec_E[1] * sin_minus_phi,
		vec_E[0] * sin_minus_phi + vec_E[1] * cos_minus_phi
	);
	double A_oriented = std::atan2(E_std_prime[1], E_std_prime[0]); // 范围 (-PI, PI]

	// 6. 计算 L_c 和权重
	//    tan(A_abs/4) 对于 A_abs <= PI 是安全的 (A_abs/4 <= PI/4)
	double tan_A_div_4 = std::tan(A_abs / 4.0);
	double L_c = R * (4.0 / 3.0) * tan_A_div_4;

	r_weights[0] = 1.0;
	r_weights[3] = 1.0;
	double cos_A_div_2 = std::cos(A_abs / 2.0);
	r_weights[1] = (1.0 + 2.0 * cos_A_div_2) / 3.0;
	r_weights[2] = r_weights[1];


	// 7. 计算标准位置下的Bézier控制点 (P0_std 在 (R,0))
	OpenMesh::Vec2d P0_std(R, 0.0);
	OpenMesh::Vec2d P3_std(R * std::cos(A_oriented), R * std::sin(A_oriented));

	double sign_A_oriented = (A_oriented >= 0.0) ? 1.0 : -1.0;
	if (std::abs(A_oriented) < 1e-6) sign_A_oriented = 1.0; // 处理 A_oriented 约等于 0 的情况

	OpenMesh::Vec2d P1_std(R, sign_A_oriented * L_c);
	OpenMesh::Vec2d P2_std(
		P3_std[0] + L_c * std::sin(A_oriented), // P2 = P3_std + L_c * tangent_vec_at_P3_pointing_inwards
		// tangent_vec_at_P3_pointing_outwards = (-sin(A_o), cos(A_o))
		// tangent_vec_at_P3_pointing_inwards = (sin(A_o), -cos(A_o))
		P3_std[1] - L_c * std::cos(A_oriented)
	);

	control_points[0] = P0_std;
	control_points[1] = P1_std;
	control_points[2] = P2_std;
	control_points[3] = P3_std;

	// 8. 将Bézier控制点变换回原始坐标系
	//    先旋转 phi_S_rot，然后平移 C
	double cos_phi = std::cos(phi_S_rot);
	double sin_phi = std::sin(phi_S_rot);

	std::vector<OpenMesh::Vec3d> result(4);
	for (int i = 0; i < 4; ++i) {
		OpenMesh::Vec2d p_std = control_points[i];
		OpenMesh::Vec2d p_rotated(
			p_std[0] * cos_phi - p_std[1] * sin_phi,
			p_std[0] * sin_phi + p_std[1] * cos_phi
		);
		control_points[i] = p_rotated + C;
		result[i] = OpenMesh::Vec3d(control_points[i][0], control_points[i][1], r_weights[i]);
	}
	return result;
}

//创建一个正方形
//void MeshViewerWidget::createSimpleMesh(void) {
//	int sampleCount = 40;
//	double step = 2.0 / (sampleCount - 1);  // 每个步长的距离
//
//	// 创建顶点
//	std::vector<Mesh::VertexHandle> vertexHandles;
//	for (int i = 0; i < sampleCount; ++i) {
//		for (int j = 0; j < sampleCount; ++j) {
//			/*double stepx = step * (2. - (double)i / sampleCount);
//			double stepy = step * (0.5 + 0.5 * (double)j / (sampleCount));*/
//			double x = (0. + j * step);
//			double y = (0. + i * step);
//			vertexHandles.push_back(mesh.add_vertex(Mesh::Point(x, y, 0.0)));
//		}
//	}
//
//	// 创建三角形面
//	for (int i = 0; i < sampleCount - 1; ++i) {
//		for (int j = 0; j < sampleCount - 1; ++j) {
//			int idx = i * sampleCount + j;
//
//			// 添加两个三角形组成一个四边形格子
//			mesh.add_face(vertexHandles[idx], vertexHandles[idx + 1], vertexHandles[idx + sampleCount]);
//			mesh.add_face(vertexHandles[idx + 1], vertexHandles[idx + sampleCount + 1], vertexHandles[idx + sampleCount]);
//		}
//	}
//}

void MeshViewerWidget::createSimpleMesh() {
	mesh.clear();
	int sampleCount = 40; // 每边的顶点数
	double step = 5.0 / (sampleCount-1 )*0.9999;  // 每个步长的距离

	// 创建顶点
	std::vector<Mesh::VertexHandle> vertexHandles;
	for (int i = 0; i < sampleCount; ++i) {
		for (int j = 0; j < sampleCount; ++j) {
			double x =0.000001 + j * step; // x 坐标从 -1 到 1
			double y = 0.000001 + i * step; // y 坐标从 -1 到 1
			vertexHandles.push_back(mesh.add_vertex(Mesh::Point(x, y, 0.0)));
		}
	}

	// 创建三角形面
	for (int i = 0; i < sampleCount-1; ++i) {
		for (int j = 0; j < sampleCount - 1; ++j) {
			// 当前顶点索引
			int idx = i * sampleCount + j;

			// 添加两个三角形组成一个四边形格子
			Mesh::VertexHandle v0 = vertexHandles[idx];
			Mesh::VertexHandle v1 = vertexHandles[idx + 1];
			Mesh::VertexHandle v2 = vertexHandles[idx + sampleCount];
			Mesh::VertexHandle v3 = vertexHandles[idx + sampleCount + 1];

			// 第一个三角形
			mesh.add_face(v0, v1, v2);

			// 第二个三角形
			mesh.add_face(v1, v3, v2);
		}
	}
}


// 函数：计算伪逆
Eigen::MatrixXd pseudoInverse(const Eigen::MatrixXd& matrix, double tolerance ) {
	// 使用 SVD 分解矩阵
	Eigen::JacobiSVD<Eigen::MatrixXd> svd(matrix, Eigen::ComputeThinU | Eigen::ComputeThinV);
	Eigen::MatrixXd U = svd.matrixU();
	Eigen::MatrixXd V = svd.matrixV();
	Eigen::VectorXd singularValues = svd.singularValues();

	// 打印 SVD 分解后各个矩阵的维度
	/*std::cout << "Matrix dimensions:" << std::endl;
	std::cout << "Original matrix: " << matrix.rows() << " x " << matrix.cols() << std::endl;
	std::cout << "U: " << U.rows() << " x " << U.cols() << std::endl;
	std::cout << "V: " << V.rows() << " x " << V.cols() << std::endl;
	std::cout << "Singular Values: " << singularValues.size() << std::endl;*/

	// 构造奇异值的倒数矩阵
	Eigen::MatrixXd singularValuesInv = Eigen::MatrixXd::Zero(singularValues.size(), singularValues.size());

	// 计算奇异值的倒数，如果奇异值小于 tolerance 则设为 0
	for (long i = 0; i < singularValues.size(); ++i) {
		if (singularValues(i) > tolerance) {
			singularValuesInv(i, i) = 1.0 / singularValues(i);
		}
	}

	// 打印倒数矩阵的维度
	//std::cout << "Singular Values Inverse: " << singularValuesInv.rows() << " x " << singularValuesInv.cols() << std::endl;

	// 计算伪逆
	Eigen::MatrixXd pinv = V * singularValuesInv * U.transpose();

	// 打印伪逆矩阵的维度
	//std::cout << "Pseudo-inverse matrix: " << pinv.rows() << " x " << pinv.cols() << std::endl;

	return pinv;
}

OpenMesh::Vec3d computeNormal(const OpenMesh::Vec3d& v1, const OpenMesh::Vec3d& v2, const OpenMesh::Vec3d& v3) {
	return (v2 - v1).cross(v3 - v1).normalized();
}

//计算格林坐标的子函数
double GCTrlInt(const OpenMesh::Vec3d& p, const OpenMesh::Vec3d& v1, const OpenMesh::Vec3d& v2, const OpenMesh::Vec3d& eta) {
	auto sign = [](double value) -> double {
		return (value > 0) ? 1.0 : -1.0;
	};
	double alpha = acos(((v2 - v1).dot(p - v1)) / ((v2 - v1).norm() * (p - v1).norm()));
	double beta = acos(((v1 - p).dot(v2 - p)) / ((v1 - p).norm() * (v2 - p).norm()));
	double lambda = (p - v1).sqrnorm() * sin(alpha) * sin(alpha);
	double c = (p - eta).sqrnorm();
	std::vector<double> thetas = { M_PI - alpha,M_PI - alpha - beta };
	for (int i = 0; i < 2; i++)
	{
		double theta = thetas[i];
		double S = sin(theta);
		double C = cos(theta);
		double Sc = S * S * c; // S^2 * c
		double sqrt_lambda = sqrt(lambda);

		// 第一部分：2√c * tan⁻¹(√cC / √(λ + S²c))
		double part1 = 2.0 * sqrt(c) * atan(sqrt(c) * C / sqrt(lambda + Sc));

		// 第二部分：√λ * log(...)
		double numerator = 2.0 * c * C;
		double denominator = c * (1.0 + C) + lambda + sqrt(lambda * lambda + lambda * Sc);
		double log_arg = 2.0 * sqrt_lambda * S * S / ((1.0 - C) * (1.0 - C))* (1.0 - numerator / denominator);
		double log_term = log(log_arg);

		// 组合最终公式
		double Itheta = (-sign(S) / 2.0) * (part1 + sqrt_lambda * log_term);
		return Itheta;
	}
	double sin_alpha = sin(alpha);
	double sin_beta = sin(beta);

	// 根据伪代码实现积分公式
	return -(1.0 / (4.0 * M_PI)) * (beta - alpha);
}

double SolidAngle(const OpenMesh::Vec3d& v1, const OpenMesh::Vec3d& v2, const OpenMesh::Vec3d& v3, const OpenMesh::Vec3d& eta)
{
	// 从 eta 到 v1, v2, v3 的向量
	OpenMesh::Vec3d r1 = v1 - eta;
	OpenMesh::Vec3d r2 = v2 - eta;
	OpenMesh::Vec3d r3 = v3 - eta;

	// 计算向量的范数
	double norm_r1 = r1.norm();
	double norm_r2 = r2.norm();
	double norm_r3 = r3.norm();

	// 计算单位向量
	OpenMesh::Vec3d u1 = r1 / norm_r1;
	OpenMesh::Vec3d u2 = r2 / norm_r2;
	OpenMesh::Vec3d u3 = r3 / norm_r3;

	// 计算混合积 (u1 · (u2 × u3))
	double triple_product = u1 | (u2 % u3);

	// 计算分子
	double numerator = std::abs(triple_product);

	// 计算分母 (1 + u1 · u2 + u2 · u3 + u3 · u1)
	double denominator = 1.0 + (u1 | u2) + (u2 | u3) + (u3 | u1);

	// 计算立体角 (4 * atan2(分子, 分母))
	double solid_angle = 2.0 * std::atan2(numerator, denominator);

	return solid_angle;
}

template <typename VecType>
std::vector<VecType> subdivideCage(const std::vector<VecType>& linear_cage) {
	std::vector<VecType> subdivided_cage;
	int n = linear_cage.size();

	for (int i = 0; i < n; ++i) {
		// 当前顶点
		const VecType& current = linear_cage[i];

		// 下一个顶点，注意最后一个顶点和第一个顶点相连
		const VecType& next = linear_cage[(i + 1) % n];

		// 将当前顶点添加到新的 cage
		subdivided_cage.push_back(current);

		// 计算中点
		VecType midpoint = (current + next) * 0.5;

		// 将中点添加到新的 cage
		subdivided_cage.push_back(midpoint);
	}

	return subdivided_cage;
}

template <typename VecType>
std::vector<VecType> subdivideCage123(const std::vector<VecType>& linear_cage) {
	std::vector<VecType> subdivided_cage;
	int n = linear_cage.size();

	for (int i = 0; i < n; ++i) {
		// 当前顶点
		const VecType& current = linear_cage[i];

		// 下一个顶点，注意最后一个顶点和第一个顶点相连
		const VecType& next = linear_cage[(i + 1) % n];

		// 将当前顶点添加到新的 cage
		subdivided_cage.push_back(current);

		// 计算三等分点
		VecType one_third = current + (next - current) * (1.0 / 3.0);
		VecType two_thirds = current + (next - current) * (2.0 / 3.0);

		// 将三等分点添加到新的 cage
		subdivided_cage.push_back(one_third);
		subdivided_cage.push_back(two_thirds);
	}

	return subdivided_cage;
}

template <typename VecType>
std::vector<VecType> subdivideCage124(const std::vector<VecType>& linear_cage) {
	std::vector<VecType> subdivided_cage;
	int n = linear_cage.size();

	for (int i = 0; i < n; ++i) {
		// 当前顶点
		const VecType& current = linear_cage[i];

		// 下一个顶点，注意最后一个顶点和第一个顶点相连
		const VecType& next = linear_cage[(i + 1) % n];

		// 将当前顶点添加到新的 cage
		subdivided_cage.push_back(current);

		// 计算三等分点
		VecType one_third = current + (next - current) * (1.0 / 4.0);
		VecType two_thirds = current + (next - current) * (2.0 / 4.0);
		VecType three_thirds = current + (next - current) * (3.0 / 4.0);

		// 将三等分点添加到新的 cage
		subdivided_cage.push_back(one_third);
		subdivided_cage.push_back(two_thirds);
		subdivided_cage.push_back(three_thirds);
	}

	return subdivided_cage;
}

template <typename VecType>
std::vector<VecType> subdivideCage2(const std::vector<VecType>& twice_cage) {
	std::vector<VecType> subdivided_cage;
	int n = twice_cage.size();

	for (int i = 0; 2*i < n; ++i) {
		// 当前顶点
		const VecType& current = twice_cage[2*i];

		// 下一个顶点，注意最后一个顶点和第一个顶点相连
		const VecType& next = twice_cage[(2*i + 1) % n];

		const VecType& next2 = twice_cage[(2*i + 2) % n];

		// 计算二次贝塞尔细分中的控制点
		VecType control_point1 = current * 0.5 + next * 0.5;
		VecType control_point2 = next2 * 0.5 + next * 0.5;
		VecType mid = control_point1 * 0.5 + control_point2 * 0.5;
		// 将当前顶点添加到新的 cage
		subdivided_cage.push_back(current);
		subdivided_cage.push_back(control_point1);
		subdivided_cage.push_back(mid);
		subdivided_cage.push_back(control_point2);

	}

	return subdivided_cage;
}

template <typename VecType>
std::vector<VecType> subdivideCage3(const std::vector<VecType>& twice_cage) {
	std::vector<VecType> subdivided_cage;
	int n = twice_cage.size();

	for (int i = 0; 3 * i < n; ++i) {
		// 当前顶点
		const VecType& p0 = twice_cage[3 * i];

		// 下一个顶点，注意最后一个顶点和第一个顶点相连
		const VecType& p1 = twice_cage[(3 * i + 1) % n];

		const VecType& p2 = twice_cage[(3 * i + 2) % n];

		const VecType& p3 = twice_cage[(3 * i + 3) % n];

		// 计算二次贝塞尔细分中的控制点
		VecType q1 = p0 * 0.5 + p1 * 0.5;
		VecType q2 = p1 * 0.5 + p2 * 0.5;
		VecType q3 = p2 * 0.5 + p3 * 0.5;
		VecType q4 = q1 * 0.5 + q2 * 0.5;
		VecType q5 = q2 * 0.5 + q3 * 0.5;
		VecType q6 = q4 * 0.5 + q5 * 0.5;
		
		// 将当前顶点添加到新的 cage
		subdivided_cage.push_back(p0);
		subdivided_cage.push_back(q1);
		subdivided_cage.push_back(q4);
		subdivided_cage.push_back(q6);
		subdivided_cage.push_back(q5);
		subdivided_cage.push_back(q3);
	}

	return subdivided_cage;
}

template <typename VecType>
std::vector<VecType> subdivideCage2(const std::vector<VecType>& twice_cage, const int n_samples) {
	std::vector<VecType> subdivided_cage;
	int n = twice_cage.size();
	
	// 遍历控制点，每 2 个点确定一个二次贝塞尔曲线段的起点 P0
	// 注意：这里假设输入 twice_cage 中的控制点顺序是 P0_0, P1_0, P2_0 (=P0_1), P1_1, P2_1 (=P0_2), ...
	// 如果不是这种结构，需要根据实际的控制点存储方式调整循环和索引。
	for (int i = 0; 2 * i < n; ++i) {
		// 当前 Bezier 曲线的三个控制点
		// P0 是当前段的起始点
		// P1 是当前段的控制点
		// P2 是当前段的终点 (同时可能是下一段的 P0)
		const VecType& p0 = twice_cage[2 * i % n];
		const VecType& p1 = twice_cage[(2 * i + 1) % n];
		const VecType& p2 = twice_cage[(2 * i + 2) % n]; // 索引 % n 用于处理闭合曲线的情况

		// 在 [0, 1] 区间内采样 n_samples 个点
		// 通常对于开放曲线，采样 j 从 0 到 n_samples-1 以避免重复终点
		// 如果是闭合曲线，可能需要调整采样范围或后处理以避免重复
		for (int j = 0; j < n_samples; ++j) {
			double t = static_cast<double>(j) / n_samples;
			double one_minus_t = 1.0 - t;
			double one_minus_t_sq = one_minus_t * one_minus_t;
			double t_sq = t * t;

			// 计算二次 Bezier 曲线上的点: B(t) = (1-t)^2 P0 + 2(1-t)t P1 + t^2 P2
			VecType point = one_minus_t_sq * p0 +
				2.0 * one_minus_t * t * p1 +
				t_sq * p2;

			subdivided_cage.push_back(point);
		}
	}

	return subdivided_cage;
}

template <typename VecType>
std::vector<VecType> subdivideCage3(const std::vector<VecType>& twice_cage, const int n_samples) {
	std::vector<VecType> subdivided_cage;
	int n = twice_cage.size();
	if (n < 4) {
		return subdivided_cage; // 如果控制点少于 4 个，无法构成三次贝塞尔曲线
	}

	for (int i = 0; 3 * i < n; ++i) {
		// 当前 Bezier 曲线的四个控制点
		const VecType& p0 = twice_cage[3 * i % n];
		const VecType& p1 = twice_cage[(3 * i + 1) % n];
		const VecType& p2 = twice_cage[(3 * i + 2) % n];
		const VecType& p3 = twice_cage[(3 * i + 3) % n];

		// 在 [0, 1] 区间内采样 n_samples 个点（包括起点和终点）
		for (int j = 0; j < n_samples; ++j) {
			double t = static_cast<double>(j) / n_samples;
			double t_sq = t * t;
			double one_minus_t = 1.0 - t;
			double one_minus_t_sq = one_minus_t * one_minus_t;
			double one_minus_t_cub = one_minus_t_sq * one_minus_t;
			double t_cub = t_sq * t;

			// 计算 Bezier 曲线上的点
			VecType point = one_minus_t_cub * p0 +
				3 * one_minus_t_sq * t * p1 +
				3 * one_minus_t * t_sq * p2 +
				t_cub * p3;

			subdivided_cage.push_back(point);
		}
	}

	return subdivided_cage;
}

template <typename VecType>
std::vector<VecType> subdivideCage3(const std::vector<VecType>& twice_cage, const int n_samples,double length) {
	std::vector<VecType> subdivided_cage;
	int n = twice_cage.size();
	if (n < 4) {
		return subdivided_cage; // 如果控制点少于 4 个，无法构成三次贝塞尔曲线
	}

	for (int i = 0; 3 * i < n; ++i) {
		// 当前 Bezier 曲线的四个控制点
		const VecType& p0 = twice_cage[3 * i % n];
		const VecType& p1 = twice_cage[(3 * i + 1) % n];
		const VecType& p2 = twice_cage[(3 * i + 2) % n];
		const VecType& p3 = twice_cage[(3 * i + 3) % n];

		if (abs(p3[0] - p0[0]) > length) {
			// 在 [0, 1] 区间内采样 n_samples 个点（包括起点和终点）
			for (int j = 0; j < n_samples; ++j) {
				double t = static_cast<double>(j) / n_samples;
				double t_sq = t * t;
				double one_minus_t = 1.0 - t;
				double one_minus_t_sq = one_minus_t * one_minus_t;
				double one_minus_t_cub = one_minus_t_sq * one_minus_t;
				double t_cub = t_sq * t;

				// 计算 Bezier 曲线上的点
				VecType point = one_minus_t_cub * p0 +
					3 * one_minus_t_sq * t * p1 +
					3 * one_minus_t * t_sq * p2 +
					t_cub * p3;

				subdivided_cage.push_back(point);
			}
		}
		else {
			subdivided_cage.push_back(p0);
			subdivided_cage.push_back(p1);
			subdivided_cage.push_back(p2);
		}
	}

	return subdivided_cage;
}


template <typename VecType>
std::vector<VecType> subdivideCage4(const std::vector<VecType>& twice_cage) {
	std::vector<VecType> subdivided_cage;
	int n = twice_cage.size();

	for (int i = 0; 4 * i < n; ++i) {
		// 当前顶点
		const VecType& p0 = twice_cage[4 * i];

		// 下一个顶点，注意最后一个顶点和第一个顶点相连
		const VecType& p1 = twice_cage[(4 * i + 1) % n];

		const VecType& p2 = twice_cage[(4 * i + 2) % n];

		const VecType& p3 = twice_cage[(4 * i + 3) % n];

		const VecType& p4 = twice_cage[(4 * i + 4) % n];

		// 计算二次贝塞尔细分中的控制点
		VecType q0 = p0 * 0.5 + p1 * 0.5;
		VecType q1 = p1 * 0.5 + p2 * 0.5;
		VecType q2 = p2 * 0.5 + p3 * 0.5;
		VecType q3 = p3 * 0.5 + p4 * 0.5;

		VecType r1 = q0 * 0.5 + q1 * 0.5;
		VecType r2 = q1 * 0.5 + q2 * 0.5;
		VecType r3 = q2 * 0.5 + q3 * 0.5;

		VecType y1 = r1 * 0.5 + r2 * 0.5;
		VecType y2 = r2 * 0.5 + r3 * 0.5;
		
		VecType z1 = y1 * 0.5 + y2 * 0.5;

		// 将当前顶点添加到新的 cage
		subdivided_cage.push_back(p0);
		subdivided_cage.push_back(q0);
		subdivided_cage.push_back(r1);
		subdivided_cage.push_back(y1);
		subdivided_cage.push_back(z1);
		subdivided_cage.push_back(y2);
		subdivided_cage.push_back(r3);
		subdivided_cage.push_back(q3);
	}

	return subdivided_cage;
}

void CalGreenBasis3D(OpenMesh::Vec3d& v1, OpenMesh::Vec3d& v2, OpenMesh::Vec3d& v3, OpenMesh::Vec3d& eta, int& index,
	double& ksiH, std::vector<double>& phiH) {
	auto sign = [](double value) -> double {
		return (value > 0) ? 1.0 : -1.0;
	};
	OpenMesh::Vec3d n = computeNormal(v1, v2, v3);//是否是单位法向
	std::vector<OpenMesh::Vec3d> vjl(3);
	vjl[0] = v1 - eta;
	vjl[1] = v2 - eta;
	vjl[2] = v3 - eta;
	OpenMesh::Vec3d zero(0., 0., 0.);
	OpenMesh::Vec3d p = vjl[0].dot(n) * n;
	std::vector<double> sk(3);
	std::vector<double> lk(3);
	std::vector<double> llk(3);
	std::vector<OpenMesh::Vec3d> ql(3);
	std::vector<OpenMesh::Vec3d> Nl(3);
	for (int l = 0; l < 3; ++l) {
		sk[l] = sign(((vjl[l] - p).cross(vjl[(l + 1) % 3])).dot(n));
        lk[l] = GCTrlInt(p, vjl[l], vjl[(l + 1) % 3], zero);
		llk[l] = GCTrlInt(zero, vjl[(l + 1) % 3], vjl[l], zero);
		ql[l] = vjl[(l + 1) % 3].cross(vjl[l]);
		Nl[l] = ql[l] / norm(ql[l]);
	}
	double II = -abs(sk[0] * lk[0] + sk[1] * lk[1] + sk[2] * lk[2]);
	ksiH = -II;
	OpenMesh::Vec3d w = n * II + Nl[0] * llk[0] + Nl[1] * llk[1] + Nl[2] * llk[2]; // 需要根据具体公式计算
	if (w.norm() > 0.000001) {
		for (int l = 0; l < 3; ++l) {
			// 更新 phi 值
			OpenMesh::Vec3d N_el; // 从伪代码中具体提取
			phiH[l] = Nl[l + 1].dot(w) / (Nl[l + 1].dot(vjl[l]));
		}
	}
}


void CalBiharmonicBasis3D(OpenMesh::Vec3d& v0, OpenMesh::Vec3d& v1, OpenMesh::Vec3d& v2, OpenMesh::Vec3d& eta, int& index,
	double& ksiBH, std::vector<double>& phiBH) {
	std::vector<OpenMesh::Vec3d> vertexs = { v0,v1,v2 };
	double lambda1 = -1. / (4 * M_PI);
	double lambda2 = -1. / (8 * M_PI);
	phiBH.resize(3);
	double w_t = SolidAngle(v0, v1, v2, eta);
	OpenMesh::Vec3d n_t = computeNormal(v0, v1, v2);
	double d_t = (eta - v0).dot(n_t);
	ksiBH = pow(d_t, 3) * w_t / 3;
	OpenMesh::Vec3d DetaksiBH = pow(d_t, 2) * n_t * w_t;//对eta的偏导数
	//3条边上的量
	for (int i = 0; i < 3; i++)
	{
		OpenMesh::Vec3d e0 = vertexs[i];
		OpenMesh::Vec3d e1 = vertexs[(i + 1) % 3];
		OpenMesh::Vec3d e = e1 - e0;
		OpenMesh::Vec3d u_e = e / norm(e);
		OpenMesh::Vec3d r_e = n_t.cross(u_e);
		OpenMesh::Vec3d lv_e0 = eta - e0; OpenMesh::Vec3d lv_e1 = eta - e1; 
		double l_e0 = lv_e0.norm(); double l_e1 = lv_e1.norm();
		double xi_e0 = lv_e0.dot(u_e); double xi_e1 = lv_e1.dot(u_e);
		double a_e = r_e.dot(lv_e0);
		double De2 = (lv_e0-u_e.sqrnorm()*lv_e0).sqrnorm();
		OpenMesh::Vec3d Dve2 = lv_e0 - u_e.sqrnorm() * lv_e0;
		ksiBH += a_e / 6 * ((2 * d_t * d_t + De2) * log((l_e1 - xi_e1) / (l_e0 - xi_e0)) - l_e1 * xi_e1 + l_e0 * xi_e0);
		OpenMesh::Vec3d u_e0 = lv_e0.normalized(); OpenMesh::Vec3d u_e1 = lv_e1.normalized();
		OpenMesh::Vec3d m_e0 = (u_e0 - u_e) / (l_e0 - xi_e0); OpenMesh::Vec3d m_e1 = (u_e1 - u_e) / (l_e1 - xi_e1);
		OpenMesh::Vec3d Detaw_t = (2 * (l_e0 + l_e1) / (pow((l_e0 + l_e1), 2) - e.sqrnorm())) * u_e0.cross(u_e1);
		DetaksiBH += pow(d_t, 3) / 3 * Detaw_t;
		DetaksiBH += r_e / 6 * ((2 * d_t * d_t + De2) * log((l_e1 - xi_e1) / (l_e0 - xi_e0)) - l_e1 * xi_e1 + l_e0 * xi_e0);
		DetaksiBH += a_e / 6 * ((4. * d_t * n_t + 2 * Dve2) * log((l_e1 - xi_e1) / (l_e0 - xi_e0)));
		DetaksiBH += a_e / 6 * ((2. * d_t * d_t + De2) * (m_e1 - m_e0));
		DetaksiBH += a_e / 6 * (-u_e1 * xi_e1 + u_e0 * xi_e0 + (l_e0 - l_e1) * u_e);
	}
	ksiBH *= -lambda2;
	DetaksiBH *= -lambda2;

	std::vector<OpenMesh::Vec3d> r_i(3);
	std::vector<double> h_i(3);
	for (int i = 0; i < 3; i++)
	{
		r_i[i] = n_t.cross(vertexs[(i + 2) % 3] - vertexs[(i + 1) % 3]) / (vertexs[(i + 2) % 3] - vertexs[(i + 1) % 3]).norm();
		h_i[i] = (vertexs[i] - vertexs[(i + 1) % 3]).dot(r_i[i]);
		OpenMesh::Vec3d g_i = r_i[i] / h_i[i];
		double gama_ti = (eta - vertexs[(i + 1) % 3]).dot(g_i);
		phiBH[i] = -d_t * DetaksiBH.dot(g_i) + 1. / 2 * d_t * gama_ti * ksiBH;
	}
}

void CalBiharmonicBasis(OpenMesh::Vec2d& v0, OpenMesh::Vec2d& v1, OpenMesh::Vec2d& v2, OpenMesh::Vec2d& eta,
	double& ksiH, double& phiH, double& BHksi, double& BHphi) {
	OpenMesh::Vec2d ei, ui, xiyi;
	double ci, L1i, L2i, Ai, hatphiH_1, hatphiBH_1, hatphiH, hatphiBH;
	{//计算前一个phi的值
		ei = v1 - v0;
		ci = ei.norm();
		ui = eta - v0;
		xiyi = OpenMesh::Vec2d(ui[0] * ei[0] + ui[1] * ei[1], ui[1] * ei[0] - ui[0] * ei[1]);
		xiyi = xiyi / ci;
		L1i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1]);
		L2i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1] + ci * ci - 2 * ci * xiyi[0]);
		Ai = atan(xiyi[0] / xiyi[1]) + atan((ci - xiyi[0]) / xiyi[1]);
		hatphiH_1 = (2 * xiyi[0] * Ai - xiyi[1] * (L1i - L2i)) / (4 * M_PI * ci);
		hatphiBH_1 = (4 * Ai * xiyi[0] * xiyi[1] * xiyi[1] - L2i * xiyi[1] * (xiyi[0] * xiyi[0] - xiyi[1] * xiyi[1] - ci * ci)
			+ L1i * xiyi[1] * (xiyi[0] * xiyi[0] - xiyi[1] * xiyi[1]) - 2 * xiyi[1] * ci * (ci + xiyi[0])) / (16 * M_PI * ci);
	}
	ei = v2 - v1;
	ci = ei.norm();
	ui = eta - v1;
	xiyi = OpenMesh::Vec2d(ui[0] * ei[0] + ui[1] * ei[1], ui[1] * ei[0] - ui[0] * ei[1]);
	xiyi = xiyi / ci;
	L1i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1]);
	L2i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1] + ci * ci - 2 * ci * xiyi[0]);
	Ai = atan(xiyi[0] / xiyi[1]) + atan((ci - xiyi[0]) / xiyi[1]);
	hatphiH = (2 * xiyi[0] * Ai - xiyi[1] * (L1i - L2i)) / (4 * M_PI * ci);
	hatphiBH = (4 * Ai * xiyi[0] * xiyi[1] * xiyi[1] - L2i * xiyi[1] * (xiyi[0] * xiyi[0] - xiyi[1] * xiyi[1] - ci * ci)
		+ L1i * xiyi[1] * (xiyi[0] * xiyi[0] - xiyi[1] * xiyi[1]) - 2 * xiyi[1] * ci * (ci + xiyi[0])) / (16 * M_PI * ci);

	ksiH = (2 * Ai * xiyi[1] + L1i * xiyi[0] - 2 * ci + (ci - xiyi[0]) * L2i) / (-4 * M_PI);
	phiH = (hatphiH_1 - hatphiH + Ai / (2 * M_PI));
	BHksi = (3 * L1i * xiyi[0] * (3 * xiyi[1] * xiyi[1] + xiyi[0] * xiyi[0])
		+ 3 * L2i * (ci - xiyi[0]) * (ci * ci - 2 * ci * xiyi[0] + 3 * xiyi[1] * xiyi[1] + xiyi[0] * xiyi[0])
		+ 12 * Ai * pow(xiyi[1], 3) + 24 * (ci * ci * xiyi[0] - ci * xiyi[0] * xiyi[0]) - 8 * ci * ci * ci - 30 * ci * pow(xiyi[1], 2)) / (-144 * M_PI);
	BHphi = (hatphiBH_1 - hatphiBH + (xiyi[1] / (8 * M_PI)) * (2 * Ai * xiyi[1] + L1i * xiyi[0] - 3 * ci + L2i * (ci - xiyi[0])));
	//std::cout << "end" << std::endl;
}


void CalBiharmonicTwiceBasis(OpenMesh::Vec2d& v0, OpenMesh::Vec2d& v1, OpenMesh::Vec2d& v2, OpenMesh::Vec2d& eta,
	std::vector<double>& values) {
	values.resize(12);
	//v0 = OpenMesh::Vec2d(0, 2); v1 = OpenMesh::Vec2d(0, 0); v2 = OpenMesh::Vec2d(2, 0); eta = OpenMesh::Vec2d(1, 1);
	OpenMesh::Vec2d ei, ui, xiyi;
	double ci, L1i, L2i, Ai, xi, yi, Ic0, Ic0_1, Ic1, It0_1, It0, It1,
		Ix0_1, Ix0, Ix1, Iy0, Iy1, Ie1,hatphiBH_1, hatphiH, hatphiBH;
	{//计算前一个phi的值
		ei = v1 - v0;
		ci = ei.norm();
		ui = eta - v0;
		xiyi = OpenMesh::Vec2d(ui[0] * ei[0] + ui[1] * ei[1], ui[1] * ei[0] - ui[0] * ei[1]);
		xiyi = xiyi / ci;
		xi = xiyi[0];
		yi = xiyi[1];
		L1i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1]);
		L2i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1] + ci * ci - 2 * ci * xiyi[0]);
		Ai = atan(xiyi[0] / xiyi[1]) + atan((ci - xiyi[0]) / xiyi[1]);
		Ic0_1 = ((xi-yi)*(xi+yi)* Ai + yi * (ci + (xi) * (L2i - L1i))) / (2*ci*ci * M_PI);
		It0_1 =2* (-ci * (ci + 2 * xi) + 4 * xi * yi * Ai + (ci * ci - xi * xi + yi * yi) * L2i + (xi - yi) * (xi + yi) * L1i) / (-8 * ci * ci * M_PI);
		Ix0_1 = yi * (ci * ci * ci + 1. / 3 * (
			2 * ci * ci * ci + 3 * ci * ci * xi + 6 * ci * xi * xi - 6 * ci * yi * yi - 6 * (3 * xi * xi * yi - yi * yi * yi) * Ai + (9 * xi * yi * yi - 3 * xi * xi * xi) * (L1i - L2i) - 3 * ci * ci * ci * L2i)
			) / (-24 * ci * ci * M_PI);
	}
	ei = v2 - v1;
	ci = ei.norm();
	ui = eta - v1;
	xiyi = OpenMesh::Vec2d(ui[0] * ei[0] + ui[1] * ei[1], ui[1] * ei[0] - ui[0] * ei[1]);
	xiyi = xiyi / ci;
	xi = xiyi[0];
	yi = xiyi[1];
	L1i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1]);
	L2i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1] + ci * ci - 2 * ci * xiyi[0]);
	Ai = atan(xiyi[0] / xiyi[1]) + atan((ci - xiyi[0]) / xiyi[1]);
	Ic0= ((ci*ci-2*ci*xi+xi*xi-yi*yi) * Ai + yi * (ci + (xi-ci) * (L2i - L1i))) / (2 * ci * ci * M_PI);
	Ic1 = (2 * (ci * xi - xi * xi + yi * yi) * Ai + yi * (-2 * ci + (ci - 2 * xi) * (L2i - L1i))) / (2 * ci * ci * M_PI);
	It0 =2* (ci * (-3 * ci + 2 * xi) + 4 * (ci - xi) * yi * Ai + (ci - xi - yi) * (ci - xi + yi) * L2i + (2 * ci * xi - xi * xi + yi * yi) * L1i) / (8 * ci * ci * M_PI);	
	It1 =2* (ci * ci - 2 * ci * xi - 2 * (ci - 2 * xi) * yi * Ai + (xi * xi - yi * yi - ci * xi) * (L1i - L2i)) / (4 * ci * ci * M_PI);
	Ix0 =yi* (-14 * ci * ci * ci + 15 * ci * ci * xi - 6 * ci * xi * xi + 6 * ci * yi * yi - 6 * yi * (-3 * ci * ci + 6 * ci * xi - 3 * xi * xi + yi * yi) * Ai
		+ (9 * ci * ci * xi - 9 * ci * xi * xi + 3 * xi * xi * xi + 9 * ci * yi * yi - 9 * xi * yi * yi) * (L1i - L2i) + 3 * ci * ci * ci * L2i) / (72 * ci * ci * M_PI);
	Ix1= yi*(-8 * ci * ci * ci -12 * ci * ci * xi +12 * ci * xi * xi -12 * ci * yi * yi + 12 * yi * (3 * ci * xi  - 3 * xi * xi + yi * yi) * Ai
		+ (9 * ci * xi * xi  -6 * xi * xi * xi - 9 * ci * yi * yi +18 * xi * yi * yi) * (L1i - L2i) + 3 * ci * ci * ci * L2i) / (72 * ci * ci * M_PI);	
	Iy0 = (-19 * ci * ci * ci * ci + 76 * ci * ci * ci * xi - 114 * ci * ci * xi * xi + 12 * ci * xi * xi * xi - 150 * ci * ci * yi * yi + 60 * ci * xi * yi * yi +
		96 * (ci - xi) * yi * yi * yi * Ai + (24 * ci * xi * xi * xi - 6 * xi * xi * xi * xi + 72 * ci * xi * yi * yi - 36 * xi * xi * yi * yi + 18 * yi * yi * yi * yi) * (L1i - L2i)
		+ (6 * ci * ci * ci * ci + 36 * ci * ci * xi * xi - 24 * ci * ci*ci * xi + 36 * ci * ci * yi * yi) * L2i) / (-1152 * ci * ci * M_PI);
	
	Iy1 = (-45 * ci * ci * ci * ci + 116 * ci * ci * ci * xi - 78 * ci * ci * xi * xi - 12 * ci * xi * xi * xi - 90 * ci * ci * yi * yi - 60 * ci * xi * yi * yi +
		96 * xi * yi * yi * yi * Ai + (6 * xi * xi * xi * xi + 36 * xi * xi * yi * yi - 18 * yi * yi * yi * yi) * (L1i - L2i)
		+ (18 * ci * ci * ci * ci - 48 * ci * ci * ci * xi + 36 * ci * ci * xi * xi + 36 * ci * ci * yi * yi) * L2i) / (-1152 * ci * ci * M_PI);
	Ie1 = (-ci * (ci + 2 * xi) + 4 * xi * yi * Ai + (ci * ci - xi * xi + yi * yi) * L2i + (xi - yi) * (xi + yi) * L1i) / (-8 * ci * ci * M_PI);
	values[0] = Ic0 + Ic0_1;
	values[1] = Ic1;
	values[2] = It0 + It0_1;
	values[3] = It1;
	values[4] = Ix0 + Ix0_1;
	values[5] = Ix1;
	values[6] = Iy0;
	values[7] = Iy1;
	values[8] = Ic0 + Ic0_1;
	values[9] = Ic1;
	values[10] = -It0/2;//要除以2吗
	values[11] = Ie1;
}

//重新计算两次情形下的系数的计算，与之前的相比，改变了导数那一项的计算方式，现在是与每条边上的两个切方向相乘
void CalBiharmonicTwiceBasisNew(OpenMesh::Vec2d& v0, OpenMesh::Vec2d& v1, OpenMesh::Vec2d& v2, OpenMesh::Vec2d& eta,
	std::vector<double>& values) {
	//values.resize(12);
	values.resize(16);
	//v0 = OpenMesh::Vec2d(0, 2); v1 = OpenMesh::Vec2d(0, 0); v2 = OpenMesh::Vec2d(2, 0); eta = OpenMesh::Vec2d(1, 1);
	OpenMesh::Vec2d ei, ui, xiyi;
	double ci, L1i, L2i, Ai, xi, yi, Ic0, Ic0_1, Ic1, It0_1, It0, It1, It1New, It2New,
		Ix0_1, Ix0, Ix1, Iy0, Iy1, Ie1, hatphiBH_1, hatphiH, hatphiBH;
	{//计算前一个phi的值
		ei = v1 - v0;
		ci = ei.norm();
		ui = eta - v0;
		xiyi = OpenMesh::Vec2d(ui[0] * ei[0] + ui[1] * ei[1], ui[1] * ei[0] - ui[0] * ei[1]);
		xiyi = xiyi / ci;
		xi = xiyi[0];
		yi = xiyi[1];
		L1i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1]);
		L2i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1] + ci * ci - 2 * ci * xiyi[0]);
		Ai = atan(xiyi[0] / xiyi[1]) + atan((ci - xiyi[0]) / xiyi[1]);
		Ic0_1 = ((xi - yi) * (xi + yi) * Ai + yi * (ci + (xi) * (L2i - L1i))) / (2 * ci * ci * M_PI);
		It0_1 = 2 * (-ci * (ci + 2 * xi) + 4 * xi * yi * Ai + (ci * ci - xi * xi + yi * yi) * L2i + (xi - yi) * (xi + yi) * L1i) / (-8 * ci * ci * M_PI);
		Ix0_1 = yi * (ci * ci * ci + 1. / 3 * (
			2 * ci * ci * ci + 3 * ci * ci * xi + 6 * ci * xi * xi - 6 * ci * yi * yi - 6 * (3 * xi * xi * yi - yi * yi * yi) * Ai + (9 * xi * yi * yi - 3 * xi * xi * xi) * (L1i - L2i) - 3 * ci * ci * ci * L2i)
			) / (-24 * ci * ci * M_PI);
	}
	ei = v2 - v1;
	ci = ei.norm();
	ui = eta - v1;
	xiyi = OpenMesh::Vec2d(ui[0] * ei[0] + ui[1] * ei[1], ui[1] * ei[0] - ui[0] * ei[1]);
	xiyi = xiyi / ci;
	xi = xiyi[0];
	yi = xiyi[1];
	L1i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1]);
	L2i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1] + ci * ci - 2 * ci * xiyi[0]);
	Ai = atan(xiyi[0] / xiyi[1]) + atan((ci - xiyi[0]) / xiyi[1]);
	Ic0 = ((ci * ci - 2 * ci * xi + xi * xi - yi * yi) * Ai + yi * (ci + (xi - ci) * (L2i - L1i))) / (2 * ci * ci * M_PI);
	Ic1 = (2 * (ci * xi - xi * xi + yi * yi) * Ai + yi * (-2 * ci + (ci - 2 * xi) * (L2i - L1i))) / (2 * ci * ci * M_PI);
	It0 = 2 * (ci * (-3 * ci + 2 * xi) + 4 * (ci - xi) * yi * Ai + (ci - xi - yi) * (ci - xi + yi) * L2i + (2 * ci * xi - xi * xi + yi * yi) * L1i) / (8 * ci * ci * M_PI);
	It1 = 2 * (ci * ci - 2 * ci * xi - 2 * (ci - 2 * xi) * yi * Ai + (xi * xi - yi * yi - ci * xi) * (L1i - L2i)) / (4 * ci * ci * M_PI);
	It1New = -It0;
	It2New = 2 * (-ci * (ci + 2 * xi) + 4 * xi * yi * Ai + (ci * ci - xi * xi + yi * yi) * L2i + (xi - yi) * (xi + yi) * L1i) / (-8 * ci * ci * M_PI);
	Ix0 = yi * (-14 * ci * ci * ci + 15 * ci * ci * xi - 6 * ci * xi * xi + 6 * ci * yi * yi - 6 * yi * (-3 * ci * ci + 6 * ci * xi - 3 * xi * xi + yi * yi) * Ai
		+ (9 * ci * ci * xi - 9 * ci * xi * xi + 3 * xi * xi * xi + 9 * ci * yi * yi - 9 * xi * yi * yi) * (L1i - L2i) + 3 * ci * ci * ci * L2i) / (72 * ci * ci * M_PI);
	Ix1 = yi * (-8 * ci * ci * ci - 12 * ci * ci * xi + 12 * ci * xi * xi - 12 * ci * yi * yi + 12 * yi * (3 * ci * xi - 3 * xi * xi + yi * yi) * Ai
		+ (9 * ci * xi * xi - 6 * xi * xi * xi - 9 * ci * yi * yi + 18 * xi * yi * yi) * (L1i - L2i) + 3 * ci * ci * ci * L2i) / (72 * ci * ci * M_PI);
	Iy0 = (-19 * ci * ci * ci * ci + 76 * ci * ci * ci * xi - 114 * ci * ci * xi * xi + 12 * ci * xi * xi * xi - 150 * ci * ci * yi * yi + 60 * ci * xi * yi * yi +
		96 * (ci - xi) * yi * yi * yi * Ai + (24 * ci * xi * xi * xi - 6 * xi * xi * xi * xi + 72 * ci * xi * yi * yi - 36 * xi * xi * yi * yi + 18 * yi * yi * yi * yi) * (L1i - L2i)
		+ (6 * ci * ci * ci * ci + 36 * ci * ci * xi * xi - 24 * ci * ci * ci * xi + 36 * ci * ci * yi * yi) * L2i) / (-1152 * ci * ci * M_PI);

	Iy1 = (-45 * ci * ci * ci * ci + 116 * ci * ci * ci * xi - 78 * ci * ci * xi * xi - 12 * ci * xi * xi * xi - 90 * ci * ci * yi * yi - 60 * ci * xi * yi * yi +
		96 * xi * yi * yi * yi * Ai + (6 * xi * xi * xi * xi + 36 * xi * xi * yi * yi - 18 * yi * yi * yi * yi) * (L1i - L2i)
		+ (18 * ci * ci * ci * ci - 48 * ci * ci * ci * xi + 36 * ci * ci * xi * xi + 36 * ci * ci * yi * yi) * L2i) / (-1152 * ci * ci * M_PI);
	Ie1 = (-ci * (ci + 2 * xi) + 4 * xi * yi * Ai + (ci * ci - xi * xi + yi * yi) * L2i + (xi - yi) * (xi + yi) * L1i) / (-8 * ci * ci * M_PI);
	values[0] = Ic0 + Ic0_1;
	values[1] = Ic1;
	values[2] = It1New;//
	values[3] = It2New;//
	values[4] = Ix0 + Ix0_1;
	values[5] = Ix1;
	values[6] = Iy0;
	values[7] = Iy1;
	values[8] = Ic0 + Ic0_1;
	values[9] = Ic1;
	values[10] = -It0 / 2;//要除以2吗
	values[11] = Ie1;
}


void MeshViewerWidget::Cal222BiharmonicBasis(OpenMesh::Vec2d& v0, OpenMesh::Vec2d& v01, OpenMesh::Vec2d& v1, OpenMesh::Vec2d& v12, OpenMesh::Vec2d& v2,
	OpenMesh::Vec2d& eta, std::vector<double>& values) {
	values.resize(12);
	//values.resize(16);
	//v0 = OpenMesh::Vec2d(0, 0); v01 = OpenMesh::Vec2d(1, -1); v1 = OpenMesh::Vec2d(2, 0); v12 = OpenMesh::Vec2d(3, 1); v2 = OpenMesh::Vec2d(2, 2);eta = OpenMesh::Vec2d(1, 1);
	OpenMesh::Vec2d ei, ui, xiyi;
	double ci, L1i, L2i, Ai, xi, yi, Ic0, Ic0_1, Ic1, It0_1, It0, It1, It1New, It2New,
		Ix0_1, Ix0, Ix1, Iy0, Iy1, Ie1, hatphiBH_1, hatphiH, hatphiBH;
	//将bezier的控制点转化为幂基下的控制点
	OpenMesh::Vec2d c0, c1, c2, m0, m1, m2;
	double c0x, c0y, c1x, c1y, c2x, c2y, etax, etay;
	double F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10;
	double Ic0t0, Ic0t1, Ic0t2, Ic0t3, Ic0t4, Ic0t5;
	double Ic0_1t0, Ic0_1t1, Ic0_1t2, Ic0_1t3, Ic0_1t4, Ic0_1t5;
	double Ic1t0, Ic1t1, Ic1t2, Ic1t3, Ic1t4, Ic1t5;
	double It0t0, It0t1, It0t2, It0t3, It0t4, It0t5;
	double It1t0, It1t1, It1t2, It1t3, It1t4, It1t5;
	double Ix0t0, Ix0t1, Ix0t2, Ix0t3, Ix0t4, Ix0t5, Ix0t6, Ix0t7, Ix0t8;
	double Ix0_1t0, Ix0_1t1, Ix0_1t2, Ix0_1t3, Ix0_1t4, Ix0_1t5, Ix0_1t6, Ix0_1t7, Ix0_1t8;	
	double Ix1t0, Ix1t1, Ix1t2, Ix1t3, Ix1t4, Ix1t5, Ix1t6, Ix1t7, Ix1t8;	
	double Iy0t0, Iy0t1, Iy0t2, Iy0t3, Iy0t4, Iy0t5, Iy0t6, Iy0t7, Iy0t8, Iy0t9, Iy0t10;	
	double Iy1t0, Iy1t1, Iy1t2, Iy1t3, Iy1t4, Iy1t5, Iy1t6, Iy1t7, Iy1t8, Iy1t9, Iy1t10;
	

	{//计算前一个phi的值
		m0 = v0;  m1 = 2 * (v01 - v0);  m2 = v1 - 2 * v01 + v0;
		c0 = v0;  c1 = v01;  c2 = v1;
		c0x = c0[0]; c0y = c0[1]; c1x = c1[0]; c1y = c1[1]; c2x = c2[0]; c2y = c2[1]; etax = eta[0]; etay = eta[1];
		
		
		//Ix0_1余项
		double Ix0_1Item = 2 * (
			(1.0 / 5.0) * (-c0y * c1x + c0x * c1y + c0y * c2x - c1y * c2x - c0x * c2y + c1x * c2y)
			+ (1.0 / 3.0) * (-c0y * c1x + c0x * c1y + c0y * etax - c1y * etax - c0x * etay + c1x * etay)
			+ (1.0 / 4.0) * (2 * c0y * c1x - 2 * c0x * c1y - c0y * c2x + c0x * c2y - c0y * etax
				+ 2 * c1y * etax - c2y * etax + c0x * etay - 2 * c1x * etay + c2x * etay)
			) * (-1.0 + 2.0 * log(sqrt(pow(c2x - etax, 2) + pow(c2y - etay, 2))));
		{
			c0x = c0[0] - eta[0]; c0y = c0[1] - eta[1]; c1x = c1[0] - eta[0]; c1y = c1[1] - eta[1]; c2x = c2[0] - eta[0]; c2y = c2[1] - eta[1];
			double dc0x, dc0y, dc1x, dc1y;
			dc0x = c1x - c0x; dc0y = c1y - c0y;
			dc1x = c2x + c0x - 2 * c1x; dc1y = c2y + c0y - 2 * c1y;
			myArray<3> ct_x, ct_y;
			myArray<2> dct_x, dct_y;
			Bezier2Poly2({ c0x,c1x,c2x }, ct_x); Bezier2Poly2({ c0y,c1y,c2y }, ct_y);
			dct_x = { dc0x,dc1x }; dct_y = { dc0y,dc1y };

			auto ctxy = multiplyPolynomials(ct_x, dct_y);
			auto cty_x = multiplyPolynomials(ct_y, -dct_x);
			auto c0_1 = addPolynomials(ctxy, cty_x, 3);
			myArray<3> c0_1_xishu{ 0,0,2 };
			auto Ic0_1result = multiplyPolynomials(c0_1_xishu, c0_1);
			Ic0_1t0 = Ic0_1result[0];
			Ic0_1t1 = Ic0_1result[1];
			Ic0_1t2 = Ic0_1result[2];
			Ic0_1t3 = Ic0_1result[3];
			Ic0_1t4 = Ic0_1result[4];
			Ic0_1t5 = Ic0_1result[5];

			auto ctxx = multiplyPolynomials(ct_x, dct_x);
			auto ctyy = multiplyPolynomials(ct_y, dct_y);
			auto c0_1b = addPolynomials(ctxx, ctyy, 3);
			auto Ix0_1half1 = integratePolynomial(Ic0_1result, 5);

			auto Ix0_1result = multiplyPolynomials(Ix0_1half1, c0_1b);
			Ix0_1t0 = Ix0_1result[0];
			Ix0_1t1 = Ix0_1result[1];
			Ix0_1t2 = Ix0_1result[2];
			Ix0_1t3 = Ix0_1result[3];
			Ix0_1t4 = Ix0_1result[4];
			Ix0_1t5 = Ix0_1result[5];
			Ix0_1t6 = Ix0_1result[6];
			Ix0_1t7 = Ix0_1result[7];
			Ix0_1t8 = Ix0_1result[8];
		}
		{
			auto ALL_f8 = ALL_F2_n(eta, m0, m1, m2, 8);//使用幂基控制点,注意已经除以2Pi了
			F0 = ALL_f8[0];
			F1 = ALL_f8[1];
			F2 = ALL_f8[2];
			F3 = ALL_f8[3];
			F4 = ALL_f8[4];
			F5 = ALL_f8[5];
			F6 = ALL_f8[6];
			F7 = ALL_f8[7];
			F8 = ALL_f8[8];

		}
		
		Ic0_1 = (Ic0_1t0 * F0 + Ic0_1t1 * F1 + Ic0_1t2 * F2 + Ic0_1t3 * F3 + Ic0_1t4 * F4 + Ic0_1t5 * F5);

		//计算Ix0_1

		Ix0_1 = -(Ix0_1t0 * F0 + Ix0_1t1 * F1 + Ix0_1t2 * F2 + Ix0_1t3 * F3 + Ix0_1t4 * F4 + Ix0_1t5 * F5
			+ Ix0_1t6 * F6 + Ix0_1t7 * F7 + Ix0_1t8 * F8) + Ix0_1Item / (8 * M_PI);
	}

	//右边半段
	m0 = v1;  m1 = 2 * (v12 - v1);  m2 = v2 - 2 * v12 + v1;
	c0 = v1;  c1 = v12;  c2 = v2;
	c0x = c0[0]; c0y = c0[1]; c1x = c1[0]; c1y = c1[1]; c2x = c2[0]; c2y = c2[1]; etax = eta[0]; etay = eta[1];
	
	
	
	//余项们
	double logterm = log((c2x - etax) * (c2x - etax) + (c2y - etay) * (c2y - etay));
	double It0Item = 0.5 * logterm;//对
	double It1Item = 0.5 * logterm;
	double Ix0Item = -(1.0 / 30.0) * (
		3 * c0y * (4 * c1x + c2x - 5 * etax) + 5 * c2y * etax
		+ 2 * c1y * (c2x + 5 * etax) - 3 * c0x * (4 * c1y + c2y - 5 * etay)
		- 5 * c2x * etay - 2 * c1x * (c2y + 5 * etay)
		) * (-1.0 + logterm);
	double Ix1Item = (1.0 / 15.0) * (
		12 * (c0y * (c1x - c2x) + c1y * c2x - c1x * c2y + c0x * (-c1y + c2y)) +
		30 * (-c1y * etax + c0y * (-c1x + etax) + c0x * (c1y - etay) + c1x * etay) +
		15 * (-c1y * c2x + c1x * c2y - 2 * c1y * etax + c2y * etax +
			c0y * (-3 * c1x + 2 * c2x + etax) + c0x * (3 * c1y - 2 * c2y - etay) +
			2 * c1x * etay - c2x * etay) +
		20 * (c0y * (3 * c1x - c2x - 2 * etax) + 3 * c1y * etax - c2y * etax -
			3 * c1x * etay + c2x * etay + c0x * (-3 * c1y + c2y + 2 * etay))
		) * (-1.0 + logterm);
	double Iy0Item = (1.0 / 60.0) * (
		(5 * pow(c0x, 2) + 5 * pow(c0y, 2) + 4 * c0x * c1x + 2 * pow(c1x, 2) +
			4 * c0y * c1y + 2 * pow(c1y, 2) + c0x * c2x + 2 * c1x * c2x + pow(c2x, 2) +
			c0y * c2y + 2 * c1y * c2y + pow(c2y, 2) -
			5 * (3 * c0x + 2 * c1x + c2x) * etax + 15 * pow(etax, 2) -
			5 * (3 * c0y + 2 * c1y + c2y) * etay + 15 * pow(etay, 2)
			) * (-2.0 + logterm)
		);

	double Iy1Item = (1.0 / 60.0) * (
		(pow(c0x, 2) + pow(c0y, 2) + 2 * c0x * c1x + 2 * pow(c1x, 2) + 2 * c0y * c1y + 2 * pow(c1y, 2) +
			c0x * c2x + 4 * c1x * c2x + 5 * pow(c2x, 2) + c0y * c2y + 4 * c1y * c2y + 5 * pow(c2y, 2) -
			5 * (c0x + 2 * c1x + 3 * c2x) * etax + 15 * pow(etax, 2) -
			5 * (c0y + 2 * c1y + 3 * c2y) * etay + 15 * pow(etay, 2)
			) * (-2 + logterm)
		);

	{
		c0x = c0[0] - eta[0]; c0y = c0[1] - eta[1]; c1x = c1[0] - eta[0]; c1y = c1[1] - eta[1]; c2x = c2[0] - eta[0]; c2y = c2[1] - eta[1];
		double dc0x, dc0y, dc1x, dc1y;
		dc0x = c1x - c0x; dc0y = c1y - c0y;
		dc1x = c2x + c0x - 2 * c1x; dc1y = c2y + c0y - 2 * c1y;
		myArray<3> ct_x, ct_y;
		myArray<2> dct_x, dct_y;
		Bezier2Poly2({ c0x,c1x,c2x }, ct_x); Bezier2Poly2({ c0y,c1y,c2y }, ct_y);
		dct_x = { dc0x,dc1x }; dct_y = { dc0y,dc1y };

		auto ctxy = multiplyPolynomials(ct_x, dct_y);
		auto cty_x = multiplyPolynomials(ct_y, -dct_x);
		auto ctdtb = addPolynomials(ctxy, cty_x, 3);
		auto ctxx = multiplyPolynomials(ct_x, dct_x);
		auto ctyy = multiplyPolynomials(ct_y, dct_y);
		auto ctdt = addPolynomials(ctxx, ctyy, 3);
		auto ctxctx= multiplyPolynomials(ct_x, ct_x);
		auto ctycty = multiplyPolynomials(ct_y, ct_y);
		auto ctct = addPolynomials(ctxctx, ctycty,4);


		myArray<3> c0_xishu{ 2,-4,2 };
		myArray<3> c1_xishu{ 0,4,-4 };
		myArray<3> t0_xishu{ 0,4,-2 };
		myArray<3> t1_xishu{ 0,0,2 };
		auto Ic0result = multiplyPolynomials(c0_xishu, ctdtb);
		auto Ic1result = multiplyPolynomials(c1_xishu, ctdtb);
		auto It0result = multiplyPolynomials(t0_xishu, ctdt);
		auto It1result = multiplyPolynomials(t1_xishu, ctdt);
		Ic0t0 = Ic0result[0];
		Ic0t1 = Ic0result[1];
		Ic0t2 = Ic0result[2];
		Ic0t3 = Ic0result[3];
		Ic0t4 = Ic0result[4];
		Ic0t5 = Ic0result[5];

		It0t0 = It0result[0];
		It0t1 = It0result[1];
		It0t2 = It0result[2];
		It0t3 = It0result[3];
		It0t4 = It0result[4];
		It0t5 = It0result[5];

		It1t0 = It1result[0];
		It1t1 = It1result[1];
		It1t2 = It1result[2];
		It1t3 = It1result[3];
		It1t4 = It1result[4];
		It1t5 = It1result[5];

		Ic1t0 = Ic1result[0];
		Ic1t1 = Ic1result[1];
		Ic1t2 = Ic1result[2];
		Ic1t3 = Ic1result[3];
		Ic1t4 = Ic1result[4];
		Ic1t5 = Ic1result[5];
		
		
		auto Ix0half1 = integratePolynomial(Ic0result, 5);
		auto Ix1half1 = integratePolynomial(Ic1result, 5);
		auto Ix0result = multiplyPolynomials(Ix0half1, ctdt);
		auto Ix1result = multiplyPolynomials(Ix1half1, ctdt);
		Ix0t0 = Ix0result[0];
		Ix0t1 = Ix0result[1];
		Ix0t2 = Ix0result[2];
		Ix0t3 = Ix0result[3];
		Ix0t4 = Ix0result[4];
		Ix0t5 = Ix0result[5];
		Ix0t6 = Ix0result[6];
		Ix0t7 = Ix0result[7];
		Ix0t8 = Ix0result[8];

		Ix1t0 = Ix1result[0];
		Ix1t1 = Ix1result[1];
		Ix1t2 = Ix1result[2];
		Ix1t3 = Ix1result[3];
		Ix1t4 = Ix1result[4];
		Ix1t5 = Ix1result[5];
		Ix1t6 = Ix1result[6];
		Ix1t7 = Ix1result[7];
		Ix1t8 = Ix1result[8];

		auto Iy0intterm = multiplyPolynomials(array<double, 2>{1, -1}, ctct);
		auto Iy0half1 = integratePolynomial(Iy0intterm, 5);
		auto Iy0result = multiplyPolynomials(Iy0half1, ctdt);
		Iy0t0 = Iy0result[0]/(-2);
		Iy0t1 = Iy0result[1]/(-2);
		Iy0t2 = Iy0result[2]/(-2);
		Iy0t3 = Iy0result[3]/(-2);
		Iy0t4 = Iy0result[4]/(-2);
		Iy0t5 = Iy0result[5]/(-2);
		Iy0t6 = Iy0result[6]/(-2);
		Iy0t7 = Iy0result[7]/(-2);
		Iy0t8 = Iy0result[8]/(-2);
		Iy0t9 = Iy0result[9]/(-2);

		auto Iy1intterm = multiplyPolynomials(array<double, 2>{0,1}, ctct);
		auto Iy1half1 = integratePolynomial(Iy1intterm, 5);
		auto Iy1result = multiplyPolynomials(Iy1half1, ctdt);
		Iy1t0 = Iy1result[0] / (-2);
		Iy1t1 = Iy1result[1] / (-2);
		Iy1t2 = Iy1result[2] / (-2);
		Iy1t3 = Iy1result[3] / (-2);
		Iy1t4 = Iy1result[4] / (-2);
		Iy1t5 = Iy1result[5] / (-2);
		Iy1t6 = Iy1result[6] / (-2);
		Iy1t7 = Iy1result[7] / (-2);
		Iy1t8 = Iy1result[8] / (-2);
		Iy1t9 = Iy1result[9] / (-2);

		
		/*std::cout << Ix1t0 << std::endl;
		std::cout << Ix1t1 << std::endl;
		std::cout << Ix1t2 << std::endl;
		std::cout << Ix1t3 << std::endl;
		std::cout << Ix1t4 << std::endl;
		std::cout << Ix1t5 << std::endl;
		std::cout << Ix1t6 << std::endl;
		std::cout << Ix1t7 << std::endl;
		std::cout << Ix1t8 << std::endl;
		exit(0);*/
	}
	
	{
		auto ALL_f9 = ALL_F2_n(eta, m0, m1, m2, 9);
		F0 = ALL_f9[0];
		F1 = ALL_f9[1];
		F2 = ALL_f9[2];
		F3 = ALL_f9[3];
		F4 = ALL_f9[4];
		F5 = ALL_f9[5];
		F6 = ALL_f9[6];
		F7 = ALL_f9[7];
		F8 = ALL_f9[8];
		F9 = ALL_f9[9];

	}
	
	Ic0 = (Ic0t0 * F0 + Ic0t1 * F1 + Ic0t2 * F2 + Ic0t3 * F3 + Ic0t4 * F4 + Ic0t5 * F5);
	Ic1 = (Ic1t0 * F0 + Ic1t1 * F1 + Ic1t2 * F2 + Ic1t3 * F3 + Ic1t4 * F4 + Ic1t5 * F5);
	It0 = (It0t0 * F0 + It0t1 * F1 + It0t2 * F2 + It0t3 * F3 + It0t4 * F4 + It0t5 * F5) + It0Item / (-2 * M_PI);
	It1 = (It1t0 * F0 + It1t1 * F1 + It1t2 * F2 + It1t3 * F3 + It1t4 * F4 + It1t5 * F5) + It1Item / (-2 * M_PI);
	Ix0 = -(Ix0t0 * F0 + Ix0t1 * F1 + Ix0t2 * F2 + Ix0t3 * F3 + Ix0t4 * F4 + Ix0t5 * F5 + Ix0t6 * F6 + Ix0t7 * F7 + Ix0t8 * F8) + Ix0Item/ (8 * M_PI);
	Ix1 = -(Ix1t0 * F0 + Ix1t1 * F1 + Ix1t2 * F2 + Ix1t3 * F3 + Ix1t4 * F4 + Ix1t5 * F5 + Ix1t6 * F6 + Ix1t7 * F7 + Ix1t8 * F8) + Ix1Item / (8 * M_PI);
	Iy0 = -(Iy0t0 * F0 + Iy0t1 * F1 + Iy0t2 * F2 + Iy0t3 * F3 + Iy0t4 * F4 + Iy0t5 * F5 + Iy0t6 * F6 + Iy0t7 * F7 + Iy0t8 * F8 + Iy0t9 * F9)+Iy0Item/ (-8 * M_PI);
	Iy1 = -(Iy1t0 * F0 + Iy1t1 * F1 + Iy1t2 * F2 + Iy1t3 * F3 + Iy1t4 * F4 + Iy1t5 * F5 + Iy1t6 * F6 + Iy1t7 * F7 + Iy1t8 * F8 + Iy1t9 * F9)+Iy1Item / (-8 * M_PI);
	
	Ie1 = It1 / 2;
	values[0] = Ic0 + Ic0_1;
	values[1] = Ic1;
	values[2] = It0;//
	values[3] = It1;//
	values[4] = Ix0 + Ix0_1;
	values[5] = Ix1;
	values[6] = Iy0;
	values[7] = Iy1;
	values[8] = Ic0 + Ic0_1;
	values[9] = Ic1;
	values[10] = It0/2 ;//要除以2吗
	values[11] = Ie1;
	//std::cout << Ic0_1 << "," << Ix0_1 << std::endl;
}

void MeshViewerWidget::Cal222BiharmonicBasis_edge(OpenMesh::Vec2d& v1, OpenMesh::Vec2d& v12, OpenMesh::Vec2d& v2,
	OpenMesh::Vec2d& eta, std::vector<double>& values) {
	values.resize(15);
	//values.resize(16);
	//v0 = OpenMesh::Vec2d(0, 0); v01 = OpenMesh::Vec2d(1, -1); v1 = OpenMesh::Vec2d(2, 0); v12 = OpenMesh::Vec2d(3, 1); v2 = OpenMesh::Vec2d(2, 2);eta = OpenMesh::Vec2d(1, 1);
	OpenMesh::Vec2d ei, ui, xiyi;
	double ci, L1i, L2i, Ai, xi, yi, Ic0, Ic0_1, Ic1, It0_1, It0, It1, It1New, It2New,
		Ix0_1, Ix0, Ix1, Iy0, Iy1, Ie1, hatphiBH_1, hatphiH, hatphiBH;
	//将bezier的控制点转化为幂基下的控制点
	OpenMesh::Vec2d c0, c1, c2, m0, m1, m2;
	double c0x, c0y, c1x, c1y, c2x, c2y, etax, etay;
	double F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10;
	double Ic0t0, Ic0t1, Ic0t2, Ic0t3, Ic0t4, Ic0t5;
	double Ic0_1t0, Ic0_1t1, Ic0_1t2, Ic0_1t3, Ic0_1t4, Ic0_1t5;
	double Ic1t0, Ic1t1, Ic1t2, Ic1t3, Ic1t4, Ic1t5;
	double It0t0, It0t1, It0t2, It0t3, It0t4, It0t5;
	double It1t0, It1t1, It1t2, It1t3, It1t4, It1t5;
	double Ix0t0, Ix0t1, Ix0t2, Ix0t3, Ix0t4, Ix0t5, Ix0t6, Ix0t7, Ix0t8;
	double Ix0_1t0, Ix0_1t1, Ix0_1t2, Ix0_1t3, Ix0_1t4, Ix0_1t5, Ix0_1t6, Ix0_1t7, Ix0_1t8;
	double Ix1t0, Ix1t1, Ix1t2, Ix1t3, Ix1t4, Ix1t5, Ix1t6, Ix1t7, Ix1t8;
	double Iy0t0, Iy0t1, Iy0t2, Iy0t3, Iy0t4, Iy0t5, Iy0t6, Iy0t7, Iy0t8, Iy0t9, Iy0t10;
	double Iy1t0, Iy1t1, Iy1t2, Iy1t3, Iy1t4, Iy1t5, Iy1t6, Iy1t7, Iy1t8, Iy1t9, Iy1t10;


	//右边半段
	m0 = v1;  m1 = 2 * (v12 - v1);  m2 = v2 - 2 * v12 + v1;
	c0 = v1;  c1 = v12;  c2 = v2;
	c0x = c0[0]; c0y = c0[1]; c1x = c1[0]; c1y = c1[1]; c2x = c2[0]; c2y = c2[1]; etax = eta[0]; etay = eta[1];



	//余项们
	double logterm = log((c2x - etax) * (c2x - etax) + (c2y - etay) * (c2y - etay));
	//Ix0_1余项
	double Ix0_1Item = 2 * (
		(1.0 / 5.0) * (-c0y * c1x + c0x * c1y + c0y * c2x - c1y * c2x - c0x * c2y + c1x * c2y)
		+ (1.0 / 3.0) * (-c0y * c1x + c0x * c1y + c0y * etax - c1y * etax - c0x * etay + c1x * etay)
		+ (1.0 / 4.0) * (2 * c0y * c1x - 2 * c0x * c1y - c0y * c2x + c0x * c2y - c0y * etax
			+ 2 * c1y * etax - c2y * etax + c0x * etay - 2 * c1x * etay + c2x * etay)
		) * (-1.0 + logterm);
	double It0Item = 0.5 * logterm;//对
	double It1Item = 0.5 * logterm;
	double Ix0Item = -(1.0 / 30.0) * (
		3 * c0y * (4 * c1x + c2x - 5 * etax) + 5 * c2y * etax
		+ 2 * c1y * (c2x + 5 * etax) - 3 * c0x * (4 * c1y + c2y - 5 * etay)
		- 5 * c2x * etay - 2 * c1x * (c2y + 5 * etay)
		) * (-1.0 + logterm);
	double Ix1Item = (1.0 / 15.0) * (
		12 * (c0y * (c1x - c2x) + c1y * c2x - c1x * c2y + c0x * (-c1y + c2y)) +
		30 * (-c1y * etax + c0y * (-c1x + etax) + c0x * (c1y - etay) + c1x * etay) +
		15 * (-c1y * c2x + c1x * c2y - 2 * c1y * etax + c2y * etax +
			c0y * (-3 * c1x + 2 * c2x + etax) + c0x * (3 * c1y - 2 * c2y - etay) +
			2 * c1x * etay - c2x * etay) +
		20 * (c0y * (3 * c1x - c2x - 2 * etax) + 3 * c1y * etax - c2y * etax -
			3 * c1x * etay + c2x * etay + c0x * (-3 * c1y + c2y + 2 * etay))
		) * (-1.0 + logterm);
	double Iy0Item = (1.0 / 60.0) * (
		(5 * pow(c0x, 2) + 5 * pow(c0y, 2) + 4 * c0x * c1x + 2 * pow(c1x, 2) +
			4 * c0y * c1y + 2 * pow(c1y, 2) + c0x * c2x + 2 * c1x * c2x + pow(c2x, 2) +
			c0y * c2y + 2 * c1y * c2y + pow(c2y, 2) -
			5 * (3 * c0x + 2 * c1x + c2x) * etax + 15 * pow(etax, 2) -
			5 * (3 * c0y + 2 * c1y + c2y) * etay + 15 * pow(etay, 2)
			) * (-2.0 + logterm)
		);

	double Iy1Item = (1.0 / 60.0) * (
		(pow(c0x, 2) + pow(c0y, 2) + 2 * c0x * c1x + 2 * pow(c1x, 2) + 2 * c0y * c1y + 2 * pow(c1y, 2) +
			c0x * c2x + 4 * c1x * c2x + 5 * pow(c2x, 2) + c0y * c2y + 4 * c1y * c2y + 5 * pow(c2y, 2) -
			5 * (c0x + 2 * c1x + 3 * c2x) * etax + 15 * pow(etax, 2) -
			5 * (c0y + 2 * c1y + 3 * c2y) * etay + 15 * pow(etay, 2)
			) * (-2 + logterm)
		);

	{
		c0x = c0[0] - eta[0]; c0y = c0[1] - eta[1]; c1x = c1[0] - eta[0]; c1y = c1[1] - eta[1]; c2x = c2[0] - eta[0]; c2y = c2[1] - eta[1];
		double dc0x, dc0y, dc1x, dc1y;
		dc0x = c1x - c0x; dc0y = c1y - c0y;
		dc1x = c2x + c0x - 2 * c1x; dc1y = c2y + c0y - 2 * c1y;
		myArray<3> ct_x, ct_y;
		myArray<2> dct_x, dct_y;
		Bezier2Poly2({ c0x,c1x,c2x }, ct_x); Bezier2Poly2({ c0y,c1y,c2y }, ct_y);
		dct_x = { dc0x,dc1x }; dct_y = { dc0y,dc1y };

		auto ctxy = multiplyPolynomials(ct_x, dct_y);
		auto cty_x = multiplyPolynomials(ct_y, -dct_x);
		auto ctdtb = addPolynomials(ctxy, cty_x, 3);
		auto ctxx = multiplyPolynomials(ct_x, dct_x);
		auto ctyy = multiplyPolynomials(ct_y, dct_y);
		auto ctdt = addPolynomials(ctxx, ctyy, 3);
		auto ctxctx = multiplyPolynomials(ct_x, ct_x);
		auto ctycty = multiplyPolynomials(ct_y, ct_y);
		auto ctct = addPolynomials(ctxctx, ctycty, 4);

		myArray<3> c0_1_xishu{ 0,0,2 };
		auto Ic0_1result = multiplyPolynomials(c0_1_xishu, ctdtb);
		Ic0_1t0 = Ic0_1result[0];
		Ic0_1t1 = Ic0_1result[1];
		Ic0_1t2 = Ic0_1result[2];
		Ic0_1t3 = Ic0_1result[3];
		Ic0_1t4 = Ic0_1result[4];
		Ic0_1t5 = Ic0_1result[5];

		
		auto Ix0_1half1 = integratePolynomial(Ic0_1result, 5);
		auto Ix0_1result = multiplyPolynomials(Ix0_1half1, ctdt);
		Ix0_1t0 = Ix0_1result[0];
		Ix0_1t1 = Ix0_1result[1];
		Ix0_1t2 = Ix0_1result[2];
		Ix0_1t3 = Ix0_1result[3];
		Ix0_1t4 = Ix0_1result[4];
		Ix0_1t5 = Ix0_1result[5];
		Ix0_1t6 = Ix0_1result[6];
		Ix0_1t7 = Ix0_1result[7];
		Ix0_1t8 = Ix0_1result[8];


		myArray<3> c0_xishu{ 2,-4,2 };
		myArray<3> c1_xishu{ 0,4,-4 };
		myArray<3> t0_xishu{ 0,4,-2 };
		myArray<3> t1_xishu{ 0,0,2 };
		auto Ic0result = multiplyPolynomials(c0_xishu, ctdtb);
		auto Ic1result = multiplyPolynomials(c1_xishu, ctdtb);
		auto It0result = multiplyPolynomials(t0_xishu, ctdt);
		auto It1result = multiplyPolynomials(t1_xishu, ctdt);
		Ic0t0 = Ic0result[0];
		Ic0t1 = Ic0result[1];
		Ic0t2 = Ic0result[2];
		Ic0t3 = Ic0result[3];
		Ic0t4 = Ic0result[4];
		Ic0t5 = Ic0result[5];

		It0t0 = It0result[0];
		It0t1 = It0result[1];
		It0t2 = It0result[2];
		It0t3 = It0result[3];
		It0t4 = It0result[4];
		It0t5 = It0result[5];

		It1t0 = It1result[0];
		It1t1 = It1result[1];
		It1t2 = It1result[2];
		It1t3 = It1result[3];
		It1t4 = It1result[4];
		It1t5 = It1result[5];

		Ic1t0 = Ic1result[0];
		Ic1t1 = Ic1result[1];
		Ic1t2 = Ic1result[2];
		Ic1t3 = Ic1result[3];
		Ic1t4 = Ic1result[4];
		Ic1t5 = Ic1result[5];


		auto Ix0half1 = integratePolynomial(Ic0result, 5);
		auto Ix1half1 = integratePolynomial(Ic1result, 5);
		auto Ix0result = multiplyPolynomials(Ix0half1, ctdt);
		auto Ix1result = multiplyPolynomials(Ix1half1, ctdt);
		Ix0t0 = Ix0result[0];
		Ix0t1 = Ix0result[1];
		Ix0t2 = Ix0result[2];
		Ix0t3 = Ix0result[3];
		Ix0t4 = Ix0result[4];
		Ix0t5 = Ix0result[5];
		Ix0t6 = Ix0result[6];
		Ix0t7 = Ix0result[7];
		Ix0t8 = Ix0result[8];

		Ix1t0 = Ix1result[0];
		Ix1t1 = Ix1result[1];
		Ix1t2 = Ix1result[2];
		Ix1t3 = Ix1result[3];
		Ix1t4 = Ix1result[4];
		Ix1t5 = Ix1result[5];
		Ix1t6 = Ix1result[6];
		Ix1t7 = Ix1result[7];
		Ix1t8 = Ix1result[8];

		auto Iy0intterm = multiplyPolynomials(array<double, 2>{1, -1}, ctct);
		auto Iy0half1 = integratePolynomial(Iy0intterm, 5);
		auto Iy0result = multiplyPolynomials(Iy0half1, ctdt);
		Iy0t0 = Iy0result[0] / (-2);
		Iy0t1 = Iy0result[1] / (-2);
		Iy0t2 = Iy0result[2] / (-2);
		Iy0t3 = Iy0result[3] / (-2);
		Iy0t4 = Iy0result[4] / (-2);
		Iy0t5 = Iy0result[5] / (-2);
		Iy0t6 = Iy0result[6] / (-2);
		Iy0t7 = Iy0result[7] / (-2);
		Iy0t8 = Iy0result[8] / (-2);
		Iy0t9 = Iy0result[9] / (-2);

		auto Iy1intterm = multiplyPolynomials(array<double, 2>{0, 1}, ctct);
		auto Iy1half1 = integratePolynomial(Iy1intterm, 5);
		auto Iy1result = multiplyPolynomials(Iy1half1, ctdt);
		Iy1t0 = Iy1result[0] / (-2);
		Iy1t1 = Iy1result[1] / (-2);
		Iy1t2 = Iy1result[2] / (-2);
		Iy1t3 = Iy1result[3] / (-2);
		Iy1t4 = Iy1result[4] / (-2);
		Iy1t5 = Iy1result[5] / (-2);
		Iy1t6 = Iy1result[6] / (-2);
		Iy1t7 = Iy1result[7] / (-2);
		Iy1t8 = Iy1result[8] / (-2);
		Iy1t9 = Iy1result[9] / (-2);


		/*std::cout << Ix1t0 << std::endl;
		std::cout << Ix1t1 << std::endl;
		std::cout << Ix1t2 << std::endl;
		std::cout << Ix1t3 << std::endl;
		std::cout << Ix1t4 << std::endl;
		std::cout << Ix1t5 << std::endl;
		std::cout << Ix1t6 << std::endl;
		std::cout << Ix1t7 << std::endl;
		std::cout << Ix1t8 << std::endl;
		exit(0);*/
	}

	{
		auto ALL_f9 = ALL_F2_n(eta, m0, m1, m2, 9);
		F0 = ALL_f9[0];
		F1 = ALL_f9[1];
		F2 = ALL_f9[2];
		F3 = ALL_f9[3];
		F4 = ALL_f9[4];
		F5 = ALL_f9[5];
		F6 = ALL_f9[6];
		F7 = ALL_f9[7];
		F8 = ALL_f9[8];
		F9 = ALL_f9[9];

	}
	Ic0_1 = (Ic0_1t0 * F0 + Ic0_1t1 * F1 + Ic0_1t2 * F2 + Ic0_1t3 * F3 + Ic0_1t4 * F4 + Ic0_1t5 * F5);
	//计算Ix0_1
	Ix0_1 = -(Ix0_1t0 * F0 + Ix0_1t1 * F1 + Ix0_1t2 * F2 + Ix0_1t3 * F3 + Ix0_1t4 * F4 + Ix0_1t5 * F5
		+ Ix0_1t6 * F6 + Ix0_1t7 * F7 + Ix0_1t8 * F8) + Ix0_1Item / (8 * M_PI);

	Ic0 = (Ic0t0 * F0 + Ic0t1 * F1 + Ic0t2 * F2 + Ic0t3 * F3 + Ic0t4 * F4 + Ic0t5 * F5);
	Ic1 = (Ic1t0 * F0 + Ic1t1 * F1 + Ic1t2 * F2 + Ic1t3 * F3 + Ic1t4 * F4 + Ic1t5 * F5);
	It0 = (It0t0 * F0 + It0t1 * F1 + It0t2 * F2 + It0t3 * F3 + It0t4 * F4 + It0t5 * F5) + It0Item / (-2 * M_PI);
	It1 = (It1t0 * F0 + It1t1 * F1 + It1t2 * F2 + It1t3 * F3 + It1t4 * F4 + It1t5 * F5) + It1Item / (-2 * M_PI);
	Ix0 = -(Ix0t0 * F0 + Ix0t1 * F1 + Ix0t2 * F2 + Ix0t3 * F3 + Ix0t4 * F4 + Ix0t5 * F5 + Ix0t6 * F6 + Ix0t7 * F7 + Ix0t8 * F8) + Ix0Item / (8 * M_PI);
	Ix1 = -(Ix1t0 * F0 + Ix1t1 * F1 + Ix1t2 * F2 + Ix1t3 * F3 + Ix1t4 * F4 + Ix1t5 * F5 + Ix1t6 * F6 + Ix1t7 * F7 + Ix1t8 * F8) + Ix1Item / (8 * M_PI);
	Iy0 = -(Iy0t0 * F0 + Iy0t1 * F1 + Iy0t2 * F2 + Iy0t3 * F3 + Iy0t4 * F4 + Iy0t5 * F5 + Iy0t6 * F6 + Iy0t7 * F7 + Iy0t8 * F8 + Iy0t9 * F9) + Iy0Item / (-8 * M_PI);
	Iy1 = -(Iy1t0 * F0 + Iy1t1 * F1 + Iy1t2 * F2 + Iy1t3 * F3 + Iy1t4 * F4 + Iy1t5 * F5 + Iy1t6 * F6 + Iy1t7 * F7 + Iy1t8 * F8 + Iy1t9 * F9) + Iy1Item / (-8 * M_PI);

	Ie1 = It1 / 2;
	values[0] = Ic0 ;
	values[1] = Ic1;
	values[2] = It0;//
	values[3] = It1;//
	values[4] = Ix0 ;
	values[5] = Ix1;
	values[6] = Iy0;
	values[7] = Iy1;
	values[8] = Ic0 ;
	values[9] = Ic1;
	values[10] = It0 / 2;//要除以2吗
	values[11] = Ie1;
	values[12] = Ic0_1;
	values[13] = Ix0_1;
	//std::cout << Ic0_1 << "," << Ix0_1 << std::endl;
	values[14] = Ic0_1;
}

void MeshViewerWidget::Cal222BiharmonicBasis_edge_test(OpenMesh::Vec2d& v1, OpenMesh::Vec2d& v12, OpenMesh::Vec2d& v2,
	OpenMesh::Vec2d& eta, std::vector<double>& values) {
	values.resize(15);
	// 初始化：混合random_device和时间戳
	static std::mt19937 gen([] {
		std::random_device rd;
		return rd() ^ static_cast<unsigned>(std::chrono::system_clock::now().time_since_epoch().count());
		}());

	std::uniform_real_distribution<double> dis(0.0, 10.0);

	for (auto& val : values) {
		val = dis(gen);
	}
}


void MeshViewerWidget::Cal323BiharmonicBasis(OpenMesh::Vec2d& v0, OpenMesh::Vec2d& v01, OpenMesh::Vec2d& v10,OpenMesh::Vec2d& v1, OpenMesh::Vec2d& v12, OpenMesh::Vec2d& v21, OpenMesh::Vec2d& v2,
	OpenMesh::Vec2d& eta, std::vector<double>& values) {
	values.resize(18);
	//values.resize(16);
	//v0 = OpenMesh::Vec2d(0, 0); v01 = OpenMesh::Vec2d(1, -1); v1 = OpenMesh::Vec2d(2, 0); v12 = OpenMesh::Vec2d(3, 1); v2 = OpenMesh::Vec2d(2, 2);eta = OpenMesh::Vec2d(1, 1);
	OpenMesh::Vec2d ei, ui, xiyi;
	double ci, L1i, L2i, Ai, xi, yi, Ic0, Ic0_1, Ic1, Ic2,  It0, It1, It2, 
		Ix0_1, Ix0, Ix1, Ix2, Iy0, Iy1, Iy2, Ie1, Ie2, hatphiBH_1, hatphiH, hatphiBH;
	//将bezier的控制点转化为幂基下的控制点
	OpenMesh::Vec2d c0, c1, c2, c3, m0, m1, m2, m3;
	double c0x, c0y, c1x, c1y, c2x, c2y, c3x, c3y, etax, etay;
	double F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14;
	double Ic0t0, Ic0t1, Ic0t2, Ic0t3, Ic0t4, Ic0t5, Ic0t6, Ic0t7;
	double Ic0_1t0, Ic0_1t1, Ic0_1t2, Ic0_1t3, Ic0_1t4, Ic0_1t5, Ic0_1t6, Ic0_1t7;
	double Ic1t0, Ic1t1, Ic1t2, Ic1t3, Ic1t4, Ic1t5, Ic1t6, Ic1t7;
	double Ic2t0, Ic2t1, Ic2t2, Ic2t3, Ic2t4, Ic2t5, Ic2t6, Ic2t7;
	double It0t0, It0t1, It0t2, It0t3, It0t4, It0t5, It0t6, It0t7, It0t8;
	double It1t0, It1t1, It1t2, It1t3, It1t4, It1t5, It1t6, It1t7, It1t8;
	double It2t0, It2t1, It2t2, It2t3, It2t4, It2t5, It2t6, It2t7, It2t8;
	double Ix0t0, Ix0t1, Ix0t2, Ix0t3, Ix0t4, Ix0t5, Ix0t6, Ix0t7, Ix0t8, Ix0t9, Ix0t10, Ix0t11, Ix0t12, Ix0t13;
	double Ix0_1t0, Ix0_1t1, Ix0_1t2, Ix0_1t3, Ix0_1t4, Ix0_1t5, Ix0_1t6, Ix0_1t7, Ix0_1t8, Ix0_1t9, Ix0_1t10, Ix0_1t11, Ix0_1t12, Ix0_1t13;
	double Ix1t0, Ix1t1, Ix1t2, Ix1t3, Ix1t4, Ix1t5, Ix1t6, Ix1t7, Ix1t8, Ix1t9, Ix1t10, Ix1t11, Ix1t12, Ix1t13;
	double Ix2t0, Ix2t1, Ix2t2, Ix2t3, Ix2t4, Ix2t5, Ix2t6, Ix2t7, Ix2t8, Ix2t9, Ix2t10, Ix2t11, Ix2t12, Ix2t13;
	double Iy0t0, Iy0t1, Iy0t2, Iy0t3, Iy0t4, Iy0t5, Iy0t6, Iy0t7, Iy0t8, Iy0t9, Iy0t10, Iy0t11, Iy0t12, Iy0t13, Iy0t14;
	double Iy1t0, Iy1t1, Iy1t2, Iy1t3, Iy1t4, Iy1t5, Iy1t6, Iy1t7, Iy1t8, Iy1t9, Iy1t10, Iy1t11, Iy1t12, Iy1t13, Iy1t14;
	double Iy2t0, Iy2t1, Iy2t2, Iy2t3, Iy2t4, Iy2t5, Iy2t6, Iy2t7, Iy2t8, Iy2t9, Iy2t10, Iy2t11, Iy2t12, Iy2t13, Iy2t14;


	{//计算前一个phi的值
		m0 = v0;  m1 = 3 * (v01 - v0);  m2 = 3 * v0 - 6 * v01 + 3 * v10; m3 = -v0 + 3 * v01 - 3 * v10 + v1;
		c0 = m0;  c1 = m1;  c2 = m2; c3 = m3;
		c0x = c0[0]; c0y = c0[1]; c1x = c1[0]; c1y = c1[1]; c2x = c2[0]; c2y = c2[1]; c3x = c3[0]; c3y = c3[1]; etax = eta[0]; etay = eta[1];

		//Ix0_1余项
		double Ix0_1Item = ((2 * (-(c1y * c3x) + c1x * c3y)) / 7. + (-(c2y * c3x) + c2x * c3y) / 8. + (-(c0y * c1x) + c0x * c1y - c1y * etax + c1x * etay) / 4. +
			(2 * (-(c0y * c2x) + c0x * c2y - c2y * etax + c2x * etay)) / 5. +
			(-(c1y * c2x) + c1x * c2y - 3 * c0y * c3x + 3 * c0x * c3y - 3 * c3y * etax + 3 * c3x * etay) / 6.) *
			(-1 + log(pow(c0x + c1x + c2x + c3x - etax, 2) + pow(c0y + c1y + c2y + c3y - etay, 2)));
		//Ic0_1幂基系数以替换
		/*{
			std::vector<double> valuesIc0_1 = { 0,0,0,-(c0y * c1x) + c0x * c1y - c1y * etax + c1x * etay,2 * (-(c0y * c2x) + c0x * c2y - c2y * etax + c2x * etay),
   -(c1y * c2x) + c1x * c2y - 3 * c0y * c3x + 3 * c0x * c3y - 3 * c3y * etax + 3 * c3x * etay,-2 * c1y * c3x + 2 * c1x * c3y,-(c2y * c3x) + c2x * c3y };
			Ic0_1t0 = valuesIc0_1[0];
			Ic0_1t1 = valuesIc0_1[1];
			Ic0_1t2 = valuesIc0_1[2];
			Ic0_1t3 = valuesIc0_1[3];
			Ic0_1t4 = valuesIc0_1[4];
			Ic0_1t5 = valuesIc0_1[5];
			Ic0_1t6 = valuesIc0_1[6];
			Ic0_1t7 = valuesIc0_1[7];
		}*/
		//Ix0_1幂基系数替换
		/*{
			std::vector<double> valuesIx0_1 = { 0,0,0,0,((-(c0y * c1x) + c0x * c1y - c1y * etax + c1x * etay) * (c0x * c1x + c0y * c1y - c1x * etax - c1y * etay)) / 8.,
   (-2 * pow(c0y,2) * (4 * c1y * c2x + 5 * c1x * c2y) + (c0x - etax) *
	   (5 * pow(c1x,2) * c1y + 8 * c1x * c2y * (c0x - etax) + 5 * c1y * (pow(c1y,2) + 2 * c0x * c2x - 2 * c2x * etax)) +
	  (5 * pow(c1x,3) + 5 * c1x * pow(c1y,2) + 18 * c1x * c2x * (c0x - etax) + 18 * c1y * c2y * (-c0x + etax)) * etay -
	  2 * (4 * c1y * c2x + 5 * c1x * c2y) * pow(etay,2) + c0y *
	   (-5 * pow(c1x,3) + 2 * c1y * (9 * c0x * c2y - 9 * c2y * etax + 8 * c2x * etay) +
		 c1x * (-5 * pow(c1y,2) + 18 * c2x * (-c0x + etax) + 20 * c2y * etay))) / 40.,
   (-3 * pow(c0y,2) * (16 * c2x * c2y + 10 * c1y * c3x + 15 * c1x * c3y) +
	  (34 * pow(c1x,2) * c2y + 69 * pow(c1y,2) * c2y + 5 * c1x * (7 * c1y * c2x + 6 * c3y * (c0x - etax)) + 48 * c2x * c2y * (c0x - etax) +
		 45 * c1y * c3x * (c0x - etax)) * (c0x - etax) +
	  (69 * pow(c1x,2) * c2x + 34 * pow(c1y,2) * c2x + 35 * c1x * c1y * c2y + 48 * (c2x - c2y) * (c2x + c2y) * (c0x - etax) +
		 75 * c1x * c3x * (c0x - etax) + 75 * c1y * c3y * (-c0x + etax)) * etay -
	  3 * (16 * c2x * c2y + 10 * c1y * c3x + 15 * c1x * c3y) * pow(etay,2) +
	  c0y * (-69 * pow(c1x,2) * c2x - 34 * pow(c1y,2) * c2x - 48 * (c2x - c2y) * (c2x + c2y) * (c0x - etax) + 96 * c2x * c2y * etay +
		 15 * c1y * (5 * c0x * c3y - 5 * c3y * etax + 4 * c3x * etay) + c1x * (-35 * c1y * c2y + 75 * c3x * (-c0x + etax) + 90 * c3y * etay))) / 120.,
   (-35 * pow(c1y,3) * c2x + 35 * pow(c1x,3) * c2y -
	  5 * pow(c1x,2) * (7 * c1y * c2x + 33 * c3y * (-c0x + etax) + 63 * c3x * (c0y - etay)) +
	  7 * c1y * (5 * c0x * pow(c2x,2) - 46 * c0y * c2x * c2y + 51 * c0x * pow(c2y,2) - 5 * pow(c2x,2) * etax - 51 * pow(c2y,2) * etax +
		 46 * c2x * c2y * etay) + c1x * (35 * pow(c1y,2) * c2y - c0y * (357 * pow(c2x,2) + 35 * pow(c2y,2) + 150 * c1y * c3y) +
		 2 * (161 * c2x * c2y + 75 * c1y * c3x) * (c0x - etax) + (357 * pow(c2x,2) + 35 * pow(c2y,2) + 150 * c1y * c3y) * etay) +
	  15 * pow(c1y,2) * (21 * c3y * (c0x - etax) + 11 * c3x * (-c0y + etay)) +
	  42 * (pow(c0x,2) * (6 * c2y * c3x + 5 * c2x * c3y) - pow(c0y,2) * (5 * c2y * c3x + 6 * c2x * c3y) +
		 (6 * c2y * c3x + 5 * c2x * c3y) * pow(etax,2) + 11 * (-(c2x * c3x) + c2y * c3y) * etax * etay -
		 (5 * c2y * c3x + 6 * c2x * c3y) * pow(etay,2) +
		 c0y * (11 * c2x * c3x * etax - 11 * c2y * c3y * etax + 10 * c2y * c3x * etay + 12 * c2x * c3y * etay) -
		 c0x * (11 * c0y * (c2x * c3x - c2y * c3y) + 12 * c2y * c3x * etax + 10 * c2x * c3y * etax - 11 * c2x * c3x * etay + 11 * c2y * c3y * etay))) / 420.,
   (20 * pow(c1x,2) * (7 * c2x * c2y - 4 * c1y * c3x) + 80 * pow(c1x,3) * c3y - 420 * pow(c0y,2) * c3x * c3y +
	  2 * (-70 * pow(c1y,2) * c2x * c2y - 40 * pow(c1y,3) * c3x + c1y * (25 * c2x * c3x + 609 * c2y * c3y) * (c0x - etax) +
		 14 * (8 * c2y * (pow(c2x,2) + pow(c2y,2)) + 15 * c3x * c3y * (c0x - etax)) * (c0x - etax)) +
	  (224 * pow(c2x,3) + 615 * c1y * c2y * c3x + 7 * c2x * (32 * pow(c2y,2) + 79 * c1y * c3y) +
		 420 * (c3x - c3y) * (c3x + c3y) * (c0x - etax)) * etay - 420 * c3x * c3y * pow(etay,2) -
	  c0y * (224 * pow(c2x,3) + 615 * c1y * c2y * c3x + 7 * c2x * (32 * pow(c2y,2) + 79 * c1y * c3y) +
		 420 * (c3x - c3y) * (c3x + c3y) * (c0x - etax) - 840 * c3x * c3y * etay) +
	  c1x * (140 * c1y * (-pow(c2x,2) + pow(c2y,2)) + 80 * pow(c1y,2) * c3y - 2 * c0y * (609 * c2x * c3x + 25 * c2y * c3y) +
		 (553 * c2y * c3x + 615 * c2x * c3y) * (c0x - etax) + 2 * (609 * c2x * c3x + 25 * c2y * c3y) * etay)) / 560.,
   (56 * c1x * c2y * (pow(c2x,2) + pow(c2y,2)) - pow(c1y,2) * (165 * c2y * c3x + 91 * c2x * c3y) +
	  pow(c1x,2) * (91 * c2y * c3x + 165 * c2x * c3y) + 42 *
	   (-(c0y * (12 * pow(c2x,2) * c3x + 5 * pow(c2y,2) * c3x + 7 * c2x * c2y * c3y)) +
		 (7 * c2x * c2y * c3x + 5 * pow(c2x,2) * c3y + 12 * pow(c2y,2) * c3y) * (c0x - etax) +
		 (12 * pow(c2x,2) * c3x + 5 * pow(c2y,2) * c3x + 7 * c2x * c2y * c3y) * etay) +
	  6 * c1x * (c0y * (-77 * pow(c3x,2) + 3 * pow(c3y,2)) + 80 * c3x * c3y * (c0x - etax) +
		 (77 * pow(c3x,2) - 3 * pow(c3y,2)) * etay) -
	  2 * c1y * (28 * pow(c2x,3) + 4 * c2x * (7 * pow(c2y,2) + 32 * c1x * c3x) - 128 * c1x * c2y * c3y +
		 3 * (3 * c0x * pow(c3x,2) + 80 * c0y * c3x * c3y - 77 * c0x * pow(c3y,2) - 3 * pow(c3x,2) * etax + 77 * pow(c3y,2) * etax -
			80 * c3x * c3y * etay))) / 336.,(960 * pow(c1x,2) * c3x * c3y - 960 * pow(c1y,2) * c3x * c3y +
	  5 * c1x * (77 * c2x * c2y * c3x + 159 * pow(c2x,2) * c3y + 236 * pow(c2y,2) * c3y) -
	  5 * c1y * (236 * pow(c2x,2) * c3x + 159 * pow(c2y,2) * c3x + 77 * c2x * c2y * c3y + 192 * c1x * (c3x - c3y) * (c3x + c3y)) +
	  21 * (-(c0y * (148 * c2x * pow(c3x,2) + 115 * c2y * c3x * c3y + 33 * c2x * pow(c3y,2))) +
		 (33 * c2y * pow(c3x,2) + 115 * c2x * c3x * c3y + 148 * c2y * pow(c3y,2)) * (c0x - etax) +
		 (148 * c2x * pow(c3x,2) + 115 * c2y * c3x * c3y + 33 * c2x * pow(c3y,2)) * etay)) / 1680.,
   (-7 * pow(c2x,2) * c2y * c3x - 7 * pow(c2y,3) * c3x + 7 * pow(c2x,3) * c3y + 7 * c2x * pow(c2y,2) * c3y +
	  54 * c2x * c3x * (-(c1y * c3x) + c1x * c3y) + 54 * c2y * c3y * (-(c1y * c3x) + c1x * c3y) +
	  42 * (pow(c3x,2) + pow(c3y,2)) * (-(c0y * c3x) + c0x * c3y - c3y * etax + c3x * etay)) / 56.,
   (3 * pow(c3x,2) * (-(c1y * c3x) + c1x * c3y)) / 7. + (3 * pow(c3y,2) * (-(c1y * c3x) + c1x * c3y)) / 7. +
	(5 * c2x * c3x * (-(c2y * c3x) + c2x * c3y)) / 16. + (5 * c2y * c3y * (-(c2y * c3x) + c2x * c3y)) / 16.,
   (-3 * (c2y * c3x - c2x * c3y) * (pow(c3x,2) + pow(c3y,2))) / 16. };
			Ix0_1t0 = valuesIx0_1[0];
			Ix0_1t1 = valuesIx0_1[1];
			Ix0_1t2 = valuesIx0_1[2];
			Ix0_1t3 = valuesIx0_1[3];
			Ix0_1t4 = valuesIx0_1[4];
			Ix0_1t5 = valuesIx0_1[5];
			Ix0_1t6 = valuesIx0_1[6];
			Ix0_1t7 = valuesIx0_1[7];
			Ix0_1t8 = valuesIx0_1[8];
			Ix0_1t9 = valuesIx0_1[9];
			Ix0_1t10 = valuesIx0_1[10];
			Ix0_1t11 = valuesIx0_1[11];
			Ix0_1t12 = valuesIx0_1[12];
			Ix0_1t13 = valuesIx0_1[13];
		}*/
		//这里与2次不同，用的是幂基
		{
			c0x = c0[0] - eta[0]; c0y = c0[1] - eta[1]; c1x = c1[0] ; c1y = c1[1]; c2x = c2[0] ; c2y = c2[1]; c3x = c3[0] ; c3y = c3[1] ;
			myArray<4> ct_x, ct_y;
			myArray<3> dct_x, dct_y;
			ct_x = { c0x,c1x,c2x,c3x }; ct_y = { c0y,c1y,c2y,c3y };
			dct_x = { c1x,2*c2x,3*c3x }; dct_y = { c1y,2 * c2y,3 * c3y };

			auto ctxy = multiplyPolynomials(ct_x, dct_y);
			auto cty_x = multiplyPolynomials(ct_y, -dct_x);
			auto ctdtb = addPolynomials(ctxy, cty_x, 5);
			auto ctxx = multiplyPolynomials(ct_x, dct_x);
			auto ctyy = multiplyPolynomials(ct_y, dct_y);
			auto ctdt = addPolynomials(ctxx, ctyy, 3);
			/*auto ctxctx = multiplyPolynomials(ct_x, ct_x);
			auto ctycty = multiplyPolynomials(ct_y, ct_y);
			auto ctct = addPolynomials(ctxctx, ctycty, 4);*/


			myArray<4> c0_1_xishu{ 0,0,0,1 };
			auto Ic0_1result = multiplyPolynomials(c0_1_xishu, ctdtb);
			Ic0_1t0 = Ic0_1result[0];
			Ic0_1t1 = Ic0_1result[1];
			Ic0_1t2 = Ic0_1result[2];
			Ic0_1t3 = Ic0_1result[3];
			Ic0_1t4 = Ic0_1result[4];
			Ic0_1t5 = Ic0_1result[5];
			Ic0_1t6 = Ic0_1result[6];
			Ic0_1t7 = Ic0_1result[7];


			auto Ix0_1half1 = integratePolynomial(Ic0_1result, 8);
			auto Ix0_1result = multiplyPolynomials(Ix0_1half1, ctdt);//ok
			Ix0_1t0 = Ix0_1result[0]/2;
			Ix0_1t1 = Ix0_1result[1]/2;
			Ix0_1t2 = Ix0_1result[2]/2;
			Ix0_1t3 = Ix0_1result[3]/2;
			Ix0_1t4 = Ix0_1result[4]/2;
			Ix0_1t5 = Ix0_1result[5]/2;
			Ix0_1t6 = Ix0_1result[6]/2;
			Ix0_1t7 = Ix0_1result[7]/2;
			Ix0_1t8 = Ix0_1result[8]/2;
			Ix0_1t9 = Ix0_1result[9]/2;
			Ix0_1t10 = Ix0_1result[10]/2;
			Ix0_1t11 = Ix0_1result[11]/2;
			Ix0_1t12 = Ix0_1result[12]/2;
			Ix0_1t13 = Ix0_1result[13]/2;
			

			


			
		}
		
		{
			auto ALL_f13 = ALL_F3_n(eta, m0, m1, m2, m3, 13);
			F0 = ALL_f13[0];//使用幂基控制点,注意已经除以2Pi了
			F1 = ALL_f13[1];
			F2 = ALL_f13[2];
			F3 = ALL_f13[3];
			F4 = ALL_f13[4];
			F5 = ALL_f13[5];
			F6 = ALL_f13[6];
			F7 = ALL_f13[7];
			F8 = ALL_f13[8];
			F9 = ALL_f13[9];
			F10 = ALL_f13[10];
			F11 = ALL_f13[11];
			F12 = ALL_f13[12];
			F13 = ALL_f13[13];
			
			}
		
		/*std::cout << eta << m0 << m1 << m2 << std::endl;
		std::cout << "new" << F0 << " " << F1 << " " << F2 << " " << F3 << " " << F4 << " " << F5 << " " << std::endl;*/
		
		Ic0_1 = (Ic0_1t0 * F0 + Ic0_1t1 * F1 + Ic0_1t2 * F2 + Ic0_1t3 * F3 + Ic0_1t4 * F4 + Ic0_1t5 * F5 + Ic0_1t6 * F6 + Ic0_1t7 * F7 );
		
		//计算Ix0_1

		Ix0_1 = -(Ix0_1t0 * F0 + Ix0_1t1 * F1 + Ix0_1t2 * F2 + Ix0_1t3 * F3 + Ix0_1t4 * F4 + Ix0_1t5 * F5
			+ Ix0_1t6 * F6 + Ix0_1t7 * F7 + Ix0_1t8 * F8 + Ix0_1t9 * F9 + Ix0_1t10 * F10 + Ix0_1t11 * F11 + Ix0_1t12 * F12 + Ix0_1t13 * F13) + Ix0_1Item / (8 * M_PI);
	}

	//右边半段
	m0 = v1;  m1 = 3 * (v12 - v1);  m2 = 3 * v1 - 6 * v12 + 3 * v21; m3 = -v1 + 3 * v12 - 3 * v21 + v2;
	c0 = m0;  c1 = m1;  c2 = m2; c3 = m3;
	c0x = c0[0]; c0y = c0[1]; c1x = c1[0]; c1y = c1[1]; c2x = c2[0]; c2y = c2[1]; c3x = c3[0]; c3y = c3[1]; etax = eta[0]; etay = eta[1];

	double logterm = log(pow(c0x + c1x + c2x + c3x - etax, 2) + pow(c0y + c1y + c2y + c3y - etay, 2));
	double It0Item = 0.5 * logterm;
	double It1Item = 0.5 * logterm;
	double It2Item = 0.5 * logterm;
	double Ix0Item = ((14 * c1x * c2y - 3 * c2y * c3x - 42 * c0y * (5 * c1x + 2 * c2x + c3x) + 12 * c1x * c3y + 3 * c2x * c3y + 42 * c0x * (5 * c1y + 2 * c2y + c3y) -
		84 * c2y * etax - 42 * c3y * etax - 2 * c1y * (7 * c2x + 6 * c3x + 105 * etax) + 42 * (5 * c1x + 2 * c2x + c3x) * etay) *
		(-1 + logterm)) / 840.;
	double Ix1Item = ((14 * c1x * c2y - 5 * c2y * c3x - 14 * c0y * (5 * c1x + 4 * c2x + 3 * c3x) + 16 * c1x * c3y + 5 * c2x * c3y + 14 * c0x * (5 * c1y + 4 * c2y + 3 * c3y) -
		56 * c2y * etax - 42 * c3y * etax - 2 * c1y * (7 * c2x + 8 * c3x + 35 * etax) + 14 * (5 * c1x + 4 * c2x + 3 * c3x) * etay) *
		(-1 + logterm)) / 280.;
	double Ix2Item = -((70 * c0y * c1x - 70 * c0x * c1y + 28 * c1y * c2x + 40 * c1y * c3x + 15 * c2y * c3x + 84 * c0y * (c2x + c3x) - 15 * c2x * c3y -
		84 * c0x * (c2y + c3y) + 70 * c1y * etax + 84 * c2y * etax + 84 * c3y * etax - 84 * (c2x + c3x) * etay -
		2 * c1x * (14 * c2y + 20 * c3y + 35 * etay)) * (-1 +logterm)) / 280.;
	double Iy0Item = ((420 * pow(c0x, 2) + 420 * pow(c0y, 2) + 42 * pow(c1x, 2) + 42 * pow(c1y, 2) + 42 * c1x * c2x + 12 * pow(c2x, 2) + 42 * c1y * c2y +
		12 * pow(c2y, 2) + 24 * c1x * c3x + 15 * c2x * c3x + 5 * pow(c3x, 2) + 24 * c1y * c3y + 15 * c2y * c3y + 5 * pow(c3y, 2) +
		42 * c0x * (5 * c1x + 2 * c2x + c3x - 20 * etax) - 42 * (5 * c1x + 2 * c2x + c3x) * etax + 420 * pow(etax, 2) +
		42 * c0y * (5 * c1y + 2 * c2y + c3y - 20 * etay) - 42 * (5 * c1y + 2 * c2y + c3y) * etay + 420 * pow(etay, 2)) *
		(-2 + logterm)) / 2520.;
	double Iy1Item = ((420 * pow(c0x, 2) + 420 * pow(c0y, 2) + 126 * pow(c1x, 2) + 126 * pow(c1y, 2) + 168 * c1x * c2x + 60 * pow(c2x, 2) +
		168 * c1y * c2y + 60 * pow(c2y, 2) + 120 * c1x * c3x + 90 * c2x * c3x + 35 * pow(c3x, 2) + 120 * c1y * c3y + 90 * c2y * c3y +
		35 * pow(c3y, 2) + 84 * c0x * (5 * c1x + 3 * c2x + 2 * c3x - 10 * etax) - 84 * (5 * c1x + 3 * c2x + 2 * c3x) * etax + 420 * pow(etax, 2) +
		84 * c0y * (5 * c1y + 3 * c2y + 2 * c3y - 10 * etay) - 84 * (5 * c1y + 3 * c2y + 2 * c3y) * etay + 420 * pow(etay, 2)) *
		(-2 + logterm)) / 2520.;
	double Iy2Item = (((pow(c2x, 2) + pow(c2y, 2) + 2 * c1x * c3x + 2 * c1y * c3y) / 7. + (c2x * c3x + c2y * c3y) / 4. + (pow(c3x, 2) + pow(c3y, 2)) / 9. +
		(pow(c0x - etax, 2) + pow(c0y - etay, 2)) / 3. + (c0x * c1x + c0y * c1y - c1x * etax - c1y * etay) / 2. +
		(pow(c1x, 2) + pow(c1y, 2) + 2 * c0x * c2x + 2 * c0y * c2y - 2 * c2x * etax - 2 * c2y * etay) / 5. +
		(c1x * c2x + c1y * c2y + c0x * c3x + c0y * c3y - c3x * etax - c3y * etay) / 3.) *
		(-2 + logterm)) / 2.;



	//Ic0系数th
	/*{
		std::vector<double> valuesIc0 = { -(c0y * c1x) + c0x * c1y - c1y * etax + c1x * etay,3 * c0y * c1x - 3 * c0x * c1y - 2 * c0y * c2x + 2 * c0x * c2y + 3 * c1y * etax - 2 * c2y * etax -
	3 * c1x * etay + 2 * c2x * etay,-3 * c0y * c1x + 3 * c0x * c1y + 6 * c0y * c2x - c1y * c2x - 6 * c0x * c2y + c1x * c2y - 3 * c0y * c3x + 3 * c0x * c3y -
	3 * c1y * etax + 6 * c2y * etax - 3 * c3y * etax + 3 * c1x * etay - 6 * c2x * etay + 3 * c3x * etay,
   c0y * c1x - c0x * c1y - 6 * c0y * c2x + 3 * c1y * c2x + 6 * c0x * c2y - 3 * c1x * c2y + 9 * c0y * c3x - 2 * c1y * c3x - 9 * c0x * c3y + 2 * c1x * c3y +
	c1y * etax - 6 * c2y * etax + 9 * c3y * etax - c1x * etay + 6 * c2x * etay - 9 * c3x * etay,
   2 * c0y * c2x - 3 * c1y * c2x - 2 * c0x * c2y + 3 * c1x * c2y - 9 * c0y * c3x + 6 * c1y * c3x - c2y * c3x + 9 * c0x * c3y - 6 * c1x * c3y + c2x * c3y +
	2 * c2y * etax - 9 * c3y * etax - 2 * c2x * etay + 9 * c3x * etay,
   c1y * c2x - c1x * c2y + 3 * c0y * c3x - 6 * c1y * c3x + 3 * c2y * c3x - 3 * c0x * c3y + 6 * c1x * c3y - 3 * c2x * c3y + 3 * c3y * etax - 3 * c3x * etay,
   2 * c1y * c3x - 3 * c2y * c3x - 2 * c1x * c3y + 3 * c2x * c3y,c2y * c3x - c2x * c3y };
		Ic0t0 = valuesIc0[0];
		Ic0t1 = valuesIc0[1];
		Ic0t2 = valuesIc0[2];
		Ic0t3 = valuesIc0[3];
		Ic0t4 = valuesIc0[4];
		Ic0t5 = valuesIc0[5];
		Ic0t6 = valuesIc0[6];
		Ic0t7 = valuesIc0[7];
	}*/
	//Ic1系数th
	/*{
		std::vector<double> valuesIc1 = { 0,3 * (-(c0y * c1x) + c0x * c1y - c1y * etax + c1x * etay),-6 * (c1y - c2y) * (c0x - etax) + 6 * (c1x - c2x) * (c0y - etay),
   3 * (c1x * c2y - c0y * (c1x - 4 * c2x + 3 * c3x) + c0x * (c1y - 4 * c2y + 3 * c3y) + 4 * c2y * etax - 3 * c3y * etax - c1y * (c2x + etax) +
	  (c1x - 4 * c2x + 3 * c3x) * etay),6 * (-(c0y * c2x) + c1y * c2x + c0x * c2y - c1x * c2y + 3 * c0y * c3x - c1y * c3x - 3 * c0x * c3y +
	  c1x * c3y - c2y * etax + 3 * c3y * etax + c2x * etay - 3 * c3x * etay),
   3 * (-(c1y * (c2x - 4 * c3x)) + c1x * (c2y - 4 * c3y) + c3y * (3 * c0x + c2x - 3 * etax) - c3x * (3 * c0y + c2y - 3 * etay)),
   6 * (-(c1y * c3x) + c2y * c3x + (c1x - c2x) * c3y),-3 * c2y * c3x + 3 * c2x * c3y };
		Ic1t0 = valuesIc1[0];
		Ic1t1 = valuesIc1[1];
		Ic1t2 = valuesIc1[2];
		Ic1t3 = valuesIc1[3];
		Ic1t4 = valuesIc1[4];
		Ic1t5 = valuesIc1[5];
		Ic1t6 = valuesIc1[6];
		Ic1t7 = valuesIc1[7];
	}*/
	//Ic2系数th
	/*{
		std::vector<double> valuesIc2 = { 0,0,3 * (-(c0y * c1x) + c0x * c1y - c1y * etax + c1x * etay),-3 * (c1y - 2 * c2y) * (c0x - etax) + 3 * (c1x - 2 * c2x) * (c0y - etay),
   6 * c0y * c2x - 3 * c1y * c2x - 6 * c0x * c2y + 3 * c1x * c2y - 9 * c0y * c3x + 9 * c0x * c3y + 6 * c2y * etax - 9 * c3y * etax - 6 * c2x * etay +
	9 * c3x * etay,-3 * c1x * c2y + 3 * c1y * (c2x - 2 * c3x) + 9 * c0y * c3x - 9 * c0x * c3y + 6 * c1x * c3y + 9 * c3y * etax - 9 * c3x * etay,
   6 * c1y * c3x - 3 * c2y * c3x + 3 * (-2 * c1x + c2x) * c3y,3 * c2y * c3x - 3 * c2x * c3y };
		Ic2t0 = valuesIc2[0];
		Ic2t1 = valuesIc2[1];
		Ic2t2 = valuesIc2[2];
		Ic2t3 = valuesIc2[3];
		Ic2t4 = valuesIc2[4];
		Ic2t5 = valuesIc2[5];
		Ic2t6 = valuesIc2[6];
		Ic2t7 = valuesIc2[7];
	}*/
	//It0系数
	if(0){
		std::vector<double> valuesIt0 = { 0,3 * (c0x * c1x + c0y * c1y - c1x * etax - c1y * etay),
   3 * (-(c0x * c1x) + pow(c1x,2) - c0y * c1y + pow(c1y,2) + 2 * c0x * c2x + 2 * c0y * c2y + c1x * etax - 2 * c2x * etax + c1y * etay -
	  2 * c2y * etay),-3 * c1x * (c1x - 3 * c2x) - 3 * c1y * (c1y - 3 * c2y) + c0x * (c1x - 6 * c2x + 9 * c3x) + c0y * (c1y - 6 * c2y + 9 * c3y) -
	(c1x - 6 * c2x + 9 * c3x) * etax - (c1y - 6 * c2y + 9 * c3y) * etay,
   pow(c1x,2) + pow(c1y,2) + 2 * c0x * c2x - 9 * c1x * c2x + 6 * pow(c2x,2) + 2 * c0y * c2y - 9 * c1y * c2y + 6 * pow(c2y,2) -
	9 * c0x * c3x + 12 * c1x * c3x - 9 * c0y * c3y + 12 * c1y * c3y - 2 * c2x * etax + 9 * c3x * etax - 2 * c2y * etay + 9 * c3y * etay,
   3 * (-2 * pow(c2x,2) + c1y * c2y - 2 * pow(c2y,2) + c1x * (c2x - 4 * c3x) + c0x * c3x + 5 * c2x * c3x + c0y * c3y - 4 * c1y * c3y +
	  5 * c2y * c3y - c3x * etax - c3y * etay),2 * pow(c2x,2) + 2 * pow(c2y,2) + 4 * c1x * c3x - 15 * c2x * c3x + 9 * pow(c3x,2) +
	4 * c1y * c3y - 15 * c2y * c3y + 9 * pow(c3y,2),5 * c2x * c3x - 9 * pow(c3x,2) + (5 * c2y - 9 * c3y) * c3y,
   3 * (pow(c3x,2) + pow(c3y,2)) };
		It0t0 = valuesIt0[0];
		It0t1 = valuesIt0[1];
		It0t2 = valuesIt0[2];
		It0t3 = valuesIt0[3];
		It0t4 = valuesIt0[4];
		It0t5 = valuesIt0[5];
		It0t6 = valuesIt0[6];
		It0t7 = valuesIt0[7];
		It0t8 = valuesIt0[8];
	}
	//It1系数
	if(0){
		std::vector<double> valuesIt1 = { 0,0,3 * (c0x * c1x + c0y * c1y - c1x * etax - c1y * etay),
   -2 * c0x * c1x + 3 * pow(c1x,2) - 2 * c0y * c1y + 3 * pow(c1y,2) + 6 * c0x * c2x + 6 * c0y * c2y + 2 * c1x * etax - 6 * c2x * etax +
	2 * c1y * etay - 6 * c2y * etay,-2 * pow(c1x,2) - 2 * pow(c1y,2) + 9 * c1x * c2x + 9 * c1y * c2y - (4 * c2x - 9 * c3x) * (c0x - etax) -
	(4 * c2y - 9 * c3y) * (c0y - etay),6 * (-(c1x * c2x) + pow(c2x,2) - c1y * c2y + pow(c2y,2) - c0x * c3x + 2 * c1x * c3x - c0y * c3y +
	  2 * c1y * c3y + c3x * etax + c3y * etay),-4 * pow(c2x,2) - 4 * pow(c2y,2) + 15 * c2x * c3x + 15 * c2y * c3y - 8 * (c1x * c3x + c1y * c3y),
   -10 * c2x * c3x + 9 * pow(c3x,2) + c3y * (-10 * c2y + 9 * c3y),-6 * (pow(c3x,2) + pow(c3y,2)) };
		It1t0 = valuesIt1[0];
		It1t1 = valuesIt1[1];
		It1t2 = valuesIt1[2];
		It1t3 = valuesIt1[3];
		It1t4 = valuesIt1[4];
		It1t5 = valuesIt1[5];
		It1t6 = valuesIt1[6];
		It1t7 = valuesIt1[7];
		It1t8 = valuesIt1[8];
	}
	//It2系数
	if(0){
		std::vector<double> valuesIt2 = { 0,0,0,c0x * c1x + c0y * c1y - c1x * etax - c1y * etay,
   pow(c1x,2) + pow(c1y,2) + 2 * c0x * c2x + 2 * c0y * c2y - 2 * c2x * etax - 2 * c2y * etay,
   3 * (c1x * c2x + c1y * c2y + c0x * c3x + c0y * c3y - c3x * etax - c3y * etay),
   2 * (pow(c2x,2) + pow(c2y,2) + 2 * c1x * c3x + 2 * c1y * c3y),5 * (c2x * c3x + c2y * c3y),3 * (pow(c3x,2) + pow(c3y,2)) };
		It2t0 = valuesIt2[0];
		It2t1 = valuesIt2[1];
		It2t2 = valuesIt2[2];
		It2t3 = valuesIt2[3];
		It2t4 = valuesIt2[4];
		It2t5 = valuesIt2[5];
		It2t6 = valuesIt2[6];
		It2t7 = valuesIt2[7];
		It2t8 = valuesIt2[8];
	}
	//Ix0系数
	if(0){
		std::vector<double> valuesIx0 = { 0,((-(c0y * c1x) + c0x * c1y - c1y * etax + c1x * etay) * (c0x * c1x + c0y * c1y - c1x * etax - c1y * etay)) / 2.,
   (pow(c0y,2) * (3 * c1x * c1y - 2 * c1y * c2x - 4 * c1x * c2y) + pow(c0x,2) * (-3 * c1x * c1y + 4 * c1y * c2x + 2 * c1x * c2y) +
	  etax * (-2 * c1y * (pow(c1x,2) + pow(c1y,2)) + (-3 * c1x * c1y + 4 * c1y * c2x + 2 * c1x * c2y) * etax) +
	  2 * c1x * (pow(c1x,2) + pow(c1y,2)) * etay + 3 * (pow(c1x,2) - 2 * c1x * c2x - c1y * (c1y - 2 * c2y)) * etax * etay +
	  (3 * c1x * c1y - 2 * c1y * c2x - 4 * c1x * c2y) * pow(etay,2) +
	  c0x * (3 * c0y * (pow(c1x,2) - pow(c1y,2) - 2 * c1x * c2x + 2 * c1y * c2y) +
		 2 * (pow(c1x,2) * c1y + pow(c1y,3) + 3 * c1x * c1y * etax - 4 * c1y * c2x * etax - 2 * c1x * c2y * etax) +
		 3 * (-pow(c1x,2) + pow(c1y,2) + 2 * c1x * c2x - 2 * c1y * c2y) * etay) +
	  c0y * (-2 * pow(c1x,3) - 3 * pow(c1x,2) * etax + c1y * (3 * c1y * etax - 6 * c2y * etax + 4 * c2x * etay) -
		 2 * c1x * (pow(c1y,2) - 3 * c2x * etax + 3 * c1y * etay - 4 * c2y * etay))) / 4.,
   (6 * pow(c0x,2) * (2 * c2x * c2y + 3 * c1y * (-c2x + c3x) + c1x * (c1y - 2 * c2y + c3y)) -
	  6 * pow(c0y,2) * (2 * c2x * c2y + c1y * (-2 * c2x + c3x) + c1x * (c1y - 3 * c2y + 3 * c3y)) +
	  etax * (9 * pow(c1x,2) * c1y + 9 * pow(c1y,3) - 16 * c1x * c1y * c2x - 8 * pow(c1x,2) * c2y - 24 * pow(c1y,2) * c2y +
		 6 * (2 * c2x * c2y + 3 * c1y * (-c2x + c3x) + c1x * (c1y - 2 * c2y + c3y)) * etax) +
	  (-9 * pow(c1x,3) - 9 * c1x * pow(c1y,2) + 24 * pow(c1x,2) * c2x + 8 * pow(c1y,2) * c2x + 16 * c1x * c1y * c2y -
		 6 * (pow(c1x,2) - pow(c1y,2) - 5 * c1x * c2x + 2 * pow(c2x,2) + 5 * c1y * c2y - 2 * pow(c2y,2) + 4 * c1x * c3x -
			4 * c1y * c3y) * etax) * etay - 6 * (2 * c2x * c2y + c1y * (-2 * c2x + c3x) + c1x * (c1y - 3 * c2y + 3 * c3y)) * pow(etay,2) +
	  c0x * (-9 * pow(c1y,3) + 24 * pow(c1y,2) * c2y -
		 6 * c0y * (pow(c1x,2) - pow(c1y,2) - 5 * c1x * c2x + 2 * pow(c2x,2) + 5 * c1y * c2y - 2 * pow(c2y,2) + 4 * c1x * c3x -
			4 * c1y * c3y) + 36 * c1y * c2x * etax - 24 * c2x * c2y * etax - 36 * c1y * c3x * etax -
		 6 * (pow(c1y,2) - 2 * pow(c2x,2) - 5 * c1y * c2y + 2 * pow(c2y,2) + 4 * c1y * c3y) * etay +
		 pow(c1x,2) * (-9 * c1y + 8 * c2y + 6 * etay) +
		 2 * c1x * (8 * c1y * c2x - 6 * c1y * etax + 12 * c2y * etax - 6 * c3y * etax - 15 * c2x * etay + 12 * c3x * etay)) +
	  c0y * (9 * pow(c1x,3) + 6 * pow(c1x,2) * (-4 * c2x + etax) +
		 c1x * (9 * pow(c1y,2) - 16 * c1y * c2y - 30 * c2x * etax + 24 * c3x * etax + 12 * (c1y - 3 * c2y + 3 * c3y) * etay) -
		 2 * (pow(c1y,2) * (4 * c2x + 3 * etax) - 6 * (pow(c2x,2) * etax - pow(c2y,2) * etax + 2 * c2x * c2y * etay) +
			3 * c1y * (-5 * c2y * etax + 4 * c3y * etax + 4 * c2x * etay - 2 * c3x * etay)))) / 12.,
   (-4 * pow(c1x,2) * c1y * c2x - 4 * pow(c1y,3) * c2x + 4 * pow(c1x,3) * c2y + 4 * c1x * pow(c1y,2) * c2y +
	  3 * pow(c0y,2) * (-6 * c1y * c2x + 16 * c2x * c2y + 9 * c1y * c3x - 8 * c2y * c3x - 12 * c2x * c3y + c1x * (c1y - 8 * c2y + 18 * c3y)) -
	  c0y * (12 * pow(c1x,3) + pow(c1x,2) * (-78 * c2x + 60 * c3x) + c1y * (-33 * c1y * c2x + 44 * c2x * c2y + 18 * c1y * c3x) +
		 c1x * (12 * pow(c1y,2) + 60 * pow(c2x,2) - 45 * c1y * c2y + 16 * pow(c2y,2) + 42 * c1y * c3y)) -
	  3 * pow(c0x,2) * (c1x * (c1y - 6 * c2y + 9 * c3y) - 2 * (4 * c1y * c2x - 8 * c2x * c2y - 9 * c1y * c3x + 6 * c2y * c3x + 4 * c2x * c3y)) -
	  12 * pow(c1x,2) * c1y * etax - 12 * pow(c1y,3) * etax + 45 * c1x * c1y * c2x * etax - 16 * c1y * pow(c2x,2) * etax +
	  33 * pow(c1x,2) * c2y * etax + 78 * pow(c1y,2) * c2y * etax - 44 * c1x * c2x * c2y * etax - 60 * c1y * pow(c2y,2) * etax -
	  42 * c1x * c1y * c3x * etax - 18 * pow(c1x,2) * c3y * etax - 60 * pow(c1y,2) * c3y * etax +
	  3 * c0y * (-pow(c1x,2) + pow(c1y,2) + c1x * (14 * c2x - 27 * c3x) + 4 * c2x * (-4 * c2x + 5 * c3x) + 4 * c2y * (4 * c2y - 5 * c3y) +
		 c1y * (-14 * c2y + 27 * c3y)) * etax - 3 * c1x * c1y * pow(etax,2) + 24 * c1y * c2x * pow(etax,2) + 18 * c1x * c2y * pow(etax,2) -
	  48 * c2x * c2y * pow(etax,2) - 54 * c1y * c3x * pow(etax,2) + 36 * c2y * c3x * pow(etax,2) - 27 * c1x * c3y * pow(etax,2) +
	  24 * c2x * c3y * pow(etax,2) - 6 * c0y * (-6 * c1y * c2x + 16 * c2x * c2y + 9 * c1y * c3x - 8 * c2y * c3x - 12 * c2x * c3y +
		 c1x * (c1y - 8 * c2y + 18 * c3y)) * etay + (12 * pow(c1x,3) +
		 12 * (4 * pow(c2x,2) - 4 * pow(c2y,2) - 5 * c2x * c3x + 5 * c2y * c3y) * etax - 3 * pow(c1y,2) * (11 * c2x - 6 * c3x + etax) +
		 3 * pow(c1x,2) * (-26 * c2x + 20 * c3x + etax) +
		 c1x * (12 * pow(c1y,2) + 60 * pow(c2x,2) - 45 * c1y * c2y + 16 * pow(c2y,2) + 42 * c1y * c3y - 42 * c2x * etax +
			81 * c3x * etax) + c1y * (44 * c2x * c2y + 42 * c2y * etax - 81 * c3y * etax)) * etay +
	  3 * (-6 * c1y * c2x + 16 * c2x * c2y + 9 * c1y * c3x - 8 * c2y * c3x - 12 * c2x * c3y + c1x * (c1y - 8 * c2y + 18 * c3y)) * pow(etay,2) +
	  c0x * (2 * c1y * (6 * pow(c1y,2) + 8 * pow(c2x,2) - 39 * c1y * c2y + 30 * pow(c2y,2) + 30 * c1y * c3y) +
		 3 * c0y * (pow(c1x,2) - pow(c1y,2) + 4 * c2x * (4 * c2x - 5 * c3x) + c1x * (-14 * c2x + 27 * c3x) + c1y * (14 * c2y - 27 * c3y) +
			4 * c2y * (-4 * c2y + 5 * c3y)) - 12 * (4 * c1y * c2x - 8 * c2x * c2y - 9 * c1y * c3x + 6 * c2y * c3x + 4 * c2x * c3y) * etax +
		 3 * pow(c1x,2) * (4 * c1y - 11 * c2y + 6 * c3y - etay) +
		 3 * (pow(c1y,2) - 14 * c1y * c2y + 16 * pow(c2y,2) + 4 * c2x * (-4 * c2x + 5 * c3x) + 27 * c1y * c3y - 20 * c2y * c3y) * etay +
		 c1x * (-45 * c1y * c2x + 44 * c2x * c2y - 36 * c2y * etax + 54 * c3y * etax + 6 * c1y * (7 * c3x + etax) + 42 * c2x * etay - 81 * c3x * etay))) /
	24.,(15 * pow(c1x,2) * c1y * c2x + 15 * pow(c1y,3) * c2x - 20 * c1x * c1y * pow(c2x,2) - 15 * pow(c1x,3) * c2y -
	  15 * c1x * pow(c1y,2) * c2y + 20 * pow(c1x,2) * c2x * c2y - 20 * pow(c1y,2) * c2x * c2y + 20 * c1x * c1y * pow(c2y,2) -
	  10 * pow(c1x,2) * c1y * c3x - 10 * pow(c1y,3) * c3x + 10 * pow(c1x,3) * c3y + 10 * c1x * pow(c1y,2) * c3y +
	  2 * pow(c0y,2) * (2 * c1y * (2 * c2x - 9 * c3x) + 5 * c2y * (c1x - 6 * c2x + 9 * c3x) - 30 * (c1x - 2 * c2x + c3x) * c3y) +
	  2 * pow(c0x,2) * (-4 * c1x * c2y + 18 * c1x * c3y -
		 5 * (-6 * c2x * c2y + c1y * (c2x - 6 * c3x) + 12 * c2y * c3x + 9 * c2x * c3y - 6 * c3x * c3y)) + 5 * pow(c1x,2) * c1y * etax +
	  5 * pow(c1y,3) * etax - 48 * c1x * c1y * c2x * etax + 30 * c1y * pow(c2x,2) * etax - 42 * pow(c1x,2) * c2y * etax -
	  90 * pow(c1y,2) * c2y * etax + 150 * c1x * c2x * c2y * etax - 40 * pow(c2x,2) * c2y * etax + 180 * c1y * pow(c2y,2) * etax -
	  40 * pow(c2y,3) * etax + 96 * c1x * c1y * c3x * etax - 60 * c1y * c2x * c3x * etax - 96 * c1x * c2y * c3x * etax + 69 * pow(c1x,2) * c3y * etax +
	  165 * pow(c1y,2) * c3y * etax - 84 * c1x * c2x * c3y * etax - 240 * c1y * c2y * c3y * etax - 10 * c1y * c2x * pow(etax,2) -
	  8 * c1x * c2y * pow(etax,2) + 60 * c2x * c2y * pow(etax,2) + 60 * c1y * c3x * pow(etax,2) - 120 * c2y * c3x * pow(etax,2) +
	  36 * c1x * c3y * pow(etax,2) - 90 * c2x * c3y * pow(etax,2) + 60 * c3x * c3y * pow(etax,2) +
	  (-5 * pow(c1x,3) + 40 * c2x * (pow(c2x,2) + pow(c2y,2)) + pow(c1y,2) * (42 * c2x - 69 * c3x) +
		 15 * pow(c1x,2) * (6 * c2x - 11 * c3x) - 30 * (2 * pow(c2x,2) - 2 * pow(c2y,2) - 7 * c2x * c3x + 2 * pow(c3x,2) +
			7 * c2y * c3y - 2 * pow(c3y,2)) * etax + c1x *
		  (-5 * pow(c1y,2) + 48 * c1y * (c2y - 2 * c3y) - 30 * (6 * pow(c2x,2) + pow(c2y,2) - 8 * c2x * c3x - 2 * c2y * c3y) +
			6 * (3 * c2x - 16 * c3x) * etax) + 6 * c1y * (-25 * c2x * c2y + 14 * c2y * c3x + 16 * c2x * c3y - 3 * c2y * etax + 16 * c3y * etax)) * etay +
	  2 * (2 * c1y * (2 * c2x - 9 * c3x) + 5 * c2y * (c1x - 6 * c2x + 9 * c3x) - 30 * (c1x - 2 * c2x + c3x) * c3y) * pow(etay,2) +
	  c0x * (-5 * pow(c1y,3) + 40 * c2y * (pow(c2x,2) + pow(c2y,2)) + pow(c1x,2) * (-5 * c1y + 42 * c2y - 69 * c3y) +
		 15 * pow(c1y,2) * (6 * c2y - 11 * c3y) - 60 * (2 * c2x * c2y - 4 * c2y * c3x - 3 * c2x * c3y + 2 * c3x * c3y) * etax +
		 30 * (2 * pow(c2x,2) - 2 * pow(c2y,2) - 7 * c2x * c3x + 2 * pow(c3x,2) + 7 * c2y * c3y - 2 * pow(c3y,2)) * etay +
		 2 * c1x * (-75 * c2x * c2y + 24 * c1y * (c2x - 2 * c3x) + 48 * c2y * c3x + 42 * c2x * c3y + 8 * c2y * etax - 36 * c3y * etax - 9 * c2x * etay +
			48 * c3x * etay) + 2 * c1y * (-90 * pow(c2y,2) - 15 * c2x * (c2x - 2 * c3x) + 120 * c2y * c3y + 10 * (c2x - 6 * c3x) * etax +
			9 * c2y * etay - 48 * c3y * etay)) + c0y * (5 * pow(c1x,3) + pow(c1y,2) * (-42 * c2x + 69 * c3x) +
		 pow(c1x,2) * (-90 * c2x + 165 * c3x) - 2 * c1y *
		  (9 * c0x * c2y - 75 * c2x * c2y + 42 * c2y * c3x - 48 * c0x * c3y + 48 * c2x * c3y - 9 * c2y * etax + 48 * c3y * etax + 8 * c2x * etay -
			36 * c3x * etay) + c1x * (5 * pow(c1y,2) - 48 * c1y * (c2y - 2 * c3y) +
			6 * (3 * c0x * c2x + 30 * pow(c2x,2) - 16 * c0x * c3x - 40 * c2x * c3x + 5 * c2y * (c2y - 2 * c3y) - 3 * c2x * etax + 16 * c3x * etax) -
			20 * (c2y - 6 * c3y) * etay) + 10 * (-4 * pow(c2x,3) - 4 * c2x * pow(c2y,2) +
			3 * c0x * (-2 * pow(c2x,2) + 2 * pow(c2y,2) + 7 * c2x * c3x - 2 * pow(c3x,2) - 7 * c2y * c3y + 2 * pow(c3y,2)) +
			6 * pow(c2x,2) * etax - 6 * pow(c2y,2) * etax - 21 * c2x * c3x * etax + 6 * pow(c3x,2) * etax + 21 * c2y * c3y * etax -
			6 * pow(c3y,2) * etax + 6 * (2 * c2x * c2y - 3 * c2y * c3x - 4 * c2x * c3y + 2 * c3x * c3y) * etay))) / 40.,
   (-36 * pow(c1x,2) * c1y * c2x - 36 * pow(c1y,3) * c2x + 135 * c1x * c1y * pow(c2x,2) - 40 * c1y * pow(c2x,3) +
	  36 * pow(c1x,3) * c2y + 36 * c1x * pow(c1y,2) * c2y - 135 * pow(c1x,2) * c2x * c2y + 135 * pow(c1y,2) * c2x * c2y +
	  40 * c1x * pow(c2x,2) * c2y - 135 * c1x * c1y * pow(c2y,2) - 40 * c1y * c2x * pow(c2y,2) + 40 * c1x * pow(c2y,3) +
	  72 * pow(c1x,2) * c1y * c3x + 72 * pow(c1y,3) * c3x - 170 * c1x * c1y * c2x * c3x + 68 * pow(c1x,2) * c2y * c3x -
	  102 * pow(c1y,2) * c2y * c3x - 72 * pow(c1x,3) * c3y - 72 * c1x * pow(c1y,2) * c3y + 102 * pow(c1x,2) * c2x * c3y -
	  68 * pow(c1y,2) * c2x * c3y + 170 * c1x * c1y * c2y * c3y +
	  3 * pow(c0y,2) * (10 * c1y * c3x - 72 * c2y * c3x + 2 * c2x * (8 * c2y - 45 * c3y) + 15 * (c1x + 9 * c3x) * c3y) -
	  3 * pow(c0x,2) * (8 * c2x * (2 * c2y - 9 * c3y) + 10 * c1x * c3y + 15 * c3x * (c1y - 6 * c2y + 9 * c3y)) + 35 * c1x * c1y * c2x * etax -
	  48 * c1y * pow(c2x,2) * etax + 34 * pow(c1x,2) * c2y * etax + 69 * pow(c1y,2) * c2y * etax - 342 * c1x * c2x * c2y * etax +
	  240 * pow(c2x,2) * c2y * etax - 390 * c1y * pow(c2y,2) * etax + 240 * pow(c2y,3) * etax - 180 * c1x * c1y * c3x * etax +
	  171 * c1y * c2x * c3x * etax + 585 * c1x * c2y * c3x * etax - 276 * c2x * c2y * c3x * etax - 90 * c1y * pow(c3x,2) * etax -
	  168 * pow(c1x,2) * c3y * etax - 348 * pow(c1y,2) * c3y * etax + 579 * c1x * c2x * c3y * etax - 144 * pow(c2x,2) * c3y * etax +
	  1335 * c1y * c2y * c3y * etax - 420 * pow(c2y,2) * c3y * etax - 330 * c1x * c3x * c3y * etax - 420 * c1y * pow(c3y,2) * etax -
	  48 * c2x * c2y * pow(etax,2) - 45 * c1y * c3x * pow(etax,2) + 270 * c2y * c3x * pow(etax,2) - 30 * c1x * c3y * pow(etax,2) +
	  216 * c2x * c3y * pow(etax,2) - 405 * c3x * c3y * pow(etax,2) +
	  (-34 * pow(c1y,2) * c2x - 240 * pow(c2x,3) + 342 * c1y * c2x * c2y - 240 * c2x * pow(c2y,2) + 168 * pow(c1y,2) * c3x +
		 420 * pow(c2x,2) * c3x - 579 * c1y * c2y * c3x + 144 * pow(c2y,2) * c3x + pow(c1x,2) * (-69 * c2x + 348 * c3x) -
		 585 * c1y * c2x * c3y + 276 * c2x * c2y * c3y + 330 * c1y * c3x * c3y +
		 3 * (16 * pow(c2x,2) - 16 * pow(c2y,2) - 162 * c2x * c3x + 135 * pow(c3x,2) + 162 * c2y * c3y - 5 * c3y * (5 * c1y + 27 * c3y)) *
		  etax + c1x * (48 * pow(c2y,2) - 171 * c2y * c3y + 90 * pow(c3y,2) + 5 * c1y * (-7 * c2y + 36 * c3y) +
			15 * (26 * pow(c2x,2) - 89 * c2x * c3x + c3x * (28 * c3x + 5 * etax)))) * etay +
	  3 * (10 * c1y * c3x - 72 * c2y * c3x + 2 * c2x * (8 * c2y - 45 * c3y) + 15 * (c1x + 9 * c3x) * c3y) * pow(etay,2) +
	  c0y * (pow(c1x,2) * (69 * c2x - 348 * c3x) + 2 * pow(c1y,2) * (17 * c2x - 84 * c3x) -
		 c1x * (48 * pow(c2y,2) - 75 * c0x * c3x - 171 * c2y * c3y + 5 * c1y * (-7 * c2y + 36 * c3y) +
			15 * (26 * pow(c2x,2) - 89 * c2x * c3x + c3x * (28 * c3x + 5 * etax)) + 90 * c3y * (c3y + etay)) +
		 c1y * (579 * c2y * c3x + 9 * c2x * (-38 * c2y + 65 * c3y) - 15 * (5 * c0x * c3y + 22 * c3x * c3y - 5 * c3y * etax + 4 * c3x * etay)) +
		 3 * (80 * pow(c2x,3) - 48 * pow(c2y,2) * c3x +
			c0x * (16 * pow(c2x,2) - 16 * pow(c2y,2) - 162 * c2x * c3x + 162 * c2y * c3y + 135 * (c3x - c3y) * (c3x + c3y)) +
			16 * pow(c2y,2) * etax - 135 * pow(c3x,2) * etax - 162 * c2y * c3y * etax + 135 * pow(c3y,2) * etax -
			4 * pow(c2x,2) * (35 * c3x + 4 * etax) + 18 * c3x * (8 * c2y - 15 * c3y) * etay +
			2 * c2x * (40 * pow(c2y,2) + 81 * c3x * etax + 90 * c3y * etay - 2 * c2y * (23 * c3y + 8 * etay)))) +
	  c0x * (pow(c1x,2) * (-34 * c2y + 168 * c3y) + c1x *
		  (342 * c2x * c2y - 585 * c2y * c3x + 5 * c1y * (-7 * c2x + 36 * c3x) - 579 * c2x * c3y + 330 * c3x * c3y + 60 * c3y * etax - 75 * c3x * etay) +
		 3 * (-80 * pow(c2y,3) + 140 * pow(c2y,2) * c3y + pow(c1y,2) * (-23 * c2y + 116 * c3y) - 180 * c2y * c3x * etax +
			270 * c3x * c3y * etax + 16 * pow(c2y,2) * etay - 135 * pow(c3x,2) * etay - 162 * c2y * c3y * etay + 135 * pow(c3y,2) * etay -
			16 * pow(c2x,2) * (5 * c2y - 3 * c3y + etay) + 2 * c2x * (46 * c2y * c3x + 16 * c2y * etax - 72 * c3y * etax + 81 * c3x * etay) +
			c1y * (16 * pow(c2x,2) - 57 * c2x * c3x + 5 *
				(26 * pow(c2y,2) - 89 * c2y * c3y + 28 * pow(c3y,2) + 6 * c3x * (c3x + etax) + 5 * c3y * etay))))) / 120.,
   (35 * pow(c1y,3) * (c2x - 6 * c3x) - 35 * pow(c1x,3) * (c2y - 6 * c3y) +
	  3 * pow(c1y,2) * (55 * c0y * c3x + 287 * c2y * c3x + 7 * c2x * (-18 * c2y + 25 * c3y) - 35 * c3y * (3 * c0x + 4 * c3x - 3 * etax) -
		 55 * c3x * etay) + pow(c1x,2) * (35 * c1y * (c2x - 6 * c3x) + 21 * c2x * (18 * c2y - 41 * c3y) +
		 15 * (21 * c0y * c3x - 35 * c2y * c3x - 11 * c0x * c3y + 28 * c3x * c3y + 11 * c3y * etax - 21 * c3x * etay)) +
	  c1x * (-322 * c0x * c2x * c2y - 315 * pow(c2x,2) * c2y - 315 * pow(c2y,3) + 1548 * c0x * c2y * c3x + 224 * c2x * c2y * c3x -
		 35 * pow(c1y,2) * (c2y - 6 * c3y) + 1644 * c0x * c2x * c3y + 336 * pow(c2x,2) * c3y + 560 * pow(c2y,2) * c3y -
		 2646 * c0x * c3x * c3y + c0y * (357 * pow(c2x,2) + 35 * pow(c2y,2) - 3444 * c2x * c3x + 2835 * pow(c3x,2) + 150 * c1y * c3y -
			252 * c2y * c3y + 189 * pow(c3y,2)) + 322 * c2x * c2y * etax - 1548 * c2y * c3x * etax - 1644 * c2x * c3y * etax +
		 2646 * c3x * c3y * etax - 7 * (51 * pow(c2x,2) + 5 * pow(c2y,2) - 492 * c2x * c3x + 405 * pow(c3x,2) - 36 * c2y * c3y +
			27 * pow(c3y,2)) * etay - 6 * c1y * (63 * pow(c2x,2) - 63 * pow(c2y,2) - 231 * c2x * c3x + 231 * c2y * c3y -
			70 * pow(c3y,2) + 5 * c3x * (5 * c0x + 14 * c3x - 5 * etax) + 25 * c3y * etay)) +
	  c1y * (315 * pow(c2x,3) - 7 * c0x * (5 * pow(c2x,2) + 51 * pow(c2y,2) - 36 * c2x * c3x - 492 * c2y * c3y +
			27 * (pow(c3x,2) + 15 * pow(c3y,2))) + 35 * pow(c2x,2) * (-16 * c3x + etax) +
		 c2x * (322 * c0y * c2y + 315 * pow(c2y,2) - 1548 * c0y * c3y - 224 * c2y * c3y - 252 * c3x * etax - 322 * c2y * etay +
			1548 * c3y * etay) - 3 * (c0y * (548 * c2y * c3x - 882 * c3x * c3y) + 7 * pow(c2y,2) * (16 * c3x - 17 * etax) -
			63 * (pow(c3x,2) + 15 * pow(c3y,2)) * etax + 882 * c3x * c3y * etay + 4 * c2y * (287 * c3y * etax - 137 * c3x * etay))) +
	  21 * (-2 * pow(c0x,2) * (6 * c2y * c3x + 5 * c2x * c3y - 27 * c3x * c3y) + 2 * pow(c0y,2) * (5 * c2y * c3x + 6 * c2x * c3y - 27 * c3x * c3y) -
		 etax * (30 * pow(c2y,3) + 5 * pow(c2x,2) * (6 * c2y - 11 * c3y) - 145 * pow(c2y,2) * c3y + 80 * c2y * pow(c3y,2) -
			54 * c3x * c3y * etax + 12 * c2y * c3x * (2 * c3x + etax) + c2x * (-90 * c2y * c3x + 56 * c3x * c3y + 10 * c3y * etax)) +
		 (30 * pow(c2x,3) - 145 * pow(c2x,2) * c3x - 55 * pow(c2y,2) * c3x + 54 * (-pow(c3x,2) + pow(c3y,2)) * etax +
			c2x * (30 * pow(c2y,2) + 80 * pow(c3x,2) - 90 * c2y * c3y + 24 * pow(c3y,2) + 22 * c3x * etax) +
			c2y * (56 * c3x * c3y - 22 * c3y * etax)) * etay + 2 * (5 * c2y * c3x + 6 * c2x * c3y - 27 * c3x * c3y) * pow(etay,2) +
		 c0x * (30 * pow(c2y,3) + 5 * pow(c2x,2) * (6 * c2y - 11 * c3y) - 145 * pow(c2y,2) * c3y + 24 * c2y * c3x * (c3x + etax) +
			2 * c2y * c3y * (40 * c3y + 11 * etay) + c2x * (-90 * c2y * c3x + 56 * c3x * c3y + 20 * c3y * etax - 22 * c3x * etay) +
			54 * (-2 * c3x * c3y * etax + pow(c3x,2) * etay - pow(c3y,2) * etay)) -
		 c0y * (30 * pow(c2x,3) - 145 * pow(c2x,2) * c3x - 55 * pow(c2y,2) * c3x +
			c2y * (22 * c0x * c3y + 56 * c3x * c3y - 22 * c3y * etax + 20 * c3x * etay) +
			54 * ((c3x - c3y) * (c3x + c3y) * (c0x - etax) - 2 * c3x * c3y * etay) +
			c2x * (30 * pow(c2y,2) - 90 * c2y * c3y + 2 * c3x * (-11 * c0x + 40 * c3x + 11 * etax) + 24 * c3y * (c3y + etay))))) / 420.,
   (-336 * c1y * pow(c2x,3) + 140 * pow(c1y,2) * c2x * c2y - 224 * c0x * pow(c2x,2) * c2y - 336 * c1y * c2x * pow(c2y,2) -
	  224 * c0x * pow(c2y,3) + 80 * pow(c1y,3) * c3x - 50 * c0x * c1y * c2x * c3x + 1722 * c1y * pow(c2x,2) * c3x -
	  960 * pow(c1y,2) * c2y * c3x + 1860 * c0x * c2x * c2y * c3x - 112 * pow(c2x,2) * c2y * c3x + 1092 * c1y * pow(c2y,2) * c3x -
	  112 * pow(c2y,3) * c3x - 980 * c1y * c2x * pow(c3x,2) - 1260 * c0x * c2y * pow(c3x,2) - 80 * pow(c1x,3) * c3y -
	  552 * pow(c1y,2) * c2x * c3y + 1248 * c0x * pow(c2x,2) * c3y + 112 * pow(c2x,3) * c3y - 1218 * c0x * c1y * c2y * c3y +
	  630 * c1y * c2x * c2y * c3y + 3108 * c0x * pow(c2y,2) * c3y + 112 * c2x * pow(c2y,2) * c3y - 420 * pow(c0x,2) * c3x * c3y +
	  420 * pow(c0y,2) * c3x * c3y + 1344 * pow(c1y,2) * c3x * c3y - 3570 * c0x * c2x * c3x * c3y - 924 * c1y * c2y * c3x * c3y +
	  840 * c0x * pow(c3x,2) * c3y + 2856 * c0x * c1y * pow(c3y,2) - 56 * c1y * c2x * pow(c3y,2) - 4830 * c0x * c2y * pow(c3y,2) +
	  840 * c0x * pow(c3y,3) + 4 * pow(c1x,2) * (-35 * c2x * c2y + 20 * c1y * c3x + 138 * c2y * c3x + 48 * (5 * c2x - 7 * c3x) * c3y) +
	  224 * pow(c2x,2) * c2y * etax + 224 * pow(c2y,3) * etax + 50 * c1y * c2x * c3x * etax - 1860 * c2x * c2y * c3x * etax +
	  1260 * c2y * pow(c3x,2) * etax - 1248 * pow(c2x,2) * c3y * etax + 1218 * c1y * c2y * c3y * etax - 3108 * pow(c2y,2) * c3y * etax +
	  840 * c0x * c3x * c3y * etax + 3570 * c2x * c3x * c3y * etax - 840 * pow(c3x,2) * c3y * etax - 2856 * c1y * pow(c3y,2) * etax +
	  4830 * c2y * pow(c3y,2) * etax - 840 * pow(c3y,3) * etax - 420 * c3x * c3y * pow(etax,2) +
	  (-224 * pow(c2x,3) - 224 * c2x * pow(c2y,2) + 3108 * pow(c2x,2) * c3x + 1248 * pow(c2y,2) * c3x + 1860 * c2x * c2y * c3y -
		 3570 * c2y * c3x * c3y + 3 * c1y * c3x * (-205 * c2y + 952 * c3y) - 7 * c2x * (690 * pow(c3x,2) + c3y * (79 * c1y + 180 * c3y)) +
		 420 * (c0x * (-pow(c3x,2) + pow(c3y,2)) + 2 * c3x * (pow(c3x,2) + pow(c3y,2)) + (c3x - c3y) * (c3x + c3y) * etax)) *
	   etay + 420 * c3x * c3y * pow(etay,2) + c1x * (336 * pow(c2y,3) - 553 * c0x * c2y * c3x - 2856 * c0y * pow(c3x,2) +
		 56 * c2y * pow(c3x,2) + 84 * pow(c2x,2) * (4 * c2y - 13 * c3y) - 80 * pow(c1y,2) * c3y + 50 * c0y * c2y * c3y -
		 1722 * pow(c2y,2) * c3y + 2856 * c0x * c3x * c3y + 980 * c2y * pow(c3y,2) +
		 28 * c1y * (5 * pow(c2x,2) - 5 * pow(c2y,2) - 54 * c2x * c3x + 54 * c2y * c3y + 48 * (c3x - c3y) * (c3x + c3y)) +
		 553 * c2y * c3x * etax - 2856 * c3x * c3y * etax + 2856 * pow(c3x,2) * etay - 50 * c2y * c3y * etay +
		 3 * c2x * (406 * c0y * c3x - 210 * c2y * c3x - 205 * c0x * c3y + 308 * c3x * c3y + 205 * c3y * etax - 406 * c3x * etay)) +
	  c0y * (224 * pow(c2x,3) + 224 * c2x * pow(c2y,2) - 3108 * pow(c2x,2) * c3x - 1248 * pow(c2y,2) * c3x +
		 3 * c1y * c3x * (205 * c2y - 952 * c3y) - 1860 * c2x * c2y * c3y + 3570 * c2y * c3x * c3y +
		 7 * c2x * (690 * pow(c3x,2) + c3y * (79 * c1y + 180 * c3y)) -
		 420 * (2 * pow(c3x,3) + c0x * (-pow(c3x,2) + pow(c3y,2)) + pow(c3x,2) * etax - pow(c3y,2) * etax +
			2 * c3x * c3y * (c3y + etay)))) / 560.,(pow(c1y,2) * (165 * c2y * c3x + 91 * c2x * c3y - 672 * c3x * c3y) +
	  pow(c1x,2) * (-91 * c2y * c3x - 165 * c2x * c3y + 672 * c3x * c3y) +
	  6 * (28 * pow(c2x,2) * c2y * c3x + 28 * pow(c2y,3) * c3x - 28 * c2x * c2y * pow(c3x,2) - 28 * pow(c2x,3) * c3y -
		 28 * c2x * pow(c2y,2) * c3y + 28 * pow(c2x,2) * c3x * c3y - 28 * pow(c2y,2) * c3x * c3y + 28 * c2x * c2y * pow(c3y,2) +
		 c0y * (7 * c3x * (12 * pow(c2x,2) + 5 * pow(c2y,2) - 54 * c2x * c3x + 27 * pow(c3x,2)) + c2y * (49 * c2x - 288 * c3x) * c3y +
			9 * (-10 * c2x + 21 * c3x) * pow(c3y,2)) -
		 c0x * (c2x * c3x * (49 * c2y - 288 * c3y) + 35 * pow(c2x,2) * c3y + 84 * pow(c2y,2) * c3y +
			189 * c3y * (pow(c3x,2) + pow(c3y,2)) - 18 * c2y * (5 * pow(c3x,2) + 21 * pow(c3y,2))) + 49 * c2x * c2y * c3x * etax -
		 90 * c2y * pow(c3x,2) * etax + 35 * pow(c2x,2) * c3y * etax + 84 * pow(c2y,2) * c3y * etax - 288 * c2x * c3x * c3y * etax +
		 189 * pow(c3x,2) * c3y * etax - 378 * c2y * pow(c3y,2) * etax + 189 * pow(c3y,3) * etax -
		 (7 * c3x * (12 * pow(c2x,2) + 5 * pow(c2y,2) - 54 * c2x * c3x + 27 * pow(c3x,2)) + c2y * (49 * c2x - 288 * c3x) * c3y +
			9 * (-10 * c2x + 21 * c3x) * pow(c3y,2)) * etay) +
	  2 * c1y * (28 * pow(c2x,3) - 420 * pow(c2x,2) * c3x - 276 * pow(c2y,2) * c3x + 32 * c2y * (-4 * c1x + 21 * c3x) * c3y +
		 c2x * (28 * pow(c2y,2) + 128 * c1x * c3x - 144 * c2y * c3y + 21 * (33 * pow(c3x,2) + pow(c3y,2))) -
		 3 * (42 * pow(c3x,3) - 80 * c0y * c3x * c3y + 42 * c3x * pow(c3y,2) + 112 * c1x * (c3x - c3y) * (c3x + c3y) +
			c0x * (-3 * pow(c3x,2) + 77 * pow(c3y,2)) + 3 * pow(c3x,2) * etax - 77 * pow(c3y,2) * etax + 80 * c3x * c3y * etay)) -
	  2 * c1x * (28 * pow(c2y,3) + 4 * pow(c2x,2) * (7 * c2y - 69 * c3y) - 420 * pow(c2y,2) * c3y + 48 * c2x * c3x * (-3 * c2y + 14 * c3y) +
		 21 * c2y * (pow(c3x,2) + 33 * pow(c3y,2)) -
		 3 * (77 * c0y * pow(c3x,2) - 80 * c0x * c3x * c3y + 42 * pow(c3x,2) * c3y - 3 * c0y * pow(c3y,2) + 42 * pow(c3y,3) +
			80 * c3x * c3y * etax - 77 * pow(c3x,2) * etay + 3 * pow(c3y,2) * etay))) / 336.,
   (-960 * pow(c1x,2) * c3x * c3y + 960 * pow(c1y,2) * c3x * c3y +
	  c1y * (c3x * (1180 * pow(c2x,2) + 795 * pow(c2y,2) - 5712 * c2x * c3x + 48 * c3x * (20 * c1x + 63 * c3x)) +
		 5 * c2y * (77 * c2x - 1128 * c3x) * c3y - 24 * (40 * c1x + 3 * (c2x - 42 * c3x)) * pow(c3y,2)) -
	  c1x * (5 * c2x * c3x * (77 * c2y - 1128 * c3y) + 795 * pow(c2x,2) * c3y +
		 4 * (295 * pow(c2y,2) * c3y + 756 * c3y * (pow(c3x,2) + pow(c3y,2)) - 6 * c2y * (3 * pow(c3x,2) + 238 * pow(c3y,2)))) +
	  3 * (-240 * pow(c2y,3) * c3x + 240 * pow(c2x,3) * c3y + 700 * pow(c2y,2) * c3x * c3y -
		 20 * pow(c2x,2) * c3x * (12 * c2y + 35 * c3y) +
		 c2x * (240 * pow(c2y,2) * c3y - 805 * c0x * c3x * c3y + 700 * c2y * (c3x - c3y) * (c3x + c3y) +
			7 * c0y * (148 * pow(c3x,2) + 33 * pow(c3y,2)) + 805 * c3x * c3y * etax + 28 * pow(c3x,2) * (6 * c3y - 37 * etay) +
			21 * pow(c3y,2) * (8 * c3y - 11 * etay)) +
		 1512 * (pow(c3x,2) + pow(c3y,2)) * (-(c0y * c3x) + c0x * c3y - c3y * etax + c3x * etay) -
		 7 * c2y * (24 * pow(c3x,3) + c0x * (33 * pow(c3x,2) + 148 * pow(c3y,2)) - 33 * pow(c3x,2) * etax -
			148 * pow(c3y,2) * etax + c3x * c3y * (-115 * c0y + 24 * c3y + 115 * etay)))) / 1680.,
   (7 * pow(c2y,3) * c3x - 7 * pow(c2x,3) * c3y - 60 * pow(c2y,2) * c3x * c3y + pow(c2x,2) * c3x * (7 * c2y + 60 * c3y) +
	  6 * c2y * (7 * pow(c3x,3) - 9 * c1x * pow(c3y,2) + c3x * c3y * (9 * c1y + 7 * c3y)) +
	  c2x * (54 * c1y * pow(c3x,2) - 7 * pow(c2y,2) * c3y + 60 * c2y * (-pow(c3x,2) + pow(c3y,2)) -
		 6 * c3y * (9 * c1x * c3x + 7 * (pow(c3x,2) + pow(c3y,2)))) +
	  42 * (pow(c3x,2) + pow(c3y,2)) * (c0y * c3x + c3y * (-c0x + 2 * c1x + etax) - c3x * (2 * c1y + etay))) / 56.,
   (35 * c2x * c3x * (c2y * c3x - c2x * c3y) + 35 * c2y * c3y * (c2y * c3x - c2x * c3y) +
	  24 * pow(c3x,2) * (2 * c1y * c3x - 3 * c2y * c3x - 2 * c1x * c3y + 3 * c2x * c3y) +
	  24 * pow(c3y,2) * (2 * c1y * c3x - 3 * c2y * c3x - 2 * c1x * c3y + 3 * c2x * c3y)) / 112.,
   (3 * (c2y * c3x - c2x * c3y) * (pow(c3x,2) + pow(c3y,2))) / 16. };
		Ix0t0 = valuesIx0[0];
		Ix0t1 = valuesIx0[1];
		Ix0t2 = valuesIx0[2];
		Ix0t3 = valuesIx0[3];
		Ix0t4 = valuesIx0[4];
		Ix0t5 = valuesIx0[5];
		Ix0t6 = valuesIx0[6];
		Ix0t7 = valuesIx0[7];
		Ix0t8 = valuesIx0[8];
		Ix0t9 = valuesIx0[9];
		Ix0t10 = valuesIx0[10];
		Ix0t11 = valuesIx0[11];
		Ix0t12 = valuesIx0[12];
		Ix0t13 = valuesIx0[13];


	}
	//Ix1系数
	if (0)
	{
		std::vector<double> valuesIx1 = { 0,0,(3 * (-(c0y * c1x) + c0x * c1y - c1y * etax + c1x * etay) * (c0x * c1x + c0y * c1y - c1x * etax - c1y * etay)) / 4.,
   (pow(c0y,2) * (4 * c1x * c1y - 4 * c1y * c2x - 6 * c1x * c2y) + pow(c0x,2) * (6 * c1y * c2x + 4 * c1x * (-c1y + c2y)) +
	  etax * (-3 * pow(c1x,2) * c1y - 3 * pow(c1y,3) + 6 * c1y * c2x * etax + 4 * c1x * (-c1y + c2y) * etax) +
	  3 * c1x * (pow(c1x,2) + pow(c1y,2)) * etay + 2 * (2 * pow(c1x,2) - 5 * c1x * c2x + c1y * (-2 * c1y + 5 * c2y)) * etax * etay +
	  2 * (2 * c1x * c1y - 2 * c1y * c2x - 3 * c1x * c2y) * pow(etay,2) +
	  c0x * (3 * pow(c1x,2) * c1y + 3 * pow(c1y,3) + 2 * c0y * (2 * pow(c1x,2) - 2 * pow(c1y,2) - 5 * c1x * c2x + 5 * c1y * c2y) +
		 8 * c1x * c1y * etax - 12 * c1y * c2x * etax - 8 * c1x * c2y * etax +
		 2 * (-2 * pow(c1x,2) + 2 * pow(c1y,2) + 5 * c1x * c2x - 5 * c1y * c2y) * etay) +
	  c0y * (-3 * pow(c1x,3) - 4 * pow(c1x,2) * etax + 2 * c1y * (2 * c1y * etax - 5 * c2y * etax + 4 * c2x * etay) +
		 c1x * (-3 * pow(c1y,2) + 10 * c2x * etax - 8 * c1y * etay + 12 * c2y * etay))) / 4.,
   (pow(c0y,2) * (12 * c1y * c2x - 16 * c2x * c2y - 9 * c1y * c3x + c1x * (-3 * c1y + 16 * c2y - 18 * c3y)) +
	  pow(c0x,2) * (2 * (-8 * c1y * c2x + 8 * c2x * c2y + 9 * c1y * c3x) + 3 * c1x * (c1y - 4 * c2y + 3 * c3y)) +
	  etax * (8 * pow(c1x,2) * c1y + 8 * pow(c1y,3) - 15 * c1x * c1y * c2x - 11 * pow(c1x,2) * c2y - 26 * pow(c1y,2) * c2y +
		 2 * (-8 * c1y * c2x + 8 * c2x * c2y + 9 * c1y * c3x) * etax + 3 * c1x * (c1y - 4 * c2y + 3 * c3y) * etax) +
	  (-8 * pow(c1x,3) - 8 * c1x * pow(c1y,2) + 26 * pow(c1x,2) * c2x + 11 * pow(c1y,2) * c2x + 15 * c1x * c1y * c2y +
		 (-3 * pow(c1x,2) + 3 * pow(c1y,2) + 28 * c1x * c2x - 16 * pow(c2x,2) - 28 * c1y * c2y + 16 * pow(c2y,2) - 27 * c1x * c3x +
			27 * c1y * c3y) * etax) * etay + (12 * c1y * c2x - 16 * c2x * c2y - 9 * c1y * c3x + c1x * (-3 * c1y + 16 * c2y - 18 * c3y)) *
	   pow(etay,2) + c0x * (-8 * pow(c1y,3) + 26 * pow(c1y,2) * c2y +
		 c0y * (-3 * pow(c1x,2) + 3 * pow(c1y,2) + 28 * c1x * c2x - 16 * pow(c2x,2) - 28 * c1y * c2y + 16 * pow(c2y,2) -
			27 * c1x * c3x + 27 * c1y * c3y) + 32 * c1y * c2x * etax - 32 * c2x * c2y * etax - 36 * c1y * c3x * etax - 3 * pow(c1y,2) * etay +
		 16 * pow(c2x,2) * etay + 28 * c1y * c2y * etay - 16 * pow(c2y,2) * etay - 27 * c1y * c3y * etay +
		 pow(c1x,2) * (-8 * c1y + 11 * c2y + 3 * etay) +
		 c1x * (15 * c1y * c2x - 6 * c1y * etax + 24 * c2y * etax - 18 * c3y * etax - 28 * c2x * etay + 27 * c3x * etay)) +
	  c0y * (8 * pow(c1x,3) + pow(c1x,2) * (-26 * c2x + 3 * etax) - pow(c1y,2) * (11 * c2x + 3 * etax) +
		 16 * (pow(c2x,2) * etax - pow(c2y,2) * etax + 2 * c2x * c2y * etay) +
		 c1y * (28 * c2y * etax - 27 * c3y * etax - 24 * c2x * etay + 18 * c3x * etay) +
		 c1x * (8 * pow(c1y,2) - 15 * c1y * c2y - 28 * c2x * etax + 27 * c3x * etax + 6 * c1y * etay - 32 * c2y * etay + 36 * c3y * etay))) / 8.,
   (3 * (-5 * pow(c1x,2) * c1y * c2x - 5 * pow(c1y,3) * c2x + 5 * pow(c1x,3) * c2y + 5 * c1x * pow(c1y,2) * c2y +
		2 * pow(c0x,2) * (5 * c1y * (c2x - 4 * c3x) + 4 * c2y * (c1x - 5 * c2x + 5 * c3x) + 3 * (-4 * c1x + 5 * c2x) * c3y) -
		2 * pow(c0y,2) * (4 * c1y * (c2x - 3 * c3x) + 5 * (-4 * c2x * c2y + 3 * c2y * c3x + c1x * (c2y - 4 * c3y) + 4 * c2x * c3y)) -
		5 * pow(c1x,2) * c1y * etax - 5 * pow(c1y,3) * etax + 32 * c1x * c1y * c2x * etax - 10 * c1y * pow(c2x,2) * etax +
		28 * pow(c1x,2) * c2y * etax + 60 * pow(c1y,2) * c2y * etax - 50 * c1x * c2x * c2y * etax - 60 * c1y * pow(c2y,2) * etax -
		32 * c1x * c1y * c3x * etax - 23 * pow(c1x,2) * c3y * etax - 55 * pow(c1y,2) * c3y * etax + 10 * c1y * c2x * pow(etax,2) +
		8 * c1x * c2y * pow(etax,2) - 40 * c2x * c2y * pow(etax,2) - 40 * c1y * c3x * pow(etax,2) + 40 * c2y * c3x * pow(etax,2) -
		24 * c1x * c3y * pow(etax,2) + 30 * c2x * c3y * pow(etax,2) +
		(5 * pow(c1x,3) + pow(c1x,2) * (-60 * c2x + 55 * c3x) + c1y * (-28 * c1y * c2x + 50 * c2x * c2y + 23 * c1y * c3x) +
		   2 * (5 * c2x * (4 * c2x - 7 * c3x) + c1y * (9 * c2y - 32 * c3y) + 5 * c2y * (-4 * c2y + 7 * c3y)) * etax +
		   c1x * (5 * pow(c1y,2) + 60 * pow(c2x,2) + 10 * pow(c2y,2) + 32 * c1y * (-c2y + c3y) - 18 * c2x * etax + 64 * c3x * etax)) *
		 etay - 2 * (4 * c1y * (c2x - 3 * c3x) + 5 * (-4 * c2x * c2y + 3 * c2y * c3x + c1x * (c2y - 4 * c3y) + 4 * c2x * c3y)) * pow(etay,2) +
		c0x * (pow(c1x,2) * (5 * c1y - 28 * c2y + 23 * c3y) +
		   5 * c1y * (pow(c1y,2) + 2 * pow(c2x,2) - 12 * c1y * c2y + 12 * pow(c2y,2) + 11 * c1y * c3y) -
		   20 * (-4 * c2x * c2y + c1y * (c2x - 4 * c3x) + 4 * c2y * c3x + 3 * c2x * c3y) * etax +
		   2 * (5 * c2x * (-4 * c2x + 7 * c3x) + 5 * c2y * (4 * c2y - 7 * c3y) + c1y * (-9 * c2y + 32 * c3y)) * etay +
		   2 * c1x * (25 * c2x * c2y + 16 * c1y * (-c2x + c3x) - 8 * c2y * etax + 24 * c3y * etax + 9 * c2x * etay - 32 * c3x * etay)) -
		c0y * (5 * pow(c1x,3) + pow(c1y,2) * (-28 * c2x + 23 * c3x) + pow(c1x,2) * (-60 * c2x + 55 * c3x) -
		   10 * (4 * pow(c2x,2) - 4 * pow(c2y,2) - 7 * c2x * c3x + 7 * c2y * c3y) * (c0x - etax) +
		   20 * (4 * c2x * c2y - 3 * c2y * c3x - 4 * c2x * c3y) * etay +
		   2 * c1y * (-9 * c0x * c2y + 25 * c2x * c2y + 32 * c0x * c3y + 9 * c2y * etax - 32 * c3y * etax - 8 * c2x * etay + 24 * c3x * etay) +
		   c1x * (5 * pow(c1y,2) + 32 * c1y * (-c2y + c3y) +
			  2 * (9 * c0x * c2x + 30 * pow(c2x,2) - 32 * c0x * c3x - 9 * c2x * etax + 32 * c3x * etax +
				 5 * (pow(c2y,2) - 2 * c2y * etay + 8 * c3y * etay)))))) / 40.,
   (24 * pow(c1x,2) * c1y * c2x + 24 * pow(c1y,3) * c2x - 45 * c1x * c1y * pow(c2x,2) - 24 * pow(c1x,3) * c2y -
	  24 * c1x * pow(c1y,2) * c2y + 45 * pow(c1x,2) * c2x * c2y - 45 * pow(c1y,2) * c2x * c2y + 45 * c1x * c1y * pow(c2y,2) -
	  24 * pow(c1x,2) * c1y * c3x - 24 * pow(c1y,3) * c3x + 24 * pow(c1x,3) * c3y + 24 * c1x * pow(c1y,2) * c3y -
	  3 * pow(c0y,2) * (10 * c1y * c3x - 48 * c2y * c3x + 4 * c2x * (4 * c2y - 15 * c3y) + 15 * (c1x + 3 * c3x) * c3y) +
	  3 * pow(c0x,2) * (16 * c2x * (c2y - 3 * c3y) + 10 * c1x * c3y + 15 * c3x * (c1y - 4 * c2y + 3 * c3y)) - 35 * c1x * c1y * c2x * etax +
	  32 * c1y * pow(c2x,2) * etax - 34 * pow(c1x,2) * c2y * etax - 69 * pow(c1y,2) * c2y * etax + 228 * c1x * c2x * c2y * etax -
	  80 * pow(c2x,2) * c2y * etax + 260 * c1y * pow(c2y,2) * etax - 80 * pow(c2y,3) * etax + 120 * c1x * c1y * c3x * etax -
	  57 * c1y * c2x * c3x * etax - 195 * c1x * c2y * c3x * etax + 112 * pow(c1x,2) * c3y * etax + 232 * pow(c1y,2) * c3y * etax -
	  193 * c1x * c2x * c3y * etax - 445 * c1y * c2y * c3y * etax + 48 * c2x * c2y * pow(etax,2) + 45 * c1y * c3x * pow(etax,2) -
	  180 * c2y * c3x * pow(etax,2) + 30 * c1x * c3y * pow(etax,2) - 144 * c2x * c3y * pow(etax,2) + 135 * c3x * c3y * pow(etax,2) +
	  (80 * c2x * (pow(c2x,2) + pow(c2y,2)) + pow(c1x,2) * (69 * c2x - 232 * c3x) + 2 * pow(c1y,2) * (17 * c2x - 56 * c3x) +
		 3 * (-16 * pow(c2x,2) + 16 * pow(c2y,2) + 108 * c2x * c3x - 45 * pow(c3x,2) - 108 * c2y * c3y + 45 * pow(c3y,2)) * etax +
		 c1x * (-260 * pow(c2x,2) + 35 * c1y * c2y - 32 * pow(c2y,2) + 445 * c2x * c3x - 120 * c1y * c3y + 57 * c2y * c3y - 75 * c3x * etax) +
		 c1y * (-228 * c2x * c2y + 193 * c2y * c3x + 195 * c2x * c3y + 75 * c3y * etax)) * etay -
	  3 * (10 * c1y * c3x - 48 * c2y * c3x + 4 * c2x * (4 * c2y - 15 * c3y) + 15 * (c1x + 3 * c3x) * c3y) * pow(etay,2) +
	  c0x * (80 * c2y * (pow(c2x,2) + pow(c2y,2)) + pow(c1y,2) * (69 * c2y - 232 * c3y) + 2 * pow(c1x,2) * (17 * c2y - 56 * c3y) +
		 6 * (-16 * c2x * c2y + 60 * c2y * c3x + 48 * c2x * c3y - 45 * c3x * c3y) * etax +
		 3 * (16 * pow(c2x,2) - 16 * pow(c2y,2) - 108 * c2x * c3x + 108 * c2y * c3y + 45 * (c3x - c3y) * (c3x + c3y)) * etay +
		 c1x * (-228 * c2x * c2y + 5 * c1y * (7 * c2x - 24 * c3x) + 195 * c2y * c3x + 193 * c2x * c3y - 60 * c3y * etax + 75 * c3x * etay) -
		 c1y * (32 * pow(c2x,2) - 57 * c2x * c3x + 5 * c2y * (52 * c2y - 89 * c3y) + 90 * c3x * etax + 75 * c3y * etay)) +
	  c0y * (-48 * c0x * pow(c2x,2) - 80 * pow(c2x,3) + 48 * c0x * pow(c2y,2) - 80 * c2x * pow(c2y,2) + 324 * c0x * c2x * c3x -
		 135 * c0x * pow(c3x,2) + pow(c1y,2) * (-34 * c2x + 112 * c3x) + pow(c1x,2) * (-69 * c2x + 232 * c3x) - 324 * c0x * c2y * c3y +
		 135 * c0x * pow(c3y,2) + 48 * pow(c2x,2) * etax - 48 * pow(c2y,2) * etax - 324 * c2x * c3x * etax + 135 * pow(c3x,2) * etax +
		 324 * c2y * c3y * etax - 135 * pow(c3y,2) * etax + 6 * (16 * c2x * c2y - 48 * c2y * c3x - 60 * c2x * c3y + 45 * c3x * c3y) * etay +
		 c1y * (-193 * c2y * c3x + 3 * c2x * (76 * c2y - 65 * c3y) + 75 * c3y * (c0x - etax) + 60 * c3x * etay) +
		 c1x * (260 * pow(c2x,2) - 35 * c1y * c2y + 32 * pow(c2y,2) - 445 * c2x * c3x + 120 * c1y * c3y - 57 * c2y * c3y +
			75 * c3x * (-c0x + etax) + 90 * c3y * etay))) / 40.,
   (-35 * pow(c1y, 3) * (c2x - 4 * c3x) + 35 * pow(c1x, 3) * (c2y - 4 * c3y) +
	   pow(c1y, 2) * (-165 * c0y * c3x - 287 * c2y * c3x + 7 * c2x * (36 * c2y - 25 * c3y) + 315 * c3y * (c0x - etax) + 165 * c3x * etay) +
	   pow(c1x, 2) * (-35 * c1y * (c2x - 4 * c3x) + 7 * c2x * (-36 * c2y + 41 * c3y) + 165 * c3y * (c0x - etax) +
		   35 * c3x * (-9 * c0y + 5 * c2y + 9 * etay)) + c1y *
	   (-105 * pow(c2x, 3) + 1096 * c0y * c2y * c3x - 882 * c0y * c3x * c3y +
		   7 * c0x * (5 * pow(c2x, 2) + 51 * pow(c2y, 2) - 24 * c2x * c3x + 9 * pow(c3x, 2) - 328 * c2y * c3y + 135 * pow(c3y, 2)) -
		   35 * pow(c2x, 2) * etax - 357 * pow(c2y, 2) * etax - 63 * pow(c3x, 2) * etax + 2296 * c2y * c3y * etax -
		   945 * pow(c3y, 2) * etax - 1096 * c2y * c3x * etay + 882 * c3x * c3y * etay +
		   c2x * (-322 * c0y * c2y - 105 * pow(c2y, 2) + 1032 * c0y * c3y + 168 * c3x * etax + 322 * c2y * etay - 1032 * c3y * etay)) +
	   c1x * (322 * c0x * c2x * c2y + 105 * pow(c2x, 2) * c2y + 105 * pow(c2y, 3) - 1032 * c0x * c2y * c3x + 35 * pow(c1y, 2) * (c2y - 4 * c3y) -
		   1096 * c0x * c2x * c3y + 882 * c0x * c3x * c3y - c0y *
		   (357 * pow(c2x, 2) + 35 * pow(c2y, 2) - 2296 * c2x * c3x + 945 * pow(c3x, 2) + 150 * c1y * c3y - 168 * c2y * c3y +
			   63 * pow(c3y, 2)) - 322 * c2x * c2y * etax + 1032 * c2y * c3x * etax + 1096 * c2x * c3y * etax - 882 * c3x * c3y * etax +
		   7 * (51 * pow(c2x, 2) + 5 * pow(c2y, 2) - 328 * c2x * c3x + 135 * pow(c3x, 2) - 24 * c2y * c3y + 9 * pow(c3y, 2)) * etay +
		   6 * c1y * (42 * pow(c2x, 2) - 42 * pow(c2y, 2) - 77 * c2x * c3x + 77 * c2y * c3y + 25 * c3x * (c0x - etax) + 25 * c3y * etay)) +
	   7 * (-6 * pow(c0y, 2) * (5 * c2y * c3x + 6 * (c2x - 3 * c3x) * c3y) +
		   (c0x - etax) * (-60 * pow(c2y, 3) + 145 * pow(c2y, 2) * c3y + pow(c2x, 2) * (-60 * c2y + 55 * c3y) +
			   30 * c2x * (3 * c2y * c3x + c3y * (c0x - etax)) + 36 * c2y * c3x * (c0x - etax) + 108 * c3x * c3y * (-c0x + etax)) +
		   (-60 * pow(c2x, 3) + 145 * pow(c2x, 2) * c3x + 55 * pow(c2y, 2) * c3x +
			   c2x * (-60 * pow(c2y, 2) + 90 * c2y * c3y + 66 * c3x * (c0x - etax)) - 108 * (c3x - c3y) * (c3x + c3y) * (c0x - etax) +
			   66 * c2y * c3y * (-c0x + etax)) * etay - 6 * (5 * c2y * c3x + 6 * (c2x - 3 * c3x) * c3y) * pow(etay, 2) +
		   c0y * (60 * pow(c2x, 3) - 145 * pow(c2x, 2) * c3x - 55 * pow(c2y, 2) * c3x + 66 * c2y * c3y * (c0x - etax) + 60 * c2y * c3x * etay +
			   c2x * (60 * pow(c2y, 2) - 90 * c2y * c3y + 66 * c3x * (-c0x + etax) + 72 * c3y * etay) +
			   108 * ((c3x - c3y) * (c3x + c3y) * (c0x - etax) - 2 * c3x * c3y * etay)))) / 140.,
	   (3 * (224 * c1y * pow(c2x, 3) - 140 * pow(c1y, 2) * c2x * c2y + 224 * c0x * pow(c2x, 2) * c2y + 224 * c1y * c2x * pow(c2y, 2) +
		   224 * c0x * pow(c2y, 3) - 80 * pow(c1y, 3) * c3x + 50 * c0x * c1y * c2x * c3x - 574 * c1y * pow(c2x, 2) * c3x +
		   640 * pow(c1y, 2) * c2y * c3x - 1240 * c0x * c2x * c2y * c3x - 364 * c1y * pow(c2y, 2) * c3x + 420 * c0x * c2y * pow(c3x, 2) +
		   4 * pow(c1x, 2) * (5 * c2x * (7 * c2y - 32 * c3y) - 4 * c3x * (5 * c1y + 23 * c2y - 28 * c3y)) + 80 * pow(c1x, 3) * c3y +
		   368 * pow(c1y, 2) * c2x * c3y - 832 * c0x * pow(c2x, 2) * c3y + 1218 * c0x * c1y * c2y * c3y - 210 * c1y * c2x * c2y * c3y -
		   2072 * c0x * pow(c2y, 2) * c3y + 420 * pow(c0x, 2) * c3x * c3y - 420 * pow(c0y, 2) * c3x * c3y - 448 * pow(c1y, 2) * c3x * c3y +
		   1190 * c0x * c2x * c3x * c3y - 1904 * c0x * c1y * pow(c3y, 2) + 1610 * c0x * c2y * pow(c3y, 2) - 224 * pow(c2x, 2) * c2y * etax -
		   224 * pow(c2y, 3) * etax - 50 * c1y * c2x * c3x * etax + 1240 * c2x * c2y * c3x * etax - 420 * c2y * pow(c3x, 2) * etax +
		   832 * pow(c2x, 2) * c3y * etax - 1218 * c1y * c2y * c3y * etax + 2072 * pow(c2y, 2) * c3y * etax - 840 * c0x * c3x * c3y * etax -
		   1190 * c2x * c3x * c3y * etax + 1904 * c1y * pow(c3y, 2) * etax - 1610 * c2y * pow(c3y, 2) * etax + 420 * c3x * c3y * pow(etax, 2) +
		   (224 * pow(c2x, 3) - 2072 * pow(c2x, 2) * c3x + 615 * c1y * c2y * c3x - 832 * pow(c2y, 2) * c3x + 420 * c0x * pow(c3x, 2) -
			   1904 * c1y * c3x * c3y + 1190 * c2y * c3x * c3y - 420 * c0x * pow(c3y, 2) +
			   c2x * (224 * pow(c2y, 2) + 1610 * pow(c3x, 2) - 1240 * c2y * c3y + 7 * c3y * (79 * c1y + 60 * c3y)) -
			   420 * (c3x - c3y) * (c3x + c3y) * etax) * etay - 420 * c3x * c3y * pow(etay, 2) -
		   c0y * (224 * pow(c2x, 3) - 2072 * pow(c2x, 2) * c3x + 615 * c1y * c2y * c3x - 832 * pow(c2y, 2) * c3x + 420 * c0x * pow(c3x, 2) -
			   1904 * c1y * c3x * c3y + 1190 * c2y * c3x * c3y - 420 * c0x * pow(c3y, 2) +
			   c2x * (224 * pow(c2y, 2) + 1610 * pow(c3x, 2) - 1240 * c2y * c3y + 7 * c3y * (79 * c1y + 60 * c3y)) - 420 * pow(c3x, 2) * etax +
			   420 * pow(c3y, 2) * etax - 840 * c3x * c3y * etay) +
		   c1x * (-224 * pow(c2y, 3) + 553 * c0x * c2y * c3x + 1904 * c0y * pow(c3x, 2) + 80 * pow(c1y, 2) * c3y - 50 * c0y * c2y * c3y +
			   574 * pow(c2y, 2) * c3y - 1904 * c0x * c3x * c3y + 28 * pow(c2x, 2) * (-8 * c2y + 13 * c3y) -
			   28 * c1y * (5 * pow(c2x, 2) - 5 * pow(c2y, 2) - 36 * c2x * c3x + 36 * c2y * c3y + 16 * (c3x - c3y) * (c3x + c3y)) +
			   615 * c2x * c3y * (c0x - etax) - 553 * c2y * c3x * etax + 1904 * c3x * c3y * etax - 1904 * pow(c3x, 2) * etay + 50 * c2y * c3y * etay +
			   42 * c2x * c3x * (-29 * c0y + 5 * c2y + 29 * etay)))) / 560.,
	   (pow(c1x, 2) * (91 * c2y * c3x + 165 * c2x * c3y - 448 * c3x * c3y) + pow(c1y, 2) * (-165 * c2y * c3x - 91 * c2x * c3y + 448 * c3x * c3y) -
		   2 * c1y * (28 * pow(c2x, 3) - 280 * pow(c2x, 2) * c3x - 184 * pow(c2y, 2) * c3x + 9 * c0x * pow(c3x, 2) - 224 * c1x * pow(c3x, 2) +
			   240 * c0y * c3x * c3y + 32 * c2y * (-4 * c1x + 7 * c3x) * c3y - 231 * c0x * pow(c3y, 2) + 224 * c1x * pow(c3y, 2) +
			   c2x * (28 * pow(c2y, 2) + 128 * c1x * c3x + 231 * pow(c3x, 2) - 96 * c2y * c3y + 7 * pow(c3y, 2)) - 9 * pow(c3x, 2) * etax +
			   231 * pow(c3y, 2) * etax - 240 * c3x * c3y * etay) +
		   2 * (-28 * pow(c2x, 2) * c2y * c3x - 28 * pow(c2y, 3) * c3x + 28 * pow(c2x, 3) * c3y + 28 * c2x * pow(c2y, 2) * c3y -
			   3 * c0y * (7 * c3x * (12 * pow(c2x, 2) + 5 * pow(c2y, 2) - 36 * c2x * c3x + 9 * pow(c3x, 2)) + c2y * (49 * c2x - 192 * c3x) * c3y +
				   3 * (-20 * c2x + 21 * c3x) * pow(c3y, 2)) +
			   3 * c0x * (c2y * (49 * c2x - 60 * c3x) * c3x + (35 * pow(c2x, 2) + 84 * pow(c2y, 2) - 192 * c2x * c3x + 63 * pow(c3x, 2)) * c3y -
				   252 * c2y * pow(c3y, 2) + 63 * pow(c3y, 3)) - 147 * c2x * c2y * c3x * etax + 180 * c2y * pow(c3x, 2) * etax -
			   105 * pow(c2x, 2) * c3y * etax - 252 * pow(c2y, 2) * c3y * etax + 576 * c2x * c3x * c3y * etax - 189 * pow(c3x, 2) * c3y * etax +
			   756 * c2y * pow(c3y, 2) * etax - 189 * pow(c3y, 3) * etax +
			   3 * (7 * c3x * (12 * pow(c2x, 2) + 5 * pow(c2y, 2) - 36 * c2x * c3x + 9 * pow(c3x, 2)) + c2y * (49 * c2x - 192 * c3x) * c3y +
				   3 * (-20 * c2x + 21 * c3x) * pow(c3y, 2)) * etay) +
		   2 * c1x * (28 * pow(c2y, 3) + 4 * pow(c2x, 2) * (7 * c2y - 46 * c3y) - 280 * pow(c2y, 2) * c3y + 32 * c2x * c3x * (-3 * c2y + 7 * c3y) +
			   7 * c2y * (pow(c3x, 2) + 33 * pow(c3y, 2)) +
			   3 * (-77 * c0y * pow(c3x, 2) + 80 * c0x * c3x * c3y + 3 * c0y * pow(c3y, 2) - 80 * c3x * c3y * etax + 77 * pow(c3x, 2) * etay -
				   3 * pow(c3y, 2) * etay))) / 112., (6 * pow(c2x, 2) * (-(c1y * c3x) + c2y * c3x + (c1x - c2x) * c3y)) / 7. +
	   (6 * pow(c2y, 2) * (-(c1y * c3x) + c2y * c3x + (c1x - c2x) * c3y)) / 7. +
	   (12 * c1x * c3x * (-(c1y * c3x) + c2y * c3x + (c1x - c2x) * c3y)) / 7. + (12 * c1y * c3y * (-(c1y * c3x) + c2y * c3x + (c1x - c2x) * c3y)) / 7. +
	   (9 * c1x * c2x * (-(c2y * c3x) + c2x * c3y)) / 16. + (9 * c1y * c2y * (-(c2y * c3x) + c2x * c3y)) / 16. +
	   (9 * c0x * c3x * (-(c2y * c3x) + c2x * c3y)) / 16. + (9 * c0y * c3y * (-(c2y * c3x) + c2x * c3y)) / 16. +
	   (9 * c3x * (c2y * c3x - c2x * c3y) * etax) / 16. + (5 * c2x * c3x *
		   (-(c1y * (c2x - 4 * c3x)) + c1x * (c2y - 4 * c3y) + c3y * (3 * c0x + c2x - 3 * etax) - c3x * (3 * c0y + c2y - 3 * etay))) / 4. +
	   (5 * c2y * c3y * (-(c1y * (c2x - 4 * c3x)) + c1x * (c2y - 4 * c3y) + c3y * (3 * c0x + c2x - 3 * etax) - c3x * (3 * c0y + c2y - 3 * etay))) / 4. -
	   (9 * c3y * (-(c2y * c3x) + c2x * c3y) * etay) / 16. + (9 * pow(c3x, 2) *
		   (-(c0y * c2x) + c1y * c2x + c0x * c2y - c1x * c2y + 3 * c0y * c3x - c1y * c3x - 3 * c0x * c3y + c1x * c3y - c2y * etax + 3 * c3y * etax +
			   c2x * etay - 3 * c3x * etay)) / 5. + (9 * pow(c3y, 2) *
				   (-(c0y * c2x) + c1y * c2x + c0x * c2y - c1x * c2y + 3 * c0y * c3x - c1y * c3x - 3 * c0x * c3y + c1x * c3y - c2y * etax + 3 * c3y * etax +
					   c2x * etay - 3 * c3x * etay)) / 5., (3 * (-7 * pow(c2y, 3) * c3x + 7 * pow(c2x, 3) * c3y + 40 * pow(c2y, 2) * c3x * c3y -
						   pow(c2x, 2) * c3x * (7 * c2y + 40 * c3y) - 2 * c2y * (7 * pow(c3x, 3) - 27 * c1x * pow(c3y, 2) + c3x * c3y * (27 * c1y + 7 * c3y)) +
						   c2x * (-54 * c1y * pow(c3x, 2) + 7 * pow(c2y, 2) * c3y + 54 * c1x * c3x * c3y + 40 * c2y * (c3x - c3y) * (c3x + c3y) +
							   14 * c3y * (pow(c3x, 2) + pow(c3y, 2))) +
						   14 * (pow(c3x, 2) + pow(c3y, 2)) * (-3 * c0y * c3x + 4 * c1y * c3x + 3 * c0x * c3y - 4 * c1x * c3y - 3 * c3y * etax + 3 * c3x * etay))) / 56.,
	   (3 * (48 * pow(c3x, 2) * (-(c1y * c3x) + c2y * c3x + (c1x - c2x) * c3y) +
		   48 * pow(c3y, 2) * (-(c1y * c3x) + c2y * c3x + (c1x - c2x) * c3y) + 35 * c2x * c3x * (-(c2y * c3x) + c2x * c3y) +
		   35 * c2y * c3y * (-(c2y * c3x) + c2x * c3y))) / 112., (-9 * (c2y * c3x - c2x * c3y) * (pow(c3x, 2) + pow(c3y, 2))) / 16. };
		Ix1t0 = valuesIx1[0];
		Ix1t1 = valuesIx1[1];
		Ix1t2 = valuesIx1[2];
		Ix1t3 = valuesIx1[3];
		Ix1t4 = valuesIx1[4];
		Ix1t5 = valuesIx1[5];
		Ix1t6 = valuesIx1[6];
		Ix1t7 = valuesIx1[7];
		Ix1t8 = valuesIx1[8];
		Ix1t9 = valuesIx1[9];
		Ix1t10 = valuesIx1[10];
		Ix1t11 = valuesIx1[11];
		Ix1t12 = valuesIx1[12];
		Ix1t13 = valuesIx1[13];
	}
	//Ix2系数
	if (0) {
		std::vector<double> valuesIx2 = { 0,0,0,((-(c0y * c1x) + c0x * c1y - c1y * etax + c1x * etay) * (c0x * c1x + c0y * c1y - c1x * etax - c1y * etay)) / 2.,
   (pow(c0y,2) * (3 * c1x * c1y - 6 * c1y * c2x - 8 * c1x * c2y) + pow(c0x,2) * (-3 * c1x * c1y + 8 * c1y * c2x + 6 * c1x * c2y) +
	  etax * (-4 * c1y * (pow(c1x,2) + pow(c1y,2)) + (-3 * c1x * c1y + 8 * c1y * c2x + 6 * c1x * c2y) * etax) +
	  4 * c1x * (pow(c1x,2) + pow(c1y,2)) * etay + (3 * pow(c1x,2) - 14 * c1x * c2x + c1y * (-3 * c1y + 14 * c2y)) * etax * etay +
	  (3 * c1x * c1y - 6 * c1y * c2x - 8 * c1x * c2y) * pow(etay,2) +
	  c0x * (c0y * (3 * pow(c1x,2) - 14 * c1x * c2x + c1y * (-3 * c1y + 14 * c2y)) + pow(c1x,2) * (4 * c1y - 3 * etay) +
		 2 * c1x * (3 * c1y * etax - 6 * c2y * etax + 7 * c2x * etay) + c1y * (4 * pow(c1y,2) - 16 * c2x * etax + 3 * c1y * etay - 14 * c2y * etay)) +
	  c0y * (-4 * pow(c1x,3) - 3 * pow(c1x,2) * etax + c1y * (3 * c1y * etax - 14 * c2y * etax + 12 * c2x * etay) +
		 2 * c1x * (-2 * pow(c1y,2) + 7 * c2x * etax - 3 * c1y * etay + 8 * c2y * etay))) / 8.,
   (3 * (2 * pow(c0y,2) * (4 * c1y * c2x - 10 * c2x * c2y - 6 * c1y * c3x + 5 * c1x * (c2y - 2 * c3y)) -
		(c0x - etax) * (pow(c1x,2) * (5 * c1y - 14 * c2y) + 4 * c1x * (-4 * c1y * c2x + (2 * c2y - 3 * c3y) * (c0x - etax)) +
		   5 * (pow(c1y,3) - 6 * pow(c1y,2) * c2y + 2 * c1y * (c2x - 2 * c3x) * (c0x - etax) + 4 * c2x * c2y * (-c0x + etax))) +
		(-5 * pow(c1x,3) + 30 * pow(c1x,2) * c2x + 14 * pow(c1y,2) * c2x + c1x * c1y * (-5 * c1y + 16 * c2y) +
		   20 * (c2x - c2y) * (c2x + c2y) * (c0x - etax) - 2 * c1x * (9 * c2x - 16 * c3x) * (c0x - etax) +
		   2 * c1y * (9 * c2y - 16 * c3y) * (c0x - etax)) * etay +
		2 * (4 * c1y * c2x - 10 * c2x * c2y - 6 * c1y * c3x + 5 * c1x * (c2y - 2 * c3y)) * pow(etay,2) +
		c0y * (5 * pow(c1x,3) - 30 * pow(c1x,2) * c2x -
		   2 * (7 * pow(c1y,2) * c2x + 10 * (c2x - c2y) * (c2x + c2y) * (c0x - etax) + c1y * (9 * c2y - 16 * c3y) * (c0x - etax) -
			  20 * c2x * c2y * etay + 4 * c1y * (2 * c2x - 3 * c3x) * etay) +
		   c1x * (5 * pow(c1y,2) - 16 * c1y * c2y + 2 * (9 * c2x - 16 * c3x) * (c0x - etax) - 20 * (c2y - 2 * c3y) * etay)))) / 40.,
   (-12 * pow(c1x,2) * c1y * c2x - 12 * pow(c1y,3) * c2x + 12 * pow(c1x,3) * c2y + 12 * c1x * pow(c1y,2) * c2y +
	  pow(c0y,2) * (48 * c2x * c2y + 30 * c1y * c3x - 72 * c2y * c3x + 45 * c1x * c3y - 90 * c2x * c3y) +
	  pow(c0x,2) * (-48 * c2x * c2y - 45 * c1y * c3x + 90 * c2y * c3x - 30 * c1x * c3y + 72 * c2x * c3y) + 35 * c1x * c1y * c2x * etax -
	  16 * c1y * pow(c2x,2) * etax + 34 * pow(c1x,2) * c2y * etax + 69 * pow(c1y,2) * c2y * etax - 114 * c1x * c2x * c2y * etax -
	  130 * c1y * pow(c2y,2) * etax - 60 * c1x * c1y * c3x * etax - 56 * pow(c1x,2) * c3y * etax - 116 * pow(c1y,2) * c3y * etax -
	  48 * c2x * c2y * pow(etax,2) - 45 * c1y * c3x * pow(etax,2) + 90 * c2y * c3x * pow(etax,2) - 30 * c1x * c3y * pow(etax,2) +
	  72 * c2x * c3y * pow(etax,2) + (pow(c1x,2) * (-69 * c2x + 116 * c3x) + 2 * c1y * (-17 * c1y * c2x + 57 * c2x * c2y + 28 * c1y * c3x) +
		 3 * (16 * pow(c2x,2) - 16 * pow(c2y,2) - 54 * c2x * c3x - 25 * c1y * c3y + 54 * c2y * c3y) * etax +
		 c1x * (130 * pow(c2x,2) - 35 * c1y * c2y + 16 * pow(c2y,2) + 60 * c1y * c3y + 75 * c3x * etax)) * etay +
	  3 * (16 * c2x * c2y + 10 * c1y * c3x - 24 * c2y * c3x + 15 * c1x * c3y - 30 * c2x * c3y) * pow(etay,2) +
	  c0y * (pow(c1x,2) * (69 * c2x - 116 * c3x) + pow(c1y,2) * (34 * c2x - 56 * c3x) +
		 6 * (8 * pow(c2x,2) - 8 * pow(c2y,2) - 27 * c2x * c3x + 27 * c2y * c3y) * (c0x - etax) +
		 12 * (-8 * c2x * c2y + 12 * c2y * c3x + 15 * c2x * c3y) * etay - 3 * c1y * (38 * c2x * c2y + 25 * c0x * c3y - 25 * c3y * etax + 20 * c3x * etay) -
		 c1x * (130 * pow(c2x,2) - 35 * c1y * c2y + 16 * pow(c2y,2) + 60 * c1y * c3y + 75 * c3x * (-c0x + etax) + 90 * c3y * etay)) +
	  c0x * (pow(c1x,2) * (-34 * c2y + 56 * c3y) + pow(c1y,2) * (-69 * c2y + 116 * c3y) +
		 c1x * (-35 * c1y * c2x + 114 * c2x * c2y + 60 * c1y * c3x + 60 * c3y * etax - 75 * c3x * etay) +
		 c1y * (16 * pow(c2x,2) + 130 * pow(c2y,2) + 90 * c3x * etax + 75 * c3y * etay) -
		 6 * (8 * pow(c2x,2) * etay + c2x * (-16 * c2y * etax + 24 * c3y * etax - 27 * c3x * etay) +
			c2y * (30 * c3x * etax - 8 * c2y * etay + 27 * c3y * etay)))) / 40.,
   (35 * pow(c1y,3) * (c2x - 2 * c3x) - 35 * pow(c1x,3) * (c2y - 2 * c3y) +
	  pow(c1x,2) * (126 * c2x * c2y + 35 * c1y * (c2x - 2 * c3x) + 165 * c3y * (-c0x + etax) + 315 * c3x * (c0y - etay)) +
	  c1y * (c0y * (322 * c2x * c2y - 548 * c2y * c3x - 516 * c2x * c3y) +
		 7 * c0x * (-5 * pow(c2x,2) + 12 * c2x * c3x + c2y * (-51 * c2y + 164 * c3y)) + 35 * pow(c2x,2) * etax + 357 * pow(c2y,2) * etax -
		 84 * c2x * c3x * etax - 1148 * c2y * c3y * etax - 322 * c2x * c2y * etay + 548 * c2y * c3x * etay + 516 * c2x * c3y * etay) -
	  3 * pow(c1y,2) * (42 * c2x * c2y + 105 * c3y * (c0x - etax) + 55 * c3x * (-c0y + etay)) +
	  c1x * (-35 * pow(c1y,2) * (c2y - 2 * c3y) + c0y * (35 * pow(c2y,2) + 7 * c2x * (51 * c2x - 164 * c3x) + 150 * c1y * c3y - 84 * c2y * c3y) -
		 2 * (161 * c2x * c2y - 258 * c2y * c3x - 274 * c2x * c3y) * (c0x - etax) +
		 7 * (-51 * pow(c2x,2) - 5 * pow(c2y,2) + 164 * c2x * c3x + 12 * c2y * c3y) * etay -
		 6 * c1y * (21 * pow(c2x,2) - 21 * pow(c2y,2) + 25 * (c0x * c3x - c3x * etax + c3y * etay))) +
	  42 * (pow(c0y,2) * (5 * c2y * c3x + 6 * c2x * c3y - 9 * c3x * c3y) -
		 (c0x - etax) * (-5 * pow(c2x,2) * c2y - 5 * pow(c2y,3) + 6 * c2y * c3x * (c0x - etax) + 5 * c2x * c3y * (c0x - etax) +
			9 * c3x * c3y * (-c0x + etax)) + (5 * pow(c2x,3) + 5 * c2x * pow(c2y,2) +
			(9 * pow(c3x,2) + (11 * c2y - 9 * c3y) * c3y) * (c0x - etax) + 11 * c2x * c3x * (-c0x + etax)) * etay +
		 (5 * c2y * c3x + 6 * c2x * c3y - 9 * c3x * c3y) * pow(etay,2) -
		 c0y * (5 * pow(c2x,3) + (9 * pow(c3x,2) + (11 * c2y - 9 * c3y) * c3y) * (c0x - etax) + 2 * c3x * (5 * c2y - 9 * c3y) * etay +
			c2x * (5 * pow(c2y,2) + 11 * c3x * (-c0x + etax) + 12 * c3y * etay)))) / 140.,
   (3 * (-112 * c1y * pow(c2x,3) + 140 * pow(c1y,2) * c2x * c2y - 224 * c0x * pow(c2x,2) * c2y - 112 * c1y * c2x * pow(c2y,2) -
		224 * c0x * pow(c2y,3) + 80 * pow(c1y,3) * c3x - 50 * c0x * c1y * c2x * c3x - 320 * pow(c1y,2) * c2y * c3x +
		620 * c0x * c2x * c2y * c3x - 80 * pow(c1x,3) * c3y - 184 * pow(c1y,2) * c2x * c3y + 416 * c0x * pow(c2x,2) * c3y -
		1218 * c0x * c1y * c2y * c3y + 1036 * c0x * pow(c2y,2) * c3y - 420 * pow(c0x,2) * c3x * c3y + 420 * pow(c0y,2) * c3x * c3y +
		952 * c0x * c1y * pow(c3y,2) + 4 * pow(c1x,2) * (-35 * c2x * c2y + 20 * c1y * c3x + 46 * c2y * c3x + 80 * c2x * c3y) +
		224 * pow(c2x,2) * c2y * etax + 224 * pow(c2y,3) * etax + 50 * c1y * c2x * c3x * etax - 620 * c2x * c2y * c3x * etax -
		416 * pow(c2x,2) * c3y * etax + 1218 * c1y * c2y * c3y * etax - 1036 * pow(c2y,2) * c3y * etax + 840 * c0x * c3x * c3y * etax -
		952 * c1y * pow(c3y,2) * etax - 420 * c3x * c3y * pow(etax,2) +
		(-224 * pow(c2x,3) + 1036 * pow(c2x,2) * c3x - 615 * c1y * c2y * c3x + 416 * pow(c2y,2) * c3x - 420 * c0x * pow(c3x,2) +
		   952 * c1y * c3x * c3y + 420 * c0x * pow(c3y,2) + c2x * (-224 * pow(c2y,2) - 553 * c1y * c3y + 620 * c2y * c3y) +
		   420 * (c3x - c3y) * (c3x + c3y) * etax) * etay + 420 * c3x * c3y * pow(etay,2) +
		c1x * (112 * pow(c2x,2) * c2y + 112 * pow(c2y,3) - 553 * c0x * c2y * c3x - 952 * c0y * pow(c3x,2) - 80 * pow(c1y,2) * c3y +
		   50 * c0y * c2y * c3y + 952 * c0x * c3x * c3y + 28 * c1y * (5 * pow(c2x,2) - 18 * c2x * c3x + c2y * (-5 * c2y + 18 * c3y)) +
		   553 * c2y * c3x * etax - 952 * c3x * c3y * etax + 615 * c2x * c3y * (-c0x + etax) + 1218 * c2x * c3x * (c0y - etay) +
		   952 * pow(c3x,2) * etay - 50 * c2y * c3y * etay) +
		c0y * (224 * pow(c2x,3) - 1036 * pow(c2x,2) * c3x - 416 * pow(c2y,2) * c3x + 420 * c0x * pow(c3x,2) +
		   c1y * c3x * (615 * c2y - 952 * c3y) - 420 * c0x * pow(c3y,2) + c2x * (224 * pow(c2y,2) + 553 * c1y * c3y - 620 * c2y * c3y) -
		   420 * pow(c3x,2) * etax + 420 * pow(c3y,2) * etax - 840 * c3x * c3y * etay))) / 560.,
   (pow(c1y,2) * (165 * c2y * c3x + 91 * c2x * c3y - 224 * c3x * c3y) + pow(c1x,2) * (-91 * c2y * c3x - 165 * c2x * c3y + 224 * c3x * c3y) +
	  2 * c1y * (28 * pow(c2x,3) - 140 * pow(c2x,2) * c3x - 92 * pow(c2y,2) * c3x + 9 * c0x * pow(c3x,2) - 112 * c1x * pow(c3x,2) -
		 128 * c1x * c2y * c3y + 240 * c0y * c3x * c3y - 231 * c0x * pow(c3y,2) + 112 * c1x * pow(c3y,2) +
		 4 * c2x * (7 * pow(c2y,2) + 32 * c1x * c3x - 12 * c2y * c3y) - 9 * pow(c3x,2) * etax + 231 * pow(c3y,2) * etax - 240 * c3x * c3y * etay
		 ) + 6 * (c0y * (7 * (5 * pow(c2y,2) + 6 * c2x * (2 * c2x - 3 * c3x)) * c3x + c2y * (49 * c2x - 96 * c3x) * c3y - 30 * c2x * pow(c3y,2)) -
		 (c2x * c3x * (49 * c2y - 96 * c3y) + 35 * pow(c2x,2) * c3y + 6 * c2y * (-5 * pow(c3x,2) + 7 * (2 * c2y - 3 * c3y) * c3y)) *
		  (c0x - etax) + (-84 * pow(c2x,2) * c3x + 126 * c2x * pow(c3x,2) + c2x * c3y * (-49 * c2y + 30 * c3y) +
			c2y * c3x * (-35 * c2y + 96 * c3y)) * etay) + 2 * c1x *
	   (-28 * pow(c2y,3) + 48 * c2x * c2y * c3x + 140 * pow(c2y,2) * c3y + pow(c2x,2) * (-28 * c2y + 92 * c3y) +
		 3 * (77 * c0y * pow(c3x,2) - 80 * c0x * c3x * c3y - 3 * c0y * pow(c3y,2) + 80 * c3x * c3y * etax - 77 * pow(c3x,2) * etay +
			3 * pow(c3y,2) * etay))) / 112.,(-960 * pow(c1x,2) * c3x * c3y + 960 * pow(c1y,2) * c3x * c3y +
	  c1y * (c3x * (795 * pow(c2y,2) + 4 * c2x * (295 * c2x - 476 * c3x) + 960 * c1x * c3x) + 5 * c2y * (77 * c2x - 376 * c3x) * c3y -
		 24 * (40 * c1x + c2x) * pow(c3y,2)) + c1x * (-795 * pow(c2x,2) * c3y + 5 * c2x * c3x * (-77 * c2y + 376 * c3y) +
		 4 * c2y * (6 * pow(c3x,2) + c3y * (-295 * c2y + 476 * c3y))) +
	  3 * (-80 * pow(c2x,2) * c2y * c3x - 80 * pow(c2y,3) * c3x + 80 * pow(c2x,3) * c3y +
		 504 * (pow(c3x,2) + pow(c3y,2)) * (-(c0y * c3x) + c0x * c3y - c3y * etax + c3x * etay) -
		 7 * c2y * (33 * c0x * pow(c3x,2) - 115 * c0y * c3x * c3y + 148 * c0x * pow(c3y,2) - 33 * pow(c3x,2) * etax -
			148 * pow(c3y,2) * etax + 115 * c3x * c3y * etay) +
		 c2x * (80 * pow(c2y,2) * c3y + 7 * c0y * (148 * pow(c3x,2) + 33 * pow(c3y,2)) + 805 * c3x * c3y * (-c0x + etax) -
			7 * (148 * pow(c3x,2) + 33 * pow(c3y,2)) * etay))) / 560.,
   (3 * (7 * pow(c2y,3) * c3x - 7 * pow(c2x,3) * c3y - 20 * pow(c2y,2) * c3x * c3y + pow(c2x,2) * c3x * (7 * c2y + 20 * c3y) +
		54 * c2y * c3y * (c1y * c3x - c1x * c3y) + c2x * (54 * c1y * pow(c3x,2) - 7 * pow(c2y,2) * c3y - 54 * c1x * c3x * c3y +
		   20 * c2y * (-pow(c3x,2) + pow(c3y,2))) +
		14 * (pow(c3x,2) + pow(c3y,2)) * (3 * c0y * c3x - 2 * c1y * c3x - 3 * c0x * c3y + 2 * c1x * c3y + 3 * c3y * etax - 3 * c3x * etay))) / 56.,
   (3 * (35 * c2x * c3x * (c2y * c3x - c2x * c3y) + 35 * c2y * c3y * (c2y * c3x - c2x * c3y) +
		24 * pow(c3x,2) * (2 * c1y * c3x - c2y * c3x + (-2 * c1x + c2x) * c3y) +
		24 * pow(c3y,2) * (2 * c1y * c3x - c2y * c3x + (-2 * c1x + c2x) * c3y))) / 112.,
	   (9 * (c2y * c3x - c2x * c3y) * (pow(c3x, 2) + pow(c3y, 2))) / 16. };
		Ix2t0 = valuesIx2[0];
		Ix2t1 = valuesIx2[1];
		Ix2t2 = valuesIx2[2];
		Ix2t3 = valuesIx2[3];
		Ix2t4 = valuesIx2[4];
		Ix2t5 = valuesIx2[5];
		Ix2t6 = valuesIx2[6];
		Ix2t7 = valuesIx2[7];
		Ix2t8 = valuesIx2[8];
		Ix2t9 = valuesIx2[9];
		Ix2t10 = valuesIx2[10];
		Ix2t11 = valuesIx2[11];
		Ix2t12 = valuesIx2[12];
		Ix2t13 = valuesIx2[13];
	}

	//Iy0系数
	if (0)
	{
		std::vector<double> valuesIy0 = { 0,-((pow(c0x - etax,2) + pow(c0y - etay,2)) * (c0x * c1x + c0y * c1y - c1x * etax - c1y * etay)) / 4.,
   (pow(c0x,3) * (c1x - 2 * c2x) + pow(c0y,3) * (c1y - 2 * c2y) -
	  pow(etax,2) * (2 * pow(c1x,2) + pow(c1y,2) + c1x * etax - 2 * c2x * etax) -
	  etax * (2 * c1x * c1y + c1y * etax - 2 * c2y * etax) * etay -
	  (pow(c1x,2) + 2 * pow(c1y,2) + c1x * etax - 2 * c2x * etax) * pow(etay,2) - (c1y - 2 * c2y) * pow(etay,3) -
	  pow(c0y,2) * (pow(c1x,2) + 2 * pow(c1y,2) + c1x * etax - 2 * c2x * etax + 3 * c1y * etay - 6 * c2y * etay) -
	  pow(c0x,2) * (2 * pow(c1x,2) - c0y * c1y + pow(c1y,2) + 2 * c0y * c2y + 3 * c1x * etax - 6 * c2x * etax + c1y * etay -
		 2 * c2y * etay) + c0y * (etax * (2 * c1x * c1y + c1y * etax - 2 * c2y * etax) +
		 2 * (pow(c1x,2) + 2 * pow(c1y,2) + c1x * etax - 2 * c2x * etax) * etay + 3 * (c1y - 2 * c2y) * pow(etay,2)) +
	  c0x * (pow(c0y,2) * (c1x - 2 * c2x) + etax * (4 * pow(c1x,2) + 2 * pow(c1y,2) + 3 * c1x * etax - 6 * c2x * etax) +
		 2 * (c1x * c1y + (c1y - 2 * c2y) * etax) * etay + (c1x - 2 * c2x) * pow(etay,2) -
		 2 * c0y * (c1y * etax - 2 * c2y * etax - 2 * c2x * etay + c1x * (c1y + etay)))) / 4.,
   (-(pow(c0x,3) * (c1x - 6 * c2x + 9 * c3x)) - pow(c0y,3) * (c1y - 6 * c2y + 9 * c3y) +
	  etax * (4 * c1x * (pow(c1x,2) + pow(c1y,2)) + c1x * (7 * c1x - 17 * c2x) * etax + 3 * c1y * (c1y - 3 * c2y) * etax +
		 (c1x - 6 * c2x + 9 * c3x) * pow(etax,2)) + (4 * c1y * (pow(c1x,2) + pow(c1y,2)) -
		 8 * (c1y * c2x + c1x * (-c1y + c2y)) * etax + (c1y - 6 * c2y + 9 * c3y) * pow(etax,2)) * etay +
	  (3 * c1x * (c1x - 3 * c2x) + c1y * (7 * c1y - 17 * c2y) + (c1x - 6 * c2x + 9 * c3x) * etax) * pow(etay,2) +
	  (c1y - 6 * c2y + 9 * c3y) * pow(etay,3) + pow(c0x,2) *
	   (c1x * (7 * c1x - 17 * c2x) + 3 * c1y * (c1y - 3 * c2y) - c0y * (c1y - 6 * c2y + 9 * c3y) + 3 * (c1x - 6 * c2x + 9 * c3x) * etax +
		 (c1y - 6 * c2y + 9 * c3y) * etay) + pow(c0y,2) *
	   (3 * c1x * (c1x - 3 * c2x) + c1y * (7 * c1y - 17 * c2y) + (c1x - 6 * c2x + 9 * c3x) * etax + 3 * (c1y - 6 * c2y + 9 * c3y) * etay) +
	  c0x * (-4 * c1x * (pow(c1x,2) + pow(c1y,2)) - 8 * c0y * (c1y * c2x + c1x * (-c1y + c2y)) -
		 pow(c0y,2) * (c1x - 6 * c2x + 9 * c3x) + 2 * (-7 * pow(c1x,2) + 17 * c1x * c2x - 3 * c1y * (c1y - 3 * c2y) +
			c0y * (c1y - 6 * c2y + 9 * c3y)) * etax - 3 * (c1x - 6 * c2x + 9 * c3x) * pow(etax,2) +
		 2 * (4 * c1y * c2x + 4 * c1x * (-c1y + c2y) + c0y * (c1x - 6 * c2x + 9 * c3x) - (c1y - 6 * c2y + 9 * c3y) * etax) * etay -
		 (c1x - 6 * c2x + 9 * c3x) * pow(etay,2)) + c0y *
	   (-4 * pow(c1x,2) * c1y - 4 * pow(c1y,3) - 8 * c1x * c1y * etax + 8 * c1y * c2x * etax + 8 * c1x * c2y * etax - c1y * pow(etax,2) +
		 6 * c2y * pow(etax,2) - 9 * c3y * pow(etax,2) -
		 2 * (3 * c1x * (c1x - 3 * c2x) + c1y * (7 * c1y - 17 * c2y) + (c1x - 6 * c2x + 9 * c3x) * etax) * etay -
		 3 * (c1y - 6 * c2y + 9 * c3y) * pow(etay,2))) / 12.,
   (-2 * pow(c1x,4) - 4 * pow(c1x,2) * pow(c1y,2) - 2 * pow(c1y,4) + pow(c0x,3) * (-4 * c2x + 18 * c3x) +
	  pow(c0y,3) * (-4 * c2y + 18 * c3y) - 11 * pow(c1x,3) * etax - 11 * c1x * pow(c1y,2) * etax + 29 * pow(c1x,2) * c2x * etax +
	  8 * pow(c1y,2) * c2x * etax + 21 * c1x * c1y * c2y * etax - 5 * pow(c1x,2) * pow(etax,2) - 2 * pow(c1y,2) * pow(etax,2) +
	  40 * c1x * c2x * pow(etax,2) - 20 * pow(c2x,2) * pow(etax,2) + 18 * c1y * c2y * pow(etax,2) -
	  12 * pow(c2y,2) * pow(etax,2) - 45 * c1x * c3x * pow(etax,2) - 24 * c1y * c3y * pow(etax,2) + 4 * c2x * pow(etax,3) -
	  18 * c3x * pow(etax,3) + (-11 * pow(c1y,3) + 29 * pow(c1y,2) * c2y + pow(c1x,2) * (-11 * c1y + 8 * c2y) +
		 c1y * (22 * c2x - 21 * c3x) * etax + c1x * (21 * c1y * c2x - 6 * c1y * etax + 22 * c2y * etax - 21 * c3y * etax) +
		 2 * etax * (-8 * c2x * c2y + 2 * c2y * etax - 9 * c3y * etax)) * etay -
	  (5 * (pow(c1y,2) - 8 * c1y * c2y + 4 * pow(c2y,2) + 9 * c1y * c3y) +
		 2 * (pow(c1x,2) - 9 * c1x * c2x + 6 * pow(c2x,2) + 12 * c1x * c3x - 2 * c2x * etax + 9 * c3x * etax)) * pow(etay,2) +
	  2 * (2 * c2y - 9 * c3y) * pow(etay,3) - pow(c0y,2) *
	   (5 * (pow(c1y,2) - 8 * c1y * c2y + 4 * pow(c2y,2) + 9 * c1y * c3y) +
		 2 * (pow(c1x,2) - 9 * c1x * c2x + 6 * pow(c2x,2) + 12 * c1x * c3x - 2 * c2x * etax + 9 * c3x * etax) + 6 * (-2 * c2y + 9 * c3y) * etay)\
	   - pow(c0x,2) * (5 * (pow(c1x,2) - 8 * c1x * c2x + 4 * pow(c2x,2) + 9 * c1x * c3x) + 6 * (-2 * c2x + 9 * c3x) * etax +
		 2 * (pow(c1y,2) + 2 * c0y * c2y - 9 * c1y * c2y + 6 * pow(c2y,2) - 9 * c0y * c3y + 12 * c1y * c3y - 2 * c2y * etay + 9 * c3y * etay)) +
	  c0x * (11 * pow(c1x,3) - 8 * pow(c1y,2) * c2x + pow(c0y,2) * (-4 * c2x + 18 * c3x) + 4 * pow(c1y,2) * etax +
		 40 * pow(c2x,2) * etax - 36 * c1y * c2y * etax + 24 * pow(c2y,2) * etax + 48 * c1y * c3y * etax - 12 * c2x * pow(etax,2) +
		 54 * c3x * pow(etax,2) + pow(c1x,2) * (-29 * c2x + 10 * etax) - 22 * c1y * c2x * etay + 16 * c2x * c2y * etay + 21 * c1y * c3x * etay -
		 8 * c2y * etax * etay + 36 * c3y * etax * etay - 4 * c2x * pow(etay,2) + 18 * c3x * pow(etay,2) +
		 c0y * (22 * c1y * c2x - 16 * c2x * c2y - 21 * c1y * c3x + 8 * c2y * etax - 36 * c3y * etax + 8 * c2x * etay - 36 * c3x * etay) +
		 c1x * (11 * pow(c1y,2) - 21 * c1y * c2y + c0y * (-6 * c1y + 22 * c2y - 21 * c3y) - 80 * c2x * etax + 90 * c3x * etax + 6 * c1y * etay -
			22 * c2y * etay + 21 * c3y * etay)) + c0y * (11 * pow(c1y,3) + 2 * etax * (8 * c2x * c2y - 2 * c2y * etax + 9 * c3y * etax) +
		 4 * (6 * pow(c2x,2) + 10 * pow(c2y,2) - 2 * c2x * etax + 9 * c3x * etax) * etay + 6 * (-2 * c2y + 9 * c3y) * pow(etay,2) +
		 pow(c1x,2) * (11 * c1y - 8 * c2y + 4 * etay) + pow(c1y,2) * (-29 * c2y + 10 * etay) +
		 c1x * (-21 * c1y * c2x + 6 * c1y * etax - 22 * c2y * etax + 21 * c3y * etax - 36 * c2x * etay + 48 * c3x * etay) +
		 c1y * (-22 * c2x * etax + 21 * c3x * etax - 80 * c2y * etay + 90 * c3y * etay))) / 24.,
   (5 * pow(c1x,4) - 7 * c0y * pow(c1y,3) + 5 * pow(c1y,4) + 20 * pow(c0y,2) * pow(c2x,2) - 22 * c0y * c1y * pow(c2x,2) -
	  24 * pow(c0y,2) * c1y * c2y + 68 * c0y * pow(c1y,2) * c2y - 15 * pow(c1y,3) * c2y + 40 * pow(c0y,2) * pow(c2y,2) -
	  52 * c0y * c1y * pow(c2y,2) - 10 * pow(c0x,3) * c3x - 50 * pow(c0y,2) * c2x * c3x - 10 * pow(c0y,3) * c3y +
	  88 * pow(c0y,2) * c1y * c3y - 59 * c0y * pow(c1y,2) * c3y - 80 * pow(c0y,2) * c2y * c3y + 14 * c0y * c1y * c2x * etax -
	  20 * pow(c1y,2) * c2x * etax - 40 * c0y * c2x * c2y * etax + 30 * c1y * c2x * c2y * etax + 10 * pow(c0y,2) * c3x * etax -
	  48 * c0y * c1y * c3x * etax + 15 * pow(c1y,2) * c3x * etax + 30 * c0y * c2y * c3x * etax + 30 * c0y * c2x * c3y * etax +
	  40 * pow(c2x,2) * pow(etax,2) - 10 * c1y * c2y * pow(etax,2) + 20 * pow(c2y,2) * pow(etax,2) -
	  80 * c2x * c3x * pow(etax,2) - 10 * c0y * c3y * pow(etax,2) + 40 * c1y * c3y * pow(etax,2) - 50 * c2y * c3y * pow(etax,2) +
	  10 * c3x * pow(etax,3) + pow(c1x,3) * (-15 * c2x + 7 * etax) +
	  (7 * pow(c1y,3) + pow(c1y,2) * (-68 * c2y + 59 * c3y) +
		 2 * c1y * (11 * pow(c2x,2) + 24 * c0y * c2y + 26 * pow(c2y,2) - 88 * c0y * c3y - 7 * c2x * etax + 24 * c3x * etax) +
		 10 * (3 * pow(c0y,2) * c3y - 2 * c0y * (2 * pow(c2x,2) - 5 * c2x * c3x + 4 * c2y * (c2y - 2 * c3y) + c3x * etax) +
			etax * (4 * c2x * c2y - 3 * c2y * c3x - 3 * c2x * c3y + c3y * etax))) * etay +
	  2 * (10 * pow(c2x,2) - 25 * c2x * c3x + c1y * (-12 * c2y + 44 * c3y) + 5 * (4 * c2y * (c2y - 2 * c3y) - 3 * c0y * c3y + c3x * etax)) *
	   pow(etay,2) + 10 * c3y * pow(etay,3) + pow(c1x,2) *
	   (5 * c1y * (2 * c1y - 3 * c2y) + c0y * (-7 * c1y + 20 * c2y - 15 * c3y) - 68 * c2x * etax + 59 * c3x * etax +
		 (7 * c1y - 20 * c2y + 15 * c3y) * etay) + 2 * pow(c0x,2) *
	   (c1x * (-12 * c2x + 44 * c3x) + 5 * (-(c1y * c2y) + 2 * pow(c2y,2) + 4 * c2x * (c2x - 2 * c3x) - c0y * c3y + 4 * c1y * c3y - 5 * c2y * c3y +
			3 * c3x * etax + c3y * etay)) + c1x * (-10 * pow(c0y,2) * (c2x - 4 * c3x) + pow(c1y,2) * (-15 * c2x + 7 * etax) +
		 2 * c0y * (24 * c1y * c2x - 15 * c2x * c2y - 22 * c1y * c3x + 7 * c2y * etax - 24 * c3y * etax + 10 * (c2x - 4 * c3x) * etay) +
		 c1y * (-48 * c2y * etax + 44 * c3y * etax - 48 * c2x * etay + 44 * c3x * etay) +
		 2 * (etax * (26 * pow(c2x,2) + 11 * pow(c2y,2) - 12 * c2x * etax + 44 * c3x * etax) +
			(15 * c2x * c2y - 7 * c2y * etax + 24 * c3y * etax) * etay - 5 * (c2x - 4 * c3x) * pow(etay,2))) -
	  c0x * (7 * pow(c1x,3) + 10 * pow(c0y,2) * c3x + pow(c1x,2) * (-68 * c2x + 59 * c3x) +
		 5 * (c1y * (-4 * c1y * c2x + 6 * c2x * c2y + 3 * c1y * c3x) +
			4 * (-(c1y * c2y) + 2 * pow(c2y,2) + 4 * c2x * (c2x - 2 * c3x) + 4 * c1y * c3y - 5 * c2y * c3y) * etax + 6 * c3x * pow(etax,2)) +
		 2 * (c1y * (-7 * c2x + 24 * c3x) + 5 * (4 * c2x * c2y - 3 * c2y * c3x - 3 * c2x * c3y + 2 * c3y * etax)) * etay + 10 * c3x * pow(etay,2) +
		 c1x * (7 * pow(c1y,2) + 52 * pow(c2x,2) + 14 * c0y * c2y - 48 * c1y * c2y + 22 * pow(c2y,2) - 48 * c0y * c3y + 44 * c1y * c3y -
			48 * c2x * etax + 176 * c3x * etax - 14 * c2y * etay + 48 * c3y * etay) +
		 2 * c0y * (c1y * (7 * c2x - 24 * c3x) - 5 * (4 * c2x * c2y - 3 * c2y * c3x - 3 * c2x * c3y + 2 * c3y * etax + 2 * c3x * etay)))) / 40.,
   (-6 * pow(c1x,4) - 6 * pow(c1y,4) - 44 * pow(c0x,2) * pow(c2x,2) - 20 * pow(c0y,2) * pow(c2x,2) -
	  52 * c0x * pow(c2x,3) - 48 * c0x * c0y * c2x * c2y - 52 * c0y * pow(c2x,2) * c2y - 20 * pow(c0x,2) * pow(c2y,2) -
	  44 * pow(c0y,2) * pow(c2y,2) - 52 * c0x * c2x * pow(c2y,2) - 52 * c0y * pow(c2y,3) + pow(c1x,3) * (69 * c2x - 52 * c3x) +
	  288 * pow(c0x,2) * c2x * c3x + 150 * pow(c0y,2) * c2x * c3x + 138 * c0x * c0y * c2y * c3x - 135 * pow(c0x,2) * pow(c3x,2) -
	  90 * pow(c0y,2) * pow(c3x,2) + pow(c1y,3) * (69 * c2y - 52 * c3y) + 138 * c0x * c0y * c2x * c3y + 150 * pow(c0x,2) * c2y * c3y +
	  288 * pow(c0y,2) * c2y * c3y - 90 * c0x * c0y * c3x * c3y - 90 * pow(c0x,2) * pow(c3y,2) - 135 * pow(c0y,2) * pow(c3y,2) +
	  88 * c0x * pow(c2x,2) * etax + 52 * pow(c2x,3) * etax + 48 * c0y * c2x * c2y * etax + 40 * c0x * pow(c2y,2) * etax +
	  52 * c2x * pow(c2y,2) * etax - 576 * c0x * c2x * c3x * etax - 138 * c0y * c2y * c3x * etax + 270 * c0x * pow(c3x,2) * etax -
	  138 * c0y * c2x * c3y * etax - 300 * c0x * c2y * c3y * etax + 90 * c0y * c3x * c3y * etax + 180 * c0x * pow(c3y,2) * etax -
	  44 * pow(c2x,2) * pow(etax,2) - 20 * pow(c2y,2) * pow(etax,2) + 288 * c2x * c3x * pow(etax,2) -
	  135 * pow(c3x,2) * pow(etax,2) + 150 * c2y * c3y * pow(etax,2) - 90 * pow(c3y,2) * pow(etax,2) +
	  2 * (26 * c2y * (pow(c2x,2) + pow(c2y,2)) + 3 * c0x * (8 * c2x * c2y - 23 * c2y * c3x - 23 * c2x * c3y + 15 * c3x * c3y) +
		 c0y * (20 * pow(c2x,2) + 44 * pow(c2y,2) - 150 * c2x * c3x + 90 * pow(c3x,2) - 288 * c2y * c3y + 135 * pow(c3y,2)) +
		 3 * (-8 * c2x * c2y + 23 * c2y * c3x + 23 * c2x * c3y - 15 * c3x * c3y) * etax) * etay -
	  (20 * pow(c2x,2) + 44 * pow(c2y,2) - 150 * c2x * c3x + 90 * pow(c3x,2) - 288 * c2y * c3y + 135 * pow(c3y,2)) *
	   pow(etay,2) - pow(c1x,2) * (12 * pow(c1y,2) + 79 * c0x * c2x + 71 * pow(c2x,2) + 24 * c0y * c2y - 69 * c1y * c2y +
		 26 * pow(c2y,2) - 249 * c0x * c3x - 69 * c0y * c3y + 52 * c1y * c3y - 79 * c2x * etax + 249 * c3x * etax - 24 * c2y * etay + 69 * c3y * etay)
		- pow(c1y,2) * (24 * c0x * c2x + 26 * pow(c2x,2) + 79 * c0y * c2y + 71 * pow(c2y,2) - 69 * c0x * c3x - 249 * c0y * c3y -
		 24 * c2x * etax + 69 * c3x * etax - 79 * c2y * etay + 249 * c3y * etay) -
	  c1x * (40 * pow(c0y,2) * c3x + pow(c1y,2) * (-69 * c2x + 52 * c3x) +
		 (-228 * pow(c2x,2) + 354 * c2x * c3x + 10 * c2y * (-9 * c2y + 16 * c3y) + 95 * c3x * (c0x - etax)) * (c0x - etax) +
		 (-104 * c2y * c3x + 6 * c2x * (23 * c2y - 15 * c3y) + 55 * c3y * (-c0x + etax)) * etay + 40 * c3x * pow(etay,2) +
		 c0y * (55 * c1y * c2x - 138 * c2x * c2y - 180 * c1y * c3x + 104 * c2y * c3x + 55 * c0x * c3y + 90 * c2x * c3y - 55 * c3y * etax -
			80 * c3x * etay) + 5 * c1y * (11 * c0x * c2y + 18 * c2x * c2y - 36 * c0x * c3y - 11 * c2y * etax + 36 * c3y * etax - 11 * c2x * etay +
			36 * c3x * etay)) - c1y * (95 * pow(c0y,2) * c3y +
		 2 * (c0x - etax) * (-69 * c2x * c2y + 45 * c2y * c3x + 20 * c0x * c3y + 52 * c2x * c3y - 20 * c3y * etax) +
		 (90 * pow(c2x,2) - 160 * c2x * c3x + 6 * c2y * (38 * c2y - 59 * c3y) + 55 * c3x * (-c0x + etax)) * etay + 95 * c3y * pow(etay,2) +
		 c0y * (-90 * pow(c2x,2) - 228 * pow(c2y,2) + 160 * c2x * c3x + 354 * c2y * c3y + 55 * c3x * (c0x - etax) - 190 * c3y * etay))) / 120.
	,(140 * pow(c1y,2) * pow(c2x,2) + 280 * c0x * pow(c2x,3) - 98 * pow(c1y,3) * c2y - 196 * c0x * c1y * c2x * c2y -
	  168 * c1y * pow(c2x,2) * c2y + 392 * pow(c1y,2) * pow(c2y,2) + 280 * c0x * c2x * pow(c2y,2) - 168 * c1y * pow(c2y,3) -
	  98 * c0x * pow(c1y,2) * c3x - 371 * pow(c0x,2) * c2x * c3x - 210 * pow(c1y,2) * c2x * c3x - 588 * c0x * pow(c2x,2) * c3x +
	  504 * c0x * c1y * c2y * c3x - 168 * c0x * pow(c2y,2) * c3x + 567 * pow(c0x,2) * pow(c3x,2) + pow(c1x,3) * (-98 * c2x + 280 * c3x) +
	  280 * pow(c1y,3) * c3y + 560 * c0x * c1y * c2x * c3y - 175 * pow(c0x,2) * c2y * c3y - 546 * pow(c1y,2) * c2y * c3y -
	  420 * c0x * c2x * c2y * c3y - 336 * c0x * c1y * c3x * c3y + 315 * pow(c0x,2) * pow(c3y,2) -
	  7 * pow(c0y,2) * (5 * (5 * c2x - 9 * c3x) * c3x + 53 * c2y * c3y - 81 * pow(c3y,2)) - 280 * pow(c2x,3) * etax +
	  196 * c1y * c2x * c2y * etax - 280 * c2x * pow(c2y,2) * etax + 98 * pow(c1y,2) * c3x * etax + 742 * c0x * c2x * c3x * etax +
	  588 * pow(c2x,2) * c3x * etax - 504 * c1y * c2y * c3x * etax + 168 * pow(c2y,2) * c3x * etax - 1134 * c0x * pow(c3x,2) * etax -
	  560 * c1y * c2x * c3y * etax + 350 * c0x * c2y * c3y * etax + 420 * c2x * c2y * c3y * etax + 336 * c1y * c3x * c3y * etax -
	  630 * c0x * pow(c3y,2) * etax - 371 * c2x * c3x * pow(etax,2) + 567 * pow(c3x,2) * pow(etax,2) -
	  175 * c2y * c3y * pow(etax,2) + 315 * pow(c3y,2) * pow(etax,2) -
	  2 * c0y * (169 * pow(c1y,2) * c3y + c1y * (60 * pow(c2x,2) + 158 * pow(c2y,2) - 380 * c2x * c3x + 165 * pow(c3x,2) -
			912 * c2y * c3y + 333 * pow(c3y,2)) + 14 *
		  (-10 * pow(c2y,3) + 15 * c2x * c2y * c3x + 21 * pow(c2y,2) * c3y + pow(c2x,2) * (-10 * c2y + 6 * c3y) +
			7 * c2y * c3x * (c0x - etax) + 7 * c2x * c3y * (c0x - etax) + 18 * c3x * c3y * (-c0x + etax))) +
	  14 * c0y * (5 * (5 * c2x - 9 * c3x) * c3x + 53 * c2y * c3y - 81 * pow(c3y,2)) * etay +
	  2 * (169 * pow(c1y,2) * c3y + c1y * (60 * pow(c2x,2) + 158 * pow(c2y,2) - 380 * c2x * c3x + 165 * pow(c3x,2) - 912 * c2y * c3y +
			333 * pow(c3y,2)) + 14 * (-10 * pow(c2y,3) + 15 * c2x * c2y * c3x + 21 * pow(c2y,2) * c3y +
			pow(c2x,2) * (-10 * c2y + 6 * c3y) + 7 * c2y * c3x * (c0x - etax) + 7 * c2x * c3y * (c0x - etax) + 18 * c3x * c3y * (-c0x + etax))) *
	   etay - 7 * (5 * (5 * c2x - 9 * c3x) * c3x + 53 * c2y * c3y - 81 * pow(c3y,2)) * pow(etay,2) +
	  2 * pow(c1x,2) * (196 * pow(c2x,2) - 273 * c2x * c3x + 35 * c2y * (2 * c2y - 3 * c3y) - 49 * c0y * c3y + 7 * c1y * (-7 * c2y + 20 * c3y) +
		 169 * c3x * (-c0x + etax) + 49 * c3y * etay) - 2 * c1x *
	   (84 * pow(c2x,3) + 98 * c0y * c2x * c2y + 84 * c2x * pow(c2y,2) + 7 * pow(c1y,2) * (7 * c2x - 20 * c3x) - 280 * c0y * c2y * c3x -
		 252 * c0y * c2x * c3y + 168 * c0y * c3x * c3y + 84 * c1y * c2x * (-3 * c2y + 2 * c3y) +
		 c0x * (158 * pow(c2x,2) + 60 * pow(c2y,2) - 912 * c2x * c3x + 333 * pow(c3x,2) - 380 * c2y * c3y + 165 * pow(c3y,2)) -
		 158 * pow(c2x,2) * etax - 60 * pow(c2y,2) * etax + 912 * c2x * c3x * etax - 333 * pow(c3x,2) * etax + 380 * c2y * c3y * etax -
		 165 * pow(c3y,2) * etax + 14 * (-7 * c2x * c2y + 20 * c2y * c3x + 18 * c2x * c3y - 12 * c3x * c3y) * etay +
		 24 * c1y * (5 * c0y * c3x + 7 * c2y * c3x + 5 * c0x * c3y - 5 * c3y * etax - 5 * c3x * etay))) / 420.,
   (-152 * pow(c1x,3) * c3x - 152 * pow(c1y,3) * c3y -
	  2 * pow(c1x,2) * (108 * pow(c2x,2) + 38 * pow(c2y,2) - 579 * c2x * c3x + 192 * pow(c3x,2) + 76 * c1y * c3y - 215 * c2y * c3y +
		 80 * pow(c3y,2)) - 2 * pow(c1y,2) * (38 * pow(c2x,2) + 108 * pow(c2y,2) - 215 * c2x * c3x + 80 * pow(c3x,2) -
		 579 * c2y * c3y + 192 * pow(c3y,2)) + c1y * (364 * pow(c2y,3) + 28 * pow(c2x,2) * (13 * c2y - 8 * c3y) -
		 714 * pow(c2y,2) * c3y + 7 * c0y * (85 * pow(c3x,2) + 189 * pow(c3y,2)) + 728 * c3x * c3y * (c0x - etax) +
		 280 * c2y * c3x * (-c0x + etax) + 304 * c2x * c3y * (-c0x + etax) - 35 * c2x * c3x * (11 * c0y + 14 * c2y - 11 * etay) -
		 7 * (85 * pow(c3x,2) + 189 * pow(c3y,2)) * etay + 969 * c2y * c3y * (-c0y + etay)) +
	  c1x * (364 * pow(c2x,3) - 152 * pow(c1y,2) * c3x - 714 * pow(c2x,2) * c3x - 304 * c0y * c2y * c3x - 224 * pow(c2y,2) * c3x +
		 1323 * c0x * pow(c3x,2) + 56 * c1y * c3x * (13 * c2y - 8 * c3y) - 385 * c0x * c2y * c3y + 728 * c0y * c3x * c3y + 595 * c0x * pow(c3y,2) -
		 1323 * pow(c3x,2) * etax + 385 * c2y * c3y * etax - 595 * pow(c3y,2) * etax + 8 * c3x * (38 * c2y - 91 * c3y) * etay +
		 c2x * (364 * pow(c2y,2) - 490 * c2y * c3y + 56 * c1y * (-5 * c2y + 13 * c3y) + 969 * c3x * (-c0x + etax) + 280 * c3y * (-c0y + etay)))\
	   - 2 * (28 * pow(c2x,4) + 76 * c0y * pow(c2y,3) + 28 * pow(c2y,4) + 70 * pow(c0y,2) * pow(c3x,2) +
		 160 * c0y * c2y * pow(c3x,2) - 612 * c0y * pow(c2y,2) * c3y + 140 * pow(c0y,2) * pow(c3y,2) + 405 * c0y * c2y * pow(c3y,2) +
		 70 * pow(c0x,2) * (2 * pow(c3x,2) + pow(c3y,2)) - 76 * pow(c2x,3) * etax + 182 * pow(c2y,2) * c3x * etax -
		 140 * c0y * c3x * c3y * etax - 245 * c2y * c3x * c3y * etax + 140 * pow(c3x,2) * pow(etax,2) + 70 * pow(c3y,2) * pow(etax,2) -
		 (76 * pow(c2y,3) - 612 * pow(c2y,2) * c3y + 5 * c2y * (32 * pow(c3x,2) + 81 * pow(c3y,2)) +
			140 * (c0y * (pow(c3x,2) + 2 * pow(c3y,2)) - c3x * c3y * etax)) * etay +
		 70 * (pow(c3x,2) + 2 * pow(c3y,2)) * pow(etay,2) +
		 2 * pow(c2x,2) * (38 * c0y * c2y + 28 * pow(c2y,2) - 91 * c0y * c3y + 306 * c3x * etax - 38 * c2y * etay + 91 * c3y * etay) -
		 c2x * (5 * c0y * c3x * (86 * c2y - 49 * c3y) + 76 * pow(c2y,2) * etax - 430 * c2y * (c3y * etax + c3x * etay) +
			5 * (81 * pow(c3x,2) * etax + 32 * pow(c3y,2) * etax + 49 * c3x * c3y * etay)) +
		 c0x * (76 * pow(c2x,3) - 612 * pow(c2x,2) * c3x +
			c2x * (76 * pow(c2y,2) + 405 * pow(c3x,2) - 430 * c2y * c3y + 160 * pow(c3y,2)) -
			7 * (26 * pow(c2y,2) * c3x - 35 * c2y * c3x * c3y +
			   20 * (-(c0y * c3x * c3y) + 2 * pow(c3x,2) * etax + pow(c3y,2) * etax + c3x * c3y * etay))))) / 560.,
   (168 * pow(c2x,4) - 276 * c1y * pow(c2y,3) + 168 * pow(c2y,4) - 420 * pow(c2x,3) * c3x - 276 * c0x * pow(c2y,2) * c3x -
	  406 * c0y * c1y * pow(c3x,2) + 441 * pow(c1y,2) * pow(c3x,2) + 882 * c0y * c2y * pow(c3x,2) - 486 * c1y * c2y * pow(c3x,2) -
	  486 * c0x * pow(c3x,3) - 867 * pow(c1y,2) * c2y * c3y - 906 * c0y * pow(c2y,2) * c3y + 2112 * c1y * pow(c2y,2) * c3y -
	  420 * pow(c2y,3) * c3y - 552 * c0x * c1y * c3x * c3y + 1440 * c0x * c2y * c3x * c3y - 486 * c0y * pow(c3x,2) * c3y -
	  958 * c0y * c1y * pow(c3y,2) + 1113 * pow(c1y,2) * pow(c3y,2) + 2322 * c0y * c2y * pow(c3y,2) - 1326 * c1y * c2y * pow(c3y,2) -
	  486 * c0x * c3x * pow(c3y,2) - 486 * c0y * pow(c3y,3) +
	  pow(c1x,2) * (-867 * c2x * c3x + 1113 * pow(c3x,2) + 63 * c3y * (-5 * c2y + 7 * c3y)) + 276 * pow(c2y,2) * c3x * etax +
	  486 * pow(c3x,3) * etax + 552 * c1y * c3x * c3y * etax - 1440 * c2y * c3x * c3y * etax + 486 * c3x * pow(c3y,2) * etax -
	  6 * pow(c2x,2) * (-56 * pow(c2y,2) + 2 * c1y * (23 * c2y - 56 * c3y) + 70 * c2y * c3y + 151 * c3x * (c0x - etax) +
		 46 * c3y * (c0y - etay)) + 2 * (453 * pow(c2y,2) * c3y + 243 * c3y * (pow(c3x,2) + pow(c3y,2)) -
		 9 * c2y * (49 * pow(c3x,2) + 129 * pow(c3y,2)) + c1y * (203 * pow(c3x,2) + 479 * pow(c3y,2))) * etay -
	  2 * c1x * (138 * pow(c2x,3) - 1056 * pow(c2x,2) * c3x - 336 * pow(c2y,2) * c3x + 479 * c0x * pow(c3x,2) +
		 12 * c1y * c3x * (23 * c2y - 56 * c3y) + 276 * c0y * c3x * c3y + 420 * c2y * c3x * c3y + 203 * c0x * pow(c3y,2) +
		 3 * c2x * (46 * pow(c2y,2) + 221 * pow(c3x,2) + 92 * c1y * c3y - 240 * c2y * c3y + 81 * pow(c3y,2)) -
		 479 * pow(c3x,2) * etax - 203 * pow(c3y,2) * etax - 276 * c3x * c3y * etay) -
	  3 * c2x * (105 * pow(c1y,2) * c3x + 140 * pow(c2y,2) * c3x - 774 * c0x * pow(c3x,2) + 30 * c0y * c3x * (7 * c2y - 16 * c3y) +
		 210 * c0x * c2y * c3y - 294 * c0x * pow(c3y,2) + 40 * c1y * c3x * (-12 * c2y + 7 * c3y) + 774 * pow(c3x,2) * etax -
		 210 * c2y * c3y * etax + 294 * pow(c3y,2) * etax - 210 * c2y * c3x * etay + 480 * c3x * c3y * etay)) / 1008.,
   (-360 * pow(c2x,4) - 360 * pow(c2y,4) + 3540 * pow(c2x,3) * c3x - 2336 * pow(c1x,2) * pow(c3x,2) -
	  896 * pow(c1y,2) * pow(c3x,2) + 3969 * c0x * pow(c3x,3) - 2232 * c1x * pow(c3x,3) + 3540 * pow(c2y,3) * c3y -
	  2880 * c1x * c1y * c3x * c3y + 3969 * c0y * pow(c3x,2) * c3y - 2232 * c1y * pow(c3x,2) * c3y - 896 * pow(c1x,2) * pow(c3y,2) -
	  2336 * pow(c1y,2) * pow(c3y,2) + 3969 * c0x * c3x * pow(c3y,2) - 2232 * c1x * c3x * pow(c3y,2) + 3969 * c0y * pow(c3y,3) -
	  2232 * c1y * pow(c3y,3) - 3 * pow(c2x,2) * (240 * pow(c2y,2) + 1495 * c1x * c3x + 1072 * pow(c3x,2) + 480 * c1y * c3y -
		 1180 * c2y * c3y + 372 * pow(c3y,2)) - 3 * pow(c2y,2) * (480 * c1x * c3x + 372 * pow(c3x,2) + c3y * (1495 * c1y + 1072 * c3y)) -
	  3969 * pow(c3x,3) * etax - 3969 * c3x * pow(c3y,2) * etax - 3969 * c3y * (pow(c3x,2) + pow(c3y,2)) * etay +
	  c2x * (3540 * pow(c2y,2) * c3x - 4837 * c0x * pow(c3x,2) + 11049 * c1x * pow(c3x,2) - 3045 * c0y * c3x * c3y -
		 105 * c2y * (29 * c1x + 40 * c3x) * c3y - 1792 * c0x * pow(c3y,2) + 3969 * c1x * pow(c3y,2) +
		 15 * c1y * c3x * (-203 * c2y + 472 * c3y) + 4837 * pow(c3x,2) * etax + 1792 * pow(c3y,2) * etax + 3045 * c3x * c3y * etay) +
	  c2y * (-7 * c0y * (256 * pow(c3x,2) + 691 * pow(c3y,2)) + 3 * c1y * (1323 * pow(c3x,2) + 3683 * pow(c3y,2)) +
		 15 * c3x * c3y * (-203 * c0x + 472 * c1x + 203 * etax) + 7 * (256 * pow(c3x,2) + 691 * pow(c3y,2)) * etay)) / 5040.,
   (-51 * pow(c2x,3) * c3x + 63 * pow(c2y,2) * pow(c3x,2) - 56 * c0x * pow(c3x,3) + 126 * c1x * pow(c3x,3) -
	  51 * pow(c2y,3) * c3y - 102 * c1x * c2y * c3x * c3y - 56 * c0y * pow(c3x,2) * c3y - 72 * c2y * pow(c3x,2) * c3y +
	  183 * pow(c2y,2) * pow(c3y,2) - 56 * c0x * c3x * pow(c3y,2) + 126 * c1x * c3x * pow(c3y,2) - 56 * c0y * pow(c3y,3) -
	  72 * c2y * pow(c3y,3) + 126 * c1y * c3y * (pow(c3x,2) + pow(c3y,2)) - 2 * c1y * c2y * (28 * pow(c3x,2) + 79 * pow(c3y,2)) +
	  3 * pow(c2x,2) * (61 * pow(c3x,2) + c3y * (-17 * c2y + 21 * c3y)) +
	  c2x * (-51 * pow(c2y,2) * c3x + 240 * c2y * c3x * c3y -
		 2 * (pow(c3x,2) * (79 * c1x + 36 * c3x) + 51 * c1y * c3x * c3y + 4 * (7 * c1x + 9 * c3x) * pow(c3y,2))) + 56 * pow(c3x,3) * etax +
	  56 * c3x * pow(c3y,2) * etax + 56 * c3y * (pow(c3x,2) + pow(c3y,2)) * etay) / 168.,
   (747 * c2y * c3y * (pow(c3x,2) + pow(c3y,2)) - 4 * (pow(c3x,2) + pow(c3y,2)) *
	   (82 * c1x * c3x + 27 * pow(c3x,2) + 82 * c1y * c3y + 27 * pow(c3y,2)) -
	  pow(c2x,2) * (479 * pow(c3x,2) + 164 * pow(c3y,2)) - pow(c2y,2) * (164 * pow(c3x,2) + 479 * pow(c3y,2)) +
	  9 * c2x * c3x * (83 * pow(c3x,2) + c3y * (-70 * c2y + 83 * c3y))) / 1008.,
   -((47 * c2x * c3x - 27 * pow(c3x,2) + (47 * c2y - 27 * c3y) * c3y) * (pow(c3x,2) + pow(c3y,2))) / 144.,
			 -pow(pow(c3x, 2) + pow(c3y, 2), 2) / 12. };
		Iy0t0 = valuesIy0[0];
		Iy0t1 = valuesIy0[1];
		Iy0t2 = valuesIy0[2];
		Iy0t3 = valuesIy0[3];
		Iy0t4 = valuesIy0[4];
		Iy0t5 = valuesIy0[5];
		Iy0t6 = valuesIy0[6];
		Iy0t7 = valuesIy0[7];
		Iy0t8 = valuesIy0[8];
		Iy0t9 = valuesIy0[9];
		Iy0t10 = valuesIy0[10];
		Iy0t11 = valuesIy0[11];
		Iy0t12 = valuesIy0[12];
		Iy0t13 = valuesIy0[13];
		Iy0t14 = valuesIy0[14];

	}
	//Iy1系数
	if (0)
	{
		std::vector<double> valuesIy1 = { 0,0,-((pow(c0x - etax,2) + pow(c0y - etay,2)) * (c0x * c1x + c0y * c1y - c1x * etax - c1y * etay)) / 4.,
   (2 * pow(c0x,3) * (c1x - 3 * c2x) + 2 * pow(c0y,3) * (c1y - 3 * c2y) -
	  pow(etax,2) * (7 * pow(c1x,2) + 3 * pow(c1y,2) + 2 * c1x * etax - 6 * c2x * etax) -
	  2 * etax * (4 * c1x * c1y + (c1y - 3 * c2y) * etax) * etay -
	  (3 * pow(c1x,2) + 7 * pow(c1y,2) + 2 * c1x * etax - 6 * c2x * etax) * pow(etay,2) - 2 * (c1y - 3 * c2y) * pow(etay,3) -
	  pow(c0y,2) * (3 * pow(c1x,2) + 7 * pow(c1y,2) + 2 * c1x * etax - 6 * c2x * etax + 6 * (c1y - 3 * c2y) * etay) -
	  pow(c0x,2) * (7 * pow(c1x,2) - 2 * c0y * c1y + 3 * pow(c1y,2) + 6 * c0y * c2y + 6 * (c1x - 3 * c2x) * etax + 2 * c1y * etay -
		 6 * c2y * etay) + 2 * c0y * (etax * (4 * c1x * c1y + (c1y - 3 * c2y) * etax) +
		 (3 * pow(c1x,2) + 7 * pow(c1y,2) + 2 * c1x * etax - 6 * c2x * etax) * etay + 3 * (c1y - 3 * c2y) * pow(etay,2)) +
	  2 * c0x * (pow(c0y,2) * (c1x - 3 * c2x) + etax * (7 * pow(c1x,2) + 3 * pow(c1y,2) + 3 * c1x * etax - 9 * c2x * etax) +
		 4 * c1x * c1y * etay + 2 * (c1y - 3 * c2y) * etax * etay + (c1x - 3 * c2x) * pow(etay,2) -
		 2 * c0y * (c1y * etax - 3 * c2y * etax - 3 * c2x * etay + c1x * (2 * c1y + etay)))) / 12.,
   (2 * pow(c0x,3) * (4 * c2x - 9 * c3x) + 2 * pow(c0y,3) * (4 * c2y - 9 * c3y) +
	  etax * (11 * c1x * (pow(c1x,2) + pow(c1y,2)) + 2 * (5 * c1x * (c1x - 4 * c2x) + c1y * (2 * c1y - 9 * c2y)) * etax +
		 2 * (-4 * c2x + 9 * c3x) * pow(etax,2)) + 2 * pow(c0x,2) *
	   (2 * pow(c1y,2) + 5 * c1x * (c1x - 4 * c2x) - 9 * c1y * c2y + 3 * (-4 * c2x + 9 * c3x) * etax + (4 * c2y - 9 * c3y) * (c0y - etay)) +
	  (11 * c1y * (pow(c1x,2) + pow(c1y,2)) + 2 * (6 * c1x * c1y - 11 * c1y * c2x - 11 * c1x * c2y) * etax +
		 2 * (-4 * c2y + 9 * c3y) * pow(etax,2)) * etay +
	  2 * (2 * pow(c1x,2) - 9 * c1x * c2x + 5 * c1y * (c1y - 4 * c2y) - 4 * c2x * etax + 9 * c3x * etax) * pow(etay,2) +
	  2 * (-4 * c2y + 9 * c3y) * pow(etay,3) + 2 * pow(c0y,2) *
	   (2 * pow(c1x,2) - 9 * c1x * c2x + 5 * c1y * (c1y - 4 * c2y) - 4 * c2x * etax + 9 * c3x * etax + 3 * (-4 * c2y + 9 * c3y) * etay) +
	  c0y * (-11 * pow(c1x,2) * c1y - 11 * pow(c1y,3) - 12 * c1x * c1y * etax + 22 * c1y * c2x * etax + 22 * c1x * c2y * etax +
		 8 * c2y * pow(etax,2) - 18 * c3y * pow(etax,2) -
		 4 * (2 * pow(c1x,2) - 9 * c1x * c2x + 5 * c1y * (c1y - 4 * c2y) - 4 * c2x * etax + 9 * c3x * etax) * etay +
		 6 * (4 * c2y - 9 * c3y) * pow(etay,2)) + c0x * (-11 * pow(c1x,3) - 20 * pow(c1x,2) * etax +
		 c1x * (12 * c0y * c1y - 11 * pow(c1y,2) - 22 * c0y * c2y + 80 * c2x * etax - 12 * c1y * etay + 22 * c2y * etay) +
		 2 * (pow(c0y,2) * (4 * c2x - 9 * c3x) + etax * (-4 * pow(c1y,2) + 18 * c1y * c2y + 12 * c2x * etax - 27 * c3x * etax) +
			(11 * c1y * c2x + 8 * c2y * etax - 18 * c3y * etax) * etay + (4 * c2x - 9 * c3x) * pow(etay,2) +
			c0y * (-11 * c1y * c2x - 8 * c2y * etax + 18 * c3y * etax - 8 * c2x * etay + 18 * c3x * etay)))) / 24.,
   (-5 * pow(c1x,4) + 14 * c0y * pow(c1y,3) - 5 * pow(c1y,4) - 20 * pow(c0y,2) * pow(c2x,2) + 48 * pow(c0y,2) * c1y * c2y -
	  68 * c0y * pow(c1y,2) * c2y - 40 * pow(c0y,2) * pow(c2y,2) + 20 * pow(c0x,3) * c3x + 20 * pow(c0y,3) * c3y -
	  88 * pow(c0y,2) * c1y * c3y - 14 * pow(c1x,3) * etax - 28 * c0y * c1y * c2x * etax + 20 * pow(c1y,2) * c2x * etax +
	  40 * c0y * c2x * c2y * etax - 20 * pow(c0y,2) * c3x * etax + 48 * c0y * c1y * c3x * etax - 40 * pow(c2x,2) * pow(etax,2) +
	  20 * c1y * c2y * pow(etax,2) - 20 * pow(c2y,2) * pow(etax,2) + 20 * c0y * c3y * pow(etax,2) - 40 * c1y * c3y * pow(etax,2) -
	  20 * c3x * pow(etax,3) + 2 * (-7 * pow(c1y,3) + 34 * pow(c1y,2) * c2y +
		 c1y * (-48 * c0y * c2y + 88 * c0y * c3y + 14 * c2x * etax - 24 * c3x * etax) -
		 10 * (3 * pow(c0y,2) * c3y - 2 * c0y * (pow(c2x,2) + 2 * pow(c2y,2) + c3x * etax) + etax * (2 * c2x * c2y + c3y * etax))) * etay -
	  4 * (5 * pow(c2x,2) - 12 * c1y * c2y + 10 * pow(c2y,2) - 15 * c0y * c3y + 22 * c1y * c3y + 5 * c3x * etax) * pow(etay,2) -
	  20 * c3y * pow(etay,3) + 2 * pow(c1x,2) * (7 * c0y * c1y - 5 * pow(c1y,2) - 10 * c0y * c2y + 34 * c2x * etax - 7 * c1y * etay +
		 10 * c2y * etay) + 2 * c1x * (10 * pow(c0y,2) * (c2x - 2 * c3x) +
		 etax * (-7 * pow(c1y,2) + 24 * c1y * c2y + 24 * c2x * etax - 44 * c3x * etax) +
		 2 * (12 * c1y * c2x + 7 * c2y * etax - 12 * c3y * etax) * etay + 10 * (c2x - 2 * c3x) * pow(etay,2) -
		 2 * c0y * (12 * c1y * c2x + 7 * c2y * etax - 12 * c3y * etax + 10 * (c2x - 2 * c3x) * etay)) +
	  4 * pow(c0x,2) * (2 * c1x * (6 * c2x - 11 * c3x) - 5 *
		  (2 * pow(c2x,2) - c1y * c2y + pow(c2y,2) - c0y * c3y + 2 * c1y * c3y + 3 * c3x * etax + c3y * etay)) +
	  2 * c0x * (7 * pow(c1x,3) - 34 * pow(c1x,2) * c2x +
		 c1x * (7 * pow(c1y,2) - 24 * c1y * c2y - 48 * c2x * etax + 88 * c3x * etax + 2 * (7 * c2y - 12 * c3y) * (c0y - etay)) +
		 2 * (-5 * pow(c1y,2) * c2x + c0y * c1y * (7 * c2x - 12 * c3x) + 5 * pow(c0y,2) * c3x +
			5 * etax * (4 * pow(c2x,2) + 2 * pow(c2y,2) + 3 * c3x * etax) + 10 * (c2x * c2y + c3y * etax) * etay + 5 * c3x * pow(etay,2) -
			10 * c0y * (c2x * c2y + c3y * etax + c3x * etay) + c1y * (-10 * c2y * etax + 20 * c3y * etax - 7 * c2x * etay + 12 * c3x * etay)))) / 40.,
   (12 * pow(c1x,4) + 12 * pow(c1y,4) - 69 * pow(c1x,3) * c2x - 69 * pow(c1y,3) * c2y +
	  pow(c1y,2) * (3 * (16 * c2x - 23 * c3x) * (c0x - etax) + (158 * c2y - 249 * c3y) * (c0y - etay)) +
	  pow(c1x,2) * (24 * pow(c1y,2) - 69 * c1y * c2y + (158 * c2x - 249 * c3x) * (c0x - etax) + 3 * (16 * c2y - 23 * c3y) * (c0y - etay)) +
	  c1x * (-69 * pow(c1y,2) * c2x + 80 * pow(c0y,2) * c3x -
		 2 * (c0x - etax) * (114 * pow(c2x,2) + 45 * pow(c2y,2) + 95 * c3x * (-c0x + etax)) +
		 2 * (69 * c2x * c2y + 55 * c3y * (-c0x + etax)) * etay + 80 * c3x * pow(etay,2) +
		 2 * c0y * (55 * c1y * c2x - 69 * c2x * c2y - 90 * c1y * c3x + 55 * c3y * (c0x - etax) - 80 * c3x * etay) +
		 10 * c1y * ((11 * c2y - 18 * c3y) * (c0x - etax) - 11 * c2x * etay + 18 * c3x * etay)) +
	  2 * c1y * (95 * pow(c0y,2) * c3y + (-69 * c2x * c2y + 40 * c3y * (c0x - etax)) * (c0x - etax) +
		 (45 * pow(c2x,2) + 114 * pow(c2y,2) + 55 * c3x * (-c0x + etax)) * etay + 95 * c3y * pow(etay,2) -
		 c0y * (45 * pow(c2x,2) + 114 * pow(c2y,2) + 55 * c3x * (-c0x + etax) + 190 * c3y * etay)) +
	  2 * (pow(c0y,2) * (20 * pow(c2x,2) - 75 * c2x * c3x + 4 * c2y * (11 * c2y - 36 * c3y)) +
		 pow(c0x,2) * (44 * pow(c2x,2) - 144 * c2x * c3x + 5 * c2y * (4 * c2y - 15 * c3y)) +
		 (44 * pow(c2x, 2) - 144 * c2x * c3x + 5 * c2y * (4 * c2y - 15 * c3y)) * pow(etax, 2) +
			 3 * (16 * c2x * c2y - 23 * c2y * c3x - 23 * c2x * c3y) * etax * etay +
			 (20 * pow(c2x, 2) - 75 * c2x * c3x + 4 * c2y * (11 * c2y - 36 * c3y)) * pow(etay, 2) +
			 c0x * (c0y * (48 * c2x * c2y - 69 * c2y * c3x - 69 * c2x * c3y) - 88 * pow(c2x, 2) * etax +
				 c2y * (-40 * c2y * etax + 150 * c3y * etax + 69 * c3x * etay) + 3 * c2x * (96 * c3x * etax - 16 * c2y * etay + 23 * c3y * etay)) +
			 c0y * (-40 * pow(c2x, 2) * etay + c2x * (-48 * c2y * etax + 69 * c3y * etax + 150 * c3x * etay) +
				 c2y * (69 * c3x * etax - 88 * c2y * etay + 288 * c3y * etay)))) / 120.,
				 (-140 * pow(c1y, 2) * pow(c2x, 2) - 280 * c0x * pow(c2x, 3) + 196 * pow(c1y, 3) * c2y + 392 * c0x * c1y * c2x * c2y -
					 392 * pow(c1y, 2) * pow(c2y, 2) - 280 * c0x * c2x * pow(c2y, 2) + 28 * pow(c1x, 3) * (7 * c2x - 10 * c3x) +
					 196 * c0x * pow(c1y, 2) * c3x + 742 * pow(c0x, 2) * c2x * c3x - 504 * c0x * c1y * c2y * c3x - 567 * pow(c0x, 2) * pow(c3x, 2) +
					 8 * c0y * c1y * (30 * pow(c2x, 2) - 95 * c2x * c3x + c2y * (79 * c2y - 228 * c3y)) + 676 * c0y * pow(c1y, 2) * c3y -
					 280 * pow(c1y, 3) * c3y - 560 * c0x * c1y * c2x * c3y + 350 * pow(c0x, 2) * c2y * c3y - 315 * pow(c0x, 2) * pow(c3y, 2) +
					 7 * pow(c0y, 2) * (50 * c2x * c3x - 45 * pow(c3x, 2) + (106 * c2y - 81 * c3y) * c3y) + 280 * pow(c2x, 3) * etax -
					 392 * c1y * c2x * c2y * etax + 280 * c2x * pow(c2y, 2) * etax - 196 * pow(c1y, 2) * c3x * etax - 1484 * c0x * c2x * c3x * etax +
					 504 * c1y * c2y * c3x * etax + 1134 * c0x * pow(c3x, 2) * etax + 560 * c1y * c2x * c3y * etax - 700 * c0x * c2y * c3y * etax +
					 630 * c0x * pow(c3y, 2) * etax + 742 * c2x * c3x * pow(etax, 2) - 567 * pow(c3x, 2) * pow(etax, 2) +
					 350 * c2y * c3y * pow(etax, 2) - 315 * pow(c3y, 2) * pow(etax, 2) -
					 56 * c0y * (5 * pow(c2x, 2) * c2y + 5 * pow(c2y, 3) + 9 * c3x * c3y * (c0x - etax) + 7 * c2y * c3x * (-c0x + etax) +
						 7 * c2x * c3y * (-c0x + etax)) - 8 * c1y * (30 * pow(c2x, 2) - 95 * c2x * c3x + c2y * (79 * c2y - 228 * c3y)) * etay -
					 676 * pow(c1y, 2) * c3y * etay - 14 * c0y * (50 * c2x * c3x - 45 * pow(c3x, 2) + (106 * c2y - 81 * c3y) * c3y) * etay +
					 56 * (5 * pow(c2x, 2) * c2y + 5 * pow(c2y, 3) + 9 * c3x * c3y * (c0x - etax) + 7 * c2y * c3x * (-c0x + etax) +
						 7 * c2x * c3y * (-c0x + etax)) * etay + 7 * (50 * c2x * c3x - 45 * pow(c3x, 2) + (106 * c2y - 81 * c3y) * c3y) * pow(etay, 2) -
					 4 * pow(c1x, 2) * (98 * pow(c2x, 2) + 35 * pow(c2y, 2) + c1y * (-49 * c2y + 70 * c3y) + 169 * c3x * (-c0x + etax) +
						 49 * c3y * (-c0y + etay)) + 4 * c1x * (-126 * c1y * c2x * c2y + 7 * pow(c1y, 2) * (7 * c2x - 10 * c3x) +
							 120 * c1y * (c0y * c3x + c0x * c3y - c3y * etax - c3x * etay) +
							 2 * (c0x * (79 * pow(c2x, 2) - 228 * c2x * c3x + 5 * c2y * (6 * c2y - 19 * c3y)) + 7 * c0y * (7 * c2x * c2y - 10 * c2y * c3x - 9 * c2x * c3y) -
								 79 * pow(c2x, 2) * etax - 30 * pow(c2y, 2) * etax + 228 * c2x * c3x * etax + 95 * c2y * c3y * etax - 49 * c2x * c2y * etay +
								 70 * c2y * c3x * etay + 63 * c2x * c3y * etay))) / 420.,
			 (304 * pow(c1x, 3) * c3x + 2 * pow(c1y, 2) * (76 * pow(c2x, 2) - 215 * c2x * c3x + 3 * c2y * (72 * c2y - 193 * c3y)) +
				 304 * pow(c1y, 3) * c3y + 2 * pow(c1x, 2) * (216 * pow(c2x, 2) + 76 * pow(c2y, 2) - 579 * c2x * c3x + 152 * c1y * c3y -
					 215 * c2y * c3y) - c1y * (364 * pow(c2x, 2) * c2y + 364 * pow(c2y, 3) + 7 * c0y * (85 * pow(c3x, 2) + 189 * pow(c3y, 2)) +
						 728 * c3x * c3y * (c0x - etax) + 560 * c2y * c3x * (-c0x + etax) + 608 * c2x * c3y * (-c0x + etax) -
						 7 * (85 * pow(c3x, 2) + 189 * pow(c3y, 2)) * etay + 770 * c2x * c3x * (-c0y + etay) + 1938 * c2y * c3y * (-c0y + etay)) -
				 c1x * (364 * pow(c2x, 3) - 304 * pow(c1y, 2) * c3x - 608 * c0y * c2y * c3x + 728 * c1y * c2y * c3x + 1323 * c0x * pow(c3x, 2) -
					 770 * c0x * c2y * c3y + 728 * c0y * c3x * c3y + 595 * c0x * pow(c3y, 2) - 1323 * pow(c3x, 2) * etax + 770 * c2y * c3y * etax -
					 595 * pow(c3y, 2) * etax + 8 * c3x * (76 * c2y - 91 * c3y) * etay +
					 2 * c2x * (182 * pow(c2y, 2) + c1y * (-280 * c2y + 364 * c3y) + 969 * c3x * (-c0x + etax) + 280 * c3y * (-c0y + etay))) +
				 4 * (70 * pow(c0x, 2) * (2 * pow(c3x, 2) + pow(c3y, 2)) + 70 * pow(c0y, 2) * (pow(c3x, 2) + 2 * pow(c3y, 2)) +
					 etax * (-76 * pow(c2x, 3) + 306 * pow(c2x, 2) * c3x + 91 * pow(c2y, 2) * c3x + c2x * c2y * (-76 * c2y + 215 * c3y) +
						 70 * (2 * pow(c3x, 2) + pow(c3y, 2)) * etax) +
					 (-76 * pow(c2y, 3) + 215 * c2x * c2y * c3x + 306 * pow(c2y, 2) * c3y + pow(c2x, 2) * (-76 * c2y + 91 * c3y) + 140 * c3x * c3y * etax) *
					 etay + 70 * (pow(c3x, 2) + 2 * pow(c3y, 2)) * pow(etay, 2) +
					 c0x * (76 * pow(c2x, 3) - 306 * pow(c2x, 2) * c3x - 91 * pow(c2y, 2) * c3x + c2x * c2y * (76 * c2y - 215 * c3y) -
						 140 * (-(c0y * c3x * c3y) + 2 * pow(c3x, 2) * etax + pow(c3y, 2) * etax + c3x * c3y * etay)) +
					 c0y * (76 * pow(c2y, 3) - 215 * c2x * c2y * c3x + pow(c2x, 2) * (76 * c2y - 91 * c3y) - 306 * pow(c2y, 2) * c3y -
						 140 * (c3x * c3y * etax + pow(c3x, 2) * etay + 2 * pow(c3y, 2) * etay)))) / 560.,
			 (-168 * pow(c2x, 4) + 552 * c1y * pow(c2y, 3) - 168 * pow(c2y, 4) + 552 * c0x * pow(c2y, 2) * c3x + 812 * c0y * c1y * pow(c3x, 2) -
				 441 * pow(c1y, 2) * pow(c3x, 2) - 882 * c0y * c2y * pow(c3x, 2) + 1734 * pow(c1y, 2) * c2y * c3y + 1812 * c0y * pow(c2y, 2) * c3y -
				 2112 * c1y * pow(c2y, 2) * c3y + 1104 * c0x * c1y * c3x * c3y - 1440 * c0x * c2y * c3x * c3y + 1916 * c0y * c1y * pow(c3y, 2) -
				 1113 * pow(c1y, 2) * pow(c3y, 2) - 2322 * c0y * c2y * pow(c3y, 2) +
				 3 * pow(c1x, 2) * ((578 * c2x - 371 * c3x) * c3x + 21 * (10 * c2y - 7 * c3y) * c3y) - 552 * pow(c2y, 2) * c3x * etax -
				 1104 * c1y * c3x * c3y * etax + 1440 * c2y * c3x * c3y * etax +
				 12 * pow(c2x, 2) * (-28 * pow(c2y, 2) + c1y * (46 * c2y - 56 * c3y) + 151 * c3x * (c0x - etax) + 46 * c3y * (c0y - etay)) -
				 2 * (7 * (58 * c1y - 63 * c2y) * pow(c3x, 2) + 906 * pow(c2y, 2) * c3y + (958 * c1y - 1161 * c2y) * pow(c3y, 2)) * etay +
				 4 * c1x * (138 * pow(c2x, 3) - 528 * pow(c2x, 2) * c3x - 168 * pow(c2y, 2) * c3x + 479 * c0x * pow(c3x, 2) +
					 12 * c1y * c3x * (23 * c2y - 28 * c3y) + 276 * c0y * c3x * c3y + 203 * c0x * pow(c3y, 2) +
					 6 * c2x * (23 * pow(c2y, 2) + 46 * c1y * c3y - 60 * c2y * c3y) - 479 * pow(c3x, 2) * etax - 203 * pow(c3y, 2) * etax -
					 276 * c3x * c3y * etay) + 18 * c2x * (35 * pow(c1y, 2) * c3x - 80 * c1y * c2y * c3x + 10 * c0y * c3x * (7 * c2y - 8 * c3y) -
						 (129 * pow(c3x, 2) - 70 * c2y * c3y + 49 * pow(c3y, 2)) * (c0x - etax) + 10 * c3x * (-7 * c2y + 8 * c3y) * etay)) / 1008.,
			 (720 * pow(c2x, 4) + 720 * pow(c2y, 4) - 3540 * pow(c2x, 3) * c3x + 4672 * pow(c1x, 2) * pow(c3x, 2) +
				 1792 * pow(c1y, 2) * pow(c3x, 2) - 3969 * c0x * pow(c3x, 3) - 3540 * pow(c2y, 3) * c3y + 5760 * c1x * c1y * c3x * c3y -
				 3969 * c0y * pow(c3x, 2) * c3y + 1792 * pow(c1x, 2) * pow(c3y, 2) + 4672 * pow(c1y, 2) * pow(c3y, 2) -
				 3969 * c0x * c3x * pow(c3y, 2) - 3969 * c0y * pow(c3y, 3) + 30 * pow(c2y, 2) * (96 * c1x * c3x + 299 * c1y * c3y) +
				 30 * pow(c2x, 2) * (48 * pow(c2y, 2) + 299 * c1x * c3x + 96 * c1y * c3y - 118 * c2y * c3y) + 3969 * pow(c3x, 3) * etax +
				 3969 * c3x * pow(c3y, 2) * etax + 3969 * c3y * (pow(c3x, 2) + pow(c3y, 2)) * etay -
				 c2x * (3540 * pow(c2y, 2) * c3x - 9674 * c0x * pow(c3x, 2) + 11049 * c1x * pow(c3x, 2) - 6090 * c1x * c2y * c3y - 6090 * c0y * c3x * c3y -
					 3584 * c0x * pow(c3y, 2) + 3969 * c1x * pow(c3y, 2) + 30 * c1y * c3x * (-203 * c2y + 236 * c3y) + 9674 * pow(c3x, 2) * etax +
					 3584 * pow(c3y, 2) * etax + 6090 * c3x * c3y * etay) +
				 c2y * (14 * c0y * (256 * pow(c3x, 2) + 691 * pow(c3y, 2)) - 3 * c1y * (1323 * pow(c3x, 2) + 3683 * pow(c3y, 2)) +
					 30 * c3x * c3y * (203 * c0x - 236 * c1x - 203 * etax) - 14 * (256 * pow(c3x, 2) + 691 * pow(c3y, 2)) * etay)) / 5040.,
			 (102 * pow(c2x, 3) * c3x - 63 * pow(c2y, 2) * pow(c3x, 2) + 112 * c0x * pow(c3x, 3) - 126 * c1x * pow(c3x, 3) +
				 102 * pow(c2y, 3) * c3y + 204 * c1x * c2y * c3x * c3y + 112 * c0y * pow(c3x, 2) * c3y - 183 * pow(c2y, 2) * pow(c3y, 2) +
				 112 * c0x * c3x * pow(c3y, 2) - 126 * c1x * c3x * pow(c3y, 2) + 112 * c0y * pow(c3y, 3) -
				 126 * c1y * c3y * (pow(c3x, 2) + pow(c3y, 2)) + 4 * c1y * c2y * (28 * pow(c3x, 2) + 79 * pow(c3y, 2)) +
				 2 * c2x * (51 * pow(c2y, 2) * c3x + 158 * c1x * pow(c3x, 2) + 102 * c1y * c3x * c3y - 120 * c2y * c3x * c3y + 56 * c1x * pow(c3y, 2)) -
				 3 * pow(c2x, 2) * (61 * pow(c3x, 2) + c3y * (-34 * c2y + 21 * c3y)) - 112 * pow(c3x, 3) * etax - 112 * c3x * pow(c3y, 2) * etax -
				 112 * c3y * (pow(c3x, 2) + pow(c3y, 2)) * etay) / 168.,
			 (-747 * c2y * c3y * (pow(c3x, 2) + pow(c3y, 2)) + 656 * (c1x * c3x + c1y * c3y) * (pow(c3x, 2) + pow(c3y, 2)) +
				 pow(c2x, 2) * (958 * pow(c3x, 2) + 328 * pow(c3y, 2)) + pow(c2y, 2) * (328 * pow(c3x, 2) + 958 * pow(c3y, 2)) -
				 9 * c2x * c3x * (83 * pow(c3x, 2) + c3y * (-140 * c2y + 83 * c3y))) / 1008.,
			 ((94 * c2x * c3x - 27 * pow(c3x, 2) + (94 * c2y - 27 * c3y) * c3y) * (pow(c3x, 2) + pow(c3y, 2))) / 144.,
			 pow(pow(c3x, 2) + pow(c3y, 2), 2) / 6. };
		Iy1t0 = valuesIy1[0];
		Iy1t1 = valuesIy1[1];
		Iy1t2 = valuesIy1[2];
		Iy1t3 = valuesIy1[3];
		Iy1t4 = valuesIy1[4];
		Iy1t5 = valuesIy1[5];
		Iy1t6 = valuesIy1[6];
		Iy1t7 = valuesIy1[7];
		Iy1t8 = valuesIy1[8];
		Iy1t9 = valuesIy1[9];
		Iy1t10 = valuesIy1[10];
		Iy1t11 = valuesIy1[11];
		Iy1t12 = valuesIy1[12];
		Iy1t13 = valuesIy1[13];
		Iy1t14 = valuesIy1[14];

	}
	//Iy2系数
	if(0){
		std::vector<double> valuesIy2 = { 0,0,0,-((pow(c0x - etax,2) + pow(c0y - etay,2)) * (c0x * c1x + c0y * c1y - c1x * etax - c1y * etay)) / 12.,
   (-4 * pow(c0x,3) * c2x - 4 * pow(c0y,3) * c2y + pow(etax,2) * (-5 * pow(c1x,2) - 2 * pow(c1y,2) + 4 * c2x * etax) +
	  2 * etax * (-3 * c1x * c1y + 2 * c2y * etax) * etay + (-2 * pow(c1x,2) - 5 * pow(c1y,2) + 4 * c2x * etax) * pow(etay,2) +
	  4 * c2y * pow(etay,3) + pow(c0x,2) * (-5 * pow(c1x,2) - 2 * pow(c1y,2) - 4 * c0y * c2y + 12 * c2x * etax + 4 * c2y * etay) +
	  pow(c0y,2) * (-2 * pow(c1x,2) - 5 * pow(c1y,2) + 4 * c2x * etax + 12 * c2y * etay) +
	  2 * c0x * (-2 * pow(c0y,2) * c2x + 5 * pow(c1x,2) * etax + 2 * etax * (pow(c1y,2) - 3 * c2x * etax) + 3 * c1x * c1y * etay -
		 4 * c2y * etax * etay - 2 * c2x * pow(etay,2) + c0y * (-3 * c1x * c1y + 4 * c2y * etax + 4 * c2x * etay)) +
	  2 * c0y * (3 * c1x * c1y * etax + 2 * pow(c1x,2) * etay + (5 * pow(c1y,2) - 4 * c2x * etax) * etay -
		 2 * c2y * (pow(etax,2) + 3 * pow(etay,2)))) / 24.,
   (-10 * pow(c0x,3) * c3x - 10 * pow(c0y,3) * c3y +
	  etax * (7 * c1x * (pow(c1x,2) + pow(c1y,2)) - 2 * (12 * c1x * c2x + 5 * c1y * c2y) * etax + 10 * c3x * pow(etax,2)) +
	  (7 * c1y * (pow(c1x,2) + pow(c1y,2)) - 14 * (c1y * c2x + c1x * c2y) * etax + 10 * c3y * pow(etax,2)) * etay -
	  2 * (5 * c1x * c2x + 12 * c1y * c2y - 5 * c3x * etax) * pow(etay,2) + 10 * c3y * pow(etay,3) +
	  2 * pow(c0y,2) * (-5 * c1x * c2x - 12 * c1y * c2y + 5 * c3x * etax + 15 * c3y * etay) +
	  c0y * (-7 * pow(c1x,2) * c1y - 7 * pow(c1y,3) + 14 * c1y * c2x * etax + 14 * c1x * c2y * etax - 10 * c3y * pow(etax,2) +
		 4 * (5 * c1x * c2x + 12 * c1y * c2y - 5 * c3x * etax) * etay - 30 * c3y * pow(etay,2)) -
	  2 * pow(c0x,2) * (12 * c1x * c2x + 5 * (c1y * c2y + c0y * c3y - 3 * c3x * etax - c3y * etay)) -
	  c0x * (7 * pow(c1x,3) + c1x * (7 * pow(c1y,2) + 14 * c0y * c2y - 48 * c2x * etax - 14 * c2y * etay) +
		 2 * (7 * c0y * c1y * c2x + 5 * pow(c0y,2) * c3x - 10 * c1y * c2y * etax + 15 * c3x * pow(etax,2) - 7 * c1y * c2x * etay +
			10 * c3y * etax * etay + 5 * c3x * pow(etay,2) - 10 * c0y * (c3y * etax + c3x * etay)))) / 40.,
   (-6 * pow(c1x,4) - 6 * pow(c1y,4) - 4 * (12 * c0x * c0y * c2x * c2y + pow(c0x,2) * (11 * pow(c2x,2) + 5 * pow(c2y,2)) +
		 pow(c0y,2) * (5 * pow(c2x,2) + 11 * pow(c2y,2))) +
	  8 * (11 * c0x * pow(c2x,2) + 6 * c0y * c2x * c2y + 5 * c0x * pow(c2y,2)) * etax -
	  4 * (11 * pow(c2x,2) + 5 * pow(c2y,2)) * pow(etax,2) +
	  8 * (c0y * (5 * pow(c2x,2) + 11 * pow(c2y,2)) + 6 * c2x * c2y * (c0x - etax)) * etay -
	  4 * (5 * pow(c2x,2) + 11 * pow(c2y,2)) * pow(etay,2) -
	  5 * c1x * (8 * pow(c0y,2) * c3x + (11 * c1y * c2y + 19 * c3x * (c0x - etax)) * (c0x - etax) +
		 11 * c0y * (c1y * c2x + c0x * c3y - c3y * etax) - 16 * c0y * c3x * etay - 11 * (c1y * c2x + c0x * c3y - c3y * etax) * etay +
		 8 * c3x * pow(etay,2)) - 5 * c1y * (8 * pow(c0x,2) * c3y + 19 * pow(c0y,2) * c3y - 11 * c0y * c3x * etax - 16 * c0x * c3y * etax +
		 8 * c3y * pow(etax,2) + 11 * c0x * c3x * (c0y - etay) - 38 * c0y * c3y * etay + 11 * c3x * etax * etay + 19 * c3y * pow(etay,2)) +
	  pow(c1x,2) * (-12 * pow(c1y,2) + 79 * c2x * (-c0x + etax) + 24 * c2y * (-c0y + etay)) +
	  pow(c1y,2) * (24 * c2x * (-c0x + etax) + 79 * c2y * (-c0y + etay))) / 120.,
   (-98 * pow(c1x,3) * c2x - 7 * pow(c0y,2) * (25 * c2x * c3x + 53 * c2y * c3y) -
	  7 * (14 * pow(c1y,3) * c2y + 28 * c0x * c1y * c2x * c2y + 14 * c0x * pow(c1y,2) * c3x + pow(c0x,2) * (53 * c2x * c3x + 25 * c2y * c3y)) +
	  14 * (14 * c1y * c2x * c2y + 7 * pow(c1y,2) * c3x + 53 * c0x * c2x * c3x + 25 * c0x * c2y * c3y) * etax -
	  7 * (53 * c2x * c3x + 25 * c2y * c3y) * pow(etax,2) +
	  2 * (2 * c1y * (30 * pow(c2x,2) + 79 * pow(c2y,2)) + 169 * pow(c1y,2) * c3y + 98 * (c2y * c3x + c2x * c3y) * (c0x - etax)) * etay -
	  7 * (25 * c2x * c3x + 53 * c2y * c3y) * pow(etay,2) -
	  2 * c0y * (2 * c1y * (30 * pow(c2x,2) + 79 * pow(c2y,2)) + 169 * pow(c1y,2) * c3y + 98 * (c2y * c3x + c2x * c3y) * (c0x - etax) -
		 7 * (25 * c2x * c3x + 53 * c2y * c3y) * etay) + pow(c1x,2) * (-98 * c1y * c2y + 338 * c3x * (-c0x + etax) + 98 * c3y * (-c0y + etay)) -
	  2 * c1x * (49 * pow(c1y,2) * c2x + 2 * (79 * c0x * pow(c2x,2) + 49 * c0y * c2x * c2y + 30 * c0x * pow(c2y,2) - 79 * pow(c2x,2) * etax -
			30 * pow(c2y,2) * etax - 49 * c2x * c2y * etay) + 120 * c1y * (c0y * c3x + c0x * c3y - c3y * etax - c3x * etay))) / 420.,
   (-4 * pow(c1y,2) * (19 * pow(c2x,2) + 54 * pow(c2y,2)) - 152 * pow(c1x,3) * c3x - 152 * pow(c1y,3) * c3y -
	  4 * pow(c1x,2) * (54 * pow(c2x,2) + 19 * (pow(c2y,2) + 2 * c1y * c3y)) -
	  4 * (38 * c0x * c2x * (pow(c2x,2) + pow(c2y,2)) + 70 * c0x * c0y * c3x * c3y +
		 35 * pow(c0x,2) * (2 * pow(c3x,2) + pow(c3y,2)) +
		 c0y * (38 * c2y * (pow(c2x,2) + pow(c2y,2)) + 35 * c0y * (pow(c3x,2) + 2 * pow(c3y,2)))) +
	  8 * (19 * c2x * (pow(c2x,2) + pow(c2y,2)) + 35 * (c0y * c3x * c3y + c0x * (2 * pow(c3x,2) + pow(c3y,2)))) * etax -
	  140 * (2 * pow(c3x,2) + pow(c3y,2)) * pow(etax,2) +
	  8 * (19 * c2y * (pow(c2x,2) + pow(c2y,2)) + 35 * (c0y * (pow(c3x,2) + 2 * pow(c3y,2)) + c3x * c3y * (c0x - etax))) * etay -
	  140 * (pow(c3x,2) + 2 * pow(c3y,2)) * pow(etay,2) -
	  c1x * (280 * c1y * c2x * c2y + 152 * pow(c1y,2) * c3x + 969 * c0x * c2x * c3x + 304 * c0y * c2y * c3x + 280 * c0y * c2x * c3y +
		 385 * c0x * c2y * c3y - 969 * c2x * c3x * etax - 385 * c2y * c3y * etax - 8 * (38 * c2y * c3x + 35 * c2x * c3y) * etay) +
	  c1y * (-(c0y * (385 * c2x * c3x + 969 * c2y * c3y)) - 8 * (35 * c2y * c3x + 38 * c2x * c3y) * (c0x - etax) +
		 (385 * c2x * c3x + 969 * c2y * c3y) * etay)) / 560.,
   (-3 * pow(c1x,2) * (289 * c2x * c3x + 105 * c2y * c3y) - 3 * pow(c1y,2) * (105 * c2x * c3x + 289 * c2y * c3y) -
	  6 * (c0x * (151 * pow(c2x,2) * c3x + 46 * pow(c2y,2) * c3x + 105 * c2x * c2y * c3y) +
		 c0y * (105 * c2x * c2y * c3x + 46 * pow(c2x,2) * c3y + 151 * pow(c2y,2) * c3y)) +
	  6 * (151 * pow(c2x,2) * c3x + 46 * pow(c2y,2) * c3x + 105 * c2x * c2y * c3y) * etax +
	  6 * (105 * c2x * c2y * c3x + 46 * pow(c2x,2) * c3y + 151 * pow(c2y,2) * c3y) * etay -
	  2 * c1x * (138 * pow(c2x,3) + 276 * c1y * c2y * c3x + 479 * c0x * pow(c3x,2) + 276 * c0y * c3x * c3y + 203 * c0x * pow(c3y,2) +
		 138 * c2x * (pow(c2y,2) + 2 * c1y * c3y) - 479 * pow(c3x,2) * etax - 203 * pow(c3y,2) * etax - 276 * c3x * c3y * etay) -
	  2 * c1y * (138 * c2y * (pow(c2x,2) + pow(c2y,2)) + c0y * (203 * pow(c3x,2) + 479 * pow(c3y,2)) +
		 276 * c3x * c3y * (c0x - etax) - (203 * pow(c3x,2) + 479 * pow(c3y,2)) * etay)) / 1008.,
   (-360 * pow(c2x,4) - 360 * pow(c2y,4) - 15 * pow(c2x,2) * (48 * pow(c2y,2) + 299 * c1x * c3x + 96 * c1y * c3y) -
	  15 * pow(c2y,2) * (96 * c1x * c3x + 299 * c1y * c3y) -
	  32 * (90 * c1x * c1y * c3x * c3y + pow(c1x,2) * (73 * pow(c3x,2) + 28 * pow(c3y,2)) +
		 pow(c1y,2) * (28 * pow(c3x,2) + 73 * pow(c3y,2))) -
	  7 * c2x * (435 * c1y * c2y * c3x + 691 * c0x * pow(c3x,2) + 435 * c1x * c2y * c3y + 435 * c0y * c3x * c3y + 256 * c0x * pow(c3y,2) -
		 691 * pow(c3x,2) * etax - 256 * pow(c3y,2) * etax - 435 * c3x * c3y * etay) -
	  7 * c2y * (c0y * (256 * pow(c3x,2) + 691 * pow(c3y,2)) + 435 * c3x * c3y * (c0x - etax) -
		 (256 * pow(c3x,2) + 691 * pow(c3y,2)) * etay)) / 5040.,
   (-51 * pow(c2x,3) * c3x - 51 * pow(c2x,2) * c2y * c3y - 51 * pow(c2y,3) * c3y -
	  2 * c1y * c2y * (28 * pow(c3x,2) + 79 * pow(c3y,2)) -
	  c2x * (51 * pow(c2y,2) * c3x + 158 * c1x * pow(c3x,2) + 102 * c1y * c3x * c3y + 56 * c1x * pow(c3y,2)) -
	  2 * (51 * c1x * c2y * c3x * c3y + 28 * c0x * c3x * (pow(c3x,2) + pow(c3y,2)) + 28 * c0y * c3y * (pow(c3x,2) + pow(c3y,2))) +
	  56 * c3x * (pow(c3x,2) + pow(c3y,2)) * etax + 56 * c3y * (pow(c3x,2) + pow(c3y,2)) * etay) / 168.,
   (-630 * c2x * c2y * c3x * c3y - 328 * (c1x * c3x + c1y * c3y) * (pow(c3x,2) + pow(c3y,2)) -
	  pow(c2x,2) * (479 * pow(c3x,2) + 164 * pow(c3y,2)) - pow(c2y,2) * (164 * pow(c3x,2) + 479 * pow(c3y,2))) / 1008.,
   (-47 * (c2x * c3x + c2y * c3y) * (pow(c3x,2) + pow(c3y,2))) / 144.,-pow(pow(c3x,2) + pow(c3y,2),2) / 12. };
		Iy2t0 = valuesIy2[0];
		Iy2t1 = valuesIy2[1];
		Iy2t2 = valuesIy2[2];
		Iy2t3 = valuesIy2[3];
		Iy2t4 = valuesIy2[4];
		Iy2t5 = valuesIy2[5];
		Iy2t6 = valuesIy2[6];
		Iy2t7 = valuesIy2[7];
		Iy2t8 = valuesIy2[8];
		Iy2t9 = valuesIy2[9];
		Iy2t10 = valuesIy2[10];
		Iy2t11 = valuesIy2[11];
		Iy2t12 = valuesIy2[12];
		Iy2t13 = valuesIy2[13];
		Iy2t14 = valuesIy2[14];
	}

	//这里与2次不同，用的是幂基
	{
		c0x = c0[0] - eta[0]; c0y = c0[1] - eta[1]; c1x = c1[0]; c1y = c1[1]; c2x = c2[0]; c2y = c2[1]; c3x = c3[0]; c3y = c3[1];
		myArray<4> ct_x, ct_y;
		myArray<3> dct_x, dct_y;
		ct_x = { c0x,c1x,c2x,c3x }; ct_y = { c0y,c1y,c2y,c3y };
		dct_x = { c1x,2 * c2x,3 * c3x }; dct_y = { c1y,2 * c2y,3 * c3y };

		auto ctxy = multiplyPolynomials(ct_x, dct_y);
		auto cty_x = multiplyPolynomials(ct_y, -dct_x);
		auto ctdtb = addPolynomials(ctxy, cty_x, 5);
		auto ctxx = multiplyPolynomials(ct_x, dct_x);
		auto ctyy = multiplyPolynomials(ct_y, dct_y);
		auto ctdt = addPolynomials(ctxx, ctyy, 5);
		auto ctxctx = multiplyPolynomials(ct_x, ct_x);
		auto ctycty = multiplyPolynomials(ct_y, ct_y);
		auto ctct = addPolynomials(ctxctx, ctycty, 6);


		myArray<4> c0_xishu{ 1,-3,3,-1 };
		auto Ic0result = multiplyPolynomials(c0_xishu, ctdtb);//okc0
		myArray<4> c1_xishu{ 0,3,-6,3 };
		auto Ic1result = multiplyPolynomials(c1_xishu, ctdtb);//okc1
		myArray<4> c2_xishu{ 0,0,3,-3 };
		auto Ic2result = multiplyPolynomials(c2_xishu, ctdtb);//okc2

		auto Ix0half1 = integratePolynomial(Ic0result, 8);
		auto Ix0result = multiplyPolynomials(Ix0half1, ctdt);//okx0
		auto Ix1half1 = integratePolynomial(Ic1result, 8);
		auto Ix1result = multiplyPolynomials(Ix1half1, ctdt);//okx1
		auto Ix2half1 = integratePolynomial(Ic2result, 8);
		auto Ix2result = multiplyPolynomials(Ix2half1, ctdt);//okx2



		//t0,t1,t2
		myArray<4> t0_xishu{ 0,3,-3,1 };
		auto It0result = multiplyPolynomials(t0_xishu, ctdt);//okt0-2
		myArray<4> t1_xishu{ 0,0,3,-2 };
		auto It1result = multiplyPolynomials(t1_xishu, ctdt);
		myArray<4> t2_xishu{ 0,0,0,1 };
		auto It2result = multiplyPolynomials(t2_xishu, ctdt);




		auto Iy0intterm = multiplyPolynomials(array<double, 3>{1, -2, 1}, ctct);
		auto Iy0half1 = integratePolynomial(Iy0intterm, 8);
		auto Iy0result = multiplyPolynomials(Iy0half1, ctdt);

		auto Iy1intterm = multiplyPolynomials(array<double, 3>{0, 2, -2}, ctct);
		auto Iy1half1 = integratePolynomial(Iy1intterm, 8);
		auto Iy1result = multiplyPolynomials(Iy1half1, ctdt);

		auto Iy2intterm = multiplyPolynomials(array<double, 3>{0, 0, 1}, ctct);
		auto Iy2half1 = integratePolynomial(Iy2intterm, 8);
		auto Iy2result = multiplyPolynomials(Iy2half1, ctdt);



		{
			Ic0t0 = Ic0result[0];
			Ic0t1 = Ic0result[1];
			Ic0t2 = Ic0result[2];
			Ic0t3 = Ic0result[3];
			Ic0t4 = Ic0result[4];
			Ic0t5 = Ic0result[5];
			Ic0t6 = Ic0result[6];
			Ic0t7 = Ic0result[7];


			Ic1t0 = Ic1result[0];
			Ic1t1 = Ic1result[1];
			Ic1t2 = Ic1result[2];
			Ic1t3 = Ic1result[3];
			Ic1t4 = Ic1result[4];
			Ic1t5 = Ic1result[5];
			Ic1t6 = Ic1result[6];
			Ic1t7 = Ic1result[7];

			Ic2t0 = Ic2result[0];
			Ic2t1 = Ic2result[1];
			Ic2t2 = Ic2result[2];
			Ic2t3 = Ic2result[3];
			Ic2t4 = Ic2result[4];
			Ic2t5 = Ic2result[5];
			Ic2t6 = Ic2result[6];
			Ic2t7 = Ic2result[7];

			Ix0t0 = Ix0result[0] / 2;
			Ix0t1 = Ix0result[1] / 2;
			Ix0t2 = Ix0result[2] / 2;
			Ix0t3 = Ix0result[3] / 2;
			Ix0t4 = Ix0result[4] / 2;
			Ix0t5 = Ix0result[5] / 2;
			Ix0t6 = Ix0result[6] / 2;
			Ix0t7 = Ix0result[7] / 2;
			Ix0t8 = Ix0result[8] / 2;
			Ix0t9 = Ix0result[9] / 2;
			Ix0t10 = Ix0result[10] / 2;
			Ix0t11 = Ix0result[11] / 2;
			Ix0t12 = Ix0result[12] / 2;
			Ix0t13 = Ix0result[13] / 2;

			Ix1t0 = Ix1result[0] / 2;
			Ix1t1 = Ix1result[1] / 2;
			Ix1t2 = Ix1result[2] / 2;
			Ix1t3 = Ix1result[3] / 2;
			Ix1t4 = Ix1result[4] / 2;
			Ix1t5 = Ix1result[5] / 2;
			Ix1t6 = Ix1result[6] / 2;
			Ix1t7 = Ix1result[7] / 2;
			Ix1t8 = Ix1result[8] / 2;
			Ix1t9 = Ix1result[9] / 2;
			Ix1t10 = Ix1result[10] / 2;
			Ix1t11 = Ix1result[11] / 2;
			Ix1t12 = Ix1result[12] / 2;
			Ix1t13 = Ix1result[13] / 2;

			Ix2t0 = Ix2result[0] / 2;
			Ix2t1 = Ix2result[1] / 2;
			Ix2t2 = Ix2result[2] / 2;
			Ix2t3 = Ix2result[3] / 2;
			Ix2t4 = Ix2result[4] / 2;
			Ix2t5 = Ix2result[5] / 2;
			Ix2t6 = Ix2result[6] / 2;
			Ix2t7 = Ix2result[7] / 2;
			Ix2t8 = Ix2result[8] / 2;
			Ix2t9 = Ix2result[9] / 2;
			Ix2t10 = Ix2result[10] / 2;
			Ix2t11 = Ix2result[11] / 2;
			Ix2t12 = Ix2result[12] / 2;
			Ix2t13 = Ix2result[13] / 2;

			It0t0 = It0result[0];
			It0t1 = It0result[1];
			It0t2 = It0result[2];
			It0t3 = It0result[3];
			It0t4 = It0result[4];
			It0t5 = It0result[5];
			It0t6 = It0result[6];
			It0t7 = It0result[7];
			It0t8 = It0result[8];

			It1t0 = It1result[0];
			It1t1 = It1result[1];
			It1t2 = It1result[2];
			It1t3 = It1result[3];
			It1t4 = It1result[4];
			It1t5 = It1result[5];
			It1t6 = It1result[6];
			It1t7 = It1result[7];
			It1t8 = It1result[8];

			It2t0 = It2result[0];
			It2t1 = It2result[1];
			It2t2 = It2result[2];
			It2t3 = It2result[3];
			It2t4 = It2result[4];
			It2t5 = It2result[5];
			It2t6 = It2result[6];
			It2t7 = It2result[7];
			It2t8 = It2result[8];

			Iy0t0 = Iy0result[0] / (-4);
			Iy0t1 = Iy0result[1] / (-4);
			Iy0t2 = Iy0result[2] / (-4);
			Iy0t3 = Iy0result[3] / (-4);
			Iy0t4 = Iy0result[4] / (-4);
			Iy0t5 = Iy0result[5] / (-4);
			Iy0t6 = Iy0result[6] / (-4);
			Iy0t7 = Iy0result[7] / (-4);
			Iy0t8 = Iy0result[8] / (-4);
			Iy0t9 = Iy0result[9] / (-4);
			Iy0t10 = Iy0result[10] / (-4);
			Iy0t11 = Iy0result[11] / (-4);
			Iy0t12 = Iy0result[12] / (-4);
			Iy0t13 = Iy0result[13] / (-4);
			Iy0t14 = Iy0result[14] / (-4);

			Iy1t0 = Iy1result[0] / (-4);
			Iy1t1 = Iy1result[1] / (-4);
			Iy1t2 = Iy1result[2] / (-4);
			Iy1t3 = Iy1result[3] / (-4);
			Iy1t4 = Iy1result[4] / (-4);
			Iy1t5 = Iy1result[5] / (-4);
			Iy1t6 = Iy1result[6] / (-4);
			Iy1t7 = Iy1result[7] / (-4);
			Iy1t8 = Iy1result[8] / (-4);
			Iy1t9 = Iy1result[9] / (-4);
			Iy1t10 = Iy1result[10] / (-4);
			Iy1t11 = Iy1result[11] / (-4);
			Iy1t12 = Iy1result[12] / (-4);
			Iy1t13 = Iy1result[13] / (-4);
			Iy1t14 = Iy1result[14] / (-4);

			Iy2t0 = Iy2result[0] / (-4);
			Iy2t1 = Iy2result[1] / (-4);
			Iy2t2 = Iy2result[2] / (-4);
			Iy2t3 = Iy2result[3] / (-4);
			Iy2t4 = Iy2result[4] / (-4);
			Iy2t5 = Iy2result[5] / (-4);
			Iy2t6 = Iy2result[6] / (-4);
			Iy2t7 = Iy2result[7] / (-4);
			Iy2t8 = Iy2result[8] / (-4);
			Iy2t9 = Iy2result[9] / (-4);
			Iy2t10 = Iy2result[10] / (-4);
			Iy2t11 = Iy2result[11] / (-4);
			Iy2t12 = Iy2result[12] / (-4);
			Iy2t13 = Iy2result[13] / (-4);
			Iy2t14 = Iy2result[14] / (-4);
		}

		/*std::cout << Iy2t0 << std::endl;
		std::cout << Iy2t1 << std::endl;
		std::cout << Iy2t2 << std::endl;
		std::cout << Iy2t3 << std::endl;
		std::cout << Iy2t4 << std::endl;
		std::cout << Iy2t5 << std::endl;
		std::cout << Iy2t6 << std::endl;
		std::cout << Iy2t7 << std::endl;
		std::cout << Iy2t8 << std::endl;
		std::cout << Iy2t9 << std::endl;
		std::cout << Iy2t10 << std::endl;
		std::cout << Iy2t11 << std::endl;
		std::cout << Iy2t12 << std::endl;
		std::cout << Iy2t13 << std::endl;
		std::cout << Iy2t14 << std::endl;
		exit(0);*/
		/*
		std::cout << It2t0 << std::endl;
		std::cout << It2t1 << std::endl;
		std::cout << It2t2 << std::endl;
		std::cout << It2t3 << std::endl;
		std::cout << It2t4 << std::endl;
		std::cout << It2t5 << std::endl;
		std::cout << It2t6 << std::endl;
		std::cout << It2t7 << std::endl;
		std::cout << It2t8 << std::endl;
		exit(0);*/




	}


	{
		auto ALL_f13 = ALL_F3_n(eta, m0, m1, m2, m3, 14);
		F0 = ALL_f13[0];//使用幂基控制点,注意已经除以2Pi了
		F1 = ALL_f13[1];
		F2 = ALL_f13[2];
		F3 = ALL_f13[3];
		F4 = ALL_f13[4];
		F5 = ALL_f13[5];
		F6 = ALL_f13[6];
		F7 = ALL_f13[7];
		F8 = ALL_f13[8];
		F9 = ALL_f13[9];
		F10 = ALL_f13[10];
		F11 = ALL_f13[11];
		F12 = ALL_f13[12];
		F13 = ALL_f13[13];
		F14 = ALL_f13[14];

		/*std::cout << "old" << F0 << " " << F1 << " " << F2 << " " << F3 << " " << F4 << " " << F5 << " " << std::endl;
			std::cout << "old" << F6 << " " << F7 << " " << F8 << " " << F9 << " " << F10 << " " << F11 << " " << std::endl;
			std::cout << "old" << F12 << " " << F13 <<""<<F14 << std::endl;
			std::cout << "new: ";
			for (int i = 0; i <= 14; ++i) {
				std::cout << ALL_f13[i] << " ";
			}
			std::cout << std::endl;
			exit(0);*/
	}
	
	/*std::cout << eta << m0 << m1 << m2 << std::endl;
	std::cout << "new" << F0 << " " << F1 << " " << F2 << " " << F3 << " " << F4 << " " << F5 << " " << std::endl;*/
	

	
	Ic0 = (Ic0t0 * F0 + Ic0t1 * F1 + Ic0t2 * F2 + Ic0t3 * F3 + Ic0t4 * F4 + Ic0t5 * F5 + Ic0t6 * F6 + Ic0t7 * F7);
	Ic1 = (Ic1t0 * F0 + Ic1t1 * F1 + Ic1t2 * F2 + Ic1t3 * F3 + Ic1t4 * F4 + Ic1t5 * F5 + Ic1t6 * F6 + Ic1t7 * F7);
	Ic2 = (Ic2t0 * F0 + Ic2t1 * F1 + Ic2t2 * F2 + Ic2t3 * F3 + Ic2t4 * F4 + Ic2t5 * F5 + Ic2t6 * F6 + Ic2t7 * F7);
	It0 = (It0t0 * F0 + It0t1 * F1 + It0t2 * F2 + It0t3 * F3 + It0t4 * F4 + It0t5 * F5 + It0t6 * F6 + It0t7 * F7 + It0t8 * F8) + It0Item / (-2 * M_PI);
	It1 = (It1t0 * F0 + It1t1 * F1 + It1t2 * F2 + It1t3 * F3 + It1t4 * F4 + It1t5 * F5 + It1t6 * F6 + It1t7 * F7 + It1t8 * F8) + It1Item / (-2 * M_PI);
	It2 = (It2t0 * F0 + It2t1 * F1 + It2t2 * F2 + It2t3 * F3 + It2t4 * F4 + It2t5 * F5 + It2t6 * F6 + It2t7 * F7 + It2t8 * F8) + It2Item / (-2 * M_PI);
	Ix0 = -(Ix0t0 * F0 + Ix0t1 * F1 + Ix0t2 * F2 + Ix0t3 * F3 + Ix0t4 * F4 + Ix0t5 * F5 + Ix0t6 * F6 + Ix0t7 * F7 + Ix0t8 * F8 + Ix0t9 * F9
		+ Ix0t10 * F10 + Ix0t11 * F11 + Ix0t12 * F12 + Ix0t13 * F13) + Ix0Item / (8 * M_PI);
	Ix1 = -(Ix1t0 * F0 + Ix1t1 * F1 + Ix1t2 * F2 + Ix1t3 * F3 + Ix1t4 * F4 + Ix1t5 * F5 + Ix1t6 * F6 + Ix1t7 * F7 + Ix1t8 * F8 + Ix1t9 * F9
		+ Ix1t10 * F10 + Ix1t11 * F11 + Ix1t12 * F12 + Ix1t13 * F13) + Ix1Item / (8 * M_PI);
	Ix2 = -(Ix2t0 * F0 + Ix2t1 * F1 + Ix2t2 * F2 + Ix2t3 * F3 + Ix2t4 * F4 + Ix2t5 * F5 + Ix2t6 * F6 + Ix2t7 * F7 + Ix2t8 * F8 + Ix2t9 * F9
		+ Ix2t10 * F10 + Ix2t11 * F11 + Ix2t12 * F12 + Ix2t13 * F13) + Ix1Item / (8 * M_PI);
	Iy0 = -(Iy0t0 * F0 + Iy0t1 * F1 + Iy0t2 * F2 + Iy0t3 * F3 + Iy0t4 * F4 + Iy0t5 * F5 + Iy0t6 * F6 + Iy0t7 * F7 + Iy0t8 * F8 + Iy0t9 * F9 
		+ Iy0t10 * F10 + Iy0t11 * F11 + Iy0t12 * F12 + Iy0t13 * F13 + Iy0t14 * F14) + Iy0Item / (-8 * M_PI);
	Iy1 = -(Iy1t0 * F0 + Iy1t1 * F1 + Iy1t2 * F2 + Iy1t3 * F3 + Iy1t4 * F4 + Iy1t5 * F5 + Iy1t6 * F6 + Iy1t7 * F7 + Iy1t8 * F8 + Iy1t9 * F9
		+ Iy1t10 * F10 + Iy1t11 * F11 + Iy1t12 * F12 + Iy1t13 * F13 + Iy1t14 * F14) + Iy1Item / (-8 * M_PI);
	Iy2 = -(Iy2t0 * F0 + Iy2t1 * F1 + Iy2t2 * F2 + Iy2t3 * F3 + Iy2t4 * F4 + Iy2t5 * F5 + Iy2t6 * F6 + Iy2t7 * F7 + Iy2t8 * F8 + Iy2t9 * F9
		+ Iy2t10 * F10 + Iy2t11 * F11 + Iy2t12 * F12 + Iy2t13 * F13 + Iy2t14 * F14) + Iy2Item / (-8 * M_PI);
	
	Ie1 = It1 / 3;
	Ie2 = It2 / 3;
	values[0] = Ic0 + Ic0_1;
	values[1] = Ic1;
	values[2] = Ic2;
	values[3] = It0;
	values[4] = It1;
	values[5] = It2;
	values[6] = Ix0 + Ix0_1;
	values[7] = Ix1;
	values[8] = Ix2;
	values[9] = Iy0;
	values[10] = Iy1;
	values[11] = Iy2;
	values[12] = values[0];
	values[13] = values[1];
	values[14] = values[2];
	values[15] = It0 / (3);
	values[16] = Ie1;
	values[17] = Ie2;
}

void MeshViewerWidget::Cal323BiharmonicBasis_edge( OpenMesh::Vec2d& v1, OpenMesh::Vec2d& v12, OpenMesh::Vec2d& v21, OpenMesh::Vec2d& v2,
	OpenMesh::Vec2d& eta, std::vector<double>& values) {
	values.resize(21);
	//values.resize(16);
	//v0 = OpenMesh::Vec2d(0, 0); v01 = OpenMesh::Vec2d(1, -1); v1 = OpenMesh::Vec2d(2, 0); v12 = OpenMesh::Vec2d(3, 1); v2 = OpenMesh::Vec2d(2, 2);eta = OpenMesh::Vec2d(1, 1);
	OpenMesh::Vec2d ei, ui, xiyi;
	double ci, L1i, L2i, Ai, xi, yi, Ic0, Ic0_1, Ic1, Ic2, It0, It1, It2,
		Ix0_1, Ix0, Ix1, Ix2, Iy0, Iy1, Iy2, Ie1, Ie2, hatphiBH_1, hatphiH, hatphiBH;
	//将bezier的控制点转化为幂基下的控制点
	OpenMesh::Vec2d c0, c1, c2, c3, m0, m1, m2, m3;
	double c0x, c0y, c1x, c1y, c2x, c2y, c3x, c3y, etax, etay;
	double F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14;
	double Ic0t0, Ic0t1, Ic0t2, Ic0t3, Ic0t4, Ic0t5, Ic0t6, Ic0t7;
	double Ic0_1t0, Ic0_1t1, Ic0_1t2, Ic0_1t3, Ic0_1t4, Ic0_1t5, Ic0_1t6, Ic0_1t7;
	double Ic1t0, Ic1t1, Ic1t2, Ic1t3, Ic1t4, Ic1t5, Ic1t6, Ic1t7;
	double Ic2t0, Ic2t1, Ic2t2, Ic2t3, Ic2t4, Ic2t5, Ic2t6, Ic2t7;
	double It0t0, It0t1, It0t2, It0t3, It0t4, It0t5, It0t6, It0t7, It0t8;
	double It1t0, It1t1, It1t2, It1t3, It1t4, It1t5, It1t6, It1t7, It1t8;
	double It2t0, It2t1, It2t2, It2t3, It2t4, It2t5, It2t6, It2t7, It2t8;
	double Ix0t0, Ix0t1, Ix0t2, Ix0t3, Ix0t4, Ix0t5, Ix0t6, Ix0t7, Ix0t8, Ix0t9, Ix0t10, Ix0t11, Ix0t12, Ix0t13;
	double Ix0_1t0, Ix0_1t1, Ix0_1t2, Ix0_1t3, Ix0_1t4, Ix0_1t5, Ix0_1t6, Ix0_1t7, Ix0_1t8, Ix0_1t9, Ix0_1t10, Ix0_1t11, Ix0_1t12, Ix0_1t13;
	double Ix1t0, Ix1t1, Ix1t2, Ix1t3, Ix1t4, Ix1t5, Ix1t6, Ix1t7, Ix1t8, Ix1t9, Ix1t10, Ix1t11, Ix1t12, Ix1t13;
	double Ix2t0, Ix2t1, Ix2t2, Ix2t3, Ix2t4, Ix2t5, Ix2t6, Ix2t7, Ix2t8, Ix2t9, Ix2t10, Ix2t11, Ix2t12, Ix2t13;
	double Iy0t0, Iy0t1, Iy0t2, Iy0t3, Iy0t4, Iy0t5, Iy0t6, Iy0t7, Iy0t8, Iy0t9, Iy0t10, Iy0t11, Iy0t12, Iy0t13, Iy0t14;
	double Iy1t0, Iy1t1, Iy1t2, Iy1t3, Iy1t4, Iy1t5, Iy1t6, Iy1t7, Iy1t8, Iy1t9, Iy1t10, Iy1t11, Iy1t12, Iy1t13, Iy1t14;
	double Iy2t0, Iy2t1, Iy2t2, Iy2t3, Iy2t4, Iy2t5, Iy2t6, Iy2t7, Iy2t8, Iy2t9, Iy2t10, Iy2t11, Iy2t12, Iy2t13, Iy2t14;

	//右边半段
	m0 = v1;  m1 = 3 * (v12 - v1);  m2 = 3 * v1 - 6 * v12 + 3 * v21; m3 = -v1 + 3 * v12 - 3 * v21 + v2;
	c0 = m0;  c1 = m1;  c2 = m2; c3 = m3;
	c0x = c0[0]; c0y = c0[1]; c1x = c1[0]; c1y = c1[1]; c2x = c2[0]; c2y = c2[1]; c3x = c3[0]; c3y = c3[1]; etax = eta[0]; etay = eta[1];

	double logterm = log(pow(c0x + c1x + c2x + c3x - etax, 2) + pow(c0y + c1y + c2y + c3y - etay, 2));
	double It0Item = 0.5 * logterm;
	double It1Item = 0.5 * logterm;
	double It2Item = 0.5 * logterm;
	double Ix0Item = ((14 * c1x * c2y - 3 * c2y * c3x - 42 * c0y * (5 * c1x + 2 * c2x + c3x) + 12 * c1x * c3y + 3 * c2x * c3y + 42 * c0x * (5 * c1y + 2 * c2y + c3y) -
		84 * c2y * etax - 42 * c3y * etax - 2 * c1y * (7 * c2x + 6 * c3x + 105 * etax) + 42 * (5 * c1x + 2 * c2x + c3x) * etay) *
		(-1 + logterm)) / 840.;
	double Ix1Item = ((14 * c1x * c2y - 5 * c2y * c3x - 14 * c0y * (5 * c1x + 4 * c2x + 3 * c3x) + 16 * c1x * c3y + 5 * c2x * c3y + 14 * c0x * (5 * c1y + 4 * c2y + 3 * c3y) -
		56 * c2y * etax - 42 * c3y * etax - 2 * c1y * (7 * c2x + 8 * c3x + 35 * etax) + 14 * (5 * c1x + 4 * c2x + 3 * c3x) * etay) *
		(-1 + logterm)) / 280.;
	double Ix2Item = -((70 * c0y * c1x - 70 * c0x * c1y + 28 * c1y * c2x + 40 * c1y * c3x + 15 * c2y * c3x + 84 * c0y * (c2x + c3x) - 15 * c2x * c3y -
		84 * c0x * (c2y + c3y) + 70 * c1y * etax + 84 * c2y * etax + 84 * c3y * etax - 84 * (c2x + c3x) * etay -
		2 * c1x * (14 * c2y + 20 * c3y + 35 * etay)) * (-1 + logterm)) / 280.;
	double Iy0Item = ((420 * pow(c0x, 2) + 420 * pow(c0y, 2) + 42 * pow(c1x, 2) + 42 * pow(c1y, 2) + 42 * c1x * c2x + 12 * pow(c2x, 2) + 42 * c1y * c2y +
		12 * pow(c2y, 2) + 24 * c1x * c3x + 15 * c2x * c3x + 5 * pow(c3x, 2) + 24 * c1y * c3y + 15 * c2y * c3y + 5 * pow(c3y, 2) +
		42 * c0x * (5 * c1x + 2 * c2x + c3x - 20 * etax) - 42 * (5 * c1x + 2 * c2x + c3x) * etax + 420 * pow(etax, 2) +
		42 * c0y * (5 * c1y + 2 * c2y + c3y - 20 * etay) - 42 * (5 * c1y + 2 * c2y + c3y) * etay + 420 * pow(etay, 2)) *
		(-2 + logterm)) / 2520.;
	double Iy1Item = ((420 * pow(c0x, 2) + 420 * pow(c0y, 2) + 126 * pow(c1x, 2) + 126 * pow(c1y, 2) + 168 * c1x * c2x + 60 * pow(c2x, 2) +
		168 * c1y * c2y + 60 * pow(c2y, 2) + 120 * c1x * c3x + 90 * c2x * c3x + 35 * pow(c3x, 2) + 120 * c1y * c3y + 90 * c2y * c3y +
		35 * pow(c3y, 2) + 84 * c0x * (5 * c1x + 3 * c2x + 2 * c3x - 10 * etax) - 84 * (5 * c1x + 3 * c2x + 2 * c3x) * etax + 420 * pow(etax, 2) +
		84 * c0y * (5 * c1y + 3 * c2y + 2 * c3y - 10 * etay) - 84 * (5 * c1y + 3 * c2y + 2 * c3y) * etay + 420 * pow(etay, 2)) *
		(-2 + logterm)) / 2520.;
	double Iy2Item = (((pow(c2x, 2) + pow(c2y, 2) + 2 * c1x * c3x + 2 * c1y * c3y) / 7. + (c2x * c3x + c2y * c3y) / 4. + (pow(c3x, 2) + pow(c3y, 2)) / 9. +
		(pow(c0x - etax, 2) + pow(c0y - etay, 2)) / 3. + (c0x * c1x + c0y * c1y - c1x * etax - c1y * etay) / 2. +
		(pow(c1x, 2) + pow(c1y, 2) + 2 * c0x * c2x + 2 * c0y * c2y - 2 * c2x * etax - 2 * c2y * etay) / 5. +
		(c1x * c2x + c1y * c2y + c0x * c3x + c0y * c3y - c3x * etax - c3y * etay) / 3.) *
		(-2 + logterm)) / 2.;
	//Ix0_1余项
	double Ix0_1Item = ((2 * (-(c1y * c3x) + c1x * c3y)) / 7. + (-(c2y * c3x) + c2x * c3y) / 8. + (-(c0y * c1x) + c0x * c1y - c1y * etax + c1x * etay) / 4. +
		(2 * (-(c0y * c2x) + c0x * c2y - c2y * etax + c2x * etay)) / 5. +
		(-(c1y * c2x) + c1x * c2y - 3 * c0y * c3x + 3 * c0x * c3y - 3 * c3y * etax + 3 * c3x * etay) / 6.) *
		(-1 + logterm);

	//这里与2次不同，用的是幂基
	{
		c0x = c0[0] - eta[0]; c0y = c0[1] - eta[1]; c1x = c1[0]; c1y = c1[1]; c2x = c2[0]; c2y = c2[1]; c3x = c3[0]; c3y = c3[1];
		myArray<4> ct_x, ct_y;
		myArray<3> dct_x, dct_y;
		ct_x = { c0x,c1x,c2x,c3x }; ct_y = { c0y,c1y,c2y,c3y };
		dct_x = { c1x,2 * c2x,3 * c3x }; dct_y = { c1y,2 * c2y,3 * c3y };

		auto ctxy = multiplyPolynomials(ct_x, dct_y);
		auto cty_x = multiplyPolynomials(ct_y, -dct_x);
		auto ctdtb = addPolynomials(ctxy, cty_x, 5);
		auto ctxx = multiplyPolynomials(ct_x, dct_x);
		auto ctyy = multiplyPolynomials(ct_y, dct_y);
		auto ctdt = addPolynomials(ctxx, ctyy, 5);
		auto ctxctx = multiplyPolynomials(ct_x, ct_x);
		auto ctycty = multiplyPolynomials(ct_y, ct_y);
		auto ctct = addPolynomials(ctxctx, ctycty, 6);


		myArray<4> c0_xishu{ 1,-3,3,-1 };
		auto Ic0result = multiplyPolynomials(c0_xishu, ctdtb);//okc0
		myArray<4> c1_xishu{ 0,3,-6,3 };
		auto Ic1result = multiplyPolynomials(c1_xishu, ctdtb);//okc1
		myArray<4> c2_xishu{ 0,0,3,-3 };
		auto Ic2result = multiplyPolynomials(c2_xishu, ctdtb);//okc2

		auto Ix0half1 = integratePolynomial(Ic0result, 8);
		auto Ix0result = multiplyPolynomials(Ix0half1, ctdt);//okx0
		auto Ix1half1 = integratePolynomial(Ic1result, 8);
		auto Ix1result = multiplyPolynomials(Ix1half1, ctdt);//okx1
		auto Ix2half1 = integratePolynomial(Ic2result, 8);
		auto Ix2result = multiplyPolynomials(Ix2half1, ctdt);//okx2



		//t0,t1,t2
		myArray<4> t0_xishu{ 0,3,-3,1 };
		auto It0result = multiplyPolynomials(t0_xishu, ctdt);//okt0-2
		myArray<4> t1_xishu{ 0,0,3,-2 };
		auto It1result = multiplyPolynomials(t1_xishu, ctdt);
		myArray<4> t2_xishu{ 0,0,0,1 };
		auto It2result = multiplyPolynomials(t2_xishu, ctdt);



		//y0,y1,y2
		auto Iy0intterm = multiplyPolynomials(array<double, 3>{1, -2, 1}, ctct);
		auto Iy0half1 = integratePolynomial(Iy0intterm, 8);
		auto Iy0result = multiplyPolynomials(Iy0half1, ctdt);

		auto Iy1intterm = multiplyPolynomials(array<double, 3>{0, 2, -2}, ctct);
		auto Iy1half1 = integratePolynomial(Iy1intterm, 8);
		auto Iy1result = multiplyPolynomials(Iy1half1, ctdt);

		auto Iy2intterm = multiplyPolynomials(array<double, 3>{0, 0, 1}, ctct);
		auto Iy2half1 = integratePolynomial(Iy2intterm, 8);
		auto Iy2result = multiplyPolynomials(Iy2half1, ctdt);


		myArray<4> c0_1_xishu{ 0,0,0,1 };
		auto Ic0_1result = multiplyPolynomials(c0_1_xishu, ctdtb);
		


		auto Ix0_1half1 = integratePolynomial(Ic0_1result, 8);
		auto Ix0_1result = multiplyPolynomials(Ix0_1half1, ctdt);//ok
		

		{
			Ic0t0 = Ic0result[0];
			Ic0t1 = Ic0result[1];
			Ic0t2 = Ic0result[2];
			Ic0t3 = Ic0result[3];
			Ic0t4 = Ic0result[4];
			Ic0t5 = Ic0result[5];
			Ic0t6 = Ic0result[6];
			Ic0t7 = Ic0result[7];


			Ic1t0 = Ic1result[0];
			Ic1t1 = Ic1result[1];
			Ic1t2 = Ic1result[2];
			Ic1t3 = Ic1result[3];
			Ic1t4 = Ic1result[4];
			Ic1t5 = Ic1result[5];
			Ic1t6 = Ic1result[6];
			Ic1t7 = Ic1result[7];

			Ic2t0 = Ic2result[0];
			Ic2t1 = Ic2result[1];
			Ic2t2 = Ic2result[2];
			Ic2t3 = Ic2result[3];
			Ic2t4 = Ic2result[4];
			Ic2t5 = Ic2result[5];
			Ic2t6 = Ic2result[6];
			Ic2t7 = Ic2result[7];

			Ix0t0 = Ix0result[0] / 2;
			Ix0t1 = Ix0result[1] / 2;
			Ix0t2 = Ix0result[2] / 2;
			Ix0t3 = Ix0result[3] / 2;
			Ix0t4 = Ix0result[4] / 2;
			Ix0t5 = Ix0result[5] / 2;
			Ix0t6 = Ix0result[6] / 2;
			Ix0t7 = Ix0result[7] / 2;
			Ix0t8 = Ix0result[8] / 2;
			Ix0t9 = Ix0result[9] / 2;
			Ix0t10 = Ix0result[10] / 2;
			Ix0t11 = Ix0result[11] / 2;
			Ix0t12 = Ix0result[12] / 2;
			Ix0t13 = Ix0result[13] / 2;

			Ix1t0 = Ix1result[0] / 2;
			Ix1t1 = Ix1result[1] / 2;
			Ix1t2 = Ix1result[2] / 2;
			Ix1t3 = Ix1result[3] / 2;
			Ix1t4 = Ix1result[4] / 2;
			Ix1t5 = Ix1result[5] / 2;
			Ix1t6 = Ix1result[6] / 2;
			Ix1t7 = Ix1result[7] / 2;
			Ix1t8 = Ix1result[8] / 2;
			Ix1t9 = Ix1result[9] / 2;
			Ix1t10 = Ix1result[10] / 2;
			Ix1t11 = Ix1result[11] / 2;
			Ix1t12 = Ix1result[12] / 2;
			Ix1t13 = Ix1result[13] / 2;

			Ix2t0 = Ix2result[0] / 2;
			Ix2t1 = Ix2result[1] / 2;
			Ix2t2 = Ix2result[2] / 2;
			Ix2t3 = Ix2result[3] / 2;
			Ix2t4 = Ix2result[4] / 2;
			Ix2t5 = Ix2result[5] / 2;
			Ix2t6 = Ix2result[6] / 2;
			Ix2t7 = Ix2result[7] / 2;
			Ix2t8 = Ix2result[8] / 2;
			Ix2t9 = Ix2result[9] / 2;
			Ix2t10 = Ix2result[10] / 2;
			Ix2t11 = Ix2result[11] / 2;
			Ix2t12 = Ix2result[12] / 2;
			Ix2t13 = Ix2result[13] / 2;

			It0t0 = It0result[0];
			It0t1 = It0result[1];
			It0t2 = It0result[2];
			It0t3 = It0result[3];
			It0t4 = It0result[4];
			It0t5 = It0result[5];
			It0t6 = It0result[6];
			It0t7 = It0result[7];
			It0t8 = It0result[8];

			It1t0 = It1result[0];
			It1t1 = It1result[1];
			It1t2 = It1result[2];
			It1t3 = It1result[3];
			It1t4 = It1result[4];
			It1t5 = It1result[5];
			It1t6 = It1result[6];
			It1t7 = It1result[7];
			It1t8 = It1result[8];

			It2t0 = It2result[0];
			It2t1 = It2result[1];
			It2t2 = It2result[2];
			It2t3 = It2result[3];
			It2t4 = It2result[4];
			It2t5 = It2result[5];
			It2t6 = It2result[6];
			It2t7 = It2result[7];
			It2t8 = It2result[8];

			Iy0t0 = Iy0result[0] / (-4);
			Iy0t1 = Iy0result[1] / (-4);
			Iy0t2 = Iy0result[2] / (-4);
			Iy0t3 = Iy0result[3] / (-4);
			Iy0t4 = Iy0result[4] / (-4);
			Iy0t5 = Iy0result[5] / (-4);
			Iy0t6 = Iy0result[6] / (-4);
			Iy0t7 = Iy0result[7] / (-4);
			Iy0t8 = Iy0result[8] / (-4);
			Iy0t9 = Iy0result[9] / (-4);
			Iy0t10 = Iy0result[10] / (-4);
			Iy0t11 = Iy0result[11] / (-4);
			Iy0t12 = Iy0result[12] / (-4);
			Iy0t13 = Iy0result[13] / (-4);
			Iy0t14 = Iy0result[14] / (-4);

			Iy1t0 = Iy1result[0] / (-4);
			Iy1t1 = Iy1result[1] / (-4);
			Iy1t2 = Iy1result[2] / (-4);
			Iy1t3 = Iy1result[3] / (-4);
			Iy1t4 = Iy1result[4] / (-4);
			Iy1t5 = Iy1result[5] / (-4);
			Iy1t6 = Iy1result[6] / (-4);
			Iy1t7 = Iy1result[7] / (-4);
			Iy1t8 = Iy1result[8] / (-4);
			Iy1t9 = Iy1result[9] / (-4);
			Iy1t10 = Iy1result[10] / (-4);
			Iy1t11 = Iy1result[11] / (-4);
			Iy1t12 = Iy1result[12] / (-4);
			Iy1t13 = Iy1result[13] / (-4);
			Iy1t14 = Iy1result[14] / (-4);

			Iy2t0 = Iy2result[0] / (-4);
			Iy2t1 = Iy2result[1] / (-4);
			Iy2t2 = Iy2result[2] / (-4);
			Iy2t3 = Iy2result[3] / (-4);
			Iy2t4 = Iy2result[4] / (-4);
			Iy2t5 = Iy2result[5] / (-4);
			Iy2t6 = Iy2result[6] / (-4);
			Iy2t7 = Iy2result[7] / (-4);
			Iy2t8 = Iy2result[8] / (-4);
			Iy2t9 = Iy2result[9] / (-4);
			Iy2t10 = Iy2result[10] / (-4);
			Iy2t11 = Iy2result[11] / (-4);
			Iy2t12 = Iy2result[12] / (-4);
			Iy2t13 = Iy2result[13] / (-4);
			Iy2t14 = Iy2result[14] / (-4);

			Ic0_1t0 = Ic0_1result[0];
			Ic0_1t1 = Ic0_1result[1];
			Ic0_1t2 = Ic0_1result[2];
			Ic0_1t3 = Ic0_1result[3];
			Ic0_1t4 = Ic0_1result[4];
			Ic0_1t5 = Ic0_1result[5];
			Ic0_1t6 = Ic0_1result[6];
			Ic0_1t7 = Ic0_1result[7];

			Ix0_1t0 = Ix0_1result[0] / 2;
			Ix0_1t1 = Ix0_1result[1] / 2;
			Ix0_1t2 = Ix0_1result[2] / 2;
			Ix0_1t3 = Ix0_1result[3] / 2;
			Ix0_1t4 = Ix0_1result[4] / 2;
			Ix0_1t5 = Ix0_1result[5] / 2;
			Ix0_1t6 = Ix0_1result[6] / 2;
			Ix0_1t7 = Ix0_1result[7] / 2;
			Ix0_1t8 = Ix0_1result[8] / 2;
			Ix0_1t9 = Ix0_1result[9] / 2;
			Ix0_1t10 = Ix0_1result[10] / 2;
			Ix0_1t11 = Ix0_1result[11] / 2;
			Ix0_1t12 = Ix0_1result[12] / 2;
			Ix0_1t13 = Ix0_1result[13] / 2;
		}

		

	}


	{
		auto ALL_f13 = ALL_F3_n(eta, m0, m1, m2, m3, 14);
		F0 = ALL_f13[0];//使用幂基控制点,注意已经除以2Pi了
		F1 = ALL_f13[1];
		F2 = ALL_f13[2];
		F3 = ALL_f13[3];
		F4 = ALL_f13[4];
		F5 = ALL_f13[5];
		F6 = ALL_f13[6];
		F7 = ALL_f13[7];
		F8 = ALL_f13[8];
		F9 = ALL_f13[9];
		F10 = ALL_f13[10];
		F11 = ALL_f13[11];
		F12 = ALL_f13[12];
		F13 = ALL_f13[13];
		F14 = ALL_f13[14];

		
	}



	Ic0 = (Ic0t0 * F0 + Ic0t1 * F1 + Ic0t2 * F2 + Ic0t3 * F3 + Ic0t4 * F4 + Ic0t5 * F5 + Ic0t6 * F6 + Ic0t7 * F7);
	Ic1 = (Ic1t0 * F0 + Ic1t1 * F1 + Ic1t2 * F2 + Ic1t3 * F3 + Ic1t4 * F4 + Ic1t5 * F5 + Ic1t6 * F6 + Ic1t7 * F7);
	Ic2 = (Ic2t0 * F0 + Ic2t1 * F1 + Ic2t2 * F2 + Ic2t3 * F3 + Ic2t4 * F4 + Ic2t5 * F5 + Ic2t6 * F6 + Ic2t7 * F7);
	It0 = (It0t0 * F0 + It0t1 * F1 + It0t2 * F2 + It0t3 * F3 + It0t4 * F4 + It0t5 * F5 + It0t6 * F6 + It0t7 * F7 + It0t8 * F8) + It0Item / (-2 * M_PI);
	It1 = (It1t0 * F0 + It1t1 * F1 + It1t2 * F2 + It1t3 * F3 + It1t4 * F4 + It1t5 * F5 + It1t6 * F6 + It1t7 * F7 + It1t8 * F8) + It1Item / (-2 * M_PI);
	It2 = (It2t0 * F0 + It2t1 * F1 + It2t2 * F2 + It2t3 * F3 + It2t4 * F4 + It2t5 * F5 + It2t6 * F6 + It2t7 * F7 + It2t8 * F8) + It2Item / (-2 * M_PI);
	Ix0 = -(Ix0t0 * F0 + Ix0t1 * F1 + Ix0t2 * F2 + Ix0t3 * F3 + Ix0t4 * F4 + Ix0t5 * F5 + Ix0t6 * F6 + Ix0t7 * F7 + Ix0t8 * F8 + Ix0t9 * F9
		+ Ix0t10 * F10 + Ix0t11 * F11 + Ix0t12 * F12 + Ix0t13 * F13) + Ix0Item / (8 * M_PI);
	Ix1 = -(Ix1t0 * F0 + Ix1t1 * F1 + Ix1t2 * F2 + Ix1t3 * F3 + Ix1t4 * F4 + Ix1t5 * F5 + Ix1t6 * F6 + Ix1t7 * F7 + Ix1t8 * F8 + Ix1t9 * F9
		+ Ix1t10 * F10 + Ix1t11 * F11 + Ix1t12 * F12 + Ix1t13 * F13) + Ix1Item / (8 * M_PI);
	Ix2 = -(Ix2t0 * F0 + Ix2t1 * F1 + Ix2t2 * F2 + Ix2t3 * F3 + Ix2t4 * F4 + Ix2t5 * F5 + Ix2t6 * F6 + Ix2t7 * F7 + Ix2t8 * F8 + Ix2t9 * F9
		+ Ix2t10 * F10 + Ix2t11 * F11 + Ix2t12 * F12 + Ix2t13 * F13) + Ix1Item / (8 * M_PI);
	Iy0 = -(Iy0t0 * F0 + Iy0t1 * F1 + Iy0t2 * F2 + Iy0t3 * F3 + Iy0t4 * F4 + Iy0t5 * F5 + Iy0t6 * F6 + Iy0t7 * F7 + Iy0t8 * F8 + Iy0t9 * F9
		+ Iy0t10 * F10 + Iy0t11 * F11 + Iy0t12 * F12 + Iy0t13 * F13 + Iy0t14 * F14) + Iy0Item / (-8 * M_PI);
	Iy1 = -(Iy1t0 * F0 + Iy1t1 * F1 + Iy1t2 * F2 + Iy1t3 * F3 + Iy1t4 * F4 + Iy1t5 * F5 + Iy1t6 * F6 + Iy1t7 * F7 + Iy1t8 * F8 + Iy1t9 * F9
		+ Iy1t10 * F10 + Iy1t11 * F11 + Iy1t12 * F12 + Iy1t13 * F13 + Iy1t14 * F14) + Iy1Item / (-8 * M_PI);
	Iy2 = -(Iy2t0 * F0 + Iy2t1 * F1 + Iy2t2 * F2 + Iy2t3 * F3 + Iy2t4 * F4 + Iy2t5 * F5 + Iy2t6 * F6 + Iy2t7 * F7 + Iy2t8 * F8 + Iy2t9 * F9
		+ Iy2t10 * F10 + Iy2t11 * F11 + Iy2t12 * F12 + Iy2t13 * F13 + Iy2t14 * F14) + Iy2Item / (-8 * M_PI);

	Ic0_1 = (Ic0_1t0 * F0 + Ic0_1t1 * F1 + Ic0_1t2 * F2 + Ic0_1t3 * F3 + Ic0_1t4 * F4 + Ic0_1t5 * F5 + Ic0_1t6 * F6 + Ic0_1t7 * F7);
	Ix0_1 = -(Ix0_1t0 * F0 + Ix0_1t1 * F1 + Ix0_1t2 * F2 + Ix0_1t3 * F3 + Ix0_1t4 * F4 + Ix0_1t5 * F5
		+ Ix0_1t6 * F6 + Ix0_1t7 * F7 + Ix0_1t8 * F8 + Ix0_1t9 * F9 + Ix0_1t10 * F10 + Ix0_1t11 * F11 + Ix0_1t12 * F12 + Ix0_1t13 * F13) + Ix0_1Item / (8 * M_PI);

	Ie1 = It1 / 3;
	Ie2 = It2 / 3;
	values[0] = Ic0;
	values[1] = Ic1;
	values[2] = Ic2;
	values[3] = It0;
	values[4] = It1;
	values[5] = It2;
	values[6] = Ix0;
	values[7] = Ix1;
	values[8] = Ix2;
	values[9] = Iy0;
	values[10] = Iy1;
	values[11] = Iy2;
	values[12] = values[0];
	values[13] = values[1];
	values[14] = values[2];
	values[15] = It0 / (3);
	values[16] = Ie1;
	values[17] = Ie2;
	values[18] = Ic0_1;
	values[19] = Ix0_1;
	values[20] = Ic0_1;
}

void MeshViewerWidget::Cal323BiharmonicBasis_edge_limit(OpenMesh::Vec2d& v1, OpenMesh::Vec2d& v12, OpenMesh::Vec2d& v21, OpenMesh::Vec2d& v2,
	OpenMesh::Vec2d& eta, double t0, std::vector<double>& values) {
	values.resize(21);

	//double ci, L1i, L2i, Ai, xi, yi, Ic0, Ic0_1, Ic1, Ic2, It0, It1, It2,
	//	Ix0_1, Ix0, Ix1, Ix2, Iy0, Iy1, Iy2, Ie1, Ie2;

	//auto B30 = [](double t) { return 1.0 * std::pow(1 - t, 3); };         // B₀³(t) = (1-t)³
	//auto B31 = [](double t) { return 3.0 * t * std::pow(1 - t, 2); };     // B₁³(t) = 3t(1-t)²
	//auto B32 = [](double t) { return 3.0 * t * t * (1 - t); };            // B₂³(t) = 3t²(1-t)
	//auto B33 = [](double t) { return 1.0 * std::pow(t, 3); };             // B₃³(t) = t³

	//Ic0 = B30(t0) / 2;
	//Ic1 = B31(t0) / 2;
	//Ic2 = B32(t0) / 2;
	//Ic0_1 = B33(t0) / 2;//ok
	//Ie1 = It1 / 3;
	//Ie2 = It2 / 3;
	//values[0] = Ic0;
	//values[1] = Ic1;
	//values[2] = Ic2;
	//values[3] = It0;
	//values[4] = It1;
	//values[5] = It2;
	//values[6] = Ix0;
	//values[7] = Ix1;
	//values[8] = Ix2;
	//values[9] = Iy0;
	//values[10] = Iy1;
	//values[11] = Iy2;
	//values[12] = values[0];
	//values[13] = values[1];
	//values[14] = values[2];
	//values[15] = It0 / (3);
	//values[16] = Ie1;
	//values[17] = Ie2;
	//values[18] = Ic0_1;
	//values[19] = Ix0_1;
	//values[20] = Ic0_1;
}

//这里，我假设每段bezier曲线是一个2次的bezier曲线，v0,v01,v10,v1.其实是v0,v0+(v01-v0)*3/2,v1
void MeshViewerWidget::Cal323BiharmonicBasisDebug1(OpenMesh::Vec2d& v0, OpenMesh::Vec2d& v01, OpenMesh::Vec2d& v10, OpenMesh::Vec2d& v1, OpenMesh::Vec2d& v12, OpenMesh::Vec2d& v21, OpenMesh::Vec2d& v2,
	OpenMesh::Vec2d& eta, std::vector<double>& values) {
	values.resize(18);
	//values.resize(16);
	//v0 = OpenMesh::Vec2d(0, 0); v01 = OpenMesh::Vec2d(1, -1); v1 = OpenMesh::Vec2d(2, 0); v12 = OpenMesh::Vec2d(3, 1); v2 = OpenMesh::Vec2d(2, 2);eta = OpenMesh::Vec2d(1, 1);
	OpenMesh::Vec2d ei, ui, xiyi;
	double ci, L1i, L2i, Ai, xi, yi, Ic0, Ic0_1, Ic1, Ic2, It0, It1, It2,
		Ix0_1, Ix0, Ix1, Ix2, Iy0, Iy1, Iy2, Ie1, Ie2, hatphiBH_1, hatphiH, hatphiBH;
	//将bezier的控制点转化为幂基下的控制点
	OpenMesh::Vec2d c0, c1, c2, c3, m0, m1, m2, m3;
	double c0x, c0y, c1x, c1y, c2x, c2y, c3x, c3y, etax, etay;
	double F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14;
	double Ic0t0, Ic0t1, Ic0t2, Ic0t3, Ic0t4, Ic0t5, Ic0t6, Ic0t7;
	double Ic0_1t0, Ic0_1t1, Ic0_1t2, Ic0_1t3, Ic0_1t4, Ic0_1t5, Ic0_1t6, Ic0_1t7;
	double Ic1t0, Ic1t1, Ic1t2, Ic1t3, Ic1t4, Ic1t5, Ic1t6, Ic1t7;
	double Ic2t0, Ic2t1, Ic2t2, Ic2t3, Ic2t4, Ic2t5, Ic2t6, Ic2t7;
	double It0t0, It0t1, It0t2, It0t3, It0t4, It0t5, It0t6, It0t7, It0t8;
	double It1t0, It1t1, It1t2, It1t3, It1t4, It1t5, It1t6, It1t7, It1t8;
	double It2t0, It2t1, It2t2, It2t3, It2t4, It2t5, It2t6, It2t7, It2t8;
	double Ix0t0, Ix0t1, Ix0t2, Ix0t3, Ix0t4, Ix0t5, Ix0t6, Ix0t7, Ix0t8, Ix0t9, Ix0t10, Ix0t11, Ix0t12, Ix0t13;
	double Ix0_1t0, Ix0_1t1, Ix0_1t2, Ix0_1t3, Ix0_1t4, Ix0_1t5, Ix0_1t6, Ix0_1t7, Ix0_1t8, Ix0_1t9, Ix0_1t10, Ix0_1t11, Ix0_1t12, Ix0_1t13;
	double Ix1t0, Ix1t1, Ix1t2, Ix1t3, Ix1t4, Ix1t5, Ix1t6, Ix1t7, Ix1t8, Ix1t9, Ix1t10, Ix1t11, Ix1t12, Ix1t13;
	double Ix2t0, Ix2t1, Ix2t2, Ix2t3, Ix2t4, Ix2t5, Ix2t6, Ix2t7, Ix2t8, Ix2t9, Ix2t10, Ix2t11, Ix2t12, Ix2t13;
	double Iy0t0, Iy0t1, Iy0t2, Iy0t3, Iy0t4, Iy0t5, Iy0t6, Iy0t7, Iy0t8, Iy0t9, Iy0t10, Iy0t11, Iy0t12, Iy0t13, Iy0t14;
	double Iy1t0, Iy1t1, Iy1t2, Iy1t3, Iy1t4, Iy1t5, Iy1t6, Iy1t7, Iy1t8, Iy1t9, Iy1t10, Iy1t11, Iy1t12, Iy1t13, Iy1t14;
	double Iy2t0, Iy2t1, Iy2t2, Iy2t3, Iy2t4, Iy2t5, Iy2t6, Iy2t7, Iy2t8, Iy2t9, Iy2t10, Iy2t11, Iy2t12, Iy2t13, Iy2t14;


	{//计算前一个phi的值
		m0 = v0;  m1 = 3 * (v01 - v0);  m2 = 3 * v0 - 6 * v01 + 3 * v10; m3 = -v0 + 3 * v01 - 3 * v10 + v1;
		c0 = m0;  c1 = m1;  c2 = m2; c3 = m3;
        //这里m3和m2应该为0.
		c0x = c0[0]; c0y = c0[1]; c1x = c1[0]; c1y = c1[1]; c2x = c2[0]; c2y = c2[1]; c3x = c3[0]; c3y = c3[1]; etax = eta[0]; etay = eta[1];
		//Ic0_1幂基系数
		{
			std::vector<double> valuesIc0_1 = { 0,0,0,-(c0y * c1x) + c0x * c1y - c1y * etax + c1x * etay,2 * (-(c0y * c2x) + c0x * c2y - c2y * etax + c2x * etay),
   -(c1y * c2x) + c1x * c2y - 3 * c0y * c3x + 3 * c0x * c3y - 3 * c3y * etax + 3 * c3x * etay,-2 * c1y * c3x + 2 * c1x * c3y,-(c2y * c3x) + c2x * c3y };
			Ic0_1t0 = valuesIc0_1[0];
			Ic0_1t1 = valuesIc0_1[1];
			Ic0_1t2 = valuesIc0_1[2];
			Ic0_1t3 = valuesIc0_1[3];
			Ic0_1t4 = valuesIc0_1[4];
			Ic0_1t5 = valuesIc0_1[5];
			Ic0_1t6 = valuesIc0_1[6];
			Ic0_1t7 = valuesIc0_1[7];
		}
		//Ix0_1幂基系数
		{//Ix0_1
			std::vector<double> valuesIx0_1 = { 0,0,0,0,((-(c0y * c1x) + c0x * c1y - c1y * etax + c1x * etay) * (c0x * c1x + c0y * c1y - c1x * etax - c1y * etay)) / 8.,
   (-2 * pow(c0y,2) * (4 * c1y * c2x + 5 * c1x * c2y) + (c0x - etax) *
	   (5 * pow(c1x,2) * c1y + 8 * c1x * c2y * (c0x - etax) + 5 * c1y * (pow(c1y,2) + 2 * c0x * c2x - 2 * c2x * etax)) +
	  (5 * pow(c1x,3) + 5 * c1x * pow(c1y,2) + 18 * c1x * c2x * (c0x - etax) + 18 * c1y * c2y * (-c0x + etax)) * etay -
	  2 * (4 * c1y * c2x + 5 * c1x * c2y) * pow(etay,2) + c0y *
	   (-5 * pow(c1x,3) + 2 * c1y * (9 * c0x * c2y - 9 * c2y * etax + 8 * c2x * etay) +
		 c1x * (-5 * pow(c1y,2) + 18 * c2x * (-c0x + etax) + 20 * c2y * etay))) / 40.,
   (-3 * pow(c0y,2) * (16 * c2x * c2y + 10 * c1y * c3x + 15 * c1x * c3y) +
	  (34 * pow(c1x,2) * c2y + 69 * pow(c1y,2) * c2y + 5 * c1x * (7 * c1y * c2x + 6 * c3y * (c0x - etax)) + 48 * c2x * c2y * (c0x - etax) +
		 45 * c1y * c3x * (c0x - etax)) * (c0x - etax) +
	  (69 * pow(c1x,2) * c2x + 34 * pow(c1y,2) * c2x + 35 * c1x * c1y * c2y + 48 * (c2x - c2y) * (c2x + c2y) * (c0x - etax) +
		 75 * c1x * c3x * (c0x - etax) + 75 * c1y * c3y * (-c0x + etax)) * etay -
	  3 * (16 * c2x * c2y + 10 * c1y * c3x + 15 * c1x * c3y) * pow(etay,2) +
	  c0y * (-69 * pow(c1x,2) * c2x - 34 * pow(c1y,2) * c2x - 48 * (c2x - c2y) * (c2x + c2y) * (c0x - etax) + 96 * c2x * c2y * etay +
		 15 * c1y * (5 * c0x * c3y - 5 * c3y * etax + 4 * c3x * etay) + c1x * (-35 * c1y * c2y + 75 * c3x * (-c0x + etax) + 90 * c3y * etay))) / 120.,
   (-35 * pow(c1y,3) * c2x + 35 * pow(c1x,3) * c2y -
	  5 * pow(c1x,2) * (7 * c1y * c2x + 33 * c3y * (-c0x + etax) + 63 * c3x * (c0y - etay)) +
	  7 * c1y * (5 * c0x * pow(c2x,2) - 46 * c0y * c2x * c2y + 51 * c0x * pow(c2y,2) - 5 * pow(c2x,2) * etax - 51 * pow(c2y,2) * etax +
		 46 * c2x * c2y * etay) + c1x * (35 * pow(c1y,2) * c2y - c0y * (357 * pow(c2x,2) + 35 * pow(c2y,2) + 150 * c1y * c3y) +
		 2 * (161 * c2x * c2y + 75 * c1y * c3x) * (c0x - etax) + (357 * pow(c2x,2) + 35 * pow(c2y,2) + 150 * c1y * c3y) * etay) +
	  15 * pow(c1y,2) * (21 * c3y * (c0x - etax) + 11 * c3x * (-c0y + etay)) +
	  42 * (pow(c0x,2) * (6 * c2y * c3x + 5 * c2x * c3y) - pow(c0y,2) * (5 * c2y * c3x + 6 * c2x * c3y) +
		 (6 * c2y * c3x + 5 * c2x * c3y) * pow(etax,2) + 11 * (-(c2x * c3x) + c2y * c3y) * etax * etay -
		 (5 * c2y * c3x + 6 * c2x * c3y) * pow(etay,2) +
		 c0y * (11 * c2x * c3x * etax - 11 * c2y * c3y * etax + 10 * c2y * c3x * etay + 12 * c2x * c3y * etay) -
		 c0x * (11 * c0y * (c2x * c3x - c2y * c3y) + 12 * c2y * c3x * etax + 10 * c2x * c3y * etax - 11 * c2x * c3x * etay + 11 * c2y * c3y * etay))) / 420.,
   (20 * pow(c1x,2) * (7 * c2x * c2y - 4 * c1y * c3x) + 80 * pow(c1x,3) * c3y - 420 * pow(c0y,2) * c3x * c3y +
	  2 * (-70 * pow(c1y,2) * c2x * c2y - 40 * pow(c1y,3) * c3x + c1y * (25 * c2x * c3x + 609 * c2y * c3y) * (c0x - etax) +
		 14 * (8 * c2y * (pow(c2x,2) + pow(c2y,2)) + 15 * c3x * c3y * (c0x - etax)) * (c0x - etax)) +
	  (224 * pow(c2x,3) + 615 * c1y * c2y * c3x + 7 * c2x * (32 * pow(c2y,2) + 79 * c1y * c3y) +
		 420 * (c3x - c3y) * (c3x + c3y) * (c0x - etax)) * etay - 420 * c3x * c3y * pow(etay,2) -
	  c0y * (224 * pow(c2x,3) + 615 * c1y * c2y * c3x + 7 * c2x * (32 * pow(c2y,2) + 79 * c1y * c3y) +
		 420 * (c3x - c3y) * (c3x + c3y) * (c0x - etax) - 840 * c3x * c3y * etay) +
	  c1x * (140 * c1y * (-pow(c2x,2) + pow(c2y,2)) + 80 * pow(c1y,2) * c3y - 2 * c0y * (609 * c2x * c3x + 25 * c2y * c3y) +
		 (553 * c2y * c3x + 615 * c2x * c3y) * (c0x - etax) + 2 * (609 * c2x * c3x + 25 * c2y * c3y) * etay)) / 560.,
   (56 * c1x * c2y * (pow(c2x,2) + pow(c2y,2)) - pow(c1y,2) * (165 * c2y * c3x + 91 * c2x * c3y) +
	  pow(c1x,2) * (91 * c2y * c3x + 165 * c2x * c3y) + 42 *
	   (-(c0y * (12 * pow(c2x,2) * c3x + 5 * pow(c2y,2) * c3x + 7 * c2x * c2y * c3y)) +
		 (7 * c2x * c2y * c3x + 5 * pow(c2x,2) * c3y + 12 * pow(c2y,2) * c3y) * (c0x - etax) +
		 (12 * pow(c2x,2) * c3x + 5 * pow(c2y,2) * c3x + 7 * c2x * c2y * c3y) * etay) +
	  6 * c1x * (c0y * (-77 * pow(c3x,2) + 3 * pow(c3y,2)) + 80 * c3x * c3y * (c0x - etax) +
		 (77 * pow(c3x,2) - 3 * pow(c3y,2)) * etay) -
	  2 * c1y * (28 * pow(c2x,3) + 4 * c2x * (7 * pow(c2y,2) + 32 * c1x * c3x) - 128 * c1x * c2y * c3y +
		 3 * (3 * c0x * pow(c3x,2) + 80 * c0y * c3x * c3y - 77 * c0x * pow(c3y,2) - 3 * pow(c3x,2) * etax + 77 * pow(c3y,2) * etax -
			80 * c3x * c3y * etay))) / 336.,(960 * pow(c1x,2) * c3x * c3y - 960 * pow(c1y,2) * c3x * c3y +
	  5 * c1x * (77 * c2x * c2y * c3x + 159 * pow(c2x,2) * c3y + 236 * pow(c2y,2) * c3y) -
	  5 * c1y * (236 * pow(c2x,2) * c3x + 159 * pow(c2y,2) * c3x + 77 * c2x * c2y * c3y + 192 * c1x * (c3x - c3y) * (c3x + c3y)) +
	  21 * (-(c0y * (148 * c2x * pow(c3x,2) + 115 * c2y * c3x * c3y + 33 * c2x * pow(c3y,2))) +
		 (33 * c2y * pow(c3x,2) + 115 * c2x * c3x * c3y + 148 * c2y * pow(c3y,2)) * (c0x - etax) +
		 (148 * c2x * pow(c3x,2) + 115 * c2y * c3x * c3y + 33 * c2x * pow(c3y,2)) * etay)) / 1680.,
   (-7 * pow(c2x,2) * c2y * c3x - 7 * pow(c2y,3) * c3x + 7 * pow(c2x,3) * c3y + 7 * c2x * pow(c2y,2) * c3y +
	  54 * c2x * c3x * (-(c1y * c3x) + c1x * c3y) + 54 * c2y * c3y * (-(c1y * c3x) + c1x * c3y) +
	  42 * (pow(c3x,2) + pow(c3y,2)) * (-(c0y * c3x) + c0x * c3y - c3y * etax + c3x * etay)) / 56.,
   (3 * pow(c3x,2) * (-(c1y * c3x) + c1x * c3y)) / 7. + (3 * pow(c3y,2) * (-(c1y * c3x) + c1x * c3y)) / 7. +
	(5 * c2x * c3x * (-(c2y * c3x) + c2x * c3y)) / 16. + (5 * c2y * c3y * (-(c2y * c3x) + c2x * c3y)) / 16.,
   (-3 * (c2y * c3x - c2x * c3y) * (pow(c3x,2) + pow(c3y,2))) / 16. };
			Ix0_1t0 = valuesIx0_1[0];
			Ix0_1t1 = valuesIx0_1[1];
			Ix0_1t2 = valuesIx0_1[2];
			Ix0_1t3 = valuesIx0_1[3];
			Ix0_1t4 = valuesIx0_1[4];
			Ix0_1t5 = valuesIx0_1[5];
			Ix0_1t6 = valuesIx0_1[6];
			Ix0_1t7 = valuesIx0_1[7];
			Ix0_1t8 = valuesIx0_1[8];
			Ix0_1t9 = valuesIx0_1[9];
			Ix0_1t10 = valuesIx0_1[10];
			Ix0_1t11 = valuesIx0_1[11];
			Ix0_1t12 = valuesIx0_1[12];
			Ix0_1t13 = valuesIx0_1[13];
		}
		F0 = F1_n(eta, m0, m1, 0);//使用幂基控制点,注意已经除以2Pi了
		F1 = F1_n(eta, m0, m1, 1);
		F2 = F1_n(eta, m0, m1, 2);
		F3 = F1_n(eta, m0, m1, 3);
		F4 = F1_n(eta, m0, m1, 4);
		F5 = F1_n(eta, m0, m1, 5);
		F6 = F1_n(eta, m0, m1, 6);
		F7 = F1_n(eta, m0, m1, 7);
		F8 = F1_n(eta, m0, m1, 8);
		F9 = F1_n(eta, m0, m1, 9);
		F10 = F1_n(eta, m0, m1, 10);
		F11 = F1_n(eta, m0, m1, 11);
		F12 = F1_n(eta, m0, m1, 12);
		F13 = F1_n(eta, m0, m1, 13);
		/*std::cout << eta << m0 << m1 << m2 << std::endl;
		std::cout << "new" << F0 << " " << F1 << " " << F2 << " " << F3 << " " << F4 << " " << F5 << " " << std::endl;*/

		Ic0_1 = (Ic0_1t0 * F0 + Ic0_1t1 * F1 + Ic0_1t2 * F2 + Ic0_1t3 * F3 + Ic0_1t4 * F4 + Ic0_1t5 * F5 + Ic0_1t6 * F6 + Ic0_1t7 * F7);
		//Ix0_1余项
		double Ix0_1Item = ((2 * (-(c1y * c3x) + c1x * c3y)) / 7. + (-(c2y * c3x) + c2x * c3y) / 8. + (-(c0y * c1x) + c0x * c1y - c1y * etax + c1x * etay) / 4. +
			(2 * (-(c0y * c2x) + c0x * c2y - c2y * etax + c2x * etay)) / 5. +
			(-(c1y * c2x) + c1x * c2y - 3 * c0y * c3x + 3 * c0x * c3y - 3 * c3y * etax + 3 * c3x * etay) / 6.) *
			(-1 + log(pow(c0x + c1x + c2x + c3x - etax, 2) + pow(c0y + c1y + c2y + c3y - etay, 2)));
		//计算Ix0_1

		Ix0_1 = -(Ix0_1t0 * F0 + Ix0_1t1 * F1 + Ix0_1t2 * F2 + Ix0_1t3 * F3 + Ix0_1t4 * F4 + Ix0_1t5 * F5
			+ Ix0_1t6 * F6 + Ix0_1t7 * F7 + Ix0_1t8 * F8 + Ix0_1t9 * F9 + Ix0_1t10 * F10 + Ix0_1t11 * F11 + Ix0_1t12 * F12 + Ix0_1t13 * F13) + Ix0_1Item / (8 * M_PI);
	}

	//右边半段
	m0 = v1;  m1 = 3 * (v12 - v1);  m2 = 3 * v1 - 6 * v12 + 3 * v21; m3 = -v1 + 3 * v12 - 3 * v21 + v2;
	c0 = m0;  c1 = m1;  c2 = m2; c3 = m3;
	//这里m3应该为0.
	c0x = c0[0]; c0y = c0[1]; c1x = c1[0]; c1y = c1[1]; c2x = c2[0]; c2y = c2[1]; c3x = c3[0]; c3y = c3[1]; etax = eta[0]; etay = eta[1];

	F0 = F1_n(eta, m0, m1, 0);//使用幂基控制点,注意已经除以2Pi了
	F1 = F1_n(eta, m0, m1, 1);
	F2 = F1_n(eta, m0, m1, 2);
	F3 = F1_n(eta, m0, m1, 3);
	F4 = F1_n(eta, m0, m1, 4);
	F5 = F1_n(eta, m0, m1, 5);
	F6 = F1_n(eta, m0, m1, 6);
	F7 = F1_n(eta, m0, m1, 7);
	F8 = F1_n(eta, m0, m1, 8);
	F9 = F1_n(eta, m0, m1, 9);
	F10 = F1_n(eta, m0, m1, 10);
	F11 = F1_n(eta, m0, m1, 11);
	F12 = F1_n(eta, m0, m1, 12);
	F13 = F1_n(eta, m0, m1, 13);
	F14 = F1_n(eta, m0, m1, 14);
	/*std::cout << eta << m0 << m1 << m2 << std::endl;
	std::cout << "new" << F0 << " " << F1 << " " << F2 << " " << F3 << " " << F4 << " " << F5 << " " << std::endl;*/

	//Ic0系数
	{//Ic0的系数
		std::vector<double> valuesIc0 = { -(c0y * c1x) + c0x * c1y - c1y * etax + c1x * etay,3 * c0y * c1x - 3 * c0x * c1y - 2 * c0y * c2x + 2 * c0x * c2y + 3 * c1y * etax - 2 * c2y * etax -
	3 * c1x * etay + 2 * c2x * etay,-3 * c0y * c1x + 3 * c0x * c1y + 6 * c0y * c2x - c1y * c2x - 6 * c0x * c2y + c1x * c2y - 3 * c0y * c3x + 3 * c0x * c3y -
	3 * c1y * etax + 6 * c2y * etax - 3 * c3y * etax + 3 * c1x * etay - 6 * c2x * etay + 3 * c3x * etay,
   c0y * c1x - c0x * c1y - 6 * c0y * c2x + 3 * c1y * c2x + 6 * c0x * c2y - 3 * c1x * c2y + 9 * c0y * c3x - 2 * c1y * c3x - 9 * c0x * c3y + 2 * c1x * c3y +
	c1y * etax - 6 * c2y * etax + 9 * c3y * etax - c1x * etay + 6 * c2x * etay - 9 * c3x * etay,
   2 * c0y * c2x - 3 * c1y * c2x - 2 * c0x * c2y + 3 * c1x * c2y - 9 * c0y * c3x + 6 * c1y * c3x - c2y * c3x + 9 * c0x * c3y - 6 * c1x * c3y + c2x * c3y +
	2 * c2y * etax - 9 * c3y * etax - 2 * c2x * etay + 9 * c3x * etay,
   c1y * c2x - c1x * c2y + 3 * c0y * c3x - 6 * c1y * c3x + 3 * c2y * c3x - 3 * c0x * c3y + 6 * c1x * c3y - 3 * c2x * c3y + 3 * c3y * etax - 3 * c3x * etay,
   2 * c1y * c3x - 3 * c2y * c3x - 2 * c1x * c3y + 3 * c2x * c3y,c2y * c3x - c2x * c3y };
		Ic0t0 = valuesIc0[0];
		Ic0t1 = valuesIc0[1];
		Ic0t2 = valuesIc0[2];
		Ic0t3 = valuesIc0[3];
		Ic0t4 = valuesIc0[4];
		Ic0t5 = valuesIc0[5];
		Ic0t6 = valuesIc0[6];
		Ic0t7 = valuesIc0[7];
	}
	//Ic1系数
	{//Ic1的系数
		std::vector<double> valuesIc1 = { 0,3 * (-(c0y * c1x) + c0x * c1y - c1y * etax + c1x * etay),-6 * (c1y - c2y) * (c0x - etax) + 6 * (c1x - c2x) * (c0y - etay),
   3 * (c1x * c2y - c0y * (c1x - 4 * c2x + 3 * c3x) + c0x * (c1y - 4 * c2y + 3 * c3y) + 4 * c2y * etax - 3 * c3y * etax - c1y * (c2x + etax) +
	  (c1x - 4 * c2x + 3 * c3x) * etay),6 * (-(c0y * c2x) + c1y * c2x + c0x * c2y - c1x * c2y + 3 * c0y * c3x - c1y * c3x - 3 * c0x * c3y +
	  c1x * c3y - c2y * etax + 3 * c3y * etax + c2x * etay - 3 * c3x * etay),
   3 * (-(c1y * (c2x - 4 * c3x)) + c1x * (c2y - 4 * c3y) + c3y * (3 * c0x + c2x - 3 * etax) - c3x * (3 * c0y + c2y - 3 * etay)),
   6 * (-(c1y * c3x) + c2y * c3x + (c1x - c2x) * c3y),-3 * c2y * c3x + 3 * c2x * c3y };
		Ic1t0 = valuesIc1[0];
		Ic1t1 = valuesIc1[1];
		Ic1t2 = valuesIc1[2];
		Ic1t3 = valuesIc1[3];
		Ic1t4 = valuesIc1[4];
		Ic1t5 = valuesIc1[5];
		Ic1t6 = valuesIc1[6];
		Ic1t7 = valuesIc1[7];
	}
	//Ic2系数
	{
		std::vector<double> valuesIc2 = { 0,0,3 * (-(c0y * c1x) + c0x * c1y - c1y * etax + c1x * etay),-3 * (c1y - 2 * c2y) * (c0x - etax) + 3 * (c1x - 2 * c2x) * (c0y - etay),
   6 * c0y * c2x - 3 * c1y * c2x - 6 * c0x * c2y + 3 * c1x * c2y - 9 * c0y * c3x + 9 * c0x * c3y + 6 * c2y * etax - 9 * c3y * etax - 6 * c2x * etay +
	9 * c3x * etay,-3 * c1x * c2y + 3 * c1y * (c2x - 2 * c3x) + 9 * c0y * c3x - 9 * c0x * c3y + 6 * c1x * c3y + 9 * c3y * etax - 9 * c3x * etay,
   6 * c1y * c3x - 3 * c2y * c3x + 3 * (-2 * c1x + c2x) * c3y,3 * c2y * c3x - 3 * c2x * c3y };
		Ic2t0 = valuesIc2[0];
		Ic2t1 = valuesIc2[1];
		Ic2t2 = valuesIc2[2];
		Ic2t3 = valuesIc2[3];
		Ic2t4 = valuesIc2[4];
		Ic2t5 = valuesIc2[5];
		Ic2t6 = valuesIc2[6];
		Ic2t7 = valuesIc2[7];
	}
	//It0系数
	{
		std::vector<double> valuesIt0 = { 0,3 * (c0x * c1x + c0y * c1y - c1x * etax - c1y * etay),
   3 * (-(c0x * c1x) + pow(c1x,2) - c0y * c1y + pow(c1y,2) + 2 * c0x * c2x + 2 * c0y * c2y + c1x * etax - 2 * c2x * etax + c1y * etay -
	  2 * c2y * etay),-3 * c1x * (c1x - 3 * c2x) - 3 * c1y * (c1y - 3 * c2y) + c0x * (c1x - 6 * c2x + 9 * c3x) + c0y * (c1y - 6 * c2y + 9 * c3y) -
	(c1x - 6 * c2x + 9 * c3x) * etax - (c1y - 6 * c2y + 9 * c3y) * etay,
   pow(c1x,2) + pow(c1y,2) + 2 * c0x * c2x - 9 * c1x * c2x + 6 * pow(c2x,2) + 2 * c0y * c2y - 9 * c1y * c2y + 6 * pow(c2y,2) -
	9 * c0x * c3x + 12 * c1x * c3x - 9 * c0y * c3y + 12 * c1y * c3y - 2 * c2x * etax + 9 * c3x * etax - 2 * c2y * etay + 9 * c3y * etay,
   3 * (-2 * pow(c2x,2) + c1y * c2y - 2 * pow(c2y,2) + c1x * (c2x - 4 * c3x) + c0x * c3x + 5 * c2x * c3x + c0y * c3y - 4 * c1y * c3y +
	  5 * c2y * c3y - c3x * etax - c3y * etay),2 * pow(c2x,2) + 2 * pow(c2y,2) + 4 * c1x * c3x - 15 * c2x * c3x + 9 * pow(c3x,2) +
	4 * c1y * c3y - 15 * c2y * c3y + 9 * pow(c3y,2),5 * c2x * c3x - 9 * pow(c3x,2) + (5 * c2y - 9 * c3y) * c3y,
   3 * (pow(c3x,2) + pow(c3y,2)) };
		It0t0 = valuesIt0[0];
		It0t1 = valuesIt0[1];
		It0t2 = valuesIt0[2];
		It0t3 = valuesIt0[3];
		It0t4 = valuesIt0[4];
		It0t5 = valuesIt0[5];
		It0t6 = valuesIt0[6];
		It0t7 = valuesIt0[7];
		It0t8 = valuesIt0[8];
	}
	//It1系数
	{
		std::vector<double> valuesIt1 = { 0,0,3 * (c0x * c1x + c0y * c1y - c1x * etax - c1y * etay),
   -2 * c0x * c1x + 3 * pow(c1x,2) - 2 * c0y * c1y + 3 * pow(c1y,2) + 6 * c0x * c2x + 6 * c0y * c2y + 2 * c1x * etax - 6 * c2x * etax +
	2 * c1y * etay - 6 * c2y * etay,-2 * pow(c1x,2) - 2 * pow(c1y,2) + 9 * c1x * c2x + 9 * c1y * c2y - (4 * c2x - 9 * c3x) * (c0x - etax) -
	(4 * c2y - 9 * c3y) * (c0y - etay),6 * (-(c1x * c2x) + pow(c2x,2) - c1y * c2y + pow(c2y,2) - c0x * c3x + 2 * c1x * c3x - c0y * c3y +
	  2 * c1y * c3y + c3x * etax + c3y * etay),-4 * pow(c2x,2) - 4 * pow(c2y,2) + 15 * c2x * c3x + 15 * c2y * c3y - 8 * (c1x * c3x + c1y * c3y),
   -10 * c2x * c3x + 9 * pow(c3x,2) + c3y * (-10 * c2y + 9 * c3y),-6 * (pow(c3x,2) + pow(c3y,2)) };
		It1t0 = valuesIt1[0];
		It1t1 = valuesIt1[1];
		It1t2 = valuesIt1[2];
		It1t3 = valuesIt1[3];
		It1t4 = valuesIt1[4];
		It1t5 = valuesIt1[5];
		It1t6 = valuesIt1[6];
		It1t7 = valuesIt1[7];
		It1t8 = valuesIt1[8];
	}
	//It2系数
	{
		std::vector<double> valuesIt2 = { 0,0,0,c0x * c1x + c0y * c1y - c1x * etax - c1y * etay,
   pow(c1x,2) + pow(c1y,2) + 2 * c0x * c2x + 2 * c0y * c2y - 2 * c2x * etax - 2 * c2y * etay,
   3 * (c1x * c2x + c1y * c2y + c0x * c3x + c0y * c3y - c3x * etax - c3y * etay),
   2 * (pow(c2x,2) + pow(c2y,2) + 2 * c1x * c3x + 2 * c1y * c3y),5 * (c2x * c3x + c2y * c3y),3 * (pow(c3x,2) + pow(c3y,2)) };
		It2t0 = valuesIt2[0];
		It2t1 = valuesIt2[1];
		It2t2 = valuesIt2[2];
		It2t3 = valuesIt2[3];
		It2t4 = valuesIt2[4];
		It2t5 = valuesIt2[5];
		It2t6 = valuesIt2[6];
		It2t7 = valuesIt2[7];
		It2t8 = valuesIt2[8];
	}
	//Ix0系数
	{
		std::vector<double> valuesIx0 = { 0,((-(c0y * c1x) + c0x * c1y - c1y * etax + c1x * etay) * (c0x * c1x + c0y * c1y - c1x * etax - c1y * etay)) / 2.,
   (pow(c0y,2) * (3 * c1x * c1y - 2 * c1y * c2x - 4 * c1x * c2y) + pow(c0x,2) * (-3 * c1x * c1y + 4 * c1y * c2x + 2 * c1x * c2y) +
	  etax * (-2 * c1y * (pow(c1x,2) + pow(c1y,2)) + (-3 * c1x * c1y + 4 * c1y * c2x + 2 * c1x * c2y) * etax) +
	  2 * c1x * (pow(c1x,2) + pow(c1y,2)) * etay + 3 * (pow(c1x,2) - 2 * c1x * c2x - c1y * (c1y - 2 * c2y)) * etax * etay +
	  (3 * c1x * c1y - 2 * c1y * c2x - 4 * c1x * c2y) * pow(etay,2) +
	  c0x * (3 * c0y * (pow(c1x,2) - pow(c1y,2) - 2 * c1x * c2x + 2 * c1y * c2y) +
		 2 * (pow(c1x,2) * c1y + pow(c1y,3) + 3 * c1x * c1y * etax - 4 * c1y * c2x * etax - 2 * c1x * c2y * etax) +
		 3 * (-pow(c1x,2) + pow(c1y,2) + 2 * c1x * c2x - 2 * c1y * c2y) * etay) +
	  c0y * (-2 * pow(c1x,3) - 3 * pow(c1x,2) * etax + c1y * (3 * c1y * etax - 6 * c2y * etax + 4 * c2x * etay) -
		 2 * c1x * (pow(c1y,2) - 3 * c2x * etax + 3 * c1y * etay - 4 * c2y * etay))) / 4.,
   (6 * pow(c0x,2) * (2 * c2x * c2y + 3 * c1y * (-c2x + c3x) + c1x * (c1y - 2 * c2y + c3y)) -
	  6 * pow(c0y,2) * (2 * c2x * c2y + c1y * (-2 * c2x + c3x) + c1x * (c1y - 3 * c2y + 3 * c3y)) +
	  etax * (9 * pow(c1x,2) * c1y + 9 * pow(c1y,3) - 16 * c1x * c1y * c2x - 8 * pow(c1x,2) * c2y - 24 * pow(c1y,2) * c2y +
		 6 * (2 * c2x * c2y + 3 * c1y * (-c2x + c3x) + c1x * (c1y - 2 * c2y + c3y)) * etax) +
	  (-9 * pow(c1x,3) - 9 * c1x * pow(c1y,2) + 24 * pow(c1x,2) * c2x + 8 * pow(c1y,2) * c2x + 16 * c1x * c1y * c2y -
		 6 * (pow(c1x,2) - pow(c1y,2) - 5 * c1x * c2x + 2 * pow(c2x,2) + 5 * c1y * c2y - 2 * pow(c2y,2) + 4 * c1x * c3x -
			4 * c1y * c3y) * etax) * etay - 6 * (2 * c2x * c2y + c1y * (-2 * c2x + c3x) + c1x * (c1y - 3 * c2y + 3 * c3y)) * pow(etay,2) +
	  c0x * (-9 * pow(c1y,3) + 24 * pow(c1y,2) * c2y -
		 6 * c0y * (pow(c1x,2) - pow(c1y,2) - 5 * c1x * c2x + 2 * pow(c2x,2) + 5 * c1y * c2y - 2 * pow(c2y,2) + 4 * c1x * c3x -
			4 * c1y * c3y) + 36 * c1y * c2x * etax - 24 * c2x * c2y * etax - 36 * c1y * c3x * etax -
		 6 * (pow(c1y,2) - 2 * pow(c2x,2) - 5 * c1y * c2y + 2 * pow(c2y,2) + 4 * c1y * c3y) * etay +
		 pow(c1x,2) * (-9 * c1y + 8 * c2y + 6 * etay) +
		 2 * c1x * (8 * c1y * c2x - 6 * c1y * etax + 12 * c2y * etax - 6 * c3y * etax - 15 * c2x * etay + 12 * c3x * etay)) +
	  c0y * (9 * pow(c1x,3) + 6 * pow(c1x,2) * (-4 * c2x + etax) +
		 c1x * (9 * pow(c1y,2) - 16 * c1y * c2y - 30 * c2x * etax + 24 * c3x * etax + 12 * (c1y - 3 * c2y + 3 * c3y) * etay) -
		 2 * (pow(c1y,2) * (4 * c2x + 3 * etax) - 6 * (pow(c2x,2) * etax - pow(c2y,2) * etax + 2 * c2x * c2y * etay) +
			3 * c1y * (-5 * c2y * etax + 4 * c3y * etax + 4 * c2x * etay - 2 * c3x * etay)))) / 12.,
   (-4 * pow(c1x,2) * c1y * c2x - 4 * pow(c1y,3) * c2x + 4 * pow(c1x,3) * c2y + 4 * c1x * pow(c1y,2) * c2y +
	  3 * pow(c0y,2) * (-6 * c1y * c2x + 16 * c2x * c2y + 9 * c1y * c3x - 8 * c2y * c3x - 12 * c2x * c3y + c1x * (c1y - 8 * c2y + 18 * c3y)) -
	  c0y * (12 * pow(c1x,3) + pow(c1x,2) * (-78 * c2x + 60 * c3x) + c1y * (-33 * c1y * c2x + 44 * c2x * c2y + 18 * c1y * c3x) +
		 c1x * (12 * pow(c1y,2) + 60 * pow(c2x,2) - 45 * c1y * c2y + 16 * pow(c2y,2) + 42 * c1y * c3y)) -
	  3 * pow(c0x,2) * (c1x * (c1y - 6 * c2y + 9 * c3y) - 2 * (4 * c1y * c2x - 8 * c2x * c2y - 9 * c1y * c3x + 6 * c2y * c3x + 4 * c2x * c3y)) -
	  12 * pow(c1x,2) * c1y * etax - 12 * pow(c1y,3) * etax + 45 * c1x * c1y * c2x * etax - 16 * c1y * pow(c2x,2) * etax +
	  33 * pow(c1x,2) * c2y * etax + 78 * pow(c1y,2) * c2y * etax - 44 * c1x * c2x * c2y * etax - 60 * c1y * pow(c2y,2) * etax -
	  42 * c1x * c1y * c3x * etax - 18 * pow(c1x,2) * c3y * etax - 60 * pow(c1y,2) * c3y * etax +
	  3 * c0y * (-pow(c1x,2) + pow(c1y,2) + c1x * (14 * c2x - 27 * c3x) + 4 * c2x * (-4 * c2x + 5 * c3x) + 4 * c2y * (4 * c2y - 5 * c3y) +
		 c1y * (-14 * c2y + 27 * c3y)) * etax - 3 * c1x * c1y * pow(etax,2) + 24 * c1y * c2x * pow(etax,2) + 18 * c1x * c2y * pow(etax,2) -
	  48 * c2x * c2y * pow(etax,2) - 54 * c1y * c3x * pow(etax,2) + 36 * c2y * c3x * pow(etax,2) - 27 * c1x * c3y * pow(etax,2) +
	  24 * c2x * c3y * pow(etax,2) - 6 * c0y * (-6 * c1y * c2x + 16 * c2x * c2y + 9 * c1y * c3x - 8 * c2y * c3x - 12 * c2x * c3y +
		 c1x * (c1y - 8 * c2y + 18 * c3y)) * etay + (12 * pow(c1x,3) +
		 12 * (4 * pow(c2x,2) - 4 * pow(c2y,2) - 5 * c2x * c3x + 5 * c2y * c3y) * etax - 3 * pow(c1y,2) * (11 * c2x - 6 * c3x + etax) +
		 3 * pow(c1x,2) * (-26 * c2x + 20 * c3x + etax) +
		 c1x * (12 * pow(c1y,2) + 60 * pow(c2x,2) - 45 * c1y * c2y + 16 * pow(c2y,2) + 42 * c1y * c3y - 42 * c2x * etax +
			81 * c3x * etax) + c1y * (44 * c2x * c2y + 42 * c2y * etax - 81 * c3y * etax)) * etay +
	  3 * (-6 * c1y * c2x + 16 * c2x * c2y + 9 * c1y * c3x - 8 * c2y * c3x - 12 * c2x * c3y + c1x * (c1y - 8 * c2y + 18 * c3y)) * pow(etay,2) +
	  c0x * (2 * c1y * (6 * pow(c1y,2) + 8 * pow(c2x,2) - 39 * c1y * c2y + 30 * pow(c2y,2) + 30 * c1y * c3y) +
		 3 * c0y * (pow(c1x,2) - pow(c1y,2) + 4 * c2x * (4 * c2x - 5 * c3x) + c1x * (-14 * c2x + 27 * c3x) + c1y * (14 * c2y - 27 * c3y) +
			4 * c2y * (-4 * c2y + 5 * c3y)) - 12 * (4 * c1y * c2x - 8 * c2x * c2y - 9 * c1y * c3x + 6 * c2y * c3x + 4 * c2x * c3y) * etax +
		 3 * pow(c1x,2) * (4 * c1y - 11 * c2y + 6 * c3y - etay) +
		 3 * (pow(c1y,2) - 14 * c1y * c2y + 16 * pow(c2y,2) + 4 * c2x * (-4 * c2x + 5 * c3x) + 27 * c1y * c3y - 20 * c2y * c3y) * etay +
		 c1x * (-45 * c1y * c2x + 44 * c2x * c2y - 36 * c2y * etax + 54 * c3y * etax + 6 * c1y * (7 * c3x + etax) + 42 * c2x * etay - 81 * c3x * etay))) /
	24.,(15 * pow(c1x,2) * c1y * c2x + 15 * pow(c1y,3) * c2x - 20 * c1x * c1y * pow(c2x,2) - 15 * pow(c1x,3) * c2y -
	  15 * c1x * pow(c1y,2) * c2y + 20 * pow(c1x,2) * c2x * c2y - 20 * pow(c1y,2) * c2x * c2y + 20 * c1x * c1y * pow(c2y,2) -
	  10 * pow(c1x,2) * c1y * c3x - 10 * pow(c1y,3) * c3x + 10 * pow(c1x,3) * c3y + 10 * c1x * pow(c1y,2) * c3y +
	  2 * pow(c0y,2) * (2 * c1y * (2 * c2x - 9 * c3x) + 5 * c2y * (c1x - 6 * c2x + 9 * c3x) - 30 * (c1x - 2 * c2x + c3x) * c3y) +
	  2 * pow(c0x,2) * (-4 * c1x * c2y + 18 * c1x * c3y -
		 5 * (-6 * c2x * c2y + c1y * (c2x - 6 * c3x) + 12 * c2y * c3x + 9 * c2x * c3y - 6 * c3x * c3y)) + 5 * pow(c1x,2) * c1y * etax +
	  5 * pow(c1y,3) * etax - 48 * c1x * c1y * c2x * etax + 30 * c1y * pow(c2x,2) * etax - 42 * pow(c1x,2) * c2y * etax -
	  90 * pow(c1y,2) * c2y * etax + 150 * c1x * c2x * c2y * etax - 40 * pow(c2x,2) * c2y * etax + 180 * c1y * pow(c2y,2) * etax -
	  40 * pow(c2y,3) * etax + 96 * c1x * c1y * c3x * etax - 60 * c1y * c2x * c3x * etax - 96 * c1x * c2y * c3x * etax + 69 * pow(c1x,2) * c3y * etax +
	  165 * pow(c1y,2) * c3y * etax - 84 * c1x * c2x * c3y * etax - 240 * c1y * c2y * c3y * etax - 10 * c1y * c2x * pow(etax,2) -
	  8 * c1x * c2y * pow(etax,2) + 60 * c2x * c2y * pow(etax,2) + 60 * c1y * c3x * pow(etax,2) - 120 * c2y * c3x * pow(etax,2) +
	  36 * c1x * c3y * pow(etax,2) - 90 * c2x * c3y * pow(etax,2) + 60 * c3x * c3y * pow(etax,2) +
	  (-5 * pow(c1x,3) + 40 * c2x * (pow(c2x,2) + pow(c2y,2)) + pow(c1y,2) * (42 * c2x - 69 * c3x) +
		 15 * pow(c1x,2) * (6 * c2x - 11 * c3x) - 30 * (2 * pow(c2x,2) - 2 * pow(c2y,2) - 7 * c2x * c3x + 2 * pow(c3x,2) +
			7 * c2y * c3y - 2 * pow(c3y,2)) * etax + c1x *
		  (-5 * pow(c1y,2) + 48 * c1y * (c2y - 2 * c3y) - 30 * (6 * pow(c2x,2) + pow(c2y,2) - 8 * c2x * c3x - 2 * c2y * c3y) +
			6 * (3 * c2x - 16 * c3x) * etax) + 6 * c1y * (-25 * c2x * c2y + 14 * c2y * c3x + 16 * c2x * c3y - 3 * c2y * etax + 16 * c3y * etax)) * etay +
	  2 * (2 * c1y * (2 * c2x - 9 * c3x) + 5 * c2y * (c1x - 6 * c2x + 9 * c3x) - 30 * (c1x - 2 * c2x + c3x) * c3y) * pow(etay,2) +
	  c0x * (-5 * pow(c1y,3) + 40 * c2y * (pow(c2x,2) + pow(c2y,2)) + pow(c1x,2) * (-5 * c1y + 42 * c2y - 69 * c3y) +
		 15 * pow(c1y,2) * (6 * c2y - 11 * c3y) - 60 * (2 * c2x * c2y - 4 * c2y * c3x - 3 * c2x * c3y + 2 * c3x * c3y) * etax +
		 30 * (2 * pow(c2x,2) - 2 * pow(c2y,2) - 7 * c2x * c3x + 2 * pow(c3x,2) + 7 * c2y * c3y - 2 * pow(c3y,2)) * etay +
		 2 * c1x * (-75 * c2x * c2y + 24 * c1y * (c2x - 2 * c3x) + 48 * c2y * c3x + 42 * c2x * c3y + 8 * c2y * etax - 36 * c3y * etax - 9 * c2x * etay +
			48 * c3x * etay) + 2 * c1y * (-90 * pow(c2y,2) - 15 * c2x * (c2x - 2 * c3x) + 120 * c2y * c3y + 10 * (c2x - 6 * c3x) * etax +
			9 * c2y * etay - 48 * c3y * etay)) + c0y * (5 * pow(c1x,3) + pow(c1y,2) * (-42 * c2x + 69 * c3x) +
		 pow(c1x,2) * (-90 * c2x + 165 * c3x) - 2 * c1y *
		  (9 * c0x * c2y - 75 * c2x * c2y + 42 * c2y * c3x - 48 * c0x * c3y + 48 * c2x * c3y - 9 * c2y * etax + 48 * c3y * etax + 8 * c2x * etay -
			36 * c3x * etay) + c1x * (5 * pow(c1y,2) - 48 * c1y * (c2y - 2 * c3y) +
			6 * (3 * c0x * c2x + 30 * pow(c2x,2) - 16 * c0x * c3x - 40 * c2x * c3x + 5 * c2y * (c2y - 2 * c3y) - 3 * c2x * etax + 16 * c3x * etax) -
			20 * (c2y - 6 * c3y) * etay) + 10 * (-4 * pow(c2x,3) - 4 * c2x * pow(c2y,2) +
			3 * c0x * (-2 * pow(c2x,2) + 2 * pow(c2y,2) + 7 * c2x * c3x - 2 * pow(c3x,2) - 7 * c2y * c3y + 2 * pow(c3y,2)) +
			6 * pow(c2x,2) * etax - 6 * pow(c2y,2) * etax - 21 * c2x * c3x * etax + 6 * pow(c3x,2) * etax + 21 * c2y * c3y * etax -
			6 * pow(c3y,2) * etax + 6 * (2 * c2x * c2y - 3 * c2y * c3x - 4 * c2x * c3y + 2 * c3x * c3y) * etay))) / 40.,
   (-36 * pow(c1x,2) * c1y * c2x - 36 * pow(c1y,3) * c2x + 135 * c1x * c1y * pow(c2x,2) - 40 * c1y * pow(c2x,3) +
	  36 * pow(c1x,3) * c2y + 36 * c1x * pow(c1y,2) * c2y - 135 * pow(c1x,2) * c2x * c2y + 135 * pow(c1y,2) * c2x * c2y +
	  40 * c1x * pow(c2x,2) * c2y - 135 * c1x * c1y * pow(c2y,2) - 40 * c1y * c2x * pow(c2y,2) + 40 * c1x * pow(c2y,3) +
	  72 * pow(c1x,2) * c1y * c3x + 72 * pow(c1y,3) * c3x - 170 * c1x * c1y * c2x * c3x + 68 * pow(c1x,2) * c2y * c3x -
	  102 * pow(c1y,2) * c2y * c3x - 72 * pow(c1x,3) * c3y - 72 * c1x * pow(c1y,2) * c3y + 102 * pow(c1x,2) * c2x * c3y -
	  68 * pow(c1y,2) * c2x * c3y + 170 * c1x * c1y * c2y * c3y +
	  3 * pow(c0y,2) * (10 * c1y * c3x - 72 * c2y * c3x + 2 * c2x * (8 * c2y - 45 * c3y) + 15 * (c1x + 9 * c3x) * c3y) -
	  3 * pow(c0x,2) * (8 * c2x * (2 * c2y - 9 * c3y) + 10 * c1x * c3y + 15 * c3x * (c1y - 6 * c2y + 9 * c3y)) + 35 * c1x * c1y * c2x * etax -
	  48 * c1y * pow(c2x,2) * etax + 34 * pow(c1x,2) * c2y * etax + 69 * pow(c1y,2) * c2y * etax - 342 * c1x * c2x * c2y * etax +
	  240 * pow(c2x,2) * c2y * etax - 390 * c1y * pow(c2y,2) * etax + 240 * pow(c2y,3) * etax - 180 * c1x * c1y * c3x * etax +
	  171 * c1y * c2x * c3x * etax + 585 * c1x * c2y * c3x * etax - 276 * c2x * c2y * c3x * etax - 90 * c1y * pow(c3x,2) * etax -
	  168 * pow(c1x,2) * c3y * etax - 348 * pow(c1y,2) * c3y * etax + 579 * c1x * c2x * c3y * etax - 144 * pow(c2x,2) * c3y * etax +
	  1335 * c1y * c2y * c3y * etax - 420 * pow(c2y,2) * c3y * etax - 330 * c1x * c3x * c3y * etax - 420 * c1y * pow(c3y,2) * etax -
	  48 * c2x * c2y * pow(etax,2) - 45 * c1y * c3x * pow(etax,2) + 270 * c2y * c3x * pow(etax,2) - 30 * c1x * c3y * pow(etax,2) +
	  216 * c2x * c3y * pow(etax,2) - 405 * c3x * c3y * pow(etax,2) +
	  (-34 * pow(c1y,2) * c2x - 240 * pow(c2x,3) + 342 * c1y * c2x * c2y - 240 * c2x * pow(c2y,2) + 168 * pow(c1y,2) * c3x +
		 420 * pow(c2x,2) * c3x - 579 * c1y * c2y * c3x + 144 * pow(c2y,2) * c3x + pow(c1x,2) * (-69 * c2x + 348 * c3x) -
		 585 * c1y * c2x * c3y + 276 * c2x * c2y * c3y + 330 * c1y * c3x * c3y +
		 3 * (16 * pow(c2x,2) - 16 * pow(c2y,2) - 162 * c2x * c3x + 135 * pow(c3x,2) + 162 * c2y * c3y - 5 * c3y * (5 * c1y + 27 * c3y)) *
		  etax + c1x * (48 * pow(c2y,2) - 171 * c2y * c3y + 90 * pow(c3y,2) + 5 * c1y * (-7 * c2y + 36 * c3y) +
			15 * (26 * pow(c2x,2) - 89 * c2x * c3x + c3x * (28 * c3x + 5 * etax)))) * etay +
	  3 * (10 * c1y * c3x - 72 * c2y * c3x + 2 * c2x * (8 * c2y - 45 * c3y) + 15 * (c1x + 9 * c3x) * c3y) * pow(etay,2) +
	  c0y * (pow(c1x,2) * (69 * c2x - 348 * c3x) + 2 * pow(c1y,2) * (17 * c2x - 84 * c3x) -
		 c1x * (48 * pow(c2y,2) - 75 * c0x * c3x - 171 * c2y * c3y + 5 * c1y * (-7 * c2y + 36 * c3y) +
			15 * (26 * pow(c2x,2) - 89 * c2x * c3x + c3x * (28 * c3x + 5 * etax)) + 90 * c3y * (c3y + etay)) +
		 c1y * (579 * c2y * c3x + 9 * c2x * (-38 * c2y + 65 * c3y) - 15 * (5 * c0x * c3y + 22 * c3x * c3y - 5 * c3y * etax + 4 * c3x * etay)) +
		 3 * (80 * pow(c2x,3) - 48 * pow(c2y,2) * c3x +
			c0x * (16 * pow(c2x,2) - 16 * pow(c2y,2) - 162 * c2x * c3x + 162 * c2y * c3y + 135 * (c3x - c3y) * (c3x + c3y)) +
			16 * pow(c2y,2) * etax - 135 * pow(c3x,2) * etax - 162 * c2y * c3y * etax + 135 * pow(c3y,2) * etax -
			4 * pow(c2x,2) * (35 * c3x + 4 * etax) + 18 * c3x * (8 * c2y - 15 * c3y) * etay +
			2 * c2x * (40 * pow(c2y,2) + 81 * c3x * etax + 90 * c3y * etay - 2 * c2y * (23 * c3y + 8 * etay)))) +
	  c0x * (pow(c1x,2) * (-34 * c2y + 168 * c3y) + c1x *
		  (342 * c2x * c2y - 585 * c2y * c3x + 5 * c1y * (-7 * c2x + 36 * c3x) - 579 * c2x * c3y + 330 * c3x * c3y + 60 * c3y * etax - 75 * c3x * etay) +
		 3 * (-80 * pow(c2y,3) + 140 * pow(c2y,2) * c3y + pow(c1y,2) * (-23 * c2y + 116 * c3y) - 180 * c2y * c3x * etax +
			270 * c3x * c3y * etax + 16 * pow(c2y,2) * etay - 135 * pow(c3x,2) * etay - 162 * c2y * c3y * etay + 135 * pow(c3y,2) * etay -
			16 * pow(c2x,2) * (5 * c2y - 3 * c3y + etay) + 2 * c2x * (46 * c2y * c3x + 16 * c2y * etax - 72 * c3y * etax + 81 * c3x * etay) +
			c1y * (16 * pow(c2x,2) - 57 * c2x * c3x + 5 *
				(26 * pow(c2y,2) - 89 * c2y * c3y + 28 * pow(c3y,2) + 6 * c3x * (c3x + etax) + 5 * c3y * etay))))) / 120.,
   (35 * pow(c1y,3) * (c2x - 6 * c3x) - 35 * pow(c1x,3) * (c2y - 6 * c3y) +
	  3 * pow(c1y,2) * (55 * c0y * c3x + 287 * c2y * c3x + 7 * c2x * (-18 * c2y + 25 * c3y) - 35 * c3y * (3 * c0x + 4 * c3x - 3 * etax) -
		 55 * c3x * etay) + pow(c1x,2) * (35 * c1y * (c2x - 6 * c3x) + 21 * c2x * (18 * c2y - 41 * c3y) +
		 15 * (21 * c0y * c3x - 35 * c2y * c3x - 11 * c0x * c3y + 28 * c3x * c3y + 11 * c3y * etax - 21 * c3x * etay)) +
	  c1x * (-322 * c0x * c2x * c2y - 315 * pow(c2x,2) * c2y - 315 * pow(c2y,3) + 1548 * c0x * c2y * c3x + 224 * c2x * c2y * c3x -
		 35 * pow(c1y,2) * (c2y - 6 * c3y) + 1644 * c0x * c2x * c3y + 336 * pow(c2x,2) * c3y + 560 * pow(c2y,2) * c3y -
		 2646 * c0x * c3x * c3y + c0y * (357 * pow(c2x,2) + 35 * pow(c2y,2) - 3444 * c2x * c3x + 2835 * pow(c3x,2) + 150 * c1y * c3y -
			252 * c2y * c3y + 189 * pow(c3y,2)) + 322 * c2x * c2y * etax - 1548 * c2y * c3x * etax - 1644 * c2x * c3y * etax +
		 2646 * c3x * c3y * etax - 7 * (51 * pow(c2x,2) + 5 * pow(c2y,2) - 492 * c2x * c3x + 405 * pow(c3x,2) - 36 * c2y * c3y +
			27 * pow(c3y,2)) * etay - 6 * c1y * (63 * pow(c2x,2) - 63 * pow(c2y,2) - 231 * c2x * c3x + 231 * c2y * c3y -
			70 * pow(c3y,2) + 5 * c3x * (5 * c0x + 14 * c3x - 5 * etax) + 25 * c3y * etay)) +
	  c1y * (315 * pow(c2x,3) - 7 * c0x * (5 * pow(c2x,2) + 51 * pow(c2y,2) - 36 * c2x * c3x - 492 * c2y * c3y +
			27 * (pow(c3x,2) + 15 * pow(c3y,2))) + 35 * pow(c2x,2) * (-16 * c3x + etax) +
		 c2x * (322 * c0y * c2y + 315 * pow(c2y,2) - 1548 * c0y * c3y - 224 * c2y * c3y - 252 * c3x * etax - 322 * c2y * etay +
			1548 * c3y * etay) - 3 * (c0y * (548 * c2y * c3x - 882 * c3x * c3y) + 7 * pow(c2y,2) * (16 * c3x - 17 * etax) -
			63 * (pow(c3x,2) + 15 * pow(c3y,2)) * etax + 882 * c3x * c3y * etay + 4 * c2y * (287 * c3y * etax - 137 * c3x * etay))) +
	  21 * (-2 * pow(c0x,2) * (6 * c2y * c3x + 5 * c2x * c3y - 27 * c3x * c3y) + 2 * pow(c0y,2) * (5 * c2y * c3x + 6 * c2x * c3y - 27 * c3x * c3y) -
		 etax * (30 * pow(c2y,3) + 5 * pow(c2x,2) * (6 * c2y - 11 * c3y) - 145 * pow(c2y,2) * c3y + 80 * c2y * pow(c3y,2) -
			54 * c3x * c3y * etax + 12 * c2y * c3x * (2 * c3x + etax) + c2x * (-90 * c2y * c3x + 56 * c3x * c3y + 10 * c3y * etax)) +
		 (30 * pow(c2x,3) - 145 * pow(c2x,2) * c3x - 55 * pow(c2y,2) * c3x + 54 * (-pow(c3x,2) + pow(c3y,2)) * etax +
			c2x * (30 * pow(c2y,2) + 80 * pow(c3x,2) - 90 * c2y * c3y + 24 * pow(c3y,2) + 22 * c3x * etax) +
			c2y * (56 * c3x * c3y - 22 * c3y * etax)) * etay + 2 * (5 * c2y * c3x + 6 * c2x * c3y - 27 * c3x * c3y) * pow(etay,2) +
		 c0x * (30 * pow(c2y,3) + 5 * pow(c2x,2) * (6 * c2y - 11 * c3y) - 145 * pow(c2y,2) * c3y + 24 * c2y * c3x * (c3x + etax) +
			2 * c2y * c3y * (40 * c3y + 11 * etay) + c2x * (-90 * c2y * c3x + 56 * c3x * c3y + 20 * c3y * etax - 22 * c3x * etay) +
			54 * (-2 * c3x * c3y * etax + pow(c3x,2) * etay - pow(c3y,2) * etay)) -
		 c0y * (30 * pow(c2x,3) - 145 * pow(c2x,2) * c3x - 55 * pow(c2y,2) * c3x +
			c2y * (22 * c0x * c3y + 56 * c3x * c3y - 22 * c3y * etax + 20 * c3x * etay) +
			54 * ((c3x - c3y) * (c3x + c3y) * (c0x - etax) - 2 * c3x * c3y * etay) +
			c2x * (30 * pow(c2y,2) - 90 * c2y * c3y + 2 * c3x * (-11 * c0x + 40 * c3x + 11 * etax) + 24 * c3y * (c3y + etay))))) / 420.,
   (-336 * c1y * pow(c2x,3) + 140 * pow(c1y,2) * c2x * c2y - 224 * c0x * pow(c2x,2) * c2y - 336 * c1y * c2x * pow(c2y,2) -
	  224 * c0x * pow(c2y,3) + 80 * pow(c1y,3) * c3x - 50 * c0x * c1y * c2x * c3x + 1722 * c1y * pow(c2x,2) * c3x -
	  960 * pow(c1y,2) * c2y * c3x + 1860 * c0x * c2x * c2y * c3x - 112 * pow(c2x,2) * c2y * c3x + 1092 * c1y * pow(c2y,2) * c3x -
	  112 * pow(c2y,3) * c3x - 980 * c1y * c2x * pow(c3x,2) - 1260 * c0x * c2y * pow(c3x,2) - 80 * pow(c1x,3) * c3y -
	  552 * pow(c1y,2) * c2x * c3y + 1248 * c0x * pow(c2x,2) * c3y + 112 * pow(c2x,3) * c3y - 1218 * c0x * c1y * c2y * c3y +
	  630 * c1y * c2x * c2y * c3y + 3108 * c0x * pow(c2y,2) * c3y + 112 * c2x * pow(c2y,2) * c3y - 420 * pow(c0x,2) * c3x * c3y +
	  420 * pow(c0y,2) * c3x * c3y + 1344 * pow(c1y,2) * c3x * c3y - 3570 * c0x * c2x * c3x * c3y - 924 * c1y * c2y * c3x * c3y +
	  840 * c0x * pow(c3x,2) * c3y + 2856 * c0x * c1y * pow(c3y,2) - 56 * c1y * c2x * pow(c3y,2) - 4830 * c0x * c2y * pow(c3y,2) +
	  840 * c0x * pow(c3y,3) + 4 * pow(c1x,2) * (-35 * c2x * c2y + 20 * c1y * c3x + 138 * c2y * c3x + 48 * (5 * c2x - 7 * c3x) * c3y) +
	  224 * pow(c2x,2) * c2y * etax + 224 * pow(c2y,3) * etax + 50 * c1y * c2x * c3x * etax - 1860 * c2x * c2y * c3x * etax +
	  1260 * c2y * pow(c3x,2) * etax - 1248 * pow(c2x,2) * c3y * etax + 1218 * c1y * c2y * c3y * etax - 3108 * pow(c2y,2) * c3y * etax +
	  840 * c0x * c3x * c3y * etax + 3570 * c2x * c3x * c3y * etax - 840 * pow(c3x,2) * c3y * etax - 2856 * c1y * pow(c3y,2) * etax +
	  4830 * c2y * pow(c3y,2) * etax - 840 * pow(c3y,3) * etax - 420 * c3x * c3y * pow(etax,2) +
	  (-224 * pow(c2x,3) - 224 * c2x * pow(c2y,2) + 3108 * pow(c2x,2) * c3x + 1248 * pow(c2y,2) * c3x + 1860 * c2x * c2y * c3y -
		 3570 * c2y * c3x * c3y + 3 * c1y * c3x * (-205 * c2y + 952 * c3y) - 7 * c2x * (690 * pow(c3x,2) + c3y * (79 * c1y + 180 * c3y)) +
		 420 * (c0x * (-pow(c3x,2) + pow(c3y,2)) + 2 * c3x * (pow(c3x,2) + pow(c3y,2)) + (c3x - c3y) * (c3x + c3y) * etax)) *
	   etay + 420 * c3x * c3y * pow(etay,2) + c1x * (336 * pow(c2y,3) - 553 * c0x * c2y * c3x - 2856 * c0y * pow(c3x,2) +
		 56 * c2y * pow(c3x,2) + 84 * pow(c2x,2) * (4 * c2y - 13 * c3y) - 80 * pow(c1y,2) * c3y + 50 * c0y * c2y * c3y -
		 1722 * pow(c2y,2) * c3y + 2856 * c0x * c3x * c3y + 980 * c2y * pow(c3y,2) +
		 28 * c1y * (5 * pow(c2x,2) - 5 * pow(c2y,2) - 54 * c2x * c3x + 54 * c2y * c3y + 48 * (c3x - c3y) * (c3x + c3y)) +
		 553 * c2y * c3x * etax - 2856 * c3x * c3y * etax + 2856 * pow(c3x,2) * etay - 50 * c2y * c3y * etay +
		 3 * c2x * (406 * c0y * c3x - 210 * c2y * c3x - 205 * c0x * c3y + 308 * c3x * c3y + 205 * c3y * etax - 406 * c3x * etay)) +
	  c0y * (224 * pow(c2x,3) + 224 * c2x * pow(c2y,2) - 3108 * pow(c2x,2) * c3x - 1248 * pow(c2y,2) * c3x +
		 3 * c1y * c3x * (205 * c2y - 952 * c3y) - 1860 * c2x * c2y * c3y + 3570 * c2y * c3x * c3y +
		 7 * c2x * (690 * pow(c3x,2) + c3y * (79 * c1y + 180 * c3y)) -
		 420 * (2 * pow(c3x,3) + c0x * (-pow(c3x,2) + pow(c3y,2)) + pow(c3x,2) * etax - pow(c3y,2) * etax +
			2 * c3x * c3y * (c3y + etay)))) / 560.,(pow(c1y,2) * (165 * c2y * c3x + 91 * c2x * c3y - 672 * c3x * c3y) +
	  pow(c1x,2) * (-91 * c2y * c3x - 165 * c2x * c3y + 672 * c3x * c3y) +
	  6 * (28 * pow(c2x,2) * c2y * c3x + 28 * pow(c2y,3) * c3x - 28 * c2x * c2y * pow(c3x,2) - 28 * pow(c2x,3) * c3y -
		 28 * c2x * pow(c2y,2) * c3y + 28 * pow(c2x,2) * c3x * c3y - 28 * pow(c2y,2) * c3x * c3y + 28 * c2x * c2y * pow(c3y,2) +
		 c0y * (7 * c3x * (12 * pow(c2x,2) + 5 * pow(c2y,2) - 54 * c2x * c3x + 27 * pow(c3x,2)) + c2y * (49 * c2x - 288 * c3x) * c3y +
			9 * (-10 * c2x + 21 * c3x) * pow(c3y,2)) -
		 c0x * (c2x * c3x * (49 * c2y - 288 * c3y) + 35 * pow(c2x,2) * c3y + 84 * pow(c2y,2) * c3y +
			189 * c3y * (pow(c3x,2) + pow(c3y,2)) - 18 * c2y * (5 * pow(c3x,2) + 21 * pow(c3y,2))) + 49 * c2x * c2y * c3x * etax -
		 90 * c2y * pow(c3x,2) * etax + 35 * pow(c2x,2) * c3y * etax + 84 * pow(c2y,2) * c3y * etax - 288 * c2x * c3x * c3y * etax +
		 189 * pow(c3x,2) * c3y * etax - 378 * c2y * pow(c3y,2) * etax + 189 * pow(c3y,3) * etax -
		 (7 * c3x * (12 * pow(c2x,2) + 5 * pow(c2y,2) - 54 * c2x * c3x + 27 * pow(c3x,2)) + c2y * (49 * c2x - 288 * c3x) * c3y +
			9 * (-10 * c2x + 21 * c3x) * pow(c3y,2)) * etay) +
	  2 * c1y * (28 * pow(c2x,3) - 420 * pow(c2x,2) * c3x - 276 * pow(c2y,2) * c3x + 32 * c2y * (-4 * c1x + 21 * c3x) * c3y +
		 c2x * (28 * pow(c2y,2) + 128 * c1x * c3x - 144 * c2y * c3y + 21 * (33 * pow(c3x,2) + pow(c3y,2))) -
		 3 * (42 * pow(c3x,3) - 80 * c0y * c3x * c3y + 42 * c3x * pow(c3y,2) + 112 * c1x * (c3x - c3y) * (c3x + c3y) +
			c0x * (-3 * pow(c3x,2) + 77 * pow(c3y,2)) + 3 * pow(c3x,2) * etax - 77 * pow(c3y,2) * etax + 80 * c3x * c3y * etay)) -
	  2 * c1x * (28 * pow(c2y,3) + 4 * pow(c2x,2) * (7 * c2y - 69 * c3y) - 420 * pow(c2y,2) * c3y + 48 * c2x * c3x * (-3 * c2y + 14 * c3y) +
		 21 * c2y * (pow(c3x,2) + 33 * pow(c3y,2)) -
		 3 * (77 * c0y * pow(c3x,2) - 80 * c0x * c3x * c3y + 42 * pow(c3x,2) * c3y - 3 * c0y * pow(c3y,2) + 42 * pow(c3y,3) +
			80 * c3x * c3y * etax - 77 * pow(c3x,2) * etay + 3 * pow(c3y,2) * etay))) / 336.,
   (-960 * pow(c1x,2) * c3x * c3y + 960 * pow(c1y,2) * c3x * c3y +
	  c1y * (c3x * (1180 * pow(c2x,2) + 795 * pow(c2y,2) - 5712 * c2x * c3x + 48 * c3x * (20 * c1x + 63 * c3x)) +
		 5 * c2y * (77 * c2x - 1128 * c3x) * c3y - 24 * (40 * c1x + 3 * (c2x - 42 * c3x)) * pow(c3y,2)) -
	  c1x * (5 * c2x * c3x * (77 * c2y - 1128 * c3y) + 795 * pow(c2x,2) * c3y +
		 4 * (295 * pow(c2y,2) * c3y + 756 * c3y * (pow(c3x,2) + pow(c3y,2)) - 6 * c2y * (3 * pow(c3x,2) + 238 * pow(c3y,2)))) +
	  3 * (-240 * pow(c2y,3) * c3x + 240 * pow(c2x,3) * c3y + 700 * pow(c2y,2) * c3x * c3y -
		 20 * pow(c2x,2) * c3x * (12 * c2y + 35 * c3y) +
		 c2x * (240 * pow(c2y,2) * c3y - 805 * c0x * c3x * c3y + 700 * c2y * (c3x - c3y) * (c3x + c3y) +
			7 * c0y * (148 * pow(c3x,2) + 33 * pow(c3y,2)) + 805 * c3x * c3y * etax + 28 * pow(c3x,2) * (6 * c3y - 37 * etay) +
			21 * pow(c3y,2) * (8 * c3y - 11 * etay)) +
		 1512 * (pow(c3x,2) + pow(c3y,2)) * (-(c0y * c3x) + c0x * c3y - c3y * etax + c3x * etay) -
		 7 * c2y * (24 * pow(c3x,3) + c0x * (33 * pow(c3x,2) + 148 * pow(c3y,2)) - 33 * pow(c3x,2) * etax -
			148 * pow(c3y,2) * etax + c3x * c3y * (-115 * c0y + 24 * c3y + 115 * etay)))) / 1680.,
   (7 * pow(c2y,3) * c3x - 7 * pow(c2x,3) * c3y - 60 * pow(c2y,2) * c3x * c3y + pow(c2x,2) * c3x * (7 * c2y + 60 * c3y) +
	  6 * c2y * (7 * pow(c3x,3) - 9 * c1x * pow(c3y,2) + c3x * c3y * (9 * c1y + 7 * c3y)) +
	  c2x * (54 * c1y * pow(c3x,2) - 7 * pow(c2y,2) * c3y + 60 * c2y * (-pow(c3x,2) + pow(c3y,2)) -
		 6 * c3y * (9 * c1x * c3x + 7 * (pow(c3x,2) + pow(c3y,2)))) +
	  42 * (pow(c3x,2) + pow(c3y,2)) * (c0y * c3x + c3y * (-c0x + 2 * c1x + etax) - c3x * (2 * c1y + etay))) / 56.,
   (35 * c2x * c3x * (c2y * c3x - c2x * c3y) + 35 * c2y * c3y * (c2y * c3x - c2x * c3y) +
	  24 * pow(c3x,2) * (2 * c1y * c3x - 3 * c2y * c3x - 2 * c1x * c3y + 3 * c2x * c3y) +
	  24 * pow(c3y,2) * (2 * c1y * c3x - 3 * c2y * c3x - 2 * c1x * c3y + 3 * c2x * c3y)) / 112.,
   (3 * (c2y * c3x - c2x * c3y) * (pow(c3x,2) + pow(c3y,2))) / 16. };
		Ix0t0 = valuesIx0[0];
		Ix0t1 = valuesIx0[1];
		Ix0t2 = valuesIx0[2];
		Ix0t3 = valuesIx0[3];
		Ix0t4 = valuesIx0[4];
		Ix0t5 = valuesIx0[5];
		Ix0t6 = valuesIx0[6];
		Ix0t7 = valuesIx0[7];
		Ix0t8 = valuesIx0[8];
		Ix0t9 = valuesIx0[9];
		Ix0t10 = valuesIx0[10];
		Ix0t11 = valuesIx0[11];
		Ix0t12 = valuesIx0[12];
		Ix0t13 = valuesIx0[13];


	}
	//Ix1系数
	if (1)
	{
		std::vector<double> valuesIx1 = { 0,0,(3 * (-(c0y * c1x) + c0x * c1y - c1y * etax + c1x * etay) * (c0x * c1x + c0y * c1y - c1x * etax - c1y * etay)) / 4.,
   (pow(c0y,2) * (4 * c1x * c1y - 4 * c1y * c2x - 6 * c1x * c2y) + pow(c0x,2) * (6 * c1y * c2x + 4 * c1x * (-c1y + c2y)) +
	  etax * (-3 * pow(c1x,2) * c1y - 3 * pow(c1y,3) + 6 * c1y * c2x * etax + 4 * c1x * (-c1y + c2y) * etax) +
	  3 * c1x * (pow(c1x,2) + pow(c1y,2)) * etay + 2 * (2 * pow(c1x,2) - 5 * c1x * c2x + c1y * (-2 * c1y + 5 * c2y)) * etax * etay +
	  2 * (2 * c1x * c1y - 2 * c1y * c2x - 3 * c1x * c2y) * pow(etay,2) +
	  c0x * (3 * pow(c1x,2) * c1y + 3 * pow(c1y,3) + 2 * c0y * (2 * pow(c1x,2) - 2 * pow(c1y,2) - 5 * c1x * c2x + 5 * c1y * c2y) +
		 8 * c1x * c1y * etax - 12 * c1y * c2x * etax - 8 * c1x * c2y * etax +
		 2 * (-2 * pow(c1x,2) + 2 * pow(c1y,2) + 5 * c1x * c2x - 5 * c1y * c2y) * etay) +
	  c0y * (-3 * pow(c1x,3) - 4 * pow(c1x,2) * etax + 2 * c1y * (2 * c1y * etax - 5 * c2y * etax + 4 * c2x * etay) +
		 c1x * (-3 * pow(c1y,2) + 10 * c2x * etax - 8 * c1y * etay + 12 * c2y * etay))) / 4.,
   (pow(c0y,2) * (12 * c1y * c2x - 16 * c2x * c2y - 9 * c1y * c3x + c1x * (-3 * c1y + 16 * c2y - 18 * c3y)) +
	  pow(c0x,2) * (2 * (-8 * c1y * c2x + 8 * c2x * c2y + 9 * c1y * c3x) + 3 * c1x * (c1y - 4 * c2y + 3 * c3y)) +
	  etax * (8 * pow(c1x,2) * c1y + 8 * pow(c1y,3) - 15 * c1x * c1y * c2x - 11 * pow(c1x,2) * c2y - 26 * pow(c1y,2) * c2y +
		 2 * (-8 * c1y * c2x + 8 * c2x * c2y + 9 * c1y * c3x) * etax + 3 * c1x * (c1y - 4 * c2y + 3 * c3y) * etax) +
	  (-8 * pow(c1x,3) - 8 * c1x * pow(c1y,2) + 26 * pow(c1x,2) * c2x + 11 * pow(c1y,2) * c2x + 15 * c1x * c1y * c2y +
		 (-3 * pow(c1x,2) + 3 * pow(c1y,2) + 28 * c1x * c2x - 16 * pow(c2x,2) - 28 * c1y * c2y + 16 * pow(c2y,2) - 27 * c1x * c3x +
			27 * c1y * c3y) * etax) * etay + (12 * c1y * c2x - 16 * c2x * c2y - 9 * c1y * c3x + c1x * (-3 * c1y + 16 * c2y - 18 * c3y)) *
	   pow(etay,2) + c0x * (-8 * pow(c1y,3) + 26 * pow(c1y,2) * c2y +
		 c0y * (-3 * pow(c1x,2) + 3 * pow(c1y,2) + 28 * c1x * c2x - 16 * pow(c2x,2) - 28 * c1y * c2y + 16 * pow(c2y,2) -
			27 * c1x * c3x + 27 * c1y * c3y) + 32 * c1y * c2x * etax - 32 * c2x * c2y * etax - 36 * c1y * c3x * etax - 3 * pow(c1y,2) * etay +
		 16 * pow(c2x,2) * etay + 28 * c1y * c2y * etay - 16 * pow(c2y,2) * etay - 27 * c1y * c3y * etay +
		 pow(c1x,2) * (-8 * c1y + 11 * c2y + 3 * etay) +
		 c1x * (15 * c1y * c2x - 6 * c1y * etax + 24 * c2y * etax - 18 * c3y * etax - 28 * c2x * etay + 27 * c3x * etay)) +
	  c0y * (8 * pow(c1x,3) + pow(c1x,2) * (-26 * c2x + 3 * etax) - pow(c1y,2) * (11 * c2x + 3 * etax) +
		 16 * (pow(c2x,2) * etax - pow(c2y,2) * etax + 2 * c2x * c2y * etay) +
		 c1y * (28 * c2y * etax - 27 * c3y * etax - 24 * c2x * etay + 18 * c3x * etay) +
		 c1x * (8 * pow(c1y,2) - 15 * c1y * c2y - 28 * c2x * etax + 27 * c3x * etax + 6 * c1y * etay - 32 * c2y * etay + 36 * c3y * etay))) / 8.,
   (3 * (-5 * pow(c1x,2) * c1y * c2x - 5 * pow(c1y,3) * c2x + 5 * pow(c1x,3) * c2y + 5 * c1x * pow(c1y,2) * c2y +
		2 * pow(c0x,2) * (5 * c1y * (c2x - 4 * c3x) + 4 * c2y * (c1x - 5 * c2x + 5 * c3x) + 3 * (-4 * c1x + 5 * c2x) * c3y) -
		2 * pow(c0y,2) * (4 * c1y * (c2x - 3 * c3x) + 5 * (-4 * c2x * c2y + 3 * c2y * c3x + c1x * (c2y - 4 * c3y) + 4 * c2x * c3y)) -
		5 * pow(c1x,2) * c1y * etax - 5 * pow(c1y,3) * etax + 32 * c1x * c1y * c2x * etax - 10 * c1y * pow(c2x,2) * etax +
		28 * pow(c1x,2) * c2y * etax + 60 * pow(c1y,2) * c2y * etax - 50 * c1x * c2x * c2y * etax - 60 * c1y * pow(c2y,2) * etax -
		32 * c1x * c1y * c3x * etax - 23 * pow(c1x,2) * c3y * etax - 55 * pow(c1y,2) * c3y * etax + 10 * c1y * c2x * pow(etax,2) +
		8 * c1x * c2y * pow(etax,2) - 40 * c2x * c2y * pow(etax,2) - 40 * c1y * c3x * pow(etax,2) + 40 * c2y * c3x * pow(etax,2) -
		24 * c1x * c3y * pow(etax,2) + 30 * c2x * c3y * pow(etax,2) +
		(5 * pow(c1x,3) + pow(c1x,2) * (-60 * c2x + 55 * c3x) + c1y * (-28 * c1y * c2x + 50 * c2x * c2y + 23 * c1y * c3x) +
		   2 * (5 * c2x * (4 * c2x - 7 * c3x) + c1y * (9 * c2y - 32 * c3y) + 5 * c2y * (-4 * c2y + 7 * c3y)) * etax +
		   c1x * (5 * pow(c1y,2) + 60 * pow(c2x,2) + 10 * pow(c2y,2) + 32 * c1y * (-c2y + c3y) - 18 * c2x * etax + 64 * c3x * etax)) *
		 etay - 2 * (4 * c1y * (c2x - 3 * c3x) + 5 * (-4 * c2x * c2y + 3 * c2y * c3x + c1x * (c2y - 4 * c3y) + 4 * c2x * c3y)) * pow(etay,2) +
		c0x * (pow(c1x,2) * (5 * c1y - 28 * c2y + 23 * c3y) +
		   5 * c1y * (pow(c1y,2) + 2 * pow(c2x,2) - 12 * c1y * c2y + 12 * pow(c2y,2) + 11 * c1y * c3y) -
		   20 * (-4 * c2x * c2y + c1y * (c2x - 4 * c3x) + 4 * c2y * c3x + 3 * c2x * c3y) * etax +
		   2 * (5 * c2x * (-4 * c2x + 7 * c3x) + 5 * c2y * (4 * c2y - 7 * c3y) + c1y * (-9 * c2y + 32 * c3y)) * etay +
		   2 * c1x * (25 * c2x * c2y + 16 * c1y * (-c2x + c3x) - 8 * c2y * etax + 24 * c3y * etax + 9 * c2x * etay - 32 * c3x * etay)) -
		c0y * (5 * pow(c1x,3) + pow(c1y,2) * (-28 * c2x + 23 * c3x) + pow(c1x,2) * (-60 * c2x + 55 * c3x) -
		   10 * (4 * pow(c2x,2) - 4 * pow(c2y,2) - 7 * c2x * c3x + 7 * c2y * c3y) * (c0x - etax) +
		   20 * (4 * c2x * c2y - 3 * c2y * c3x - 4 * c2x * c3y) * etay +
		   2 * c1y * (-9 * c0x * c2y + 25 * c2x * c2y + 32 * c0x * c3y + 9 * c2y * etax - 32 * c3y * etax - 8 * c2x * etay + 24 * c3x * etay) +
		   c1x * (5 * pow(c1y,2) + 32 * c1y * (-c2y + c3y) +
			  2 * (9 * c0x * c2x + 30 * pow(c2x,2) - 32 * c0x * c3x - 9 * c2x * etax + 32 * c3x * etax +
				 5 * (pow(c2y,2) - 2 * c2y * etay + 8 * c3y * etay)))))) / 40.,
   (24 * pow(c1x,2) * c1y * c2x + 24 * pow(c1y,3) * c2x - 45 * c1x * c1y * pow(c2x,2) - 24 * pow(c1x,3) * c2y -
	  24 * c1x * pow(c1y,2) * c2y + 45 * pow(c1x,2) * c2x * c2y - 45 * pow(c1y,2) * c2x * c2y + 45 * c1x * c1y * pow(c2y,2) -
	  24 * pow(c1x,2) * c1y * c3x - 24 * pow(c1y,3) * c3x + 24 * pow(c1x,3) * c3y + 24 * c1x * pow(c1y,2) * c3y -
	  3 * pow(c0y,2) * (10 * c1y * c3x - 48 * c2y * c3x + 4 * c2x * (4 * c2y - 15 * c3y) + 15 * (c1x + 3 * c3x) * c3y) +
	  3 * pow(c0x,2) * (16 * c2x * (c2y - 3 * c3y) + 10 * c1x * c3y + 15 * c3x * (c1y - 4 * c2y + 3 * c3y)) - 35 * c1x * c1y * c2x * etax +
	  32 * c1y * pow(c2x,2) * etax - 34 * pow(c1x,2) * c2y * etax - 69 * pow(c1y,2) * c2y * etax + 228 * c1x * c2x * c2y * etax -
	  80 * pow(c2x,2) * c2y * etax + 260 * c1y * pow(c2y,2) * etax - 80 * pow(c2y,3) * etax + 120 * c1x * c1y * c3x * etax -
	  57 * c1y * c2x * c3x * etax - 195 * c1x * c2y * c3x * etax + 112 * pow(c1x,2) * c3y * etax + 232 * pow(c1y,2) * c3y * etax -
	  193 * c1x * c2x * c3y * etax - 445 * c1y * c2y * c3y * etax + 48 * c2x * c2y * pow(etax,2) + 45 * c1y * c3x * pow(etax,2) -
	  180 * c2y * c3x * pow(etax,2) + 30 * c1x * c3y * pow(etax,2) - 144 * c2x * c3y * pow(etax,2) + 135 * c3x * c3y * pow(etax,2) +
	  (80 * c2x * (pow(c2x,2) + pow(c2y,2)) + pow(c1x,2) * (69 * c2x - 232 * c3x) + 2 * pow(c1y,2) * (17 * c2x - 56 * c3x) +
		 3 * (-16 * pow(c2x,2) + 16 * pow(c2y,2) + 108 * c2x * c3x - 45 * pow(c3x,2) - 108 * c2y * c3y + 45 * pow(c3y,2)) * etax +
		 c1x * (-260 * pow(c2x,2) + 35 * c1y * c2y - 32 * pow(c2y,2) + 445 * c2x * c3x - 120 * c1y * c3y + 57 * c2y * c3y - 75 * c3x * etax) +
		 c1y * (-228 * c2x * c2y + 193 * c2y * c3x + 195 * c2x * c3y + 75 * c3y * etax)) * etay -
	  3 * (10 * c1y * c3x - 48 * c2y * c3x + 4 * c2x * (4 * c2y - 15 * c3y) + 15 * (c1x + 3 * c3x) * c3y) * pow(etay,2) +
	  c0x * (80 * c2y * (pow(c2x,2) + pow(c2y,2)) + pow(c1y,2) * (69 * c2y - 232 * c3y) + 2 * pow(c1x,2) * (17 * c2y - 56 * c3y) +
		 6 * (-16 * c2x * c2y + 60 * c2y * c3x + 48 * c2x * c3y - 45 * c3x * c3y) * etax +
		 3 * (16 * pow(c2x,2) - 16 * pow(c2y,2) - 108 * c2x * c3x + 108 * c2y * c3y + 45 * (c3x - c3y) * (c3x + c3y)) * etay +
		 c1x * (-228 * c2x * c2y + 5 * c1y * (7 * c2x - 24 * c3x) + 195 * c2y * c3x + 193 * c2x * c3y - 60 * c3y * etax + 75 * c3x * etay) -
		 c1y * (32 * pow(c2x,2) - 57 * c2x * c3x + 5 * c2y * (52 * c2y - 89 * c3y) + 90 * c3x * etax + 75 * c3y * etay)) +
	  c0y * (-48 * c0x * pow(c2x,2) - 80 * pow(c2x,3) + 48 * c0x * pow(c2y,2) - 80 * c2x * pow(c2y,2) + 324 * c0x * c2x * c3x -
		 135 * c0x * pow(c3x,2) + pow(c1y,2) * (-34 * c2x + 112 * c3x) + pow(c1x,2) * (-69 * c2x + 232 * c3x) - 324 * c0x * c2y * c3y +
		 135 * c0x * pow(c3y,2) + 48 * pow(c2x,2) * etax - 48 * pow(c2y,2) * etax - 324 * c2x * c3x * etax + 135 * pow(c3x,2) * etax +
		 324 * c2y * c3y * etax - 135 * pow(c3y,2) * etax + 6 * (16 * c2x * c2y - 48 * c2y * c3x - 60 * c2x * c3y + 45 * c3x * c3y) * etay +
		 c1y * (-193 * c2y * c3x + 3 * c2x * (76 * c2y - 65 * c3y) + 75 * c3y * (c0x - etax) + 60 * c3x * etay) +
		 c1x * (260 * pow(c2x,2) - 35 * c1y * c2y + 32 * pow(c2y,2) - 445 * c2x * c3x + 120 * c1y * c3y - 57 * c2y * c3y +
			75 * c3x * (-c0x + etax) + 90 * c3y * etay))) / 40.,
   (-35 * pow(c1y, 3) * (c2x - 4 * c3x) + 35 * pow(c1x, 3) * (c2y - 4 * c3y) +
	   pow(c1y, 2) * (-165 * c0y * c3x - 287 * c2y * c3x + 7 * c2x * (36 * c2y - 25 * c3y) + 315 * c3y * (c0x - etax) + 165 * c3x * etay) +
	   pow(c1x, 2) * (-35 * c1y * (c2x - 4 * c3x) + 7 * c2x * (-36 * c2y + 41 * c3y) + 165 * c3y * (c0x - etax) +
		   35 * c3x * (-9 * c0y + 5 * c2y + 9 * etay)) + c1y *
	   (-105 * pow(c2x, 3) + 1096 * c0y * c2y * c3x - 882 * c0y * c3x * c3y +
		   7 * c0x * (5 * pow(c2x, 2) + 51 * pow(c2y, 2) - 24 * c2x * c3x + 9 * pow(c3x, 2) - 328 * c2y * c3y + 135 * pow(c3y, 2)) -
		   35 * pow(c2x, 2) * etax - 357 * pow(c2y, 2) * etax - 63 * pow(c3x, 2) * etax + 2296 * c2y * c3y * etax -
		   945 * pow(c3y, 2) * etax - 1096 * c2y * c3x * etay + 882 * c3x * c3y * etay +
		   c2x * (-322 * c0y * c2y - 105 * pow(c2y, 2) + 1032 * c0y * c3y + 168 * c3x * etax + 322 * c2y * etay - 1032 * c3y * etay)) +
	   c1x * (322 * c0x * c2x * c2y + 105 * pow(c2x, 2) * c2y + 105 * pow(c2y, 3) - 1032 * c0x * c2y * c3x + 35 * pow(c1y, 2) * (c2y - 4 * c3y) -
		   1096 * c0x * c2x * c3y + 882 * c0x * c3x * c3y - c0y *
		   (357 * pow(c2x, 2) + 35 * pow(c2y, 2) - 2296 * c2x * c3x + 945 * pow(c3x, 2) + 150 * c1y * c3y - 168 * c2y * c3y +
			   63 * pow(c3y, 2)) - 322 * c2x * c2y * etax + 1032 * c2y * c3x * etax + 1096 * c2x * c3y * etax - 882 * c3x * c3y * etax +
		   7 * (51 * pow(c2x, 2) + 5 * pow(c2y, 2) - 328 * c2x * c3x + 135 * pow(c3x, 2) - 24 * c2y * c3y + 9 * pow(c3y, 2)) * etay +
		   6 * c1y * (42 * pow(c2x, 2) - 42 * pow(c2y, 2) - 77 * c2x * c3x + 77 * c2y * c3y + 25 * c3x * (c0x - etax) + 25 * c3y * etay)) +
	   7 * (-6 * pow(c0y, 2) * (5 * c2y * c3x + 6 * (c2x - 3 * c3x) * c3y) +
		   (c0x - etax) * (-60 * pow(c2y, 3) + 145 * pow(c2y, 2) * c3y + pow(c2x, 2) * (-60 * c2y + 55 * c3y) +
			   30 * c2x * (3 * c2y * c3x + c3y * (c0x - etax)) + 36 * c2y * c3x * (c0x - etax) + 108 * c3x * c3y * (-c0x + etax)) +
		   (-60 * pow(c2x, 3) + 145 * pow(c2x, 2) * c3x + 55 * pow(c2y, 2) * c3x +
			   c2x * (-60 * pow(c2y, 2) + 90 * c2y * c3y + 66 * c3x * (c0x - etax)) - 108 * (c3x - c3y) * (c3x + c3y) * (c0x - etax) +
			   66 * c2y * c3y * (-c0x + etax)) * etay - 6 * (5 * c2y * c3x + 6 * (c2x - 3 * c3x) * c3y) * pow(etay, 2) +
		   c0y * (60 * pow(c2x, 3) - 145 * pow(c2x, 2) * c3x - 55 * pow(c2y, 2) * c3x + 66 * c2y * c3y * (c0x - etax) + 60 * c2y * c3x * etay +
			   c2x * (60 * pow(c2y, 2) - 90 * c2y * c3y + 66 * c3x * (-c0x + etax) + 72 * c3y * etay) +
			   108 * ((c3x - c3y) * (c3x + c3y) * (c0x - etax) - 2 * c3x * c3y * etay)))) / 140.,
	   (3 * (224 * c1y * pow(c2x, 3) - 140 * pow(c1y, 2) * c2x * c2y + 224 * c0x * pow(c2x, 2) * c2y + 224 * c1y * c2x * pow(c2y, 2) +
		   224 * c0x * pow(c2y, 3) - 80 * pow(c1y, 3) * c3x + 50 * c0x * c1y * c2x * c3x - 574 * c1y * pow(c2x, 2) * c3x +
		   640 * pow(c1y, 2) * c2y * c3x - 1240 * c0x * c2x * c2y * c3x - 364 * c1y * pow(c2y, 2) * c3x + 420 * c0x * c2y * pow(c3x, 2) +
		   4 * pow(c1x, 2) * (5 * c2x * (7 * c2y - 32 * c3y) - 4 * c3x * (5 * c1y + 23 * c2y - 28 * c3y)) + 80 * pow(c1x, 3) * c3y +
		   368 * pow(c1y, 2) * c2x * c3y - 832 * c0x * pow(c2x, 2) * c3y + 1218 * c0x * c1y * c2y * c3y - 210 * c1y * c2x * c2y * c3y -
		   2072 * c0x * pow(c2y, 2) * c3y + 420 * pow(c0x, 2) * c3x * c3y - 420 * pow(c0y, 2) * c3x * c3y - 448 * pow(c1y, 2) * c3x * c3y +
		   1190 * c0x * c2x * c3x * c3y - 1904 * c0x * c1y * pow(c3y, 2) + 1610 * c0x * c2y * pow(c3y, 2) - 224 * pow(c2x, 2) * c2y * etax -
		   224 * pow(c2y, 3) * etax - 50 * c1y * c2x * c3x * etax + 1240 * c2x * c2y * c3x * etax - 420 * c2y * pow(c3x, 2) * etax +
		   832 * pow(c2x, 2) * c3y * etax - 1218 * c1y * c2y * c3y * etax + 2072 * pow(c2y, 2) * c3y * etax - 840 * c0x * c3x * c3y * etax -
		   1190 * c2x * c3x * c3y * etax + 1904 * c1y * pow(c3y, 2) * etax - 1610 * c2y * pow(c3y, 2) * etax + 420 * c3x * c3y * pow(etax, 2) +
		   (224 * pow(c2x, 3) - 2072 * pow(c2x, 2) * c3x + 615 * c1y * c2y * c3x - 832 * pow(c2y, 2) * c3x + 420 * c0x * pow(c3x, 2) -
			   1904 * c1y * c3x * c3y + 1190 * c2y * c3x * c3y - 420 * c0x * pow(c3y, 2) +
			   c2x * (224 * pow(c2y, 2) + 1610 * pow(c3x, 2) - 1240 * c2y * c3y + 7 * c3y * (79 * c1y + 60 * c3y)) -
			   420 * (c3x - c3y) * (c3x + c3y) * etax) * etay - 420 * c3x * c3y * pow(etay, 2) -
		   c0y * (224 * pow(c2x, 3) - 2072 * pow(c2x, 2) * c3x + 615 * c1y * c2y * c3x - 832 * pow(c2y, 2) * c3x + 420 * c0x * pow(c3x, 2) -
			   1904 * c1y * c3x * c3y + 1190 * c2y * c3x * c3y - 420 * c0x * pow(c3y, 2) +
			   c2x * (224 * pow(c2y, 2) + 1610 * pow(c3x, 2) - 1240 * c2y * c3y + 7 * c3y * (79 * c1y + 60 * c3y)) - 420 * pow(c3x, 2) * etax +
			   420 * pow(c3y, 2) * etax - 840 * c3x * c3y * etay) +
		   c1x * (-224 * pow(c2y, 3) + 553 * c0x * c2y * c3x + 1904 * c0y * pow(c3x, 2) + 80 * pow(c1y, 2) * c3y - 50 * c0y * c2y * c3y +
			   574 * pow(c2y, 2) * c3y - 1904 * c0x * c3x * c3y + 28 * pow(c2x, 2) * (-8 * c2y + 13 * c3y) -
			   28 * c1y * (5 * pow(c2x, 2) - 5 * pow(c2y, 2) - 36 * c2x * c3x + 36 * c2y * c3y + 16 * (c3x - c3y) * (c3x + c3y)) +
			   615 * c2x * c3y * (c0x - etax) - 553 * c2y * c3x * etax + 1904 * c3x * c3y * etax - 1904 * pow(c3x, 2) * etay + 50 * c2y * c3y * etay +
			   42 * c2x * c3x * (-29 * c0y + 5 * c2y + 29 * etay)))) / 560.,
	   (pow(c1x, 2) * (91 * c2y * c3x + 165 * c2x * c3y - 448 * c3x * c3y) + pow(c1y, 2) * (-165 * c2y * c3x - 91 * c2x * c3y + 448 * c3x * c3y) -
		   2 * c1y * (28 * pow(c2x, 3) - 280 * pow(c2x, 2) * c3x - 184 * pow(c2y, 2) * c3x + 9 * c0x * pow(c3x, 2) - 224 * c1x * pow(c3x, 2) +
			   240 * c0y * c3x * c3y + 32 * c2y * (-4 * c1x + 7 * c3x) * c3y - 231 * c0x * pow(c3y, 2) + 224 * c1x * pow(c3y, 2) +
			   c2x * (28 * pow(c2y, 2) + 128 * c1x * c3x + 231 * pow(c3x, 2) - 96 * c2y * c3y + 7 * pow(c3y, 2)) - 9 * pow(c3x, 2) * etax +
			   231 * pow(c3y, 2) * etax - 240 * c3x * c3y * etay) +
		   2 * (-28 * pow(c2x, 2) * c2y * c3x - 28 * pow(c2y, 3) * c3x + 28 * pow(c2x, 3) * c3y + 28 * c2x * pow(c2y, 2) * c3y -
			   3 * c0y * (7 * c3x * (12 * pow(c2x, 2) + 5 * pow(c2y, 2) - 36 * c2x * c3x + 9 * pow(c3x, 2)) + c2y * (49 * c2x - 192 * c3x) * c3y +
				   3 * (-20 * c2x + 21 * c3x) * pow(c3y, 2)) +
			   3 * c0x * (c2y * (49 * c2x - 60 * c3x) * c3x + (35 * pow(c2x, 2) + 84 * pow(c2y, 2) - 192 * c2x * c3x + 63 * pow(c3x, 2)) * c3y -
				   252 * c2y * pow(c3y, 2) + 63 * pow(c3y, 3)) - 147 * c2x * c2y * c3x * etax + 180 * c2y * pow(c3x, 2) * etax -
			   105 * pow(c2x, 2) * c3y * etax - 252 * pow(c2y, 2) * c3y * etax + 576 * c2x * c3x * c3y * etax - 189 * pow(c3x, 2) * c3y * etax +
			   756 * c2y * pow(c3y, 2) * etax - 189 * pow(c3y, 3) * etax +
			   3 * (7 * c3x * (12 * pow(c2x, 2) + 5 * pow(c2y, 2) - 36 * c2x * c3x + 9 * pow(c3x, 2)) + c2y * (49 * c2x - 192 * c3x) * c3y +
				   3 * (-20 * c2x + 21 * c3x) * pow(c3y, 2)) * etay) +
		   2 * c1x * (28 * pow(c2y, 3) + 4 * pow(c2x, 2) * (7 * c2y - 46 * c3y) - 280 * pow(c2y, 2) * c3y + 32 * c2x * c3x * (-3 * c2y + 7 * c3y) +
			   7 * c2y * (pow(c3x, 2) + 33 * pow(c3y, 2)) +
			   3 * (-77 * c0y * pow(c3x, 2) + 80 * c0x * c3x * c3y + 3 * c0y * pow(c3y, 2) - 80 * c3x * c3y * etax + 77 * pow(c3x, 2) * etay -
				   3 * pow(c3y, 2) * etay))) / 112., (6 * pow(c2x, 2) * (-(c1y * c3x) + c2y * c3x + (c1x - c2x) * c3y)) / 7. +
	   (6 * pow(c2y, 2) * (-(c1y * c3x) + c2y * c3x + (c1x - c2x) * c3y)) / 7. +
	   (12 * c1x * c3x * (-(c1y * c3x) + c2y * c3x + (c1x - c2x) * c3y)) / 7. + (12 * c1y * c3y * (-(c1y * c3x) + c2y * c3x + (c1x - c2x) * c3y)) / 7. +
	   (9 * c1x * c2x * (-(c2y * c3x) + c2x * c3y)) / 16. + (9 * c1y * c2y * (-(c2y * c3x) + c2x * c3y)) / 16. +
	   (9 * c0x * c3x * (-(c2y * c3x) + c2x * c3y)) / 16. + (9 * c0y * c3y * (-(c2y * c3x) + c2x * c3y)) / 16. +
	   (9 * c3x * (c2y * c3x - c2x * c3y) * etax) / 16. + (5 * c2x * c3x *
		   (-(c1y * (c2x - 4 * c3x)) + c1x * (c2y - 4 * c3y) + c3y * (3 * c0x + c2x - 3 * etax) - c3x * (3 * c0y + c2y - 3 * etay))) / 4. +
	   (5 * c2y * c3y * (-(c1y * (c2x - 4 * c3x)) + c1x * (c2y - 4 * c3y) + c3y * (3 * c0x + c2x - 3 * etax) - c3x * (3 * c0y + c2y - 3 * etay))) / 4. -
	   (9 * c3y * (-(c2y * c3x) + c2x * c3y) * etay) / 16. + (9 * pow(c3x, 2) *
		   (-(c0y * c2x) + c1y * c2x + c0x * c2y - c1x * c2y + 3 * c0y * c3x - c1y * c3x - 3 * c0x * c3y + c1x * c3y - c2y * etax + 3 * c3y * etax +
			   c2x * etay - 3 * c3x * etay)) / 5. + (9 * pow(c3y, 2) *
				   (-(c0y * c2x) + c1y * c2x + c0x * c2y - c1x * c2y + 3 * c0y * c3x - c1y * c3x - 3 * c0x * c3y + c1x * c3y - c2y * etax + 3 * c3y * etax +
					   c2x * etay - 3 * c3x * etay)) / 5., (3 * (-7 * pow(c2y, 3) * c3x + 7 * pow(c2x, 3) * c3y + 40 * pow(c2y, 2) * c3x * c3y -
						   pow(c2x, 2) * c3x * (7 * c2y + 40 * c3y) - 2 * c2y * (7 * pow(c3x, 3) - 27 * c1x * pow(c3y, 2) + c3x * c3y * (27 * c1y + 7 * c3y)) +
						   c2x * (-54 * c1y * pow(c3x, 2) + 7 * pow(c2y, 2) * c3y + 54 * c1x * c3x * c3y + 40 * c2y * (c3x - c3y) * (c3x + c3y) +
							   14 * c3y * (pow(c3x, 2) + pow(c3y, 2))) +
						   14 * (pow(c3x, 2) + pow(c3y, 2)) * (-3 * c0y * c3x + 4 * c1y * c3x + 3 * c0x * c3y - 4 * c1x * c3y - 3 * c3y * etax + 3 * c3x * etay))) / 56.,
	   (3 * (48 * pow(c3x, 2) * (-(c1y * c3x) + c2y * c3x + (c1x - c2x) * c3y) +
		   48 * pow(c3y, 2) * (-(c1y * c3x) + c2y * c3x + (c1x - c2x) * c3y) + 35 * c2x * c3x * (-(c2y * c3x) + c2x * c3y) +
		   35 * c2y * c3y * (-(c2y * c3x) + c2x * c3y))) / 112., (-9 * (c2y * c3x - c2x * c3y) * (pow(c3x, 2) + pow(c3y, 2))) / 16. };
		Ix1t0 = valuesIx1[0];
		Ix1t1 = valuesIx1[1];
		Ix1t2 = valuesIx1[2];
		Ix1t3 = valuesIx1[3];
		Ix1t4 = valuesIx1[4];
		Ix1t5 = valuesIx1[5];
		Ix1t6 = valuesIx1[6];
		Ix1t7 = valuesIx1[7];
		Ix1t8 = valuesIx1[8];
		Ix1t9 = valuesIx1[9];
		Ix1t10 = valuesIx1[10];
		Ix1t11 = valuesIx1[11];
		Ix1t12 = valuesIx1[12];
		Ix1t13 = valuesIx1[13];
	}
	//Ix2系数
	{
		std::vector<double> valuesIx2 = { 0,0,0,((-(c0y * c1x) + c0x * c1y - c1y * etax + c1x * etay) * (c0x * c1x + c0y * c1y - c1x * etax - c1y * etay)) / 2.,
   (pow(c0y,2) * (3 * c1x * c1y - 6 * c1y * c2x - 8 * c1x * c2y) + pow(c0x,2) * (-3 * c1x * c1y + 8 * c1y * c2x + 6 * c1x * c2y) +
	  etax * (-4 * c1y * (pow(c1x,2) + pow(c1y,2)) + (-3 * c1x * c1y + 8 * c1y * c2x + 6 * c1x * c2y) * etax) +
	  4 * c1x * (pow(c1x,2) + pow(c1y,2)) * etay + (3 * pow(c1x,2) - 14 * c1x * c2x + c1y * (-3 * c1y + 14 * c2y)) * etax * etay +
	  (3 * c1x * c1y - 6 * c1y * c2x - 8 * c1x * c2y) * pow(etay,2) +
	  c0x * (c0y * (3 * pow(c1x,2) - 14 * c1x * c2x + c1y * (-3 * c1y + 14 * c2y)) + pow(c1x,2) * (4 * c1y - 3 * etay) +
		 2 * c1x * (3 * c1y * etax - 6 * c2y * etax + 7 * c2x * etay) + c1y * (4 * pow(c1y,2) - 16 * c2x * etax + 3 * c1y * etay - 14 * c2y * etay)) +
	  c0y * (-4 * pow(c1x,3) - 3 * pow(c1x,2) * etax + c1y * (3 * c1y * etax - 14 * c2y * etax + 12 * c2x * etay) +
		 2 * c1x * (-2 * pow(c1y,2) + 7 * c2x * etax - 3 * c1y * etay + 8 * c2y * etay))) / 8.,
   (3 * (2 * pow(c0y,2) * (4 * c1y * c2x - 10 * c2x * c2y - 6 * c1y * c3x + 5 * c1x * (c2y - 2 * c3y)) -
		(c0x - etax) * (pow(c1x,2) * (5 * c1y - 14 * c2y) + 4 * c1x * (-4 * c1y * c2x + (2 * c2y - 3 * c3y) * (c0x - etax)) +
		   5 * (pow(c1y,3) - 6 * pow(c1y,2) * c2y + 2 * c1y * (c2x - 2 * c3x) * (c0x - etax) + 4 * c2x * c2y * (-c0x + etax))) +
		(-5 * pow(c1x,3) + 30 * pow(c1x,2) * c2x + 14 * pow(c1y,2) * c2x + c1x * c1y * (-5 * c1y + 16 * c2y) +
		   20 * (c2x - c2y) * (c2x + c2y) * (c0x - etax) - 2 * c1x * (9 * c2x - 16 * c3x) * (c0x - etax) +
		   2 * c1y * (9 * c2y - 16 * c3y) * (c0x - etax)) * etay +
		2 * (4 * c1y * c2x - 10 * c2x * c2y - 6 * c1y * c3x + 5 * c1x * (c2y - 2 * c3y)) * pow(etay,2) +
		c0y * (5 * pow(c1x,3) - 30 * pow(c1x,2) * c2x -
		   2 * (7 * pow(c1y,2) * c2x + 10 * (c2x - c2y) * (c2x + c2y) * (c0x - etax) + c1y * (9 * c2y - 16 * c3y) * (c0x - etax) -
			  20 * c2x * c2y * etay + 4 * c1y * (2 * c2x - 3 * c3x) * etay) +
		   c1x * (5 * pow(c1y,2) - 16 * c1y * c2y + 2 * (9 * c2x - 16 * c3x) * (c0x - etax) - 20 * (c2y - 2 * c3y) * etay)))) / 40.,
   (-12 * pow(c1x,2) * c1y * c2x - 12 * pow(c1y,3) * c2x + 12 * pow(c1x,3) * c2y + 12 * c1x * pow(c1y,2) * c2y +
	  pow(c0y,2) * (48 * c2x * c2y + 30 * c1y * c3x - 72 * c2y * c3x + 45 * c1x * c3y - 90 * c2x * c3y) +
	  pow(c0x,2) * (-48 * c2x * c2y - 45 * c1y * c3x + 90 * c2y * c3x - 30 * c1x * c3y + 72 * c2x * c3y) + 35 * c1x * c1y * c2x * etax -
	  16 * c1y * pow(c2x,2) * etax + 34 * pow(c1x,2) * c2y * etax + 69 * pow(c1y,2) * c2y * etax - 114 * c1x * c2x * c2y * etax -
	  130 * c1y * pow(c2y,2) * etax - 60 * c1x * c1y * c3x * etax - 56 * pow(c1x,2) * c3y * etax - 116 * pow(c1y,2) * c3y * etax -
	  48 * c2x * c2y * pow(etax,2) - 45 * c1y * c3x * pow(etax,2) + 90 * c2y * c3x * pow(etax,2) - 30 * c1x * c3y * pow(etax,2) +
	  72 * c2x * c3y * pow(etax,2) + (pow(c1x,2) * (-69 * c2x + 116 * c3x) + 2 * c1y * (-17 * c1y * c2x + 57 * c2x * c2y + 28 * c1y * c3x) +
		 3 * (16 * pow(c2x,2) - 16 * pow(c2y,2) - 54 * c2x * c3x - 25 * c1y * c3y + 54 * c2y * c3y) * etax +
		 c1x * (130 * pow(c2x,2) - 35 * c1y * c2y + 16 * pow(c2y,2) + 60 * c1y * c3y + 75 * c3x * etax)) * etay +
	  3 * (16 * c2x * c2y + 10 * c1y * c3x - 24 * c2y * c3x + 15 * c1x * c3y - 30 * c2x * c3y) * pow(etay,2) +
	  c0y * (pow(c1x,2) * (69 * c2x - 116 * c3x) + pow(c1y,2) * (34 * c2x - 56 * c3x) +
		 6 * (8 * pow(c2x,2) - 8 * pow(c2y,2) - 27 * c2x * c3x + 27 * c2y * c3y) * (c0x - etax) +
		 12 * (-8 * c2x * c2y + 12 * c2y * c3x + 15 * c2x * c3y) * etay - 3 * c1y * (38 * c2x * c2y + 25 * c0x * c3y - 25 * c3y * etax + 20 * c3x * etay) -
		 c1x * (130 * pow(c2x,2) - 35 * c1y * c2y + 16 * pow(c2y,2) + 60 * c1y * c3y + 75 * c3x * (-c0x + etax) + 90 * c3y * etay)) +
	  c0x * (pow(c1x,2) * (-34 * c2y + 56 * c3y) + pow(c1y,2) * (-69 * c2y + 116 * c3y) +
		 c1x * (-35 * c1y * c2x + 114 * c2x * c2y + 60 * c1y * c3x + 60 * c3y * etax - 75 * c3x * etay) +
		 c1y * (16 * pow(c2x,2) + 130 * pow(c2y,2) + 90 * c3x * etax + 75 * c3y * etay) -
		 6 * (8 * pow(c2x,2) * etay + c2x * (-16 * c2y * etax + 24 * c3y * etax - 27 * c3x * etay) +
			c2y * (30 * c3x * etax - 8 * c2y * etay + 27 * c3y * etay)))) / 40.,
   (35 * pow(c1y,3) * (c2x - 2 * c3x) - 35 * pow(c1x,3) * (c2y - 2 * c3y) +
	  pow(c1x,2) * (126 * c2x * c2y + 35 * c1y * (c2x - 2 * c3x) + 165 * c3y * (-c0x + etax) + 315 * c3x * (c0y - etay)) +
	  c1y * (c0y * (322 * c2x * c2y - 548 * c2y * c3x - 516 * c2x * c3y) +
		 7 * c0x * (-5 * pow(c2x,2) + 12 * c2x * c3x + c2y * (-51 * c2y + 164 * c3y)) + 35 * pow(c2x,2) * etax + 357 * pow(c2y,2) * etax -
		 84 * c2x * c3x * etax - 1148 * c2y * c3y * etax - 322 * c2x * c2y * etay + 548 * c2y * c3x * etay + 516 * c2x * c3y * etay) -
	  3 * pow(c1y,2) * (42 * c2x * c2y + 105 * c3y * (c0x - etax) + 55 * c3x * (-c0y + etay)) +
	  c1x * (-35 * pow(c1y,2) * (c2y - 2 * c3y) + c0y * (35 * pow(c2y,2) + 7 * c2x * (51 * c2x - 164 * c3x) + 150 * c1y * c3y - 84 * c2y * c3y) -
		 2 * (161 * c2x * c2y - 258 * c2y * c3x - 274 * c2x * c3y) * (c0x - etax) +
		 7 * (-51 * pow(c2x,2) - 5 * pow(c2y,2) + 164 * c2x * c3x + 12 * c2y * c3y) * etay -
		 6 * c1y * (21 * pow(c2x,2) - 21 * pow(c2y,2) + 25 * (c0x * c3x - c3x * etax + c3y * etay))) +
	  42 * (pow(c0y,2) * (5 * c2y * c3x + 6 * c2x * c3y - 9 * c3x * c3y) -
		 (c0x - etax) * (-5 * pow(c2x,2) * c2y - 5 * pow(c2y,3) + 6 * c2y * c3x * (c0x - etax) + 5 * c2x * c3y * (c0x - etax) +
			9 * c3x * c3y * (-c0x + etax)) + (5 * pow(c2x,3) + 5 * c2x * pow(c2y,2) +
			(9 * pow(c3x,2) + (11 * c2y - 9 * c3y) * c3y) * (c0x - etax) + 11 * c2x * c3x * (-c0x + etax)) * etay +
		 (5 * c2y * c3x + 6 * c2x * c3y - 9 * c3x * c3y) * pow(etay,2) -
		 c0y * (5 * pow(c2x,3) + (9 * pow(c3x,2) + (11 * c2y - 9 * c3y) * c3y) * (c0x - etax) + 2 * c3x * (5 * c2y - 9 * c3y) * etay +
			c2x * (5 * pow(c2y,2) + 11 * c3x * (-c0x + etax) + 12 * c3y * etay)))) / 140.,
   (3 * (-112 * c1y * pow(c2x,3) + 140 * pow(c1y,2) * c2x * c2y - 224 * c0x * pow(c2x,2) * c2y - 112 * c1y * c2x * pow(c2y,2) -
		224 * c0x * pow(c2y,3) + 80 * pow(c1y,3) * c3x - 50 * c0x * c1y * c2x * c3x - 320 * pow(c1y,2) * c2y * c3x +
		620 * c0x * c2x * c2y * c3x - 80 * pow(c1x,3) * c3y - 184 * pow(c1y,2) * c2x * c3y + 416 * c0x * pow(c2x,2) * c3y -
		1218 * c0x * c1y * c2y * c3y + 1036 * c0x * pow(c2y,2) * c3y - 420 * pow(c0x,2) * c3x * c3y + 420 * pow(c0y,2) * c3x * c3y +
		952 * c0x * c1y * pow(c3y,2) + 4 * pow(c1x,2) * (-35 * c2x * c2y + 20 * c1y * c3x + 46 * c2y * c3x + 80 * c2x * c3y) +
		224 * pow(c2x,2) * c2y * etax + 224 * pow(c2y,3) * etax + 50 * c1y * c2x * c3x * etax - 620 * c2x * c2y * c3x * etax -
		416 * pow(c2x,2) * c3y * etax + 1218 * c1y * c2y * c3y * etax - 1036 * pow(c2y,2) * c3y * etax + 840 * c0x * c3x * c3y * etax -
		952 * c1y * pow(c3y,2) * etax - 420 * c3x * c3y * pow(etax,2) +
		(-224 * pow(c2x,3) + 1036 * pow(c2x,2) * c3x - 615 * c1y * c2y * c3x + 416 * pow(c2y,2) * c3x - 420 * c0x * pow(c3x,2) +
		   952 * c1y * c3x * c3y + 420 * c0x * pow(c3y,2) + c2x * (-224 * pow(c2y,2) - 553 * c1y * c3y + 620 * c2y * c3y) +
		   420 * (c3x - c3y) * (c3x + c3y) * etax) * etay + 420 * c3x * c3y * pow(etay,2) +
		c1x * (112 * pow(c2x,2) * c2y + 112 * pow(c2y,3) - 553 * c0x * c2y * c3x - 952 * c0y * pow(c3x,2) - 80 * pow(c1y,2) * c3y +
		   50 * c0y * c2y * c3y + 952 * c0x * c3x * c3y + 28 * c1y * (5 * pow(c2x,2) - 18 * c2x * c3x + c2y * (-5 * c2y + 18 * c3y)) +
		   553 * c2y * c3x * etax - 952 * c3x * c3y * etax + 615 * c2x * c3y * (-c0x + etax) + 1218 * c2x * c3x * (c0y - etay) +
		   952 * pow(c3x,2) * etay - 50 * c2y * c3y * etay) +
		c0y * (224 * pow(c2x,3) - 1036 * pow(c2x,2) * c3x - 416 * pow(c2y,2) * c3x + 420 * c0x * pow(c3x,2) +
		   c1y * c3x * (615 * c2y - 952 * c3y) - 420 * c0x * pow(c3y,2) + c2x * (224 * pow(c2y,2) + 553 * c1y * c3y - 620 * c2y * c3y) -
		   420 * pow(c3x,2) * etax + 420 * pow(c3y,2) * etax - 840 * c3x * c3y * etay))) / 560.,
   (pow(c1y,2) * (165 * c2y * c3x + 91 * c2x * c3y - 224 * c3x * c3y) + pow(c1x,2) * (-91 * c2y * c3x - 165 * c2x * c3y + 224 * c3x * c3y) +
	  2 * c1y * (28 * pow(c2x,3) - 140 * pow(c2x,2) * c3x - 92 * pow(c2y,2) * c3x + 9 * c0x * pow(c3x,2) - 112 * c1x * pow(c3x,2) -
		 128 * c1x * c2y * c3y + 240 * c0y * c3x * c3y - 231 * c0x * pow(c3y,2) + 112 * c1x * pow(c3y,2) +
		 4 * c2x * (7 * pow(c2y,2) + 32 * c1x * c3x - 12 * c2y * c3y) - 9 * pow(c3x,2) * etax + 231 * pow(c3y,2) * etax - 240 * c3x * c3y * etay
		 ) + 6 * (c0y * (7 * (5 * pow(c2y,2) + 6 * c2x * (2 * c2x - 3 * c3x)) * c3x + c2y * (49 * c2x - 96 * c3x) * c3y - 30 * c2x * pow(c3y,2)) -
		 (c2x * c3x * (49 * c2y - 96 * c3y) + 35 * pow(c2x,2) * c3y + 6 * c2y * (-5 * pow(c3x,2) + 7 * (2 * c2y - 3 * c3y) * c3y)) *
		  (c0x - etax) + (-84 * pow(c2x,2) * c3x + 126 * c2x * pow(c3x,2) + c2x * c3y * (-49 * c2y + 30 * c3y) +
			c2y * c3x * (-35 * c2y + 96 * c3y)) * etay) + 2 * c1x *
	   (-28 * pow(c2y,3) + 48 * c2x * c2y * c3x + 140 * pow(c2y,2) * c3y + pow(c2x,2) * (-28 * c2y + 92 * c3y) +
		 3 * (77 * c0y * pow(c3x,2) - 80 * c0x * c3x * c3y - 3 * c0y * pow(c3y,2) + 80 * c3x * c3y * etax - 77 * pow(c3x,2) * etay +
			3 * pow(c3y,2) * etay))) / 112.,(-960 * pow(c1x,2) * c3x * c3y + 960 * pow(c1y,2) * c3x * c3y +
	  c1y * (c3x * (795 * pow(c2y,2) + 4 * c2x * (295 * c2x - 476 * c3x) + 960 * c1x * c3x) + 5 * c2y * (77 * c2x - 376 * c3x) * c3y -
		 24 * (40 * c1x + c2x) * pow(c3y,2)) + c1x * (-795 * pow(c2x,2) * c3y + 5 * c2x * c3x * (-77 * c2y + 376 * c3y) +
		 4 * c2y * (6 * pow(c3x,2) + c3y * (-295 * c2y + 476 * c3y))) +
	  3 * (-80 * pow(c2x,2) * c2y * c3x - 80 * pow(c2y,3) * c3x + 80 * pow(c2x,3) * c3y +
		 504 * (pow(c3x,2) + pow(c3y,2)) * (-(c0y * c3x) + c0x * c3y - c3y * etax + c3x * etay) -
		 7 * c2y * (33 * c0x * pow(c3x,2) - 115 * c0y * c3x * c3y + 148 * c0x * pow(c3y,2) - 33 * pow(c3x,2) * etax -
			148 * pow(c3y,2) * etax + 115 * c3x * c3y * etay) +
		 c2x * (80 * pow(c2y,2) * c3y + 7 * c0y * (148 * pow(c3x,2) + 33 * pow(c3y,2)) + 805 * c3x * c3y * (-c0x + etax) -
			7 * (148 * pow(c3x,2) + 33 * pow(c3y,2)) * etay))) / 560.,
   (3 * (7 * pow(c2y,3) * c3x - 7 * pow(c2x,3) * c3y - 20 * pow(c2y,2) * c3x * c3y + pow(c2x,2) * c3x * (7 * c2y + 20 * c3y) +
		54 * c2y * c3y * (c1y * c3x - c1x * c3y) + c2x * (54 * c1y * pow(c3x,2) - 7 * pow(c2y,2) * c3y - 54 * c1x * c3x * c3y +
		   20 * c2y * (-pow(c3x,2) + pow(c3y,2))) +
		14 * (pow(c3x,2) + pow(c3y,2)) * (3 * c0y * c3x - 2 * c1y * c3x - 3 * c0x * c3y + 2 * c1x * c3y + 3 * c3y * etax - 3 * c3x * etay))) / 56.,
   (3 * (35 * c2x * c3x * (c2y * c3x - c2x * c3y) + 35 * c2y * c3y * (c2y * c3x - c2x * c3y) +
		24 * pow(c3x,2) * (2 * c1y * c3x - c2y * c3x + (-2 * c1x + c2x) * c3y) +
		24 * pow(c3y,2) * (2 * c1y * c3x - c2y * c3x + (-2 * c1x + c2x) * c3y))) / 112.,
	   (9 * (c2y * c3x - c2x * c3y) * (pow(c3x, 2) + pow(c3y, 2))) / 16. };
		Ix2t0 = valuesIx2[0];
		Ix2t1 = valuesIx2[1];
		Ix2t2 = valuesIx2[2];
		Ix2t3 = valuesIx2[3];
		Ix2t4 = valuesIx2[4];
		Ix2t5 = valuesIx2[5];
		Ix2t6 = valuesIx2[6];
		Ix2t7 = valuesIx2[7];
		Ix2t8 = valuesIx2[8];
		Ix2t9 = valuesIx2[9];
		Ix2t10 = valuesIx2[10];
		Ix2t11 = valuesIx2[11];
		Ix2t12 = valuesIx2[12];
		Ix2t13 = valuesIx2[13];
	}

	//Iy0系数
	if (1)
	{
		std::vector<double> valuesIy0 = { 0,-((pow(c0x - etax,2) + pow(c0y - etay,2)) * (c0x * c1x + c0y * c1y - c1x * etax - c1y * etay)) / 4.,
   (pow(c0x,3) * (c1x - 2 * c2x) + pow(c0y,3) * (c1y - 2 * c2y) -
	  pow(etax,2) * (2 * pow(c1x,2) + pow(c1y,2) + c1x * etax - 2 * c2x * etax) -
	  etax * (2 * c1x * c1y + c1y * etax - 2 * c2y * etax) * etay -
	  (pow(c1x,2) + 2 * pow(c1y,2) + c1x * etax - 2 * c2x * etax) * pow(etay,2) - (c1y - 2 * c2y) * pow(etay,3) -
	  pow(c0y,2) * (pow(c1x,2) + 2 * pow(c1y,2) + c1x * etax - 2 * c2x * etax + 3 * c1y * etay - 6 * c2y * etay) -
	  pow(c0x,2) * (2 * pow(c1x,2) - c0y * c1y + pow(c1y,2) + 2 * c0y * c2y + 3 * c1x * etax - 6 * c2x * etax + c1y * etay -
		 2 * c2y * etay) + c0y * (etax * (2 * c1x * c1y + c1y * etax - 2 * c2y * etax) +
		 2 * (pow(c1x,2) + 2 * pow(c1y,2) + c1x * etax - 2 * c2x * etax) * etay + 3 * (c1y - 2 * c2y) * pow(etay,2)) +
	  c0x * (pow(c0y,2) * (c1x - 2 * c2x) + etax * (4 * pow(c1x,2) + 2 * pow(c1y,2) + 3 * c1x * etax - 6 * c2x * etax) +
		 2 * (c1x * c1y + (c1y - 2 * c2y) * etax) * etay + (c1x - 2 * c2x) * pow(etay,2) -
		 2 * c0y * (c1y * etax - 2 * c2y * etax - 2 * c2x * etay + c1x * (c1y + etay)))) / 4.,
   (-(pow(c0x,3) * (c1x - 6 * c2x + 9 * c3x)) - pow(c0y,3) * (c1y - 6 * c2y + 9 * c3y) +
	  etax * (4 * c1x * (pow(c1x,2) + pow(c1y,2)) + c1x * (7 * c1x - 17 * c2x) * etax + 3 * c1y * (c1y - 3 * c2y) * etax +
		 (c1x - 6 * c2x + 9 * c3x) * pow(etax,2)) + (4 * c1y * (pow(c1x,2) + pow(c1y,2)) -
		 8 * (c1y * c2x + c1x * (-c1y + c2y)) * etax + (c1y - 6 * c2y + 9 * c3y) * pow(etax,2)) * etay +
	  (3 * c1x * (c1x - 3 * c2x) + c1y * (7 * c1y - 17 * c2y) + (c1x - 6 * c2x + 9 * c3x) * etax) * pow(etay,2) +
	  (c1y - 6 * c2y + 9 * c3y) * pow(etay,3) + pow(c0x,2) *
	   (c1x * (7 * c1x - 17 * c2x) + 3 * c1y * (c1y - 3 * c2y) - c0y * (c1y - 6 * c2y + 9 * c3y) + 3 * (c1x - 6 * c2x + 9 * c3x) * etax +
		 (c1y - 6 * c2y + 9 * c3y) * etay) + pow(c0y,2) *
	   (3 * c1x * (c1x - 3 * c2x) + c1y * (7 * c1y - 17 * c2y) + (c1x - 6 * c2x + 9 * c3x) * etax + 3 * (c1y - 6 * c2y + 9 * c3y) * etay) +
	  c0x * (-4 * c1x * (pow(c1x,2) + pow(c1y,2)) - 8 * c0y * (c1y * c2x + c1x * (-c1y + c2y)) -
		 pow(c0y,2) * (c1x - 6 * c2x + 9 * c3x) + 2 * (-7 * pow(c1x,2) + 17 * c1x * c2x - 3 * c1y * (c1y - 3 * c2y) +
			c0y * (c1y - 6 * c2y + 9 * c3y)) * etax - 3 * (c1x - 6 * c2x + 9 * c3x) * pow(etax,2) +
		 2 * (4 * c1y * c2x + 4 * c1x * (-c1y + c2y) + c0y * (c1x - 6 * c2x + 9 * c3x) - (c1y - 6 * c2y + 9 * c3y) * etax) * etay -
		 (c1x - 6 * c2x + 9 * c3x) * pow(etay,2)) + c0y *
	   (-4 * pow(c1x,2) * c1y - 4 * pow(c1y,3) - 8 * c1x * c1y * etax + 8 * c1y * c2x * etax + 8 * c1x * c2y * etax - c1y * pow(etax,2) +
		 6 * c2y * pow(etax,2) - 9 * c3y * pow(etax,2) -
		 2 * (3 * c1x * (c1x - 3 * c2x) + c1y * (7 * c1y - 17 * c2y) + (c1x - 6 * c2x + 9 * c3x) * etax) * etay -
		 3 * (c1y - 6 * c2y + 9 * c3y) * pow(etay,2))) / 12.,
   (-2 * pow(c1x,4) - 4 * pow(c1x,2) * pow(c1y,2) - 2 * pow(c1y,4) + pow(c0x,3) * (-4 * c2x + 18 * c3x) +
	  pow(c0y,3) * (-4 * c2y + 18 * c3y) - 11 * pow(c1x,3) * etax - 11 * c1x * pow(c1y,2) * etax + 29 * pow(c1x,2) * c2x * etax +
	  8 * pow(c1y,2) * c2x * etax + 21 * c1x * c1y * c2y * etax - 5 * pow(c1x,2) * pow(etax,2) - 2 * pow(c1y,2) * pow(etax,2) +
	  40 * c1x * c2x * pow(etax,2) - 20 * pow(c2x,2) * pow(etax,2) + 18 * c1y * c2y * pow(etax,2) -
	  12 * pow(c2y,2) * pow(etax,2) - 45 * c1x * c3x * pow(etax,2) - 24 * c1y * c3y * pow(etax,2) + 4 * c2x * pow(etax,3) -
	  18 * c3x * pow(etax,3) + (-11 * pow(c1y,3) + 29 * pow(c1y,2) * c2y + pow(c1x,2) * (-11 * c1y + 8 * c2y) +
		 c1y * (22 * c2x - 21 * c3x) * etax + c1x * (21 * c1y * c2x - 6 * c1y * etax + 22 * c2y * etax - 21 * c3y * etax) +
		 2 * etax * (-8 * c2x * c2y + 2 * c2y * etax - 9 * c3y * etax)) * etay -
	  (5 * (pow(c1y,2) - 8 * c1y * c2y + 4 * pow(c2y,2) + 9 * c1y * c3y) +
		 2 * (pow(c1x,2) - 9 * c1x * c2x + 6 * pow(c2x,2) + 12 * c1x * c3x - 2 * c2x * etax + 9 * c3x * etax)) * pow(etay,2) +
	  2 * (2 * c2y - 9 * c3y) * pow(etay,3) - pow(c0y,2) *
	   (5 * (pow(c1y,2) - 8 * c1y * c2y + 4 * pow(c2y,2) + 9 * c1y * c3y) +
		 2 * (pow(c1x,2) - 9 * c1x * c2x + 6 * pow(c2x,2) + 12 * c1x * c3x - 2 * c2x * etax + 9 * c3x * etax) + 6 * (-2 * c2y + 9 * c3y) * etay)\
	   - pow(c0x,2) * (5 * (pow(c1x,2) - 8 * c1x * c2x + 4 * pow(c2x,2) + 9 * c1x * c3x) + 6 * (-2 * c2x + 9 * c3x) * etax +
		 2 * (pow(c1y,2) + 2 * c0y * c2y - 9 * c1y * c2y + 6 * pow(c2y,2) - 9 * c0y * c3y + 12 * c1y * c3y - 2 * c2y * etay + 9 * c3y * etay)) +
	  c0x * (11 * pow(c1x,3) - 8 * pow(c1y,2) * c2x + pow(c0y,2) * (-4 * c2x + 18 * c3x) + 4 * pow(c1y,2) * etax +
		 40 * pow(c2x,2) * etax - 36 * c1y * c2y * etax + 24 * pow(c2y,2) * etax + 48 * c1y * c3y * etax - 12 * c2x * pow(etax,2) +
		 54 * c3x * pow(etax,2) + pow(c1x,2) * (-29 * c2x + 10 * etax) - 22 * c1y * c2x * etay + 16 * c2x * c2y * etay + 21 * c1y * c3x * etay -
		 8 * c2y * etax * etay + 36 * c3y * etax * etay - 4 * c2x * pow(etay,2) + 18 * c3x * pow(etay,2) +
		 c0y * (22 * c1y * c2x - 16 * c2x * c2y - 21 * c1y * c3x + 8 * c2y * etax - 36 * c3y * etax + 8 * c2x * etay - 36 * c3x * etay) +
		 c1x * (11 * pow(c1y,2) - 21 * c1y * c2y + c0y * (-6 * c1y + 22 * c2y - 21 * c3y) - 80 * c2x * etax + 90 * c3x * etax + 6 * c1y * etay -
			22 * c2y * etay + 21 * c3y * etay)) + c0y * (11 * pow(c1y,3) + 2 * etax * (8 * c2x * c2y - 2 * c2y * etax + 9 * c3y * etax) +
		 4 * (6 * pow(c2x,2) + 10 * pow(c2y,2) - 2 * c2x * etax + 9 * c3x * etax) * etay + 6 * (-2 * c2y + 9 * c3y) * pow(etay,2) +
		 pow(c1x,2) * (11 * c1y - 8 * c2y + 4 * etay) + pow(c1y,2) * (-29 * c2y + 10 * etay) +
		 c1x * (-21 * c1y * c2x + 6 * c1y * etax - 22 * c2y * etax + 21 * c3y * etax - 36 * c2x * etay + 48 * c3x * etay) +
		 c1y * (-22 * c2x * etax + 21 * c3x * etax - 80 * c2y * etay + 90 * c3y * etay))) / 24.,
   (5 * pow(c1x,4) - 7 * c0y * pow(c1y,3) + 5 * pow(c1y,4) + 20 * pow(c0y,2) * pow(c2x,2) - 22 * c0y * c1y * pow(c2x,2) -
	  24 * pow(c0y,2) * c1y * c2y + 68 * c0y * pow(c1y,2) * c2y - 15 * pow(c1y,3) * c2y + 40 * pow(c0y,2) * pow(c2y,2) -
	  52 * c0y * c1y * pow(c2y,2) - 10 * pow(c0x,3) * c3x - 50 * pow(c0y,2) * c2x * c3x - 10 * pow(c0y,3) * c3y +
	  88 * pow(c0y,2) * c1y * c3y - 59 * c0y * pow(c1y,2) * c3y - 80 * pow(c0y,2) * c2y * c3y + 14 * c0y * c1y * c2x * etax -
	  20 * pow(c1y,2) * c2x * etax - 40 * c0y * c2x * c2y * etax + 30 * c1y * c2x * c2y * etax + 10 * pow(c0y,2) * c3x * etax -
	  48 * c0y * c1y * c3x * etax + 15 * pow(c1y,2) * c3x * etax + 30 * c0y * c2y * c3x * etax + 30 * c0y * c2x * c3y * etax +
	  40 * pow(c2x,2) * pow(etax,2) - 10 * c1y * c2y * pow(etax,2) + 20 * pow(c2y,2) * pow(etax,2) -
	  80 * c2x * c3x * pow(etax,2) - 10 * c0y * c3y * pow(etax,2) + 40 * c1y * c3y * pow(etax,2) - 50 * c2y * c3y * pow(etax,2) +
	  10 * c3x * pow(etax,3) + pow(c1x,3) * (-15 * c2x + 7 * etax) +
	  (7 * pow(c1y,3) + pow(c1y,2) * (-68 * c2y + 59 * c3y) +
		 2 * c1y * (11 * pow(c2x,2) + 24 * c0y * c2y + 26 * pow(c2y,2) - 88 * c0y * c3y - 7 * c2x * etax + 24 * c3x * etax) +
		 10 * (3 * pow(c0y,2) * c3y - 2 * c0y * (2 * pow(c2x,2) - 5 * c2x * c3x + 4 * c2y * (c2y - 2 * c3y) + c3x * etax) +
			etax * (4 * c2x * c2y - 3 * c2y * c3x - 3 * c2x * c3y + c3y * etax))) * etay +
	  2 * (10 * pow(c2x,2) - 25 * c2x * c3x + c1y * (-12 * c2y + 44 * c3y) + 5 * (4 * c2y * (c2y - 2 * c3y) - 3 * c0y * c3y + c3x * etax)) *
	   pow(etay,2) + 10 * c3y * pow(etay,3) + pow(c1x,2) *
	   (5 * c1y * (2 * c1y - 3 * c2y) + c0y * (-7 * c1y + 20 * c2y - 15 * c3y) - 68 * c2x * etax + 59 * c3x * etax +
		 (7 * c1y - 20 * c2y + 15 * c3y) * etay) + 2 * pow(c0x,2) *
	   (c1x * (-12 * c2x + 44 * c3x) + 5 * (-(c1y * c2y) + 2 * pow(c2y,2) + 4 * c2x * (c2x - 2 * c3x) - c0y * c3y + 4 * c1y * c3y - 5 * c2y * c3y +
			3 * c3x * etax + c3y * etay)) + c1x * (-10 * pow(c0y,2) * (c2x - 4 * c3x) + pow(c1y,2) * (-15 * c2x + 7 * etax) +
		 2 * c0y * (24 * c1y * c2x - 15 * c2x * c2y - 22 * c1y * c3x + 7 * c2y * etax - 24 * c3y * etax + 10 * (c2x - 4 * c3x) * etay) +
		 c1y * (-48 * c2y * etax + 44 * c3y * etax - 48 * c2x * etay + 44 * c3x * etay) +
		 2 * (etax * (26 * pow(c2x,2) + 11 * pow(c2y,2) - 12 * c2x * etax + 44 * c3x * etax) +
			(15 * c2x * c2y - 7 * c2y * etax + 24 * c3y * etax) * etay - 5 * (c2x - 4 * c3x) * pow(etay,2))) -
	  c0x * (7 * pow(c1x,3) + 10 * pow(c0y,2) * c3x + pow(c1x,2) * (-68 * c2x + 59 * c3x) +
		 5 * (c1y * (-4 * c1y * c2x + 6 * c2x * c2y + 3 * c1y * c3x) +
			4 * (-(c1y * c2y) + 2 * pow(c2y,2) + 4 * c2x * (c2x - 2 * c3x) + 4 * c1y * c3y - 5 * c2y * c3y) * etax + 6 * c3x * pow(etax,2)) +
		 2 * (c1y * (-7 * c2x + 24 * c3x) + 5 * (4 * c2x * c2y - 3 * c2y * c3x - 3 * c2x * c3y + 2 * c3y * etax)) * etay + 10 * c3x * pow(etay,2) +
		 c1x * (7 * pow(c1y,2) + 52 * pow(c2x,2) + 14 * c0y * c2y - 48 * c1y * c2y + 22 * pow(c2y,2) - 48 * c0y * c3y + 44 * c1y * c3y -
			48 * c2x * etax + 176 * c3x * etax - 14 * c2y * etay + 48 * c3y * etay) +
		 2 * c0y * (c1y * (7 * c2x - 24 * c3x) - 5 * (4 * c2x * c2y - 3 * c2y * c3x - 3 * c2x * c3y + 2 * c3y * etax + 2 * c3x * etay)))) / 40.,
   (-6 * pow(c1x,4) - 6 * pow(c1y,4) - 44 * pow(c0x,2) * pow(c2x,2) - 20 * pow(c0y,2) * pow(c2x,2) -
	  52 * c0x * pow(c2x,3) - 48 * c0x * c0y * c2x * c2y - 52 * c0y * pow(c2x,2) * c2y - 20 * pow(c0x,2) * pow(c2y,2) -
	  44 * pow(c0y,2) * pow(c2y,2) - 52 * c0x * c2x * pow(c2y,2) - 52 * c0y * pow(c2y,3) + pow(c1x,3) * (69 * c2x - 52 * c3x) +
	  288 * pow(c0x,2) * c2x * c3x + 150 * pow(c0y,2) * c2x * c3x + 138 * c0x * c0y * c2y * c3x - 135 * pow(c0x,2) * pow(c3x,2) -
	  90 * pow(c0y,2) * pow(c3x,2) + pow(c1y,3) * (69 * c2y - 52 * c3y) + 138 * c0x * c0y * c2x * c3y + 150 * pow(c0x,2) * c2y * c3y +
	  288 * pow(c0y,2) * c2y * c3y - 90 * c0x * c0y * c3x * c3y - 90 * pow(c0x,2) * pow(c3y,2) - 135 * pow(c0y,2) * pow(c3y,2) +
	  88 * c0x * pow(c2x,2) * etax + 52 * pow(c2x,3) * etax + 48 * c0y * c2x * c2y * etax + 40 * c0x * pow(c2y,2) * etax +
	  52 * c2x * pow(c2y,2) * etax - 576 * c0x * c2x * c3x * etax - 138 * c0y * c2y * c3x * etax + 270 * c0x * pow(c3x,2) * etax -
	  138 * c0y * c2x * c3y * etax - 300 * c0x * c2y * c3y * etax + 90 * c0y * c3x * c3y * etax + 180 * c0x * pow(c3y,2) * etax -
	  44 * pow(c2x,2) * pow(etax,2) - 20 * pow(c2y,2) * pow(etax,2) + 288 * c2x * c3x * pow(etax,2) -
	  135 * pow(c3x,2) * pow(etax,2) + 150 * c2y * c3y * pow(etax,2) - 90 * pow(c3y,2) * pow(etax,2) +
	  2 * (26 * c2y * (pow(c2x,2) + pow(c2y,2)) + 3 * c0x * (8 * c2x * c2y - 23 * c2y * c3x - 23 * c2x * c3y + 15 * c3x * c3y) +
		 c0y * (20 * pow(c2x,2) + 44 * pow(c2y,2) - 150 * c2x * c3x + 90 * pow(c3x,2) - 288 * c2y * c3y + 135 * pow(c3y,2)) +
		 3 * (-8 * c2x * c2y + 23 * c2y * c3x + 23 * c2x * c3y - 15 * c3x * c3y) * etax) * etay -
	  (20 * pow(c2x,2) + 44 * pow(c2y,2) - 150 * c2x * c3x + 90 * pow(c3x,2) - 288 * c2y * c3y + 135 * pow(c3y,2)) *
	   pow(etay,2) - pow(c1x,2) * (12 * pow(c1y,2) + 79 * c0x * c2x + 71 * pow(c2x,2) + 24 * c0y * c2y - 69 * c1y * c2y +
		 26 * pow(c2y,2) - 249 * c0x * c3x - 69 * c0y * c3y + 52 * c1y * c3y - 79 * c2x * etax + 249 * c3x * etax - 24 * c2y * etay + 69 * c3y * etay)
		- pow(c1y,2) * (24 * c0x * c2x + 26 * pow(c2x,2) + 79 * c0y * c2y + 71 * pow(c2y,2) - 69 * c0x * c3x - 249 * c0y * c3y -
		 24 * c2x * etax + 69 * c3x * etax - 79 * c2y * etay + 249 * c3y * etay) -
	  c1x * (40 * pow(c0y,2) * c3x + pow(c1y,2) * (-69 * c2x + 52 * c3x) +
		 (-228 * pow(c2x,2) + 354 * c2x * c3x + 10 * c2y * (-9 * c2y + 16 * c3y) + 95 * c3x * (c0x - etax)) * (c0x - etax) +
		 (-104 * c2y * c3x + 6 * c2x * (23 * c2y - 15 * c3y) + 55 * c3y * (-c0x + etax)) * etay + 40 * c3x * pow(etay,2) +
		 c0y * (55 * c1y * c2x - 138 * c2x * c2y - 180 * c1y * c3x + 104 * c2y * c3x + 55 * c0x * c3y + 90 * c2x * c3y - 55 * c3y * etax -
			80 * c3x * etay) + 5 * c1y * (11 * c0x * c2y + 18 * c2x * c2y - 36 * c0x * c3y - 11 * c2y * etax + 36 * c3y * etax - 11 * c2x * etay +
			36 * c3x * etay)) - c1y * (95 * pow(c0y,2) * c3y +
		 2 * (c0x - etax) * (-69 * c2x * c2y + 45 * c2y * c3x + 20 * c0x * c3y + 52 * c2x * c3y - 20 * c3y * etax) +
		 (90 * pow(c2x,2) - 160 * c2x * c3x + 6 * c2y * (38 * c2y - 59 * c3y) + 55 * c3x * (-c0x + etax)) * etay + 95 * c3y * pow(etay,2) +
		 c0y * (-90 * pow(c2x,2) - 228 * pow(c2y,2) + 160 * c2x * c3x + 354 * c2y * c3y + 55 * c3x * (c0x - etax) - 190 * c3y * etay))) / 120.
	,(140 * pow(c1y,2) * pow(c2x,2) + 280 * c0x * pow(c2x,3) - 98 * pow(c1y,3) * c2y - 196 * c0x * c1y * c2x * c2y -
	  168 * c1y * pow(c2x,2) * c2y + 392 * pow(c1y,2) * pow(c2y,2) + 280 * c0x * c2x * pow(c2y,2) - 168 * c1y * pow(c2y,3) -
	  98 * c0x * pow(c1y,2) * c3x - 371 * pow(c0x,2) * c2x * c3x - 210 * pow(c1y,2) * c2x * c3x - 588 * c0x * pow(c2x,2) * c3x +
	  504 * c0x * c1y * c2y * c3x - 168 * c0x * pow(c2y,2) * c3x + 567 * pow(c0x,2) * pow(c3x,2) + pow(c1x,3) * (-98 * c2x + 280 * c3x) +
	  280 * pow(c1y,3) * c3y + 560 * c0x * c1y * c2x * c3y - 175 * pow(c0x,2) * c2y * c3y - 546 * pow(c1y,2) * c2y * c3y -
	  420 * c0x * c2x * c2y * c3y - 336 * c0x * c1y * c3x * c3y + 315 * pow(c0x,2) * pow(c3y,2) -
	  7 * pow(c0y,2) * (5 * (5 * c2x - 9 * c3x) * c3x + 53 * c2y * c3y - 81 * pow(c3y,2)) - 280 * pow(c2x,3) * etax +
	  196 * c1y * c2x * c2y * etax - 280 * c2x * pow(c2y,2) * etax + 98 * pow(c1y,2) * c3x * etax + 742 * c0x * c2x * c3x * etax +
	  588 * pow(c2x,2) * c3x * etax - 504 * c1y * c2y * c3x * etax + 168 * pow(c2y,2) * c3x * etax - 1134 * c0x * pow(c3x,2) * etax -
	  560 * c1y * c2x * c3y * etax + 350 * c0x * c2y * c3y * etax + 420 * c2x * c2y * c3y * etax + 336 * c1y * c3x * c3y * etax -
	  630 * c0x * pow(c3y,2) * etax - 371 * c2x * c3x * pow(etax,2) + 567 * pow(c3x,2) * pow(etax,2) -
	  175 * c2y * c3y * pow(etax,2) + 315 * pow(c3y,2) * pow(etax,2) -
	  2 * c0y * (169 * pow(c1y,2) * c3y + c1y * (60 * pow(c2x,2) + 158 * pow(c2y,2) - 380 * c2x * c3x + 165 * pow(c3x,2) -
			912 * c2y * c3y + 333 * pow(c3y,2)) + 14 *
		  (-10 * pow(c2y,3) + 15 * c2x * c2y * c3x + 21 * pow(c2y,2) * c3y + pow(c2x,2) * (-10 * c2y + 6 * c3y) +
			7 * c2y * c3x * (c0x - etax) + 7 * c2x * c3y * (c0x - etax) + 18 * c3x * c3y * (-c0x + etax))) +
	  14 * c0y * (5 * (5 * c2x - 9 * c3x) * c3x + 53 * c2y * c3y - 81 * pow(c3y,2)) * etay +
	  2 * (169 * pow(c1y,2) * c3y + c1y * (60 * pow(c2x,2) + 158 * pow(c2y,2) - 380 * c2x * c3x + 165 * pow(c3x,2) - 912 * c2y * c3y +
			333 * pow(c3y,2)) + 14 * (-10 * pow(c2y,3) + 15 * c2x * c2y * c3x + 21 * pow(c2y,2) * c3y +
			pow(c2x,2) * (-10 * c2y + 6 * c3y) + 7 * c2y * c3x * (c0x - etax) + 7 * c2x * c3y * (c0x - etax) + 18 * c3x * c3y * (-c0x + etax))) *
	   etay - 7 * (5 * (5 * c2x - 9 * c3x) * c3x + 53 * c2y * c3y - 81 * pow(c3y,2)) * pow(etay,2) +
	  2 * pow(c1x,2) * (196 * pow(c2x,2) - 273 * c2x * c3x + 35 * c2y * (2 * c2y - 3 * c3y) - 49 * c0y * c3y + 7 * c1y * (-7 * c2y + 20 * c3y) +
		 169 * c3x * (-c0x + etax) + 49 * c3y * etay) - 2 * c1x *
	   (84 * pow(c2x,3) + 98 * c0y * c2x * c2y + 84 * c2x * pow(c2y,2) + 7 * pow(c1y,2) * (7 * c2x - 20 * c3x) - 280 * c0y * c2y * c3x -
		 252 * c0y * c2x * c3y + 168 * c0y * c3x * c3y + 84 * c1y * c2x * (-3 * c2y + 2 * c3y) +
		 c0x * (158 * pow(c2x,2) + 60 * pow(c2y,2) - 912 * c2x * c3x + 333 * pow(c3x,2) - 380 * c2y * c3y + 165 * pow(c3y,2)) -
		 158 * pow(c2x,2) * etax - 60 * pow(c2y,2) * etax + 912 * c2x * c3x * etax - 333 * pow(c3x,2) * etax + 380 * c2y * c3y * etax -
		 165 * pow(c3y,2) * etax + 14 * (-7 * c2x * c2y + 20 * c2y * c3x + 18 * c2x * c3y - 12 * c3x * c3y) * etay +
		 24 * c1y * (5 * c0y * c3x + 7 * c2y * c3x + 5 * c0x * c3y - 5 * c3y * etax - 5 * c3x * etay))) / 420.,
   (-152 * pow(c1x,3) * c3x - 152 * pow(c1y,3) * c3y -
	  2 * pow(c1x,2) * (108 * pow(c2x,2) + 38 * pow(c2y,2) - 579 * c2x * c3x + 192 * pow(c3x,2) + 76 * c1y * c3y - 215 * c2y * c3y +
		 80 * pow(c3y,2)) - 2 * pow(c1y,2) * (38 * pow(c2x,2) + 108 * pow(c2y,2) - 215 * c2x * c3x + 80 * pow(c3x,2) -
		 579 * c2y * c3y + 192 * pow(c3y,2)) + c1y * (364 * pow(c2y,3) + 28 * pow(c2x,2) * (13 * c2y - 8 * c3y) -
		 714 * pow(c2y,2) * c3y + 7 * c0y * (85 * pow(c3x,2) + 189 * pow(c3y,2)) + 728 * c3x * c3y * (c0x - etax) +
		 280 * c2y * c3x * (-c0x + etax) + 304 * c2x * c3y * (-c0x + etax) - 35 * c2x * c3x * (11 * c0y + 14 * c2y - 11 * etay) -
		 7 * (85 * pow(c3x,2) + 189 * pow(c3y,2)) * etay + 969 * c2y * c3y * (-c0y + etay)) +
	  c1x * (364 * pow(c2x,3) - 152 * pow(c1y,2) * c3x - 714 * pow(c2x,2) * c3x - 304 * c0y * c2y * c3x - 224 * pow(c2y,2) * c3x +
		 1323 * c0x * pow(c3x,2) + 56 * c1y * c3x * (13 * c2y - 8 * c3y) - 385 * c0x * c2y * c3y + 728 * c0y * c3x * c3y + 595 * c0x * pow(c3y,2) -
		 1323 * pow(c3x,2) * etax + 385 * c2y * c3y * etax - 595 * pow(c3y,2) * etax + 8 * c3x * (38 * c2y - 91 * c3y) * etay +
		 c2x * (364 * pow(c2y,2) - 490 * c2y * c3y + 56 * c1y * (-5 * c2y + 13 * c3y) + 969 * c3x * (-c0x + etax) + 280 * c3y * (-c0y + etay)))\
	   - 2 * (28 * pow(c2x,4) + 76 * c0y * pow(c2y,3) + 28 * pow(c2y,4) + 70 * pow(c0y,2) * pow(c3x,2) +
		 160 * c0y * c2y * pow(c3x,2) - 612 * c0y * pow(c2y,2) * c3y + 140 * pow(c0y,2) * pow(c3y,2) + 405 * c0y * c2y * pow(c3y,2) +
		 70 * pow(c0x,2) * (2 * pow(c3x,2) + pow(c3y,2)) - 76 * pow(c2x,3) * etax + 182 * pow(c2y,2) * c3x * etax -
		 140 * c0y * c3x * c3y * etax - 245 * c2y * c3x * c3y * etax + 140 * pow(c3x,2) * pow(etax,2) + 70 * pow(c3y,2) * pow(etax,2) -
		 (76 * pow(c2y,3) - 612 * pow(c2y,2) * c3y + 5 * c2y * (32 * pow(c3x,2) + 81 * pow(c3y,2)) +
			140 * (c0y * (pow(c3x,2) + 2 * pow(c3y,2)) - c3x * c3y * etax)) * etay +
		 70 * (pow(c3x,2) + 2 * pow(c3y,2)) * pow(etay,2) +
		 2 * pow(c2x,2) * (38 * c0y * c2y + 28 * pow(c2y,2) - 91 * c0y * c3y + 306 * c3x * etax - 38 * c2y * etay + 91 * c3y * etay) -
		 c2x * (5 * c0y * c3x * (86 * c2y - 49 * c3y) + 76 * pow(c2y,2) * etax - 430 * c2y * (c3y * etax + c3x * etay) +
			5 * (81 * pow(c3x,2) * etax + 32 * pow(c3y,2) * etax + 49 * c3x * c3y * etay)) +
		 c0x * (76 * pow(c2x,3) - 612 * pow(c2x,2) * c3x +
			c2x * (76 * pow(c2y,2) + 405 * pow(c3x,2) - 430 * c2y * c3y + 160 * pow(c3y,2)) -
			7 * (26 * pow(c2y,2) * c3x - 35 * c2y * c3x * c3y +
			   20 * (-(c0y * c3x * c3y) + 2 * pow(c3x,2) * etax + pow(c3y,2) * etax + c3x * c3y * etay))))) / 560.,
   (168 * pow(c2x,4) - 276 * c1y * pow(c2y,3) + 168 * pow(c2y,4) - 420 * pow(c2x,3) * c3x - 276 * c0x * pow(c2y,2) * c3x -
	  406 * c0y * c1y * pow(c3x,2) + 441 * pow(c1y,2) * pow(c3x,2) + 882 * c0y * c2y * pow(c3x,2) - 486 * c1y * c2y * pow(c3x,2) -
	  486 * c0x * pow(c3x,3) - 867 * pow(c1y,2) * c2y * c3y - 906 * c0y * pow(c2y,2) * c3y + 2112 * c1y * pow(c2y,2) * c3y -
	  420 * pow(c2y,3) * c3y - 552 * c0x * c1y * c3x * c3y + 1440 * c0x * c2y * c3x * c3y - 486 * c0y * pow(c3x,2) * c3y -
	  958 * c0y * c1y * pow(c3y,2) + 1113 * pow(c1y,2) * pow(c3y,2) + 2322 * c0y * c2y * pow(c3y,2) - 1326 * c1y * c2y * pow(c3y,2) -
	  486 * c0x * c3x * pow(c3y,2) - 486 * c0y * pow(c3y,3) +
	  pow(c1x,2) * (-867 * c2x * c3x + 1113 * pow(c3x,2) + 63 * c3y * (-5 * c2y + 7 * c3y)) + 276 * pow(c2y,2) * c3x * etax +
	  486 * pow(c3x,3) * etax + 552 * c1y * c3x * c3y * etax - 1440 * c2y * c3x * c3y * etax + 486 * c3x * pow(c3y,2) * etax -
	  6 * pow(c2x,2) * (-56 * pow(c2y,2) + 2 * c1y * (23 * c2y - 56 * c3y) + 70 * c2y * c3y + 151 * c3x * (c0x - etax) +
		 46 * c3y * (c0y - etay)) + 2 * (453 * pow(c2y,2) * c3y + 243 * c3y * (pow(c3x,2) + pow(c3y,2)) -
		 9 * c2y * (49 * pow(c3x,2) + 129 * pow(c3y,2)) + c1y * (203 * pow(c3x,2) + 479 * pow(c3y,2))) * etay -
	  2 * c1x * (138 * pow(c2x,3) - 1056 * pow(c2x,2) * c3x - 336 * pow(c2y,2) * c3x + 479 * c0x * pow(c3x,2) +
		 12 * c1y * c3x * (23 * c2y - 56 * c3y) + 276 * c0y * c3x * c3y + 420 * c2y * c3x * c3y + 203 * c0x * pow(c3y,2) +
		 3 * c2x * (46 * pow(c2y,2) + 221 * pow(c3x,2) + 92 * c1y * c3y - 240 * c2y * c3y + 81 * pow(c3y,2)) -
		 479 * pow(c3x,2) * etax - 203 * pow(c3y,2) * etax - 276 * c3x * c3y * etay) -
	  3 * c2x * (105 * pow(c1y,2) * c3x + 140 * pow(c2y,2) * c3x - 774 * c0x * pow(c3x,2) + 30 * c0y * c3x * (7 * c2y - 16 * c3y) +
		 210 * c0x * c2y * c3y - 294 * c0x * pow(c3y,2) + 40 * c1y * c3x * (-12 * c2y + 7 * c3y) + 774 * pow(c3x,2) * etax -
		 210 * c2y * c3y * etax + 294 * pow(c3y,2) * etax - 210 * c2y * c3x * etay + 480 * c3x * c3y * etay)) / 1008.,
   (-360 * pow(c2x,4) - 360 * pow(c2y,4) + 3540 * pow(c2x,3) * c3x - 2336 * pow(c1x,2) * pow(c3x,2) -
	  896 * pow(c1y,2) * pow(c3x,2) + 3969 * c0x * pow(c3x,3) - 2232 * c1x * pow(c3x,3) + 3540 * pow(c2y,3) * c3y -
	  2880 * c1x * c1y * c3x * c3y + 3969 * c0y * pow(c3x,2) * c3y - 2232 * c1y * pow(c3x,2) * c3y - 896 * pow(c1x,2) * pow(c3y,2) -
	  2336 * pow(c1y,2) * pow(c3y,2) + 3969 * c0x * c3x * pow(c3y,2) - 2232 * c1x * c3x * pow(c3y,2) + 3969 * c0y * pow(c3y,3) -
	  2232 * c1y * pow(c3y,3) - 3 * pow(c2x,2) * (240 * pow(c2y,2) + 1495 * c1x * c3x + 1072 * pow(c3x,2) + 480 * c1y * c3y -
		 1180 * c2y * c3y + 372 * pow(c3y,2)) - 3 * pow(c2y,2) * (480 * c1x * c3x + 372 * pow(c3x,2) + c3y * (1495 * c1y + 1072 * c3y)) -
	  3969 * pow(c3x,3) * etax - 3969 * c3x * pow(c3y,2) * etax - 3969 * c3y * (pow(c3x,2) + pow(c3y,2)) * etay +
	  c2x * (3540 * pow(c2y,2) * c3x - 4837 * c0x * pow(c3x,2) + 11049 * c1x * pow(c3x,2) - 3045 * c0y * c3x * c3y -
		 105 * c2y * (29 * c1x + 40 * c3x) * c3y - 1792 * c0x * pow(c3y,2) + 3969 * c1x * pow(c3y,2) +
		 15 * c1y * c3x * (-203 * c2y + 472 * c3y) + 4837 * pow(c3x,2) * etax + 1792 * pow(c3y,2) * etax + 3045 * c3x * c3y * etay) +
	  c2y * (-7 * c0y * (256 * pow(c3x,2) + 691 * pow(c3y,2)) + 3 * c1y * (1323 * pow(c3x,2) + 3683 * pow(c3y,2)) +
		 15 * c3x * c3y * (-203 * c0x + 472 * c1x + 203 * etax) + 7 * (256 * pow(c3x,2) + 691 * pow(c3y,2)) * etay)) / 5040.,
   (-51 * pow(c2x,3) * c3x + 63 * pow(c2y,2) * pow(c3x,2) - 56 * c0x * pow(c3x,3) + 126 * c1x * pow(c3x,3) -
	  51 * pow(c2y,3) * c3y - 102 * c1x * c2y * c3x * c3y - 56 * c0y * pow(c3x,2) * c3y - 72 * c2y * pow(c3x,2) * c3y +
	  183 * pow(c2y,2) * pow(c3y,2) - 56 * c0x * c3x * pow(c3y,2) + 126 * c1x * c3x * pow(c3y,2) - 56 * c0y * pow(c3y,3) -
	  72 * c2y * pow(c3y,3) + 126 * c1y * c3y * (pow(c3x,2) + pow(c3y,2)) - 2 * c1y * c2y * (28 * pow(c3x,2) + 79 * pow(c3y,2)) +
	  3 * pow(c2x,2) * (61 * pow(c3x,2) + c3y * (-17 * c2y + 21 * c3y)) +
	  c2x * (-51 * pow(c2y,2) * c3x + 240 * c2y * c3x * c3y -
		 2 * (pow(c3x,2) * (79 * c1x + 36 * c3x) + 51 * c1y * c3x * c3y + 4 * (7 * c1x + 9 * c3x) * pow(c3y,2))) + 56 * pow(c3x,3) * etax +
	  56 * c3x * pow(c3y,2) * etax + 56 * c3y * (pow(c3x,2) + pow(c3y,2)) * etay) / 168.,
   (747 * c2y * c3y * (pow(c3x,2) + pow(c3y,2)) - 4 * (pow(c3x,2) + pow(c3y,2)) *
	   (82 * c1x * c3x + 27 * pow(c3x,2) + 82 * c1y * c3y + 27 * pow(c3y,2)) -
	  pow(c2x,2) * (479 * pow(c3x,2) + 164 * pow(c3y,2)) - pow(c2y,2) * (164 * pow(c3x,2) + 479 * pow(c3y,2)) +
	  9 * c2x * c3x * (83 * pow(c3x,2) + c3y * (-70 * c2y + 83 * c3y))) / 1008.,
   -((47 * c2x * c3x - 27 * pow(c3x,2) + (47 * c2y - 27 * c3y) * c3y) * (pow(c3x,2) + pow(c3y,2))) / 144.,
			 -pow(pow(c3x, 2) + pow(c3y, 2), 2) / 12. };
		Iy0t0 = valuesIy0[0];
		Iy0t1 = valuesIy0[1];
		Iy0t2 = valuesIy0[2];
		Iy0t3 = valuesIy0[3];
		Iy0t4 = valuesIy0[4];
		Iy0t5 = valuesIy0[5];
		Iy0t6 = valuesIy0[6];
		Iy0t7 = valuesIy0[7];
		Iy0t8 = valuesIy0[8];
		Iy0t9 = valuesIy0[9];
		Iy0t10 = valuesIy0[10];
		Iy0t11 = valuesIy0[11];
		Iy0t12 = valuesIy0[12];
		Iy0t13 = valuesIy0[13];
		Iy0t14 = valuesIy0[14];

	}
	//Iy1系数
	if (1)
	{
		std::vector<double> valuesIy1 = { 0,0,-((pow(c0x - etax,2) + pow(c0y - etay,2)) * (c0x * c1x + c0y * c1y - c1x * etax - c1y * etay)) / 4.,
   (2 * pow(c0x,3) * (c1x - 3 * c2x) + 2 * pow(c0y,3) * (c1y - 3 * c2y) -
	  pow(etax,2) * (7 * pow(c1x,2) + 3 * pow(c1y,2) + 2 * c1x * etax - 6 * c2x * etax) -
	  2 * etax * (4 * c1x * c1y + (c1y - 3 * c2y) * etax) * etay -
	  (3 * pow(c1x,2) + 7 * pow(c1y,2) + 2 * c1x * etax - 6 * c2x * etax) * pow(etay,2) - 2 * (c1y - 3 * c2y) * pow(etay,3) -
	  pow(c0y,2) * (3 * pow(c1x,2) + 7 * pow(c1y,2) + 2 * c1x * etax - 6 * c2x * etax + 6 * (c1y - 3 * c2y) * etay) -
	  pow(c0x,2) * (7 * pow(c1x,2) - 2 * c0y * c1y + 3 * pow(c1y,2) + 6 * c0y * c2y + 6 * (c1x - 3 * c2x) * etax + 2 * c1y * etay -
		 6 * c2y * etay) + 2 * c0y * (etax * (4 * c1x * c1y + (c1y - 3 * c2y) * etax) +
		 (3 * pow(c1x,2) + 7 * pow(c1y,2) + 2 * c1x * etax - 6 * c2x * etax) * etay + 3 * (c1y - 3 * c2y) * pow(etay,2)) +
	  2 * c0x * (pow(c0y,2) * (c1x - 3 * c2x) + etax * (7 * pow(c1x,2) + 3 * pow(c1y,2) + 3 * c1x * etax - 9 * c2x * etax) +
		 4 * c1x * c1y * etay + 2 * (c1y - 3 * c2y) * etax * etay + (c1x - 3 * c2x) * pow(etay,2) -
		 2 * c0y * (c1y * etax - 3 * c2y * etax - 3 * c2x * etay + c1x * (2 * c1y + etay)))) / 12.,
   (2 * pow(c0x,3) * (4 * c2x - 9 * c3x) + 2 * pow(c0y,3) * (4 * c2y - 9 * c3y) +
	  etax * (11 * c1x * (pow(c1x,2) + pow(c1y,2)) + 2 * (5 * c1x * (c1x - 4 * c2x) + c1y * (2 * c1y - 9 * c2y)) * etax +
		 2 * (-4 * c2x + 9 * c3x) * pow(etax,2)) + 2 * pow(c0x,2) *
	   (2 * pow(c1y,2) + 5 * c1x * (c1x - 4 * c2x) - 9 * c1y * c2y + 3 * (-4 * c2x + 9 * c3x) * etax + (4 * c2y - 9 * c3y) * (c0y - etay)) +
	  (11 * c1y * (pow(c1x,2) + pow(c1y,2)) + 2 * (6 * c1x * c1y - 11 * c1y * c2x - 11 * c1x * c2y) * etax +
		 2 * (-4 * c2y + 9 * c3y) * pow(etax,2)) * etay +
	  2 * (2 * pow(c1x,2) - 9 * c1x * c2x + 5 * c1y * (c1y - 4 * c2y) - 4 * c2x * etax + 9 * c3x * etax) * pow(etay,2) +
	  2 * (-4 * c2y + 9 * c3y) * pow(etay,3) + 2 * pow(c0y,2) *
	   (2 * pow(c1x,2) - 9 * c1x * c2x + 5 * c1y * (c1y - 4 * c2y) - 4 * c2x * etax + 9 * c3x * etax + 3 * (-4 * c2y + 9 * c3y) * etay) +
	  c0y * (-11 * pow(c1x,2) * c1y - 11 * pow(c1y,3) - 12 * c1x * c1y * etax + 22 * c1y * c2x * etax + 22 * c1x * c2y * etax +
		 8 * c2y * pow(etax,2) - 18 * c3y * pow(etax,2) -
		 4 * (2 * pow(c1x,2) - 9 * c1x * c2x + 5 * c1y * (c1y - 4 * c2y) - 4 * c2x * etax + 9 * c3x * etax) * etay +
		 6 * (4 * c2y - 9 * c3y) * pow(etay,2)) + c0x * (-11 * pow(c1x,3) - 20 * pow(c1x,2) * etax +
		 c1x * (12 * c0y * c1y - 11 * pow(c1y,2) - 22 * c0y * c2y + 80 * c2x * etax - 12 * c1y * etay + 22 * c2y * etay) +
		 2 * (pow(c0y,2) * (4 * c2x - 9 * c3x) + etax * (-4 * pow(c1y,2) + 18 * c1y * c2y + 12 * c2x * etax - 27 * c3x * etax) +
			(11 * c1y * c2x + 8 * c2y * etax - 18 * c3y * etax) * etay + (4 * c2x - 9 * c3x) * pow(etay,2) +
			c0y * (-11 * c1y * c2x - 8 * c2y * etax + 18 * c3y * etax - 8 * c2x * etay + 18 * c3x * etay)))) / 24.,
   (-5 * pow(c1x,4) + 14 * c0y * pow(c1y,3) - 5 * pow(c1y,4) - 20 * pow(c0y,2) * pow(c2x,2) + 48 * pow(c0y,2) * c1y * c2y -
	  68 * c0y * pow(c1y,2) * c2y - 40 * pow(c0y,2) * pow(c2y,2) + 20 * pow(c0x,3) * c3x + 20 * pow(c0y,3) * c3y -
	  88 * pow(c0y,2) * c1y * c3y - 14 * pow(c1x,3) * etax - 28 * c0y * c1y * c2x * etax + 20 * pow(c1y,2) * c2x * etax +
	  40 * c0y * c2x * c2y * etax - 20 * pow(c0y,2) * c3x * etax + 48 * c0y * c1y * c3x * etax - 40 * pow(c2x,2) * pow(etax,2) +
	  20 * c1y * c2y * pow(etax,2) - 20 * pow(c2y,2) * pow(etax,2) + 20 * c0y * c3y * pow(etax,2) - 40 * c1y * c3y * pow(etax,2) -
	  20 * c3x * pow(etax,3) + 2 * (-7 * pow(c1y,3) + 34 * pow(c1y,2) * c2y +
		 c1y * (-48 * c0y * c2y + 88 * c0y * c3y + 14 * c2x * etax - 24 * c3x * etax) -
		 10 * (3 * pow(c0y,2) * c3y - 2 * c0y * (pow(c2x,2) + 2 * pow(c2y,2) + c3x * etax) + etax * (2 * c2x * c2y + c3y * etax))) * etay -
	  4 * (5 * pow(c2x,2) - 12 * c1y * c2y + 10 * pow(c2y,2) - 15 * c0y * c3y + 22 * c1y * c3y + 5 * c3x * etax) * pow(etay,2) -
	  20 * c3y * pow(etay,3) + 2 * pow(c1x,2) * (7 * c0y * c1y - 5 * pow(c1y,2) - 10 * c0y * c2y + 34 * c2x * etax - 7 * c1y * etay +
		 10 * c2y * etay) + 2 * c1x * (10 * pow(c0y,2) * (c2x - 2 * c3x) +
		 etax * (-7 * pow(c1y,2) + 24 * c1y * c2y + 24 * c2x * etax - 44 * c3x * etax) +
		 2 * (12 * c1y * c2x + 7 * c2y * etax - 12 * c3y * etax) * etay + 10 * (c2x - 2 * c3x) * pow(etay,2) -
		 2 * c0y * (12 * c1y * c2x + 7 * c2y * etax - 12 * c3y * etax + 10 * (c2x - 2 * c3x) * etay)) +
	  4 * pow(c0x,2) * (2 * c1x * (6 * c2x - 11 * c3x) - 5 *
		  (2 * pow(c2x,2) - c1y * c2y + pow(c2y,2) - c0y * c3y + 2 * c1y * c3y + 3 * c3x * etax + c3y * etay)) +
	  2 * c0x * (7 * pow(c1x,3) - 34 * pow(c1x,2) * c2x +
		 c1x * (7 * pow(c1y,2) - 24 * c1y * c2y - 48 * c2x * etax + 88 * c3x * etax + 2 * (7 * c2y - 12 * c3y) * (c0y - etay)) +
		 2 * (-5 * pow(c1y,2) * c2x + c0y * c1y * (7 * c2x - 12 * c3x) + 5 * pow(c0y,2) * c3x +
			5 * etax * (4 * pow(c2x,2) + 2 * pow(c2y,2) + 3 * c3x * etax) + 10 * (c2x * c2y + c3y * etax) * etay + 5 * c3x * pow(etay,2) -
			10 * c0y * (c2x * c2y + c3y * etax + c3x * etay) + c1y * (-10 * c2y * etax + 20 * c3y * etax - 7 * c2x * etay + 12 * c3x * etay)))) / 40.,
   (12 * pow(c1x,4) + 12 * pow(c1y,4) - 69 * pow(c1x,3) * c2x - 69 * pow(c1y,3) * c2y +
	  pow(c1y,2) * (3 * (16 * c2x - 23 * c3x) * (c0x - etax) + (158 * c2y - 249 * c3y) * (c0y - etay)) +
	  pow(c1x,2) * (24 * pow(c1y,2) - 69 * c1y * c2y + (158 * c2x - 249 * c3x) * (c0x - etax) + 3 * (16 * c2y - 23 * c3y) * (c0y - etay)) +
	  c1x * (-69 * pow(c1y,2) * c2x + 80 * pow(c0y,2) * c3x -
		 2 * (c0x - etax) * (114 * pow(c2x,2) + 45 * pow(c2y,2) + 95 * c3x * (-c0x + etax)) +
		 2 * (69 * c2x * c2y + 55 * c3y * (-c0x + etax)) * etay + 80 * c3x * pow(etay,2) +
		 2 * c0y * (55 * c1y * c2x - 69 * c2x * c2y - 90 * c1y * c3x + 55 * c3y * (c0x - etax) - 80 * c3x * etay) +
		 10 * c1y * ((11 * c2y - 18 * c3y) * (c0x - etax) - 11 * c2x * etay + 18 * c3x * etay)) +
	  2 * c1y * (95 * pow(c0y,2) * c3y + (-69 * c2x * c2y + 40 * c3y * (c0x - etax)) * (c0x - etax) +
		 (45 * pow(c2x,2) + 114 * pow(c2y,2) + 55 * c3x * (-c0x + etax)) * etay + 95 * c3y * pow(etay,2) -
		 c0y * (45 * pow(c2x,2) + 114 * pow(c2y,2) + 55 * c3x * (-c0x + etax) + 190 * c3y * etay)) +
	  2 * (pow(c0y,2) * (20 * pow(c2x,2) - 75 * c2x * c3x + 4 * c2y * (11 * c2y - 36 * c3y)) +
		 pow(c0x,2) * (44 * pow(c2x,2) - 144 * c2x * c3x + 5 * c2y * (4 * c2y - 15 * c3y)) +
		 (44 * pow(c2x, 2) - 144 * c2x * c3x + 5 * c2y * (4 * c2y - 15 * c3y)) * pow(etax, 2) +
			 3 * (16 * c2x * c2y - 23 * c2y * c3x - 23 * c2x * c3y) * etax * etay +
			 (20 * pow(c2x, 2) - 75 * c2x * c3x + 4 * c2y * (11 * c2y - 36 * c3y)) * pow(etay, 2) +
			 c0x * (c0y * (48 * c2x * c2y - 69 * c2y * c3x - 69 * c2x * c3y) - 88 * pow(c2x, 2) * etax +
				 c2y * (-40 * c2y * etax + 150 * c3y * etax + 69 * c3x * etay) + 3 * c2x * (96 * c3x * etax - 16 * c2y * etay + 23 * c3y * etay)) +
			 c0y * (-40 * pow(c2x, 2) * etay + c2x * (-48 * c2y * etax + 69 * c3y * etax + 150 * c3x * etay) +
				 c2y * (69 * c3x * etax - 88 * c2y * etay + 288 * c3y * etay)))) / 120.,
				 (-140 * pow(c1y, 2) * pow(c2x, 2) - 280 * c0x * pow(c2x, 3) + 196 * pow(c1y, 3) * c2y + 392 * c0x * c1y * c2x * c2y -
					 392 * pow(c1y, 2) * pow(c2y, 2) - 280 * c0x * c2x * pow(c2y, 2) + 28 * pow(c1x, 3) * (7 * c2x - 10 * c3x) +
					 196 * c0x * pow(c1y, 2) * c3x + 742 * pow(c0x, 2) * c2x * c3x - 504 * c0x * c1y * c2y * c3x - 567 * pow(c0x, 2) * pow(c3x, 2) +
					 8 * c0y * c1y * (30 * pow(c2x, 2) - 95 * c2x * c3x + c2y * (79 * c2y - 228 * c3y)) + 676 * c0y * pow(c1y, 2) * c3y -
					 280 * pow(c1y, 3) * c3y - 560 * c0x * c1y * c2x * c3y + 350 * pow(c0x, 2) * c2y * c3y - 315 * pow(c0x, 2) * pow(c3y, 2) +
					 7 * pow(c0y, 2) * (50 * c2x * c3x - 45 * pow(c3x, 2) + (106 * c2y - 81 * c3y) * c3y) + 280 * pow(c2x, 3) * etax -
					 392 * c1y * c2x * c2y * etax + 280 * c2x * pow(c2y, 2) * etax - 196 * pow(c1y, 2) * c3x * etax - 1484 * c0x * c2x * c3x * etax +
					 504 * c1y * c2y * c3x * etax + 1134 * c0x * pow(c3x, 2) * etax + 560 * c1y * c2x * c3y * etax - 700 * c0x * c2y * c3y * etax +
					 630 * c0x * pow(c3y, 2) * etax + 742 * c2x * c3x * pow(etax, 2) - 567 * pow(c3x, 2) * pow(etax, 2) +
					 350 * c2y * c3y * pow(etax, 2) - 315 * pow(c3y, 2) * pow(etax, 2) -
					 56 * c0y * (5 * pow(c2x, 2) * c2y + 5 * pow(c2y, 3) + 9 * c3x * c3y * (c0x - etax) + 7 * c2y * c3x * (-c0x + etax) +
						 7 * c2x * c3y * (-c0x + etax)) - 8 * c1y * (30 * pow(c2x, 2) - 95 * c2x * c3x + c2y * (79 * c2y - 228 * c3y)) * etay -
					 676 * pow(c1y, 2) * c3y * etay - 14 * c0y * (50 * c2x * c3x - 45 * pow(c3x, 2) + (106 * c2y - 81 * c3y) * c3y) * etay +
					 56 * (5 * pow(c2x, 2) * c2y + 5 * pow(c2y, 3) + 9 * c3x * c3y * (c0x - etax) + 7 * c2y * c3x * (-c0x + etax) +
						 7 * c2x * c3y * (-c0x + etax)) * etay + 7 * (50 * c2x * c3x - 45 * pow(c3x, 2) + (106 * c2y - 81 * c3y) * c3y) * pow(etay, 2) -
					 4 * pow(c1x, 2) * (98 * pow(c2x, 2) + 35 * pow(c2y, 2) + c1y * (-49 * c2y + 70 * c3y) + 169 * c3x * (-c0x + etax) +
						 49 * c3y * (-c0y + etay)) + 4 * c1x * (-126 * c1y * c2x * c2y + 7 * pow(c1y, 2) * (7 * c2x - 10 * c3x) +
							 120 * c1y * (c0y * c3x + c0x * c3y - c3y * etax - c3x * etay) +
							 2 * (c0x * (79 * pow(c2x, 2) - 228 * c2x * c3x + 5 * c2y * (6 * c2y - 19 * c3y)) + 7 * c0y * (7 * c2x * c2y - 10 * c2y * c3x - 9 * c2x * c3y) -
								 79 * pow(c2x, 2) * etax - 30 * pow(c2y, 2) * etax + 228 * c2x * c3x * etax + 95 * c2y * c3y * etax - 49 * c2x * c2y * etay +
								 70 * c2y * c3x * etay + 63 * c2x * c3y * etay))) / 420.,
			 (304 * pow(c1x, 3) * c3x + 2 * pow(c1y, 2) * (76 * pow(c2x, 2) - 215 * c2x * c3x + 3 * c2y * (72 * c2y - 193 * c3y)) +
				 304 * pow(c1y, 3) * c3y + 2 * pow(c1x, 2) * (216 * pow(c2x, 2) + 76 * pow(c2y, 2) - 579 * c2x * c3x + 152 * c1y * c3y -
					 215 * c2y * c3y) - c1y * (364 * pow(c2x, 2) * c2y + 364 * pow(c2y, 3) + 7 * c0y * (85 * pow(c3x, 2) + 189 * pow(c3y, 2)) +
						 728 * c3x * c3y * (c0x - etax) + 560 * c2y * c3x * (-c0x + etax) + 608 * c2x * c3y * (-c0x + etax) -
						 7 * (85 * pow(c3x, 2) + 189 * pow(c3y, 2)) * etay + 770 * c2x * c3x * (-c0y + etay) + 1938 * c2y * c3y * (-c0y + etay)) -
				 c1x * (364 * pow(c2x, 3) - 304 * pow(c1y, 2) * c3x - 608 * c0y * c2y * c3x + 728 * c1y * c2y * c3x + 1323 * c0x * pow(c3x, 2) -
					 770 * c0x * c2y * c3y + 728 * c0y * c3x * c3y + 595 * c0x * pow(c3y, 2) - 1323 * pow(c3x, 2) * etax + 770 * c2y * c3y * etax -
					 595 * pow(c3y, 2) * etax + 8 * c3x * (76 * c2y - 91 * c3y) * etay +
					 2 * c2x * (182 * pow(c2y, 2) + c1y * (-280 * c2y + 364 * c3y) + 969 * c3x * (-c0x + etax) + 280 * c3y * (-c0y + etay))) +
				 4 * (70 * pow(c0x, 2) * (2 * pow(c3x, 2) + pow(c3y, 2)) + 70 * pow(c0y, 2) * (pow(c3x, 2) + 2 * pow(c3y, 2)) +
					 etax * (-76 * pow(c2x, 3) + 306 * pow(c2x, 2) * c3x + 91 * pow(c2y, 2) * c3x + c2x * c2y * (-76 * c2y + 215 * c3y) +
						 70 * (2 * pow(c3x, 2) + pow(c3y, 2)) * etax) +
					 (-76 * pow(c2y, 3) + 215 * c2x * c2y * c3x + 306 * pow(c2y, 2) * c3y + pow(c2x, 2) * (-76 * c2y + 91 * c3y) + 140 * c3x * c3y * etax) *
					 etay + 70 * (pow(c3x, 2) + 2 * pow(c3y, 2)) * pow(etay, 2) +
					 c0x * (76 * pow(c2x, 3) - 306 * pow(c2x, 2) * c3x - 91 * pow(c2y, 2) * c3x + c2x * c2y * (76 * c2y - 215 * c3y) -
						 140 * (-(c0y * c3x * c3y) + 2 * pow(c3x, 2) * etax + pow(c3y, 2) * etax + c3x * c3y * etay)) +
					 c0y * (76 * pow(c2y, 3) - 215 * c2x * c2y * c3x + pow(c2x, 2) * (76 * c2y - 91 * c3y) - 306 * pow(c2y, 2) * c3y -
						 140 * (c3x * c3y * etax + pow(c3x, 2) * etay + 2 * pow(c3y, 2) * etay)))) / 560.,
			 (-168 * pow(c2x, 4) + 552 * c1y * pow(c2y, 3) - 168 * pow(c2y, 4) + 552 * c0x * pow(c2y, 2) * c3x + 812 * c0y * c1y * pow(c3x, 2) -
				 441 * pow(c1y, 2) * pow(c3x, 2) - 882 * c0y * c2y * pow(c3x, 2) + 1734 * pow(c1y, 2) * c2y * c3y + 1812 * c0y * pow(c2y, 2) * c3y -
				 2112 * c1y * pow(c2y, 2) * c3y + 1104 * c0x * c1y * c3x * c3y - 1440 * c0x * c2y * c3x * c3y + 1916 * c0y * c1y * pow(c3y, 2) -
				 1113 * pow(c1y, 2) * pow(c3y, 2) - 2322 * c0y * c2y * pow(c3y, 2) +
				 3 * pow(c1x, 2) * ((578 * c2x - 371 * c3x) * c3x + 21 * (10 * c2y - 7 * c3y) * c3y) - 552 * pow(c2y, 2) * c3x * etax -
				 1104 * c1y * c3x * c3y * etax + 1440 * c2y * c3x * c3y * etax +
				 12 * pow(c2x, 2) * (-28 * pow(c2y, 2) + c1y * (46 * c2y - 56 * c3y) + 151 * c3x * (c0x - etax) + 46 * c3y * (c0y - etay)) -
				 2 * (7 * (58 * c1y - 63 * c2y) * pow(c3x, 2) + 906 * pow(c2y, 2) * c3y + (958 * c1y - 1161 * c2y) * pow(c3y, 2)) * etay +
				 4 * c1x * (138 * pow(c2x, 3) - 528 * pow(c2x, 2) * c3x - 168 * pow(c2y, 2) * c3x + 479 * c0x * pow(c3x, 2) +
					 12 * c1y * c3x * (23 * c2y - 28 * c3y) + 276 * c0y * c3x * c3y + 203 * c0x * pow(c3y, 2) +
					 6 * c2x * (23 * pow(c2y, 2) + 46 * c1y * c3y - 60 * c2y * c3y) - 479 * pow(c3x, 2) * etax - 203 * pow(c3y, 2) * etax -
					 276 * c3x * c3y * etay) + 18 * c2x * (35 * pow(c1y, 2) * c3x - 80 * c1y * c2y * c3x + 10 * c0y * c3x * (7 * c2y - 8 * c3y) -
						 (129 * pow(c3x, 2) - 70 * c2y * c3y + 49 * pow(c3y, 2)) * (c0x - etax) + 10 * c3x * (-7 * c2y + 8 * c3y) * etay)) / 1008.,
			 (720 * pow(c2x, 4) + 720 * pow(c2y, 4) - 3540 * pow(c2x, 3) * c3x + 4672 * pow(c1x, 2) * pow(c3x, 2) +
				 1792 * pow(c1y, 2) * pow(c3x, 2) - 3969 * c0x * pow(c3x, 3) - 3540 * pow(c2y, 3) * c3y + 5760 * c1x * c1y * c3x * c3y -
				 3969 * c0y * pow(c3x, 2) * c3y + 1792 * pow(c1x, 2) * pow(c3y, 2) + 4672 * pow(c1y, 2) * pow(c3y, 2) -
				 3969 * c0x * c3x * pow(c3y, 2) - 3969 * c0y * pow(c3y, 3) + 30 * pow(c2y, 2) * (96 * c1x * c3x + 299 * c1y * c3y) +
				 30 * pow(c2x, 2) * (48 * pow(c2y, 2) + 299 * c1x * c3x + 96 * c1y * c3y - 118 * c2y * c3y) + 3969 * pow(c3x, 3) * etax +
				 3969 * c3x * pow(c3y, 2) * etax + 3969 * c3y * (pow(c3x, 2) + pow(c3y, 2)) * etay -
				 c2x * (3540 * pow(c2y, 2) * c3x - 9674 * c0x * pow(c3x, 2) + 11049 * c1x * pow(c3x, 2) - 6090 * c1x * c2y * c3y - 6090 * c0y * c3x * c3y -
					 3584 * c0x * pow(c3y, 2) + 3969 * c1x * pow(c3y, 2) + 30 * c1y * c3x * (-203 * c2y + 236 * c3y) + 9674 * pow(c3x, 2) * etax +
					 3584 * pow(c3y, 2) * etax + 6090 * c3x * c3y * etay) +
				 c2y * (14 * c0y * (256 * pow(c3x, 2) + 691 * pow(c3y, 2)) - 3 * c1y * (1323 * pow(c3x, 2) + 3683 * pow(c3y, 2)) +
					 30 * c3x * c3y * (203 * c0x - 236 * c1x - 203 * etax) - 14 * (256 * pow(c3x, 2) + 691 * pow(c3y, 2)) * etay)) / 5040.,
			 (102 * pow(c2x, 3) * c3x - 63 * pow(c2y, 2) * pow(c3x, 2) + 112 * c0x * pow(c3x, 3) - 126 * c1x * pow(c3x, 3) +
				 102 * pow(c2y, 3) * c3y + 204 * c1x * c2y * c3x * c3y + 112 * c0y * pow(c3x, 2) * c3y - 183 * pow(c2y, 2) * pow(c3y, 2) +
				 112 * c0x * c3x * pow(c3y, 2) - 126 * c1x * c3x * pow(c3y, 2) + 112 * c0y * pow(c3y, 3) -
				 126 * c1y * c3y * (pow(c3x, 2) + pow(c3y, 2)) + 4 * c1y * c2y * (28 * pow(c3x, 2) + 79 * pow(c3y, 2)) +
				 2 * c2x * (51 * pow(c2y, 2) * c3x + 158 * c1x * pow(c3x, 2) + 102 * c1y * c3x * c3y - 120 * c2y * c3x * c3y + 56 * c1x * pow(c3y, 2)) -
				 3 * pow(c2x, 2) * (61 * pow(c3x, 2) + c3y * (-34 * c2y + 21 * c3y)) - 112 * pow(c3x, 3) * etax - 112 * c3x * pow(c3y, 2) * etax -
				 112 * c3y * (pow(c3x, 2) + pow(c3y, 2)) * etay) / 168.,
			 (-747 * c2y * c3y * (pow(c3x, 2) + pow(c3y, 2)) + 656 * (c1x * c3x + c1y * c3y) * (pow(c3x, 2) + pow(c3y, 2)) +
				 pow(c2x, 2) * (958 * pow(c3x, 2) + 328 * pow(c3y, 2)) + pow(c2y, 2) * (328 * pow(c3x, 2) + 958 * pow(c3y, 2)) -
				 9 * c2x * c3x * (83 * pow(c3x, 2) + c3y * (-140 * c2y + 83 * c3y))) / 1008.,
			 ((94 * c2x * c3x - 27 * pow(c3x, 2) + (94 * c2y - 27 * c3y) * c3y) * (pow(c3x, 2) + pow(c3y, 2))) / 144.,
			 pow(pow(c3x, 2) + pow(c3y, 2), 2) / 6. };
		Iy1t0 = valuesIy1[0];
		Iy1t1 = valuesIy1[1];
		Iy1t2 = valuesIy1[2];
		Iy1t3 = valuesIy1[3];
		Iy1t4 = valuesIy1[4];
		Iy1t5 = valuesIy1[5];
		Iy1t6 = valuesIy1[6];
		Iy1t7 = valuesIy1[7];
		Iy1t8 = valuesIy1[8];
		Iy1t9 = valuesIy1[9];
		Iy1t10 = valuesIy1[10];
		Iy1t11 = valuesIy1[11];
		Iy1t12 = valuesIy1[12];
		Iy1t13 = valuesIy1[13];
		Iy1t14 = valuesIy1[14];

	}
	//Iy2系数
	{
		std::vector<double> valuesIy2 = { 0,0,0,-((pow(c0x - etax,2) + pow(c0y - etay,2)) * (c0x * c1x + c0y * c1y - c1x * etax - c1y * etay)) / 12.,
   (-4 * pow(c0x,3) * c2x - 4 * pow(c0y,3) * c2y + pow(etax,2) * (-5 * pow(c1x,2) - 2 * pow(c1y,2) + 4 * c2x * etax) +
	  2 * etax * (-3 * c1x * c1y + 2 * c2y * etax) * etay + (-2 * pow(c1x,2) - 5 * pow(c1y,2) + 4 * c2x * etax) * pow(etay,2) +
	  4 * c2y * pow(etay,3) + pow(c0x,2) * (-5 * pow(c1x,2) - 2 * pow(c1y,2) - 4 * c0y * c2y + 12 * c2x * etax + 4 * c2y * etay) +
	  pow(c0y,2) * (-2 * pow(c1x,2) - 5 * pow(c1y,2) + 4 * c2x * etax + 12 * c2y * etay) +
	  2 * c0x * (-2 * pow(c0y,2) * c2x + 5 * pow(c1x,2) * etax + 2 * etax * (pow(c1y,2) - 3 * c2x * etax) + 3 * c1x * c1y * etay -
		 4 * c2y * etax * etay - 2 * c2x * pow(etay,2) + c0y * (-3 * c1x * c1y + 4 * c2y * etax + 4 * c2x * etay)) +
	  2 * c0y * (3 * c1x * c1y * etax + 2 * pow(c1x,2) * etay + (5 * pow(c1y,2) - 4 * c2x * etax) * etay -
		 2 * c2y * (pow(etax,2) + 3 * pow(etay,2)))) / 24.,
   (-10 * pow(c0x,3) * c3x - 10 * pow(c0y,3) * c3y +
	  etax * (7 * c1x * (pow(c1x,2) + pow(c1y,2)) - 2 * (12 * c1x * c2x + 5 * c1y * c2y) * etax + 10 * c3x * pow(etax,2)) +
	  (7 * c1y * (pow(c1x,2) + pow(c1y,2)) - 14 * (c1y * c2x + c1x * c2y) * etax + 10 * c3y * pow(etax,2)) * etay -
	  2 * (5 * c1x * c2x + 12 * c1y * c2y - 5 * c3x * etax) * pow(etay,2) + 10 * c3y * pow(etay,3) +
	  2 * pow(c0y,2) * (-5 * c1x * c2x - 12 * c1y * c2y + 5 * c3x * etax + 15 * c3y * etay) +
	  c0y * (-7 * pow(c1x,2) * c1y - 7 * pow(c1y,3) + 14 * c1y * c2x * etax + 14 * c1x * c2y * etax - 10 * c3y * pow(etax,2) +
		 4 * (5 * c1x * c2x + 12 * c1y * c2y - 5 * c3x * etax) * etay - 30 * c3y * pow(etay,2)) -
	  2 * pow(c0x,2) * (12 * c1x * c2x + 5 * (c1y * c2y + c0y * c3y - 3 * c3x * etax - c3y * etay)) -
	  c0x * (7 * pow(c1x,3) + c1x * (7 * pow(c1y,2) + 14 * c0y * c2y - 48 * c2x * etax - 14 * c2y * etay) +
		 2 * (7 * c0y * c1y * c2x + 5 * pow(c0y,2) * c3x - 10 * c1y * c2y * etax + 15 * c3x * pow(etax,2) - 7 * c1y * c2x * etay +
			10 * c3y * etax * etay + 5 * c3x * pow(etay,2) - 10 * c0y * (c3y * etax + c3x * etay)))) / 40.,
   (-6 * pow(c1x,4) - 6 * pow(c1y,4) - 4 * (12 * c0x * c0y * c2x * c2y + pow(c0x,2) * (11 * pow(c2x,2) + 5 * pow(c2y,2)) +
		 pow(c0y,2) * (5 * pow(c2x,2) + 11 * pow(c2y,2))) +
	  8 * (11 * c0x * pow(c2x,2) + 6 * c0y * c2x * c2y + 5 * c0x * pow(c2y,2)) * etax -
	  4 * (11 * pow(c2x,2) + 5 * pow(c2y,2)) * pow(etax,2) +
	  8 * (c0y * (5 * pow(c2x,2) + 11 * pow(c2y,2)) + 6 * c2x * c2y * (c0x - etax)) * etay -
	  4 * (5 * pow(c2x,2) + 11 * pow(c2y,2)) * pow(etay,2) -
	  5 * c1x * (8 * pow(c0y,2) * c3x + (11 * c1y * c2y + 19 * c3x * (c0x - etax)) * (c0x - etax) +
		 11 * c0y * (c1y * c2x + c0x * c3y - c3y * etax) - 16 * c0y * c3x * etay - 11 * (c1y * c2x + c0x * c3y - c3y * etax) * etay +
		 8 * c3x * pow(etay,2)) - 5 * c1y * (8 * pow(c0x,2) * c3y + 19 * pow(c0y,2) * c3y - 11 * c0y * c3x * etax - 16 * c0x * c3y * etax +
		 8 * c3y * pow(etax,2) + 11 * c0x * c3x * (c0y - etay) - 38 * c0y * c3y * etay + 11 * c3x * etax * etay + 19 * c3y * pow(etay,2)) +
	  pow(c1x,2) * (-12 * pow(c1y,2) + 79 * c2x * (-c0x + etax) + 24 * c2y * (-c0y + etay)) +
	  pow(c1y,2) * (24 * c2x * (-c0x + etax) + 79 * c2y * (-c0y + etay))) / 120.,
   (-98 * pow(c1x,3) * c2x - 7 * pow(c0y,2) * (25 * c2x * c3x + 53 * c2y * c3y) -
	  7 * (14 * pow(c1y,3) * c2y + 28 * c0x * c1y * c2x * c2y + 14 * c0x * pow(c1y,2) * c3x + pow(c0x,2) * (53 * c2x * c3x + 25 * c2y * c3y)) +
	  14 * (14 * c1y * c2x * c2y + 7 * pow(c1y,2) * c3x + 53 * c0x * c2x * c3x + 25 * c0x * c2y * c3y) * etax -
	  7 * (53 * c2x * c3x + 25 * c2y * c3y) * pow(etax,2) +
	  2 * (2 * c1y * (30 * pow(c2x,2) + 79 * pow(c2y,2)) + 169 * pow(c1y,2) * c3y + 98 * (c2y * c3x + c2x * c3y) * (c0x - etax)) * etay -
	  7 * (25 * c2x * c3x + 53 * c2y * c3y) * pow(etay,2) -
	  2 * c0y * (2 * c1y * (30 * pow(c2x,2) + 79 * pow(c2y,2)) + 169 * pow(c1y,2) * c3y + 98 * (c2y * c3x + c2x * c3y) * (c0x - etax) -
		 7 * (25 * c2x * c3x + 53 * c2y * c3y) * etay) + pow(c1x,2) * (-98 * c1y * c2y + 338 * c3x * (-c0x + etax) + 98 * c3y * (-c0y + etay)) -
	  2 * c1x * (49 * pow(c1y,2) * c2x + 2 * (79 * c0x * pow(c2x,2) + 49 * c0y * c2x * c2y + 30 * c0x * pow(c2y,2) - 79 * pow(c2x,2) * etax -
			30 * pow(c2y,2) * etax - 49 * c2x * c2y * etay) + 120 * c1y * (c0y * c3x + c0x * c3y - c3y * etax - c3x * etay))) / 420.,
   (-4 * pow(c1y,2) * (19 * pow(c2x,2) + 54 * pow(c2y,2)) - 152 * pow(c1x,3) * c3x - 152 * pow(c1y,3) * c3y -
	  4 * pow(c1x,2) * (54 * pow(c2x,2) + 19 * (pow(c2y,2) + 2 * c1y * c3y)) -
	  4 * (38 * c0x * c2x * (pow(c2x,2) + pow(c2y,2)) + 70 * c0x * c0y * c3x * c3y +
		 35 * pow(c0x,2) * (2 * pow(c3x,2) + pow(c3y,2)) +
		 c0y * (38 * c2y * (pow(c2x,2) + pow(c2y,2)) + 35 * c0y * (pow(c3x,2) + 2 * pow(c3y,2)))) +
	  8 * (19 * c2x * (pow(c2x,2) + pow(c2y,2)) + 35 * (c0y * c3x * c3y + c0x * (2 * pow(c3x,2) + pow(c3y,2)))) * etax -
	  140 * (2 * pow(c3x,2) + pow(c3y,2)) * pow(etax,2) +
	  8 * (19 * c2y * (pow(c2x,2) + pow(c2y,2)) + 35 * (c0y * (pow(c3x,2) + 2 * pow(c3y,2)) + c3x * c3y * (c0x - etax))) * etay -
	  140 * (pow(c3x,2) + 2 * pow(c3y,2)) * pow(etay,2) -
	  c1x * (280 * c1y * c2x * c2y + 152 * pow(c1y,2) * c3x + 969 * c0x * c2x * c3x + 304 * c0y * c2y * c3x + 280 * c0y * c2x * c3y +
		 385 * c0x * c2y * c3y - 969 * c2x * c3x * etax - 385 * c2y * c3y * etax - 8 * (38 * c2y * c3x + 35 * c2x * c3y) * etay) +
	  c1y * (-(c0y * (385 * c2x * c3x + 969 * c2y * c3y)) - 8 * (35 * c2y * c3x + 38 * c2x * c3y) * (c0x - etax) +
		 (385 * c2x * c3x + 969 * c2y * c3y) * etay)) / 560.,
   (-3 * pow(c1x,2) * (289 * c2x * c3x + 105 * c2y * c3y) - 3 * pow(c1y,2) * (105 * c2x * c3x + 289 * c2y * c3y) -
	  6 * (c0x * (151 * pow(c2x,2) * c3x + 46 * pow(c2y,2) * c3x + 105 * c2x * c2y * c3y) +
		 c0y * (105 * c2x * c2y * c3x + 46 * pow(c2x,2) * c3y + 151 * pow(c2y,2) * c3y)) +
	  6 * (151 * pow(c2x,2) * c3x + 46 * pow(c2y,2) * c3x + 105 * c2x * c2y * c3y) * etax +
	  6 * (105 * c2x * c2y * c3x + 46 * pow(c2x,2) * c3y + 151 * pow(c2y,2) * c3y) * etay -
	  2 * c1x * (138 * pow(c2x,3) + 276 * c1y * c2y * c3x + 479 * c0x * pow(c3x,2) + 276 * c0y * c3x * c3y + 203 * c0x * pow(c3y,2) +
		 138 * c2x * (pow(c2y,2) + 2 * c1y * c3y) - 479 * pow(c3x,2) * etax - 203 * pow(c3y,2) * etax - 276 * c3x * c3y * etay) -
	  2 * c1y * (138 * c2y * (pow(c2x,2) + pow(c2y,2)) + c0y * (203 * pow(c3x,2) + 479 * pow(c3y,2)) +
		 276 * c3x * c3y * (c0x - etax) - (203 * pow(c3x,2) + 479 * pow(c3y,2)) * etay)) / 1008.,
   (-360 * pow(c2x,4) - 360 * pow(c2y,4) - 15 * pow(c2x,2) * (48 * pow(c2y,2) + 299 * c1x * c3x + 96 * c1y * c3y) -
	  15 * pow(c2y,2) * (96 * c1x * c3x + 299 * c1y * c3y) -
	  32 * (90 * c1x * c1y * c3x * c3y + pow(c1x,2) * (73 * pow(c3x,2) + 28 * pow(c3y,2)) +
		 pow(c1y,2) * (28 * pow(c3x,2) + 73 * pow(c3y,2))) -
	  7 * c2x * (435 * c1y * c2y * c3x + 691 * c0x * pow(c3x,2) + 435 * c1x * c2y * c3y + 435 * c0y * c3x * c3y + 256 * c0x * pow(c3y,2) -
		 691 * pow(c3x,2) * etax - 256 * pow(c3y,2) * etax - 435 * c3x * c3y * etay) -
	  7 * c2y * (c0y * (256 * pow(c3x,2) + 691 * pow(c3y,2)) + 435 * c3x * c3y * (c0x - etax) -
		 (256 * pow(c3x,2) + 691 * pow(c3y,2)) * etay)) / 5040.,
   (-51 * pow(c2x,3) * c3x - 51 * pow(c2x,2) * c2y * c3y - 51 * pow(c2y,3) * c3y -
	  2 * c1y * c2y * (28 * pow(c3x,2) + 79 * pow(c3y,2)) -
	  c2x * (51 * pow(c2y,2) * c3x + 158 * c1x * pow(c3x,2) + 102 * c1y * c3x * c3y + 56 * c1x * pow(c3y,2)) -
	  2 * (51 * c1x * c2y * c3x * c3y + 28 * c0x * c3x * (pow(c3x,2) + pow(c3y,2)) + 28 * c0y * c3y * (pow(c3x,2) + pow(c3y,2))) +
	  56 * c3x * (pow(c3x,2) + pow(c3y,2)) * etax + 56 * c3y * (pow(c3x,2) + pow(c3y,2)) * etay) / 168.,
   (-630 * c2x * c2y * c3x * c3y - 328 * (c1x * c3x + c1y * c3y) * (pow(c3x,2) + pow(c3y,2)) -
	  pow(c2x,2) * (479 * pow(c3x,2) + 164 * pow(c3y,2)) - pow(c2y,2) * (164 * pow(c3x,2) + 479 * pow(c3y,2))) / 1008.,
   (-47 * (c2x * c3x + c2y * c3y) * (pow(c3x,2) + pow(c3y,2))) / 144.,-pow(pow(c3x,2) + pow(c3y,2),2) / 12. };
		Iy2t0 = valuesIy2[0];
		Iy2t1 = valuesIy2[1];
		Iy2t2 = valuesIy2[2];
		Iy2t3 = valuesIy2[3];
		Iy2t4 = valuesIy2[4];
		Iy2t5 = valuesIy2[5];
		Iy2t6 = valuesIy2[6];
		Iy2t7 = valuesIy2[7];
		Iy2t8 = valuesIy2[8];
		Iy2t9 = valuesIy2[9];
		Iy2t10 = valuesIy2[10];
		Iy2t11 = valuesIy2[11];
		Iy2t12 = valuesIy2[12];
		Iy2t13 = valuesIy2[13];
		Iy2t14 = valuesIy2[14];
	}

	double It0Item = 0.5 * log(pow(c0x + c1x + c2x + c3x - etax, 2) + pow(c0y + c1y + c2y + c3y - etay, 2));
	double It1Item = 0.5 * log(pow(c0x + c1x + c2x + c3x - etax, 2) + pow(c0y + c1y + c2y + c3y - etay, 2));
	double It2Item = 0.5 * log(pow(c0x + c1x + c2x + c3x - etax, 2) + pow(c0y + c1y + c2y + c3y - etay, 2));
	double Ix0Item = ((14 * c1x * c2y - 3 * c2y * c3x - 42 * c0y * (5 * c1x + 2 * c2x + c3x) + 12 * c1x * c3y + 3 * c2x * c3y + 42 * c0x * (5 * c1y + 2 * c2y + c3y) -
		84 * c2y * etax - 42 * c3y * etax - 2 * c1y * (7 * c2x + 6 * c3x + 105 * etax) + 42 * (5 * c1x + 2 * c2x + c3x) * etay) *
		(-1 + log(pow(c0x + c1x + c2x + c3x - etax, 2) + pow(c0y + c1y + c2y + c3y - etay, 2)))) / 840.;
	double Ix1Item = ((14 * c1x * c2y - 5 * c2y * c3x - 14 * c0y * (5 * c1x + 4 * c2x + 3 * c3x) + 16 * c1x * c3y + 5 * c2x * c3y + 14 * c0x * (5 * c1y + 4 * c2y + 3 * c3y) -
		56 * c2y * etax - 42 * c3y * etax - 2 * c1y * (7 * c2x + 8 * c3x + 35 * etax) + 14 * (5 * c1x + 4 * c2x + 3 * c3x) * etay) *
		(-1 + log(pow(c0x + c1x + c2x + c3x - etax, 2) + pow(c0y + c1y + c2y + c3y - etay, 2)))) / 280.;
	double Ix2Item = -((70 * c0y * c1x - 70 * c0x * c1y + 28 * c1y * c2x + 40 * c1y * c3x + 15 * c2y * c3x + 84 * c0y * (c2x + c3x) - 15 * c2x * c3y -
		84 * c0x * (c2y + c3y) + 70 * c1y * etax + 84 * c2y * etax + 84 * c3y * etax - 84 * (c2x + c3x) * etay -
		2 * c1x * (14 * c2y + 20 * c3y + 35 * etay)) * (-1 +
			log(pow(c0x + c1x + c2x + c3x - etax, 2) + pow(c0y + c1y + c2y + c3y - etay, 2)))) / 280.;
	double Iy0Item = ((420 * pow(c0x, 2) + 420 * pow(c0y, 2) + 42 * pow(c1x, 2) + 42 * pow(c1y, 2) + 42 * c1x * c2x + 12 * pow(c2x, 2) + 42 * c1y * c2y +
		12 * pow(c2y, 2) + 24 * c1x * c3x + 15 * c2x * c3x + 5 * pow(c3x, 2) + 24 * c1y * c3y + 15 * c2y * c3y + 5 * pow(c3y, 2) +
		42 * c0x * (5 * c1x + 2 * c2x + c3x - 20 * etax) - 42 * (5 * c1x + 2 * c2x + c3x) * etax + 420 * pow(etax, 2) +
		42 * c0y * (5 * c1y + 2 * c2y + c3y - 20 * etay) - 42 * (5 * c1y + 2 * c2y + c3y) * etay + 420 * pow(etay, 2)) *
		(-2 + log(pow(c0x + c1x + c2x + c3x - etax, 2) + pow(c0y + c1y + c2y + c3y - etay, 2)))) / 2520.;
	double Iy1Item = ((420 * pow(c0x, 2) + 420 * pow(c0y, 2) + 126 * pow(c1x, 2) + 126 * pow(c1y, 2) + 168 * c1x * c2x + 60 * pow(c2x, 2) +
		168 * c1y * c2y + 60 * pow(c2y, 2) + 120 * c1x * c3x + 90 * c2x * c3x + 35 * pow(c3x, 2) + 120 * c1y * c3y + 90 * c2y * c3y +
		35 * pow(c3y, 2) + 84 * c0x * (5 * c1x + 3 * c2x + 2 * c3x - 10 * etax) - 84 * (5 * c1x + 3 * c2x + 2 * c3x) * etax + 420 * pow(etax, 2) +
		84 * c0y * (5 * c1y + 3 * c2y + 2 * c3y - 10 * etay) - 84 * (5 * c1y + 3 * c2y + 2 * c3y) * etay + 420 * pow(etay, 2)) *
		(-2 + log(pow(c0x + c1x + c2x + c3x - etax, 2) + pow(c0y + c1y + c2y + c3y - etay, 2)))) / 2520.;
	double Iy2Item = (((pow(c2x, 2) + pow(c2y, 2) + 2 * c1x * c3x + 2 * c1y * c3y) / 7. + (c2x * c3x + c2y * c3y) / 4. + (pow(c3x, 2) + pow(c3y, 2)) / 9. +
		(pow(c0x - etax, 2) + pow(c0y - etay, 2)) / 3. + (c0x * c1x + c0y * c1y - c1x * etax - c1y * etay) / 2. +
		(pow(c1x, 2) + pow(c1y, 2) + 2 * c0x * c2x + 2 * c0y * c2y - 2 * c2x * etax - 2 * c2y * etay) / 5. +
		(c1x * c2x + c1y * c2y + c0x * c3x + c0y * c3y - c3x * etax - c3y * etay) / 3.) *
		(-2 + log(pow(c0x + c1x + c2x + c3x - etax, 2) + pow(c0y + c1y + c2y + c3y - etay, 2)))) / 2.;
	Ic0 = (Ic0t0 * F0 + Ic0t1 * F1 + Ic0t2 * F2 + Ic0t3 * F3 + Ic0t4 * F4 + Ic0t5 * F5 + Ic0t6 * F6 + Ic0t7 * F7);
	Ic1 = (Ic1t0 * F0 + Ic1t1 * F1 + Ic1t2 * F2 + Ic1t3 * F3 + Ic1t4 * F4 + Ic1t5 * F5 + Ic1t6 * F6 + Ic1t7 * F7);
	Ic2 = (Ic2t0 * F0 + Ic2t1 * F1 + Ic2t2 * F2 + Ic2t3 * F3 + Ic2t4 * F4 + Ic2t5 * F5 + Ic2t6 * F6 + Ic2t7 * F7);
	It0 = (It0t0 * F0 + It0t1 * F1 + It0t2 * F2 + It0t3 * F3 + It0t4 * F4 + It0t5 * F5 + It0t6 * F6 + It0t7 * F7 + It0t8 * F8) + It0Item / (-2 * M_PI);
	It1 = (It1t0 * F0 + It1t1 * F1 + It1t2 * F2 + It1t3 * F3 + It1t4 * F4 + It1t5 * F5 + It1t6 * F6 + It1t7 * F7 + It1t8 * F8) + It1Item / (-2 * M_PI);
	It2 = (It2t0 * F0 + It2t1 * F1 + It2t2 * F2 + It2t3 * F3 + It2t4 * F4 + It2t5 * F5 + It2t6 * F6 + It2t7 * F7 + It2t8 * F8) + It2Item / (-2 * M_PI);
	Ix0 = -(Ix0t0 * F0 + Ix0t1 * F1 + Ix0t2 * F2 + Ix0t3 * F3 + Ix0t4 * F4 + Ix0t5 * F5 + Ix0t6 * F6 + Ix0t7 * F7 + Ix0t8 * F8 + Ix0t9 * F9
		+ Ix0t10 * F10 + Ix0t11 * F11 + Ix0t12 * F12 + Ix0t13 * F13) + Ix0Item / (8 * M_PI);
	Ix1 = -(Ix1t0 * F0 + Ix1t1 * F1 + Ix1t2 * F2 + Ix1t3 * F3 + Ix1t4 * F4 + Ix1t5 * F5 + Ix1t6 * F6 + Ix1t7 * F7 + Ix1t8 * F8 + Ix1t9 * F9
		+ Ix1t10 * F10 + Ix1t11 * F11 + Ix1t12 * F12 + Ix1t13 * F13) + Ix1Item / (8 * M_PI);
	Ix2 = -(Ix2t0 * F0 + Ix2t1 * F1 + Ix2t2 * F2 + Ix2t3 * F3 + Ix2t4 * F4 + Ix2t5 * F5 + Ix2t6 * F6 + Ix2t7 * F7 + Ix2t8 * F8 + Ix2t9 * F9
		+ Ix2t10 * F10 + Ix2t11 * F11 + Ix2t12 * F12 + Ix2t13 * F13) + Ix1Item / (8 * M_PI);
	Iy0 = -(Iy0t0 * F0 + Iy0t1 * F1 + Iy0t2 * F2 + Iy0t3 * F3 + Iy0t4 * F4 + Iy0t5 * F5 + Iy0t6 * F6 + Iy0t7 * F7 + Iy0t8 * F8 + Iy0t9 * F9
		+ Iy0t10 * F10 + Iy0t11 * F11 + Iy0t12 * F12 + Iy0t13 * F13 + Iy0t14 * F14) + Iy0Item / (-8 * M_PI);
	Iy1 = -(Iy1t0 * F0 + Iy1t1 * F1 + Iy1t2 * F2 + Iy1t3 * F3 + Iy1t4 * F4 + Iy1t5 * F5 + Iy1t6 * F6 + Iy1t7 * F7 + Iy1t8 * F8 + Iy1t9 * F9
		+ Iy1t10 * F10 + Iy1t11 * F11 + Iy1t12 * F12 + Iy1t13 * F13 + Iy1t14 * F14) + Iy1Item / (-8 * M_PI);
	Iy2 = -(Iy2t0 * F0 + Iy2t1 * F1 + Iy2t2 * F2 + Iy2t3 * F3 + Iy2t4 * F4 + Iy2t5 * F5 + Iy2t6 * F6 + Iy2t7 * F7 + Iy2t8 * F8 + Iy2t9 * F9
		+ Iy2t10 * F10 + Iy2t11 * F11 + Iy2t12 * F12 + Iy2t13 * F13 + Iy2t14 * F14) + Iy2Item / (-8 * M_PI);

	Ie1 = It1 / 3;
	Ie2 = It2 / 3;
	values[0] = Ic0 + Ic0_1;
	values[1] = Ic1;
	values[2] = Ic2;
	values[3] = It0;
	values[4] = It1;
	values[5] = It2;
	values[6] = Ix0 + Ix0_1;
	values[7] = Ix1;
	values[8] = Ix2;
	values[9] = Iy0;
	values[10] = Iy1;
	values[11] = Iy2;
	values[12] = values[0];
	values[13] = values[1];
	values[14] = values[2];
	values[15] = It0 / (3);
	values[16] = Ie1;
	values[17] = Ie2;
}


//重新计算两次情形下的系数的计算，与之前的相比，改变了导数那一项的计算方式，现在是与每条边上的两个切方向相乘
//再次更新，我希望在value的最后加上4个导数的计算。
void CalBiharmonicTwiceBasisNewDer(OpenMesh::Vec2d& v0, OpenMesh::Vec2d& v1, OpenMesh::Vec2d& v2, OpenMesh::Vec2d& eta,
	std::vector<double>& values) {
	//values.resize(12);
	values.resize(28);
	//v0 = OpenMesh::Vec2d(0, 2); v1 = OpenMesh::Vec2d(0, 0); v2 = OpenMesh::Vec2d(2, 0); eta = OpenMesh::Vec2d(1, 1);
	OpenMesh::Vec2d ei, ui, xiyi;
	double ci, L1i, L2i, Ai, xi, yi, Ic0, Ic0_1, Ic1, It0_1, It0, It1, It1New, It2New,
		Ix0_1, Ix0, Ix1, Iy0, Iy1, Ie1, hatphiBH_1, hatphiH, hatphiBH;
	double Ic0dx, Ic0dy, Ic0_1dx, Ic0_1dy, Ic1dx, Ic1dy, It0dx, It0dy, It0_1dx, It0_1dy, It1dx, It1dy, Ix0dx, Ix0dy, Ix0_1dx, Ix0_1dy, Ix1dx, Ix1dy,
		Iy0dx, Iy0dy, Iy1dx, Iy1dy;
	Eigen::Matrix2d RotateM;
	{
		//计算前一个phi的值
		ei = v1 - v0;
		ci = ei.norm();
		RotateM << ei[0], -ei[1],
			ei[1], ei[0];
		RotateM /= (ci);
		ui = eta - v0;
		xiyi = OpenMesh::Vec2d(ui[0] * ei[0] + ui[1] * ei[1], ui[1] * ei[0] - ui[0] * ei[1]);
		xiyi = xiyi / ci;
		xi = xiyi[0];
		yi = xiyi[1];
		L1i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1]);
		L2i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1] + ci * ci - 2 * ci * xiyi[0]);
		Ai = atan(xiyi[0] / xiyi[1]) + atan((ci - xiyi[0]) / xiyi[1]);
		Ic0_1 = ((xi - yi) * (xi + yi) * Ai + yi * (ci + (xi) * (L2i - L1i))) / (2 * ci * ci * M_PI);
		It0_1 = 2 * (-ci * (ci + 2 * xi) + 4 * xi * yi * Ai + (ci * ci - xi * xi + yi * yi) * L2i + (xi - yi) * (xi + yi) * L1i) / (-8 * ci * ci * M_PI);
		Ix0_1 = yi * (ci * ci * ci + 1. / 3 * (
			2 * ci * ci * ci + 3 * ci * ci * xi + 6 * ci * xi * xi - 6 * ci * yi * yi - 6 * (3 * xi * xi * yi - yi * yi * yi) * Ai + (9 * xi * yi * yi - 3 * xi * xi * xi) * (L1i - L2i) - 3 * ci * ci * ci * L2i)
			) / (-24 * ci * ci * M_PI);
		Ic0_1dx = (2 * xi * Ai + yi * (-ci * ci / ((ci - xi) * (ci - xi) + yi * yi) + L2i - L1i)) / (2 * ci * ci * M_PI);
		Ic0_1dy = (ci * ci * ci - 3 * ci * ci * xi + 2 * ci * xi * xi + 2 * ci * yi * yi - 2 * yi * (ci * ci - 2 * ci * xi + xi * xi + yi * yi) * Ai +
			(-ci * ci * xi + 2 * ci * xi * xi - xi * xi * xi - xi * yi * yi) * (L1i - L2i)) / (2 * ci * ci * M_PI * (ci * ci - 2 * ci * xi + xi * xi + yi * yi));
		Ix0_1dx = (1.0 / (8 * ci * ci * M_PI)) * yi * (-ci * (ci + 2 * xi) + 4 * xi * yi * (Ai)-(xi - yi) * (xi + yi) * (L2i - L1i));
		Ix0_1dy = (1.0 / (72 * ci * ci * M_PI)) * (-5 * ci * ci * ci - 3 * ci * ci * xi - 6 * ci * xi * xi + 24 * ci * yi * yi +
			12 * (3 * xi * xi * yi - 2 * yi * yi * yi) * (Ai)+(3 * xi * xi * xi - 27 * xi * yi * yi) * L1i + (-3 * xi * xi * xi + 27 * xi * yi * yi + 3 * ci * ci * ci) * L2i);


		Eigen::Vector2d tiduc0_1(Ic0_1dx, Ic0_1dy);
		Eigen::Vector2d tidux0_1(Ix0_1dx, Ix0_1dy);
		auto real_tiduc0_1 = RotateM * tiduc0_1;
		auto real_tidux0_1 = RotateM * tidux0_1;
		Ic0_1dx = real_tiduc0_1[0];
		Ic0_1dy = real_tiduc0_1[1];
		Ix0_1dx = real_tidux0_1[0];
		Ix0_1dy = real_tidux0_1[1];
	}
	{


		ei = v2 - v1;
		ci = ei.norm();
		ui = eta - v1;
		xiyi = OpenMesh::Vec2d(ui[0] * ei[0] + ui[1] * ei[1], ui[1] * ei[0] - ui[0] * ei[1]);
		xiyi = xiyi / ci;
		xi = xiyi[0];
		yi = xiyi[1];
		L1i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1]);
		L2i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1] + ci * ci - 2 * ci * xiyi[0]);
		Ai = atan(xiyi[0] / xiyi[1]) + atan((ci - xiyi[0]) / xiyi[1]);
		Ic0 = ((ci * ci - 2 * ci * xi + xi * xi - yi * yi) * Ai + yi * (ci + (xi - ci) * (L2i - L1i))) / (2 * ci * ci * M_PI);
		Ic1 = (2 * (ci * xi - xi * xi + yi * yi) * Ai + yi * (-2 * ci + (ci - 2 * xi) * (L2i - L1i))) / (2 * ci * ci * M_PI);
		It0 = 2 * (ci * (-3 * ci + 2 * xi) + 4 * (ci - xi) * yi * Ai + (ci - xi - yi) * (ci - xi + yi) * L2i + (2 * ci * xi - xi * xi + yi * yi) * L1i) / (8 * ci * ci * M_PI);
		It1 = 2 * (ci * ci - 2 * ci * xi - 2 * (ci - 2 * xi) * yi * Ai + (xi * xi - yi * yi - ci * xi) * (L1i - L2i)) / (4 * ci * ci * M_PI);
		It1New = -It0;
		It2New = 2 * (-ci * (ci + 2 * xi) + 4 * xi * yi * Ai + (ci * ci - xi * xi + yi * yi) * L2i + (xi - yi) * (xi + yi) * L1i) / (-8 * ci * ci * M_PI);
		Ix0 = yi * (-14 * ci * ci * ci + 15 * ci * ci * xi - 6 * ci * xi * xi + 6 * ci * yi * yi - 6 * yi * (-3 * ci * ci + 6 * ci * xi - 3 * xi * xi + yi * yi) * Ai
			+ (9 * ci * ci * xi - 9 * ci * xi * xi + 3 * xi * xi * xi + 9 * ci * yi * yi - 9 * xi * yi * yi) * (L1i - L2i) + 3 * ci * ci * ci * L2i) / (72 * ci * ci * M_PI);
		Ix1 = yi * (-8 * ci * ci * ci - 12 * ci * ci * xi + 12 * ci * xi * xi - 12 * ci * yi * yi + 12 * yi * (3 * ci * xi - 3 * xi * xi + yi * yi) * Ai
			+ (9 * ci * xi * xi - 6 * xi * xi * xi - 9 * ci * yi * yi + 18 * xi * yi * yi) * (L1i - L2i) + 3 * ci * ci * ci * L2i) / (72 * ci * ci * M_PI);
		Iy0 = (-19 * ci * ci * ci * ci + 76 * ci * ci * ci * xi - 114 * ci * ci * xi * xi + 12 * ci * xi * xi * xi - 150 * ci * ci * yi * yi + 60 * ci * xi * yi * yi +
			96 * (ci - xi) * yi * yi * yi * Ai + (24 * ci * xi * xi * xi - 6 * xi * xi * xi * xi + 72 * ci * xi * yi * yi - 36 * xi * xi * yi * yi + 18 * yi * yi * yi * yi) * (L1i - L2i)
			+ (6 * ci * ci * ci * ci + 36 * ci * ci * xi * xi - 24 * ci * ci * ci * xi + 36 * ci * ci * yi * yi) * L2i) / (-1152 * ci * ci * M_PI);

		Iy1 = (-45 * ci * ci * ci * ci + 116 * ci * ci * ci * xi - 78 * ci * ci * xi * xi - 12 * ci * xi * xi * xi - 90 * ci * ci * yi * yi - 60 * ci * xi * yi * yi +
			96 * xi * yi * yi * yi * Ai + (6 * xi * xi * xi * xi + 36 * xi * xi * yi * yi - 18 * yi * yi * yi * yi) * (L1i - L2i)
			+ (18 * ci * ci * ci * ci - 48 * ci * ci * ci * xi + 36 * ci * ci * xi * xi + 36 * ci * ci * yi * yi) * L2i) / (-1152 * ci * ci * M_PI);
		Ie1 = (-ci * (ci + 2 * xi) + 4 * xi * yi * Ai + (ci * ci - xi * xi + yi * yi) * L2i + (xi - yi) * (xi + yi) * L1i) / (-8 * ci * ci * M_PI);

		Ic0dx = yi * (ci * ci / (xi * xi + yi * yi) - 2 * (ci - xi) / yi * (Ai)+L2i - L1i) / (2 * ci * ci * M_PI);
		Ic0dy = (-ci * ci * xi + 2 * ci * xi * xi + 2 * ci * yi * yi - 2 * yi * (xi * xi + yi * yi) * Ai +
			(ci * xi * xi - xi * xi * xi + ci * yi * yi - xi * yi * yi) * (L1i - L2i)) / (2 * ci * ci * M_PI * (xi * xi + yi * yi));
		Ic1dx = ((ci - 2 * xi) * Ai + yi * (L1i - L2i)) / (ci * ci * M_PI);
		Ic1dy = (-4 * ci + 4 * yi * Ai + (ci - 2 * xi) * (L2i - L1i)) / (2 * ci * ci * M_PI);
		It0dx = -(ci - yi * Ai + (ci - xi) / 2 * (L1i - L2i)) / (2 * ci * ci * M_PI);//加了负号改正为new
		It0dy = -(2 * (ci - xi) * Ai + yi * (L1i - L2i)) / (4 * ci * ci * M_PI);//加了负号改正为new
		It1dx = (2 * ci - 2 * yi * Ai + xi * L2i - xi * L1i) / (4 * ci * ci * M_PI);//yj改正为new
		It1dy = -((yi * ((xi * (Ai)) / yi + 0.5 * (L2i - L1i))) / (2 * ci * ci * M_PI));//yj改正为new
		Ix0dx = (ci * (3 * ci - 2 * xi) + 4 * (-ci + xi) * yi * Ai - (ci - xi - yi) * (ci - xi + yi) * (L2i - L1i)) * (yi / (8 * ci * ci * M_PI));
		Ix0dy = (-14 * ci * ci * ci + 15 * ci * ci * xi - 6 * ci * xi * xi + 24 * ci * yi * yi + 12 * yi * (3 * ci * ci - 6 * ci * xi + 3 * xi * xi - 2 * yi * yi) * Ai
			+ (9 * ci * ci * xi - 9 * ci * xi * xi + 3 * xi * xi * xi + 27 * ci * yi * yi - 27 * xi * yi * yi) * (L1i - L2i) + 3 * ci * ci * ci * L2i) / (72 * ci * ci * M_PI);

		Ix1dx = (1.0 / (2 * ci * ci * M_PI)) * yi * (-0.5 * ci * (ci - 2 * xi) +
			(ci - 2 * xi) * yi * (Ai)-0.5 * ((ci - xi) * xi + yi * yi) * (L2i - L1i));
		Ix1dy = (1.0 / (2 * ci * ci * M_PI)) * yi * (-0.5 * ci * (ci - 2 * xi) +
			(ci - 2 * xi) * yi * (atan((ci - xi) / yi) + atan(xi / yi)) - 0.5 * ((ci - xi) * xi + yi * yi) * (L2i - L1i));
		Iy0dx = (1.0 / (144 * ci * M_PI)) * (-8 * ci * ci * ci + 24 * ci * ci * xi - 6 * ci * xi * xi - 12 * ci * yi * yi +
			12 * yi * yi * yi * (Ai)+(-9 * ci * xi * xi + 3 * xi * xi * xi - 9 * ci * yi * yi + 9 * xi * yi * yi) * L1i +
			(3 * ci * ci * ci - 9 * ci * ci * xi + 9 * ci * xi * xi - 3 * xi * xi * xi + 9 * ci * yi * yi - 9 * xi * yi * yi) * L2i);
		Iy0dy = -(1.0 / (16 * ci * M_PI)) * yi * (2 * ci * (-2 * ci + xi) + 4 * (ci - xi) * yi * (Ai)+
			(ci - xi - yi) * (ci - xi + yi) * L2i + (2 * ci * xi - xi * xi + yi * yi) * L1i);
		Iy1dx = (1.0 / (144 * ci * M_PI)) * (2 * ci * (-5 * ci * ci + 6 * ci * xi + 3 * xi * xi + 6 * yi * yi) - 12 * yi * yi * yi * (Ai)+
			3 * ((ci - xi) * (ci - xi) * (2 * ci + xi) + 3 * xi * yi * yi) * L2i - 3 * xi * (xi * xi + 3 * yi * yi) * L1i);
		Iy1dy = (1.0 / (16 * ci * M_PI)) * yi * (ci * ci + ci * (ci + 2 * xi) - 4 * xi * yi * (Ai)-
			(ci * ci - xi * xi + yi * yi) * L2i - (xi - yi) * (xi + yi) * L1i);

		RotateM << ei[0], -ei[1],
			ei[1], ei[0];
		RotateM /= (ci);//旋转矩阵


		Eigen::Vector2d tiduc0(Ic0dx, Ic0dy);
		Eigen::Vector2d tiduc1(Ic1dx, Ic1dy);
		Eigen::Vector2d tidut0(It0dx, It0dy);
		Eigen::Vector2d tidut1(It1dx, It1dy);
		Eigen::Vector2d tidux0(Ix0dx, Ix0dy);
		Eigen::Vector2d tidux1(Ix1dx, Ix1dy);
		Eigen::Vector2d tiduy0(Iy0dx, Iy0dy);
		Eigen::Vector2d tiduy1(Iy1dx, Iy1dy);
		auto real_tiduc0 = RotateM * tiduc0;
		auto real_tiduc1 = RotateM * tiduc1;
		auto real_tidut0 = RotateM * tidut0;
		auto real_tidut1 = RotateM * tidut1;
		auto real_tidux0 = RotateM * tidux0;
		auto real_tidux1 = RotateM * tidux1;
		auto real_tiduy0 = RotateM * tiduy0;
		auto real_tiduy1 = RotateM * tiduy1;

		Ic0dx = real_tiduc0[0]; Ic0dy = real_tiduc0[1];
		Ic1dx = real_tiduc1[0]; Ic1dy = real_tiduc1[1];
		It0dx = real_tidut0[0]; It0dy = real_tidut0[1];
		It1dx = real_tidut1[0]; It1dy = real_tidut1[1];
		Ix0dx = real_tidux0[0]; Ix0dy = real_tidux0[1];
		Ix1dx = real_tidux1[0]; Ix1dy = real_tidux1[1];
		Iy0dx = real_tiduy0[0]; Iy0dy = real_tiduy0[1];
		Iy1dx = real_tiduy1[0]; Iy1dy = real_tiduy1[1];
	}


	values[0] = Ic0 + Ic0_1;
	values[1] = Ic1;
	values[2] = It1New;//
	values[3] = It2New;//
	values[4] = Ix0 + Ix0_1;
	values[5] = Ix1;
	values[6] = Iy0;
	values[7] = Iy1;
	values[8] = Ic0 + Ic0_1;
	values[9] = Ic1;
	values[10] = -It0 / 2;//要除以2吗
	values[11] = Ie1;
	values[12] = Ic0dx + Ic0_1dx;
	values[13] = Ic0dy + Ic0_1dy;
	values[14] = Ic1dx;
	values[15] = Ic1dy;
	values[16] = 2 * It0dx;
	values[17] = 2 * It0dy;
	values[18] = 2 * It1dx;
	values[19] = 2 * It1dy;
	values[20] = Ix0dx + Ix0_1dx;
	values[21] = Ix0dy + Ix0_1dy;
	values[22] = Ix1dx;
	values[23] = Ix1dy;
	values[24] = Iy0dx;
	values[25] = Iy0dy;
	values[26] = Iy1dx;
	values[27] = Iy1dy;
}


//重新计算两次情形下的系数的计算，与之前的相比，改变了导数那一项的计算方式，现在是与每条边上的两个切方向相乘
//再次更新，我希望在value的最后加上4个导数的计算。
void CalBiharmonicTwiceBasisNewDerBoundary(OpenMesh::Vec2d& v0, OpenMesh::Vec2d& v1, OpenMesh::Vec2d& v2, OpenMesh::Vec2d& eta,
	std::vector<double>& values, int signEdge) {
	//values.resize(12);
	values.resize(28);
	//v0 = OpenMesh::Vec2d(0, 2); v1 = OpenMesh::Vec2d(0, 0); v2 = OpenMesh::Vec2d(2, 0); eta = OpenMesh::Vec2d(1, 1);
	OpenMesh::Vec2d ei, ui, xiyi;
	double ci, L1i, L2i, Ai, xi, yi, Ic0, Ic0_1, Ic1, It0_1, It0, It1,It1New,It2New,
		Ix0_1, Ix0, Ix1, Iy0, Iy1, Ie1, hatphiBH_1, hatphiH, hatphiBH;
	double Ic0dx, Ic0dy, Ic0_1dx, Ic0_1dy, Ic1dx, Ic1dy, It0dx, It0dy, It0_1dx, It0_1dy, It1dx, It1dy, Ix0dx, Ix0dy, Ix0_1dx, Ix0_1dy, Ix1dx, Ix1dy, 
		Iy0dx, Iy0dy, Iy1dx, Iy1dy;
	Eigen::Matrix2d RotateM;
	{
		if (signEdge <= 0 && signEdge >= -2) {//此时eta在前一条边上，只考虑yi=0，并且0=<xi<ci-xi
			ei = v1 - v0;
			ci = ei.norm();
			RotateM << ei[0], -ei[1],
				ei[1], ei[0];
			RotateM /= (ci);
			ui = eta - v0;
			xiyi = OpenMesh::Vec2d(ui[0] * ei[0] + ui[1] * ei[1], ui[1] * ei[0] - ui[0] * ei[1]);
			xiyi = xiyi / ci;
			xi = xiyi[0];
			yi = xiyi[1];
			Ic0_1 = xi * xi / (2 * ci * ci);
			Ix0_1 = 0;
			Ic0_1dx = xi / (ci * ci);
			Ix0_1dx = 0;
			if (signEdge == -1) {//eta在v0上
				Ic0_1dy = 1. / (2 * ci * M_PI);
				Ix0_1dy = (ci * (-5 + 6 * log(ci))) / (72 * M_PI);
				
			}
			else if (signEdge == 0)
			{//eta在v1上
				Ic0_1dy = 0;
				Ix0_1dy = (ci * (-7 + 3 * log(ci))) / (36 * M_PI);
			}
			else {//eta在线段上
				Ic0_1dy = (ci * (ci - 2 * xi) +xi * (-ci + xi) * (-log((ci - xi) * (ci - xi)) + log(xi * xi))) /(2 * ci * ci * M_PI * (ci - xi));
				Ix0_1dy = (-5 * ci * ci * ci - 3 * ci * ci * xi - 6 * ci * xi * xi +
					6 * xi * xi * xi * log(xi) + (3 * ci * ci * ci - 3 * xi * xi * xi) * log(ci * ci - 2 * ci * xi + xi * xi)) / (72 * ci * ci * M_PI);
			}
			/*std::cout <<"boundary" <<signEdge<< std::endl;
			std::cout << Ic0_1 << " " << Ix0_1 << " " << Ic0_1dx << " " << Ic0_1dy << " " << Ix0_1dx << " "<<Ix0_1dx << std::endl;*/
			
		}
		
		{//计算前一个phi的值
			ei = v1 - v0;
			ci = ei.norm();
			RotateM << ei[0], -ei[1],
				ei[1], ei[0];
			RotateM /= (ci);
			ui = eta - v0;
			xiyi = OpenMesh::Vec2d(ui[0] * ei[0] + ui[1] * ei[1], ui[1] * ei[0] - ui[0] * ei[1]);
			xiyi = xiyi / ci;
			xi = xiyi[0];
			yi = xiyi[1];
			L1i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1]);
			L2i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1] + ci * ci - 2 * ci * xiyi[0]);
			Ai = atan(xiyi[0] / xiyi[1]) + atan((ci - xiyi[0]) / xiyi[1]);
			Ic0_1 = ((xi - yi) * (xi + yi) * Ai + yi * (ci + (xi) * (L2i - L1i))) / (2 * ci * ci * M_PI);
			It0_1 = 2 * (-ci * (ci + 2 * xi) + 4 * xi * yi * Ai + (ci * ci - xi * xi + yi * yi) * L2i + (xi - yi) * (xi + yi) * L1i) / (-8 * ci * ci * M_PI);
			Ix0_1 = yi * (ci * ci * ci + 1. / 3 * (
				2 * ci * ci * ci + 3 * ci * ci * xi + 6 * ci * xi * xi - 6 * ci * yi * yi - 6 * (3 * xi * xi * yi - yi * yi * yi) * Ai + (9 * xi * yi * yi - 3 * xi * xi * xi) * (L1i - L2i) - 3 * ci * ci * ci * L2i)
				) / (-24 * ci * ci * M_PI);
			Ic0_1dx = (2 * xi * Ai + yi * (-ci * ci / ((ci - xi) * (ci - xi) + yi * yi) + L2i - L1i)) / (2 * ci * ci * M_PI);
			Ic0_1dy = (ci * ci * ci - 3 * ci * ci * xi + 2 * ci * xi * xi + 2 * ci * yi * yi - 2 * yi * (ci * ci - 2 * ci * xi + xi * xi + yi * yi) * Ai +
				(-ci * ci * xi + 2 * ci * xi * xi - xi * xi * xi - xi * yi * yi) * (L1i - L2i)) / (2 * ci * ci * M_PI * (ci * ci - 2 * ci * xi + xi * xi + yi * yi));
			Ix0_1dx = (1.0 / (8 * ci * ci * M_PI)) * yi * (-ci * (ci + 2 * xi) + 4 * xi * yi * (Ai)-(xi - yi) * (xi + yi) * (L2i - L1i));
			Ix0_1dy = (1.0 / (72 * ci * ci * M_PI)) * (-5 * ci * ci * ci - 3 * ci * ci * xi - 6 * ci * xi * xi + 24 * ci * yi * yi +
				12 * (3 * xi * xi * yi - 2 * yi * yi * yi) * (Ai)+(3 * xi * xi * xi - 27 * xi * yi * yi) * L1i + (-3 * xi * xi * xi + 27 * xi * yi * yi + 3 * ci * ci * ci) * L2i);
			/*std::cout << Ic0_1 << " " << Ix0_1 << " " << Ic0_1dx << " " << Ic0_1dy << " " << Ix0_1dx << " " << Ix0_1dx << std::endl;*/
		}
		Eigen::Vector2d tiduc0_1(Ic0_1dx, Ic0_1dy);
		Eigen::Vector2d tidux0_1(Ix0_1dx, Ix0_1dy);
		auto real_tiduc0_1 = RotateM * tiduc0_1;
		auto real_tidux0_1 = RotateM * tidux0_1;
		Ic0_1dx = real_tiduc0_1[0];
		Ic0_1dy = real_tiduc0_1[1];
		Ix0_1dx = real_tidux0_1[0];
		Ix0_1dy = real_tidux0_1[1];
	}
	{
		if (signEdge >= 0 && signEdge <= 2) {//在右边的边上
			ei = v2 - v1;
			ci = ei.norm();
			ui = eta - v1;
			xiyi = OpenMesh::Vec2d(ui[0] * ei[0] + ui[1] * ei[1], ui[1] * ei[0] - ui[0] * ei[1]);
			xiyi = xiyi / ci;
			xi = xiyi[0];
			yi = xiyi[1];
			Ic0 = (ci - xi) * (ci - xi) / (2 * ci * ci);
			Ic1 = (ci - xi) * xi / (ci * ci);
			Ix0 = 0;
			Ix1 = 0;
			
			Ic0dx = (-ci + xi) / (ci * ci);
			Ic1dx = (ci - 2 * xi) / (ci * ci);
			It0dy = -(ci - xi) / (2 * ci * ci);//加了-号
			It1dy = -xi / (2 * ci * ci);
			Ix0dx = 0;
			Ix1dx = 0;
			Iy0dy = 0;
			Iy1dy = 0;
			if (signEdge == 0) {//在v1上
				It1New = -(-3 + log(ci * ci)) / (8 * M_PI);
				It2New = (-1 + 2 * log(ci)) / (8 * M_PI);//wrong
				Iy0 = -((ci * ci * (-19 + 6 * log(ci * ci))) / (1152 * M_PI));
				Iy1= - ((ci * ci * (-5. + 4. * log(ci ))) / (128 * M_PI));
				Ie1 = (1 - 2 * log(ci)) / (8 * M_PI);
				Ic0dy = 0;
				Ic1dy=0;
				It0dx=0;
				It1dx = 1. / (2 * ci * M_PI);
				Ix0dy = ci * (-7 + 3 * log(ci )) / (36 * M_PI);
				Ix1dy = ci * (-8 + 3 * log(ci * ci)) / (72 * M_PI);
				Iy0dx= ci*ci * (-8 + 3 * log(ci * ci)) / (144 * M_PI);
				Iy1dx= ci * ci * (-5 + 6 * log(ci)) / (72 * M_PI);
			}
			else if (signEdge == 1) {//在v2上
				It1New = -(-1 + log(ci * ci)) / (8 * M_PI);
				It2New = (-3. + 2. * log(ci)) / (8 * M_PI);//wrong
				Iy0= -((ci * ci * (-5. + 2. * log(ci * ci))) / (128 * M_PI));
				Iy1 =- ((ci * ci * (-19. + 12. * log(ci))) / (1152 * M_PI));
				Ie1 = (3 - 2 * log(ci)) / (8 * M_PI);
				Ic0dy = 1. / (2 * ci * M_PI);
				Ic1dy=0;
				It0dx=- 1. / (2 * ci * M_PI);//加-号
				It1dx=0;
				Ix0dy = ci * (-5 + 3 * log(ci * ci)) / (72 * M_PI);
				Ix1dy = ci * (-4 + 3 * log(ci)) / (36 * M_PI);
				Iy0dx= ci*ci * (5 - 6 * log(ci)) / (72 * M_PI);
				Iy1dx = ci * ci * (-4 + 3 * log(ci)) / (72 * M_PI);
			}
			else {
				It1New = 2 * (ci * (3 * ci - 2 * xi) + (ci - xi) * (-ci + xi) * log((ci - xi) * (ci - xi)) + (-2 * ci * xi + xi * xi) * log(xi * xi)) / (8 * ci * ci * M_PI);
				It2New = 2 * (-(-ci * (ci + 2 * xi) + 2 * (ci * ci - xi * xi) * log(ci - xi) + 2 * xi * xi * log(xi))) / (8 * ci * ci * M_PI);
				Iy0 = (ci * (19 * ci * ci * ci - 76 * ci * ci * xi + 114 * ci * xi * xi - 12 * xi * xi * xi) -
					6 * pow(ci - xi, 4) * log(pow(ci - xi, 2)) + 6 * xi * xi * xi * (-4 * ci + xi) * log(pow(xi, 2))) / (1152 * ci * ci * M_PI);;
				Iy1 = (ci * (45 * ci * ci * ci - 116 * ci * ci * xi + 78 * ci * xi * xi + 12 * xi * xi * xi) -
					12 * pow(ci - xi, 3) * (3 * ci + xi) * log(ci - xi) - 12 * pow(xi, 4) * log(xi)) / (1152 * ci * ci * M_PI);
				Ie1 = (ci * (ci + 2 * xi) + 2 * (-ci * ci + xi * xi) * log(ci - xi) - 2 * xi * xi * log(xi)) / (8 * ci * ci * M_PI);

				Ic0dy = (-ci * (ci - 2 * xi) + 2 * xi * (-ci + xi) * (log(ci - xi) - log(xi))) / (2 * ci * ci * M_PI * xi);
				Ic1dy = (-4 * ci + (ci - 2 * xi) * log(1 + (ci * (ci - 2 * xi)) / (xi * xi))) / (2 * ci * ci * M_PI);
				It0dx = -(2 * ci + (ci - xi) * log((xi * xi) / ((ci - xi) * (ci - xi)))) / (4 * ci * ci * M_PI);//加了-
				
				It1dx = (ci + xi * log(ci - xi) - xi * log(xi)) / (2 * ci * ci * M_PI);
				
				
				Ix0dy = (ci * (-14 * ci * ci + 15 * ci * xi - 6 * xi * xi) +
					6 * ci * ci * ci * log(ci - xi) + 3 * xi * (3 * ci * ci - 3 * ci * xi + xi * xi) * (-log((ci - xi) * (ci - xi)) + log(xi * xi))) / (72 * ci * ci * M_PI);
				
				Ix1dy= (-8 * ci * ci * ci - 12 * ci * ci * xi + 12 * ci * xi * xi +
					2 * (9 * ci * xi * xi - 6 * xi * xi * xi) * log(xi) +(3 * ci * ci * ci - 9 * ci * xi * xi + 6 * xi * xi * xi) *log(ci * ci - 2 * ci * xi + xi * xi)) /(72 * ci * ci * M_PI);
				Iy0dx= (-8 * ci * ci * ci + 24 * ci * ci * xi - 6 * ci * xi * xi +
					2 * (-9 * ci * xi * xi + 3 * xi * xi * xi) * log(xi) +
					(3 * ci * ci * ci - 9 * ci * ci * xi + 9 * ci * xi * xi - 3 * xi * xi * xi) *log(ci * ci - 2 * ci * xi + xi * xi)) /(144 * ci * M_PI);
				
				Iy1dx= (2 * ci * (-5 * ci * ci + 6 * ci * xi + 3 * xi * xi) +
					6 * (ci - xi) * (ci - xi) * (2 * ci + xi) * log(ci - xi) -6 * xi * xi * xi * log(xi)) /(144 * ci * M_PI);
				
			}
			/*std::cout << "boundary" << signEdge << std::endl;
			std::cout << Ic0 << " " << Ic1 << " " << It1New << " " << It2New << " " << Ix0 << " " << Ix1 << " " << Iy0 << " " << Iy1 << " " << std::endl;
			std::cout << Ic0dx << " " << Ic0dy << " " << Ic1dx << "" << Ic1dy << " " << It0dx << " " << It0dy << " " << It1dx << " " << It1dy << " " << Ix0dx << " " << Ix0dy
				<< " " << Ix1dx << " " << Ix1dy << " " << Iy0dx << " " << Iy0dy << " " << Iy1dx << " " << Iy1dy << std::endl;*/
		}
		{
			ei = v2 - v1;
			ci = ei.norm();
			ui = eta - v1;
			xiyi = OpenMesh::Vec2d(ui[0] * ei[0] + ui[1] * ei[1], ui[1] * ei[0] - ui[0] * ei[1]);
			xiyi = xiyi / ci;
			xi = xiyi[0];
			yi = xiyi[1];
			L1i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1]);
			L2i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1] + ci * ci - 2 * ci * xiyi[0]);
			Ai = atan(xiyi[0] / xiyi[1]) + atan((ci - xiyi[0]) / xiyi[1]);
			Ic0 = ((ci * ci - 2 * ci * xi + xi * xi - yi * yi) * Ai + yi * (ci + (xi - ci) * (L2i - L1i))) / (2 * ci * ci * M_PI);
			Ic1 = (2 * (ci * xi - xi * xi + yi * yi) * Ai + yi * (-2 * ci + (ci - 2 * xi) * (L2i - L1i))) / (2 * ci * ci * M_PI);
			It0 = 2 * (ci * (-3 * ci + 2 * xi) + 4 * (ci - xi) * yi * Ai + (ci - xi - yi) * (ci - xi + yi) * L2i + (2 * ci * xi - xi * xi + yi * yi) * L1i) / (8 * ci * ci * M_PI);
			It1 = 2 * (ci * ci - 2 * ci * xi - 2 * (ci - 2 * xi) * yi * Ai + (xi * xi - yi * yi - ci * xi) * (L1i - L2i)) / (4 * ci * ci * M_PI);
			It1New = -It0;
			It2New = 2 * (-ci * (ci + 2 * xi) + 4 * xi * yi * Ai + (ci * ci - xi * xi + yi * yi) * L2i + (xi - yi) * (xi + yi) * L1i) / (-8 * ci * ci * M_PI);
			Ix0 = yi * (-14 * ci * ci * ci + 15 * ci * ci * xi - 6 * ci * xi * xi + 6 * ci * yi * yi - 6 * yi * (-3 * ci * ci + 6 * ci * xi - 3 * xi * xi + yi * yi) * Ai
				+ (9 * ci * ci * xi - 9 * ci * xi * xi + 3 * xi * xi * xi + 9 * ci * yi * yi - 9 * xi * yi * yi) * (L1i - L2i) + 3 * ci * ci * ci * L2i) / (72 * ci * ci * M_PI);
			Ix1 = yi * (-8 * ci * ci * ci - 12 * ci * ci * xi + 12 * ci * xi * xi - 12 * ci * yi * yi + 12 * yi * (3 * ci * xi - 3 * xi * xi + yi * yi) * Ai
				+ (9 * ci * xi * xi - 6 * xi * xi * xi - 9 * ci * yi * yi + 18 * xi * yi * yi) * (L1i - L2i) + 3 * ci * ci * ci * L2i) / (72 * ci * ci * M_PI);
			Iy0 = (-19 * ci * ci * ci * ci + 76 * ci * ci * ci * xi - 114 * ci * ci * xi * xi + 12 * ci * xi * xi * xi - 150 * ci * ci * yi * yi + 60 * ci * xi * yi * yi +
				96 * (ci - xi) * yi * yi * yi * Ai + (24 * ci * xi * xi * xi - 6 * xi * xi * xi * xi + 72 * ci * xi * yi * yi - 36 * xi * xi * yi * yi + 18 * yi * yi * yi * yi) * (L1i - L2i)
				+ (6 * ci * ci * ci * ci + 36 * ci * ci * xi * xi - 24 * ci * ci * ci * xi + 36 * ci * ci * yi * yi) * L2i) / (-1152 * ci * ci * M_PI);

			Iy1 = (-45 * ci * ci * ci * ci + 116 * ci * ci * ci * xi - 78 * ci * ci * xi * xi - 12 * ci * xi * xi * xi - 90 * ci * ci * yi * yi - 60 * ci * xi * yi * yi +
				96 * xi * yi * yi * yi * Ai + (6 * xi * xi * xi * xi + 36 * xi * xi * yi * yi - 18 * yi * yi * yi * yi) * (L1i - L2i)
				+ (18 * ci * ci * ci * ci - 48 * ci * ci * ci * xi + 36 * ci * ci * xi * xi + 36 * ci * ci * yi * yi) * L2i) / (-1152 * ci * ci * M_PI);
			Ie1 = (-ci * (ci + 2 * xi) + 4 * xi * yi * Ai + (ci * ci - xi * xi + yi * yi) * L2i + (xi - yi) * (xi + yi) * L1i) / (-8 * ci * ci * M_PI);

			Ic0dx = yi * (ci * ci / (xi * xi + yi * yi) - 2 * (ci - xi) / yi * (Ai)+L2i - L1i) / (2 * ci * ci * M_PI);
			Ic0dy = (-ci * ci * xi + 2 * ci * xi * xi + 2 * ci * yi * yi - 2 * yi * (xi * xi + yi * yi) * Ai +
				(ci * xi * xi - xi * xi * xi + ci * yi * yi - xi * yi * yi) * (L1i - L2i)) / (2 * ci * ci * M_PI * (xi * xi + yi * yi));
			Ic1dx = ((ci - 2 * xi) * Ai + yi * (L1i - L2i)) / (ci * ci * M_PI);
			Ic1dy = (-4 * ci + 4 * yi * Ai + (ci - 2 * xi) * (L2i - L1i)) / (2 * ci * ci * M_PI);
			It0dx = -(ci - yi * Ai + (ci - xi) / 2 * (L1i - L2i)) / (2 * ci * ci * M_PI);//加了负号改正为new
			It0dy = -(2 * (ci - xi) * Ai + yi * (L1i - L2i)) / (4 * ci * ci * M_PI);//加了负号改正为new
			It1dx = (2 * ci - 2 * yi * Ai + xi * L2i - xi * L1i) / (4 * ci * ci * M_PI);//yj改正为new
			It1dy = -((yi * ((xi * (Ai)) / yi + 0.5 * (L2i - L1i))) / (2 * ci * ci * M_PI));//yj改正为new
			Ix0dx = (ci * (3 * ci - 2 * xi) + 4 * (-ci + xi) * yi * Ai - (ci - xi - yi) * (ci - xi + yi) * (L2i - L1i)) * (yi / (8 * ci * ci * M_PI));
			Ix0dy = (-14 * ci * ci * ci + 15 * ci * ci * xi - 6 * ci * xi * xi + 24 * ci * yi * yi + 12 * yi * (3 * ci * ci - 6 * ci * xi + 3 * xi * xi - 2 * yi * yi) * Ai
				+ (9 * ci * ci * xi - 9 * ci * xi * xi + 3 * xi * xi * xi + 27 * ci * yi * yi - 27 * xi * yi * yi) * (L1i - L2i) + 3 * ci * ci * ci * L2i) / (72 * ci * ci * M_PI);

			Ix1dx = (1.0 / (2 * ci * ci * M_PI)) * yi * (-0.5 * ci * (ci - 2 * xi) +
				(ci - 2 * xi) * yi * (Ai)-0.5 * ((ci - xi) * xi + yi * yi) * (L2i - L1i));
			Ix1dy = (1.0 / (72 * ci * ci * M_PI)) * (-8 * ci * ci * ci - 12 * ci * ci * xi + 12 * ci * xi * xi - 48 * ci * yi * yi +
				24 * yi * (3 * ci * xi - 3 * xi * xi + 2 * yi * yi) * (Ai) +
				(9 * ci * xi * xi - 6 * xi * xi * xi - 27 * ci * yi * yi + 54 * xi * yi * yi) * L1i +
				(3 * ci * ci * ci - 9 * ci * xi * xi + 6 * xi * xi * xi + 27 * ci * yi * yi - 54 * xi * yi * yi) *L2i);
			Iy0dx = (1.0 / (144 * ci * M_PI)) * (-8 * ci * ci * ci + 24 * ci * ci * xi - 6 * ci * xi * xi - 12 * ci * yi * yi +
				12 * yi * yi * yi * (Ai)+(-9 * ci * xi * xi + 3 * xi * xi * xi - 9 * ci * yi * yi + 9 * xi * yi * yi) * L1i +
				(3 * ci * ci * ci - 9 * ci * ci * xi + 9 * ci * xi * xi - 3 * xi * xi * xi + 9 * ci * yi * yi - 9 * xi * yi * yi) * L2i);
			Iy0dy = -(1.0 / (16 * ci * M_PI)) * yi * (2 * ci * (-2 * ci + xi) + 4 * (ci - xi) * yi * (Ai)+
				(ci - xi - yi) * (ci - xi + yi) * L2i + (2 * ci * xi - xi * xi + yi * yi) * L1i);
			Iy1dx = (1.0 / (144 * ci * M_PI)) * (2 * ci * (-5 * ci * ci + 6 * ci * xi + 3 * xi * xi + 6 * yi * yi) - 12 * yi * yi * yi * (Ai)+
				3 * ((ci - xi) * (ci - xi) * (2 * ci + xi) + 3 * xi * yi * yi) * L2i - 3 * xi * (xi * xi + 3 * yi * yi) * L1i);
			Iy1dy = (1.0 / (16 * ci * M_PI)) * yi * (ci * ci + ci * (ci + 2 * xi) - 4 * xi * yi * (Ai)-
				(ci * ci - xi * xi + yi * yi) * L2i - (xi - yi) * (xi + yi) * L1i);
			/*std::cout << Ic0 << " " << Ic1 << " " << It1New << " " << It2New << " " << Ix0 << " " << Ix1 << " " << Iy0 << " " << Iy1 << " " << std::endl;
			std::cout << Ic0dx << " " << Ic0dy << " " << Ic1dx << "" << Ic1dy << " " << It0dx << " " << It0dy << " " << It1dx << " " << It1dy << " " << Ix0dx << " " << Ix0dy
				<< " " << Ix1dx << " " << Ix1dy << " " << Iy0dx << " " << Iy0dy <<" " << Iy1dx << " " << Iy1dy << std::endl;*/
		}
		RotateM << ei[0], -ei[1],
			ei[1], ei[0];
		RotateM /= (ci);//旋转矩阵


		Eigen::Vector2d tiduc0(Ic0dx, Ic0dy);
		Eigen::Vector2d tiduc1(Ic1dx, Ic1dy);
		Eigen::Vector2d tidut0(It0dx, It0dy);
		Eigen::Vector2d tidut1(It1dx, It1dy);
		Eigen::Vector2d tidux0(Ix0dx, Ix0dy);
		Eigen::Vector2d tidux1(Ix1dx, Ix1dy);
		Eigen::Vector2d tiduy0(Iy0dx, Iy0dy);
		Eigen::Vector2d tiduy1(Iy1dx, Iy1dy);
		auto real_tiduc0 = RotateM * tiduc0;
		auto real_tiduc1 = RotateM * tiduc1;
		auto real_tidut0 = RotateM * tidut0;
		auto real_tidut1 = RotateM * tidut1;
		auto real_tidux0 = RotateM * tidux0;
		auto real_tidux1 = RotateM * tidux1;
		auto real_tiduy0 = RotateM * tiduy0;
		auto real_tiduy1 = RotateM * tiduy1;

		Ic0dx = real_tiduc0[0]; Ic0dy = real_tiduc0[1];
		Ic1dx = real_tiduc1[0]; Ic1dy = real_tiduc1[1];
		It0dx = real_tidut0[0]; It0dy = real_tidut0[1];
		It1dx = real_tidut1[0]; It1dy = real_tidut1[1];
		Ix0dx = real_tidux0[0]; Ix0dy = real_tidux0[1];
		Ix1dx = real_tidux1[0]; Ix1dy = real_tidux1[1];
		Iy0dx = real_tiduy0[0]; Iy0dy = real_tiduy0[1];
		Iy1dx = real_tiduy1[0]; Iy1dy = real_tiduy1[1];
	}
	

	values[0] = Ic0 + Ic0_1;
	values[1] = Ic1;
	values[2] = It1New;//
	values[3] = It2New;//
	values[4] = Ix0 + Ix0_1;
	values[5] = Ix1;
	values[6] = Iy0;
	values[7] = Iy1;
	values[8] = Ic0 + Ic0_1;
	values[9] = Ic1;
	values[10] = -It0 / 2;//要除以2吗
	values[11] = Ie1;
	values[12] = Ic0dx + Ic0_1dx;
	values[13] = Ic0dy + Ic0_1dy;
	values[14] = Ic1dx;
	values[15] = Ic1dy;
	values[16] = 2*It0dx;
	values[17] = 2*It0dy;
	values[18] = 2*It1dx;
	values[19] = 2*It1dy;
	values[20] = Ix0dx+Ix0_1dx;
	values[21] = Ix0dy+Ix0_1dy;
	values[22] = Ix1dx;
	values[23] = Ix1dy;
	values[24] = Iy0dx;
	values[25] = Iy0dy;
	values[26] = Iy1dx;
	values[27] = Iy1dy;
}

//重新计算两次情形下的系数的计算，与之前的相比，改变了导数那一项的计算方式，现在是与每条边上的两个切方向相乘
//再次更新，我希望在value的最后加上4个导数的计算。
void CalBiharmonicTwiceBasisNewDerV1(OpenMesh::Vec2d& v0, OpenMesh::Vec2d& v1, OpenMesh::Vec2d& v2, OpenMesh::Vec2d& eta,
	std::vector<double>& values) {
	//values.resize(12);
	values.resize(28);
	//v0 = OpenMesh::Vec2d(0, 2); v1 = OpenMesh::Vec2d(0, 0); v2 = OpenMesh::Vec2d(2, 0); eta = OpenMesh::Vec2d(1, 1);
	OpenMesh::Vec2d ei, ui, xiyi;
	double ci, L1i, L2i, Ai, xi, yi, Ic0, Ic0_1, Ic1, It0_1, It0, It1, It1New, It2New,
		Ix0_1, Ix0, Ix1, Iy0, Iy1, Ie1, hatphiBH_1, hatphiH, hatphiBH;
	double Ic0dx, Ic0dy, Ic0_1dx, Ic0_1dy, Ic1dx, Ic1dy, It0dx, It0dy, It0_1dx, It0_1dy, It1dx, It1dy, Ix0dx, Ix0dy, Ix0_1dx, Ix0_1dy, Ix1dx, Ix1dy,
		Iy0dx, Iy0dy, Iy1dx, Iy1dy;
	Eigen::Matrix2d RotateM;
	{//计算前一个phi的值
		ei = v1 - v0;
		ci = ei.norm();
		RotateM << ei[0], -ei[1],
			ei[1], ei[0];
		RotateM /= (ci );
		//std::cout << RotateM * Eigen::Vector2d(ci, 0) << std::endl;
		ui = eta - v0;
		xiyi = OpenMesh::Vec2d(ui[0] * ei[0] + ui[1] * ei[1], ui[1] * ei[0] - ui[0] * ei[1]);
		xiyi = xiyi / ci;
		xi = xiyi[0];
		yi = xiyi[1];
		L1i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1]);
		L2i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1] + ci * ci - 2 * ci * xiyi[0]);
		Ai = atan(xiyi[0] / xiyi[1]) + atan((ci - xiyi[0]) / xiyi[1]);
		Ic0_1 = ((xi - yi) * (xi + yi) * Ai + yi * (ci + (xi) * (L2i - L1i))) / (2 * ci * ci * M_PI);
		It0_1 = 2 * (-ci * (ci + 2 * xi) + 4 * xi * yi * Ai + (ci * ci - xi * xi + yi * yi) * L2i + (xi - yi) * (xi + yi) * L1i) / (-8 * ci * ci * M_PI);
		Ix0_1 = yi * (ci * ci * ci + 1. / 3 * (
			2 * ci * ci * ci + 3 * ci * ci * xi + 6 * ci * xi * xi - 6 * ci * yi * yi - 6 * (3 * xi * xi * yi - yi * yi * yi) * Ai + (9 * xi * yi * yi - 3 * xi * xi * xi) * (L1i - L2i) - 3 * ci * ci * ci * L2i)
			) / (-24 * ci * ci * M_PI);
		Ic0_1dx = (2 * xi * Ai + yi * ( L2i - L1i)) / (2 * ci * ci * M_PI);
		Ic0_1dy = (2*ci - 2 * yi * Ai -xi* (L1i - L2i)) / (2 * ci * ci * M_PI );
		Ix0_1dx = (1.0 / (8 * ci * ci * M_PI)) * yi * (-ci * (ci + 2 * xi) + 4 * xi * yi * (Ai)-(xi - yi) * (xi + yi) * (L2i - L1i));
		Ix0_1dy = (1.0 / (72 * ci * ci * M_PI)) * (-5 * ci * ci * ci - 3 * ci * ci * xi - 6 * ci * xi * xi + 24 * ci * yi * yi +
			12 * (3 * xi * xi * yi - 2 * yi * yi * yi) * (Ai)+(3 * xi * xi * xi - 27 * xi * yi * yi) * L1i + (-3 * xi * xi * xi + 27 * xi * yi * yi + 3 * ci * ci * ci) * L2i);
		Eigen::Vector2d tiduc0_1(Ic0_1dx, Ic0_1dy);
		Eigen::Vector2d tidux0_1(Ix0_1dx, Ix0_1dy);
		auto real_tiduc0_1 = RotateM * tiduc0_1;
		auto real_tidux0_1 = RotateM * tidux0_1;
		Ic0_1dx = real_tiduc0_1[0];
		Ic0_1dy = real_tiduc0_1[1];
		Ix0_1dx = real_tidux0_1[0];
		Ix0_1dy = real_tidux0_1[1];
	}
	ei = v2 - v1;
	ci = ei.norm();
	ui = eta - v1;
	xiyi = OpenMesh::Vec2d(ui[0] * ei[0] + ui[1] * ei[1], ui[1] * ei[0] - ui[0] * ei[1]);
	xiyi = xiyi / ci;
	xi = xiyi[0];
	yi = xiyi[1];
	L1i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1]);
	L2i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1] + ci * ci - 2 * ci * xiyi[0]);
	Ai = atan(xiyi[0] / xiyi[1]) + atan((ci - xiyi[0]) / xiyi[1]);
	Ic0 = ((ci * ci - 2 * ci * xi + xi * xi - yi * yi) * Ai + yi * (ci + (xi - ci) * (L2i - L1i))) / (2 * ci * ci * M_PI);
	Ic1 = (2 * (ci * xi - xi * xi + yi * yi) * Ai + yi * (-2 * ci + (ci - 2 * xi) * (L2i - L1i))) / (2 * ci * ci * M_PI);
	It0 = 2 * (ci * (-3 * ci + 2 * xi) + 4 * (ci - xi) * yi * Ai + (ci - xi - yi) * (ci - xi + yi) * L2i + (2 * ci * xi - xi * xi + yi * yi) * L1i) / (8 * ci * ci * M_PI);
	It1 = 2 * (ci * ci - 2 * ci * xi - 2 * (ci - 2 * xi) * yi * Ai + (xi * xi - yi * yi - ci * xi) * (L1i - L2i)) / (4 * ci * ci * M_PI);
	It1New = -It0;
	It2New = 2 * (-ci * (ci + 2 * xi) + 4 * xi * yi * Ai + (ci * ci - xi * xi + yi * yi) * L2i + (xi - yi) * (xi + yi) * L1i) / (-8 * ci * ci * M_PI);
	Ix0 = yi * (-14 * ci * ci * ci + 15 * ci * ci * xi - 6 * ci * xi * xi + 6 * ci * yi * yi - 6 * yi * (-3 * ci * ci + 6 * ci * xi - 3 * xi * xi + yi * yi) * Ai
		+ (9 * ci * ci * xi - 9 * ci * xi * xi + 3 * xi * xi * xi + 9 * ci * yi * yi - 9 * xi * yi * yi) * (L1i - L2i) + 3 * ci * ci * ci * L2i) / (72 * ci * ci * M_PI);
	Ix1 = yi * (-8 * ci * ci * ci - 12 * ci * ci * xi + 12 * ci * xi * xi - 12 * ci * yi * yi + 12 * yi * (3 * ci * xi - 3 * xi * xi + yi * yi) * Ai
		+ (9 * ci * xi * xi - 6 * xi * xi * xi - 9 * ci * yi * yi + 18 * xi * yi * yi) * (L1i - L2i) + 3 * ci * ci * ci * L2i) / (72 * ci * ci * M_PI);
	Iy0 = (-19 * ci * ci * ci * ci + 76 * ci * ci * ci * xi - 114 * ci * ci * xi * xi + 12 * ci * xi * xi * xi - 150 * ci * ci * yi * yi + 60 * ci * xi * yi * yi +
		96 * (ci - xi) * yi * yi * yi * Ai + (24 * ci * xi * xi * xi - 6 * xi * xi * xi * xi + 72 * ci * xi * yi * yi - 36 * xi * xi * yi * yi + 18 * yi * yi * yi * yi) * (L1i - L2i)
		+ (6 * ci * ci * ci * ci + 36 * ci * ci * xi * xi - 24 * ci * ci * ci * xi + 36 * ci * ci * yi * yi) * L2i) / (-1152 * ci * ci * M_PI);

	Iy1 = (-45 * ci * ci * ci * ci + 116 * ci * ci * ci * xi - 78 * ci * ci * xi * xi - 12 * ci * xi * xi * xi - 90 * ci * ci * yi * yi - 60 * ci * xi * yi * yi +
		96 * xi * yi * yi * yi * Ai + (6 * xi * xi * xi * xi + 36 * xi * xi * yi * yi - 18 * yi * yi * yi * yi) * (L1i - L2i)
		+ (18 * ci * ci * ci * ci - 48 * ci * ci * ci * xi + 36 * ci * ci * xi * xi + 36 * ci * ci * yi * yi) * L2i) / (-1152 * ci * ci * M_PI);
	Ie1 = (-ci * (ci + 2 * xi) + 4 * xi * yi * Ai + (ci * ci - xi * xi + yi * yi) * L2i + (xi - yi) * (xi + yi) * L1i) / (-8 * ci * ci * M_PI);

	RotateM << ei[0], -ei[1],
		ei[1], ei[0];
	RotateM /= (ci );//旋转矩阵
	Ic0dx = yi * ( - 2 * (ci - xi) / yi * (Ai)+L2i - L1i) / (2 * ci * ci * M_PI);
	Ic0dy = (2*ci - 2 * yi * Ai +(ci - xi) * (L1i - L2i)) / (2 * ci * ci * M_PI );
	Ic1dx = ((ci - 2 * xi) * Ai + yi * (L1i - L2i)) / (ci * ci * M_PI);
	Ic1dy = (-4 * ci + 4 * yi * Ai + (ci - 2 * xi) * (L2i - L1i)) / (2 * ci * ci * M_PI);
	It0dx = -(ci - yi * Ai + (ci - xi) / 2 * (L1i - L2i)) / (2 * ci * ci * M_PI);//加了负号改正为new
	It0dy = -(2 * (ci - xi) * Ai + yi * (L1i - L2i)) / (4 * ci * ci * M_PI);//加了负号改正为new
	//It0_1dx = -(2 * ci - 2 * yi * Ai + xi * (L2i - L1i)) / (4 * ci * ci * M_PI);//需要改正为new
	//It0_1dy = -(yi * (xi * Ai / yi + (L2i - L1i) / 2)) / (-2 * ci * ci * M_PI);//需要改正为new
	It1dx = (-ci + yi * (Ai)+0.5 * (ci - xi) * (L2i - L1i)) / (2 * ci * ci * M_PI);//yj改正为new
	It1dy = (-2 * (ci - xi) * Ai + yi * (L2i - L1i)) / (4 * ci * ci * M_PI);//yj改正为new
	Ix0dx = (ci * (3 * ci - 2 * xi) + 4 * (-ci + xi) * yi * Ai - (ci - xi - yi) * (ci - xi + yi) * (L2i - L1i)) * (yi / (8 * ci * ci * M_PI));
	Ix0dy = (-14 * ci * ci * ci + 15 * ci * ci * xi - 6 * ci * xi * xi + 24 * ci * yi * yi + 12 * yi * (3 * ci * ci - 6 * ci * xi + 3 * xi * xi - 2 * yi * yi) * Ai
		+ (9 * ci * ci * xi - 9 * ci * xi * xi + 3 * xi * xi * xi + 27 * ci * yi * yi - 27 * xi * yi * yi) * (L1i - L2i) + 3 * ci * ci * ci * L2i) / (72 * ci * ci * M_PI);

	Ix1dx = (1.0 / (2 * ci * ci * M_PI)) * yi * (-0.5 * ci * (ci - 2 * xi) +
		(ci - 2 * xi) * yi * (Ai)-0.5 * ((ci - xi) * xi + yi * yi) * (L2i - L1i));
	Ix1dy = (1.0 / (2 * ci * ci * M_PI)) * yi * (-0.5 * ci * (ci - 2 * xi) +
		(ci - 2 * xi) * yi * (atan((ci - xi) / yi) + atan(xi / yi)) - 0.5 * ((ci - xi) * xi + yi * yi) * (L2i - L1i));
	Iy0dx = (1.0 / (144 * ci * M_PI)) * (-8 * ci * ci * ci + 24 * ci * ci * xi - 6 * ci * xi * xi - 12 * ci * yi * yi +
		12 * yi * yi * yi * (Ai)+(-9 * ci * xi * xi + 3 * xi * xi * xi - 9 * ci * yi * yi + 9 * xi * yi * yi) * L1i +
		(3 * ci * ci * ci - 9 * ci * ci * xi + 9 * ci * xi * xi - 3 * xi * xi * xi + 9 * ci * yi * yi - 9 * xi * yi * yi) * L2i);
	Iy0dy = -(1.0 / (16 * ci * M_PI)) * yi * (2 * ci * (-2 * ci + xi) + 4 * (ci - xi) * yi * (Ai)+
		(ci - xi - yi) * (ci - xi + yi) * L2i + (2 * ci * xi - xi * xi + yi * yi) * L1i);
	Iy1dx = (1.0 / (144 * ci * M_PI)) * (2 * ci * (-5 * ci * ci + 6 * ci * xi + 3 * xi * xi + 6 * yi * yi) - 12 * yi * yi * yi * (Ai)+
		3 * ((ci - xi) * (ci - xi) * (2 * ci + xi) + 3 * xi * yi * yi) * L2i - 3 * xi * (xi * xi + 3 * yi * yi) * L1i);
	Iy1dy = (1.0 / (16 * ci * M_PI)) * yi * (ci * ci + ci * (ci + 2 * xi) - 4 * xi * yi * (Ai)-
		(ci * ci - xi * xi + yi * yi) * L2i - (xi - yi) * (xi + yi) * L1i);

	Eigen::Vector2d tiduc0(Ic0dx, Ic0dy);
	Eigen::Vector2d tiduc1(Ic1dx, Ic1dy);
	Eigen::Vector2d tidut0(It0dx, It0dy);
	Eigen::Vector2d tidut1(It1dx, It1dy);
	Eigen::Vector2d tidux0(Ix0dx, Ix0dy);
	Eigen::Vector2d tidux1(Ix1dx, Ix1dy);
	Eigen::Vector2d tiduy0(Iy0dx, Iy0dy);
	Eigen::Vector2d tiduy1(Iy1dx, Iy1dy);
	auto real_tiduc0 = RotateM * tiduc0;
	auto real_tiduc1 = RotateM * tiduc1;
	auto real_tidut0 = RotateM * tidut0;
	auto real_tidut1 = RotateM * tidut1;
	auto real_tidux0 = RotateM * tidux0;
	auto real_tidux1 = RotateM * tidux1;
	auto real_tiduy0 = RotateM * tiduy0;
	auto real_tiduy1 = RotateM * tiduy1;

	Ic0dx = real_tiduc0[0]; Ic0dy = real_tiduc0[1];
	Ic1dx = real_tiduc1[0]; Ic1dy = real_tiduc1[1];
	It0dx = real_tidut0[0]; It0dy = real_tidut0[1];
	It1dx = real_tidut1[0]; It1dy = real_tidut1[1];
	Ix0dx = real_tidux0[0]; Ix0dy = real_tidux0[1];
	Ix1dx = real_tidux1[0]; Ix1dy = real_tidux1[1];
	Iy0dx = real_tiduy0[0]; Iy0dy = real_tiduy0[1];
	Iy1dx = real_tiduy1[0]; Iy1dy = real_tiduy1[1];

	values[0] = Ic0 + Ic0_1;
	values[1] = Ic1;
	values[2] = It1New;//
	values[3] = It2New;//
	values[4] = Ix0 + Ix0_1;
	values[5] = Ix1;
	values[6] = Iy0;
	values[7] = Iy1;
	values[8] = Ic0 + Ic0_1;
	values[9] = Ic1;
	values[10] = -It0 / 2;//要除以2吗
	values[11] = Ie1;
	values[12] = Ic0dx + Ic0_1dx;
	values[13] = Ic0dy + Ic0_1dy;
	values[14] = Ic1dx;
	values[15] = Ic1dy;
	values[16] = It0dx;
	values[17] = It0dy;
	values[18] = It1dx;
	values[19] = It1dy;
	values[20] = Ix0dx + Ix0_1dx;
	values[21] = Ix0dy + Ix0_1dy;
	values[22] = Ix1dx;
	values[23] = Ix1dy;
	values[24] = Iy0dx;
	values[25] = Iy0dy;
	values[26] = Iy1dx;
	values[27] = Iy1dy;
}

void CalBiharmonicThirdBasis(OpenMesh::Vec2d& v0, OpenMesh::Vec2d& v1, OpenMesh::Vec2d& v2, OpenMesh::Vec2d& eta,
	std::vector<double>& values) {
	values.resize(18);
	//v0 = OpenMesh::Vec2d(0, 2); v1 = OpenMesh::Vec2d(0, 0); v2 = OpenMesh::Vec2d(2, 0); eta = OpenMesh::Vec2d(1, 1);
	OpenMesh::Vec2d ei, ui, xiyi;
	double ci, L1i, L2i, Ai, xi, yi, Ic0, Ic0_1, Ic1,Ic2, It0_1, It0, It1,It2,
		Ix0_1, Ix0, Ix1,Ix2, Iy0, Iy1,Iy2, Ie1, Ie2,hatphiBH_1, hatphiH, hatphiBH;
	{//计算前一个phi的值
		ei = v1 - v0;
		ci = ei.norm();
		ui = eta - v0;
		xiyi = OpenMesh::Vec2d(ui[0] * ei[0] + ui[1] * ei[1], ui[1] * ei[0] - ui[0] * ei[1]);
		xiyi = xiyi / ci;
		xi = xiyi[0];
		yi = xiyi[1];
		L1i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1]);
		L2i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1] + ci * ci - 2 * ci * xiyi[0]);
		Ai = atan(xiyi[0] / xiyi[1]) + atan((ci - xiyi[0]) / xiyi[1]);
		Ic0_1 = (1. / (4 * pow(ci, 3) * M_PI)) * (ci * (ci + 4 * xi) * yi +2 * (pow(xi, 3) - 3 * xi * pow(yi, 2)) * Ai -
			yi * (-3 * pow(xi, 2) + pow(yi, 2)) *(L2i-L1i));
		It0_1 = -(1. / (12 * pow(ci, 3) * M_PI)) * (-ci * (2 * pow(ci, 2) + 3 * ci * xi + 6 * pow(xi, 2) - 6 * pow(yi, 2)) -
			6 * yi * (-3 * pow(xi, 2) + pow(yi, 2)) * Ai + 3 * (pow(ci, 3) - pow(xi, 3) + 3 * xi * pow(yi, 2)) * L2i + 3 * xi * (pow(xi, 2) - 3 * pow(yi, 2)) * L1i);
		Ix0_1 = (1. / (192 * pow(ci, 3) * M_PI)) * yi * (
			-ci * (9 * pow(ci, 3) + 4 * pow(ci, 2) * xi + 6 * ci * pow(xi, 2) + 12 * pow(xi, 3)) + 6 * ci * (ci + 6 * xi) * pow(yi, 2) +
			48 * xi * (xi - yi) * yi * (xi + yi) * Ai + 6 * pow(ci, 4) * L2i + 6 * (pow(xi, 4) - 6 * pow(xi, 2) * pow(yi, 2) + pow(yi, 4)) * (-L2i + L1i));
	}
	ei = v2 - v1;
	ci = ei.norm();
	ui = eta - v1;
	xiyi = OpenMesh::Vec2d(ui[0] * ei[0] + ui[1] * ei[1], ui[1] * ei[0] - ui[0] * ei[1]);
	xiyi = xiyi / ci;
	xi = xiyi[0];
	yi = xiyi[1];
	L1i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1]);
	L2i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1] + ci * ci - 2 * ci * xiyi[0]);
	Ai = atan(xiyi[0] / xiyi[1]) + atan((ci - xiyi[0]) / xiyi[1]);
	Ic0 = (ci * (5 * ci - 4 * xi) * yi + 2 * (ci - xi) * (pow(ci - xi, 2) - 3 * pow(yi, 2)) * Ai + yi * (-3 * pow(ci - xi, 2) + pow(yi, 2)) * (L2i - L1i)) / (4 * pow(ci, 3) * M_PI);
	Ic1 = (1. / (4 * pow(ci, 3) * M_PI)) * 3 * (ci * (-3 * ci + 4 * xi) * yi +
		2 * ((pow(ci - xi, 2) * xi) + (2 * ci - 3 * xi) * pow(yi, 2)) * Ai + yi * (-(ci - 3 * xi) * (ci - xi) + pow(yi, 2)) * (L1i - L2i));
	Ic2 = (1. / (4 * pow(ci, 3) * M_PI)) * (-6 * (pow(xi, 3) - 3 * xi * pow(yi, 2) + ci * (-pow(xi, 2) + pow(yi, 2))) * Ai +
		3 * yi * (ci * (ci - 4 * xi) - (2 * ci * xi - 3 * pow(xi, 2) + pow(yi, 2)) * L1i + (2 * ci * xi - 3 * pow(xi, 2) + pow(yi, 2)) * L2i));
	It0 = (1. / (12 * pow(ci, 3) * M_PI)) * (ci * (-11 * pow(ci, 2) + 15 * ci * xi - 6 * pow(xi, 2) + 6 * pow(yi, 2)) -
		6 * yi * (-3 * pow(ci - xi, 2) + pow(yi, 2)) * Ai + 3 * (ci - xi) * (pow(ci - xi, 2) - 3 * pow(yi, 2)) * L2i +
		3 * (xi * (3 * pow(ci, 2) - 3 * ci * xi + pow(xi, 2)) + 3 * (ci - xi) * pow(yi, 2)) * L1i);
	It1 = -(1. / (4 * pow(ci, 3) * M_PI)) * 3 * ((1. / 3) * ci * (-2 * pow(ci, 2) + 9 * ci * xi - 6 * pow(xi, 2) + 6 * pow(yi, 2)) +
		2 * yi * (pow(ci, 2) - 4 * ci * xi + 3 * pow(xi, 2) - pow(yi, 2)) * Ai - ((pow(ci - xi, 2) * xi) + (2 * ci - 3 * xi) * pow(yi, 2)) * (L2i - L1i));
	It2 = (1. / (4 * pow(ci, 3) * M_PI)) * (ci * (pow(ci, 2) + 3 * ci * xi - 6 * pow(xi, 2) + 6 * pow(yi, 2)) -
		6 * yi * (2 * ci * xi - 3 * pow(xi, 2) + pow(yi, 2)) * Ai + 3 * ((ci - xi) * pow(xi, 2) - (ci - 3 * xi) * pow(yi, 2)) * (L2i - L1i));
	Ix0 = (1. / (192 * pow(ci, 3) * M_PI)) * yi * (ci * (-31 * pow(ci, 3) + 52 * pow(ci, 2) * xi - 42 * ci * pow(xi, 2) + 12 * pow(xi, 3) +6 * (7 * ci - 6 * xi) * pow(yi, 2)) 
		+6 * (8 * (ci - xi) * (ci - xi - yi) * yi * (ci - xi + yi) * Ai +((pow(ci - xi, 2)) + 2 * (ci - xi) * yi - pow(yi, 2)) *((pow(ci - xi, 2)) + 2 * (-ci + xi) * yi - pow(yi, 2)) *L2i
			+(-xi * (-2 * ci + xi) * (2 * pow(ci, 2) - 2 * ci * xi + pow(xi, 2)) +6 * pow(ci - xi, 2) * pow(yi, 2) - pow(yi, 4)) * L1i));
	Ix1 = (1. / (192 * pow(ci, 3) * M_PI)) * yi * (
		-ci * (19 * pow(ci, 3) + 36 * pow(ci, 2) * xi + 78 * ci * (-pow(xi, 2) + pow(yi, 2)) + 36 * (pow(xi, 3) - 3 * xi * pow(yi, 2))) +
		6 * (
			8 * yi * (3 * pow(ci - xi, 2) * xi + (2 * ci - 3 * xi) * pow(yi, 2)) * Ai +
			((pow(ci - xi, 3) * (ci + 3 * xi)) + 6 * (ci - 3 * xi) * (ci - xi) * pow(yi, 2) - 3 * pow(yi, 4)) * L2i +
			(pow(xi, 2) * (6 * pow(ci, 2) - 8 * ci * xi + 3 * pow(xi, 2)) - 6 * (ci - 3 * xi) * (ci - xi) * pow(yi, 2) + 3 * pow(yi, 4)) * L1i
			));
	Ix2= (1. / (192 * pow(ci, 3) * M_PI)) * yi * (
		-ci * (13 * pow(ci, 3) + 12 * pow(ci, 2) * xi +30 * ci * (xi - yi) * (xi + yi) -36 * (pow(xi, 3) - 3 * xi * pow(yi, 2))) +
		6 * (
			-8 * yi * (3 * pow(xi, 2) * (-ci + xi) + (ci - 3 * xi) * pow(yi, 2)) * Ai +(pow(ci, 4) - 4 * ci * (pow(xi, 3) - 3 * xi * pow(yi, 2)) +
				3 * (pow(xi, 4) - 6 * pow(xi, 2) * pow(yi, 2) + pow(yi, 4))) * L2i +
			((4 * ci - 3 * xi) * pow(xi, 3) +6 * xi * (-2 * ci + 3 * xi) * pow(yi, 2) -3 * pow(yi, 4)) * L1i
			));
	Iy0 = (1. / (14400 * pow(ci, 3) * M_PI)) * (
		ci * (107 * pow(ci, 4) - 535 * pow(ci, 3) * xi + 10 * pow(ci, 2) * (107 * pow(xi, 2) + 143 * pow(yi, 2)) - 30 * ci * (9 * pow(xi, 3) + 43 * xi * pow(yi, 2)) +
			60 * (pow(xi, 4) + 9 * pow(xi, 2) * pow(yi, 2) - 4 * pow(yi, 4))) +
		30 * (
			8 * pow(yi, 3) * (-5 * pow(ci - xi, 2) + pow(yi, 2)) * Ai -
			(ci - xi) * (pow(ci - xi, 4) + 10 * pow(ci - xi, 2) * pow(yi, 2) - 15 * pow(yi, 4)) *
			L2i -
			(pow(xi, 3) * (10 * pow(ci, 2) - 5 * ci * xi + pow(xi, 2)) + 10 * xi * (3 * pow(ci, 2) - 3 * ci * xi + pow(xi, 2)) * pow(yi, 2) + 15 * (ci - xi) * pow(yi, 4)) * L1i
			));

	Iy1 = (1. / (14400 * pow(ci, 3) * M_PI)) * (
		ci * (261 * pow(ci, 4) - 830 * pow(ci, 3) * xi +
			10 * pow(ci, 2) * (71 * pow(xi, 2) + 89 * pow(yi, 2)) + 120 * ci * (2 * pow(xi, 3) + 9 * xi * pow(yi, 2)) - 120 * (pow(xi, 4) + 9 * pow(xi, 2) * pow(yi, 2) - 4 * pow(yi, 4))) -
		480 * pow(yi, 3) * (5 * (ci - xi) * xi + pow(yi, 2)) * Ai -
		30 * ((pow(ci - xi, 4) * (3 * ci + 2 * xi)) + 10 * pow(ci - xi, 2) * (ci + 2 * xi) * pow(yi, 2) + 15 * (ci - 2 * xi) * pow(yi, 4)) * L2i -
		30 * ((5 * ci - 2 * xi) * pow(xi, 4) + 10 * (3 * ci - 2 * xi) * pow(xi, 2) * pow(yi, 2) - 15 * (ci - 2 * xi) * pow(yi, 4)) * L1i
		);
	Iy2 = (1. / (14400 * pow(ci, 3) * M_PI)) * (
		ci * (432 * pow(ci, 4) - 1035 * pow(ci, 3) * xi + 20 * pow(ci, 2) * (31 * pow(xi, 2) + 34 * pow(yi, 2)) + 30 * ci * (pow(xi, 3) + 7 * xi * pow(yi, 2)) +
			60 * (pow(xi, 4) + 9 * pow(xi, 2) * pow(yi, 2) - 4 * pow(yi, 4))) +
		240 * pow(yi, 3) * (-5 * pow(xi, 2) + pow(yi, 2)) * Ai -
		30 * ((pow(ci - xi, 3) * (6 * pow(ci, 2) + 3 * ci * xi + pow(xi, 2))) + 10 * (pow(ci, 3) - pow(xi, 3)) * pow(yi, 2) + 15 * xi * pow(yi, 4)) * L2i -
		30 * xi * (pow(xi, 4) + 10 * pow(xi, 2) * pow(yi, 2) - 15 * pow(yi, 4)) * L1i
		);
	Ie1 = (1. / (36 * pow(ci, 3) * M_PI)) * (
		ci * (5 * pow(ci, 2) + 12 * ci * xi + 12 * (-pow(xi, 2) + pow(yi, 2))) -
		12 * yi * (3 * (ci - xi) * xi + pow(yi, 2)) * Ai -
		3 * ((pow(ci - xi, 2) * (ci + 2 * xi)) + 3 * (ci - 2 * xi) * pow(yi, 2)) * L2i +
		3 * (-3 * ci * pow(xi, 2) + 2 * pow(xi, 3) + 3 * ci * pow(yi, 2) - 6 * xi * pow(yi, 2)) * L1i
		);
	Ie2= (1. / (36 * pow(ci, 3) * M_PI)) * (
		ci * (2 * pow(ci, 2) + 3 * ci * xi + 6 * pow(xi, 2) - 6 * pow(yi, 2)) +
		6 * yi * (-3 * pow(xi, 2) + pow(yi, 2)) * Ai -
		3 * (pow(ci, 3) - pow(xi, 3) + 3 * xi * pow(yi, 2)) * L2i -
		3 * xi * (pow(xi, 2) - 3 * pow(yi, 2)) * L1i
		);
	values[0] = Ic0 + Ic0_1;
	values[1] = Ic1;
	values[2] = Ic2;
	values[3] = It0 + It0_1;
	values[4] = It1;
	values[5] = It2;
	values[6] = Ix0 + Ix0_1;
	values[7] = Ix1;
	values[8] = Ix2;
	values[9] = Iy0;
	values[10] = Iy1;
	values[11] = Iy2;
	values[12] = values[0];
	values[13] = values[1];
	values[14] = values[2];
	values[15] = It0 / (-3);
	values[16] = Ie1;
	values[17] = Ie2;
}

//使用了新的t0,t1,t2
void CalBiharmonicThirdBasisNew(OpenMesh::Vec2d& v0, OpenMesh::Vec2d& v1, OpenMesh::Vec2d& v2, OpenMesh::Vec2d& eta,
	std::vector<double>& values) {
	values.resize(18);
	//v0 = OpenMesh::Vec2d(0, 2); v1 = OpenMesh::Vec2d(0, 0); v2 = OpenMesh::Vec2d(2, 0); eta = OpenMesh::Vec2d(1, 1);
	OpenMesh::Vec2d ei, ui, xiyi;
	double ci, L1i, L2i, Ai, xi, yi, Ic0, Ic0_1, Ic1, Ic2, It0_1, It0, It1, It2,
		Ix0_1, Ix0, Ix1, Ix2, Iy0, Iy1, Iy2, Ie1, Ie2, hatphiBH_1, hatphiH, hatphiBH;
	{//计算前一个phi的值
		ei = v1 - v0;
		ci = ei.norm();
		ui = eta - v0;
		xiyi = OpenMesh::Vec2d(ui[0] * ei[0] + ui[1] * ei[1], ui[1] * ei[0] - ui[0] * ei[1]);
		xiyi = xiyi / ci;
		xi = xiyi[0];
		yi = xiyi[1];
		L1i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1]);
		L2i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1] + ci * ci - 2 * ci * xiyi[0]);
		Ai = atan(xiyi[0] / xiyi[1]) + atan((ci - xiyi[0]) / xiyi[1]);
		Ic0_1 = (1. / (4 * pow(ci, 3) * M_PI)) * (ci * (ci + 4 * xi) * yi + 2 * (pow(xi, 3) - 3 * xi * pow(yi, 2)) * Ai -
			yi * (-3 * pow(xi, 2) + pow(yi, 2)) * (L2i - L1i));
		It0_1 = -(1. / (12 * pow(ci, 3) * M_PI)) * (-ci * (2 * pow(ci, 2) + 3 * ci * xi + 6 * pow(xi, 2) - 6 * pow(yi, 2)) -
			6 * yi * (-3 * pow(xi, 2) + pow(yi, 2)) * Ai + 3 * (pow(ci, 3) - pow(xi, 3) + 3 * xi * pow(yi, 2)) * L2i + 3 * xi * (pow(xi, 2) - 3 * pow(yi, 2)) * L1i);
		Ix0_1 = (1. / (192 * pow(ci, 3) * M_PI)) * yi * (
			-ci * (9 * pow(ci, 3) + 4 * pow(ci, 2) * xi + 6 * ci * pow(xi, 2) + 12 * pow(xi, 3)) + 6 * ci * (ci + 6 * xi) * pow(yi, 2) +
			48 * xi * (xi - yi) * yi * (xi + yi) * Ai + 6 * pow(ci, 4) * L2i + 6 * (pow(xi, 4) - 6 * pow(xi, 2) * pow(yi, 2) + pow(yi, 4)) * (-L2i + L1i));
	}
	ei = v2 - v1;
	ci = ei.norm();
	ui = eta - v1;
	xiyi = OpenMesh::Vec2d(ui[0] * ei[0] + ui[1] * ei[1], ui[1] * ei[0] - ui[0] * ei[1]);
	xiyi = xiyi / ci;
	xi = xiyi[0];
	yi = xiyi[1];
	L1i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1]);
	L2i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1] + ci * ci - 2 * ci * xiyi[0]);
	Ai = atan(xiyi[0] / xiyi[1]) + atan((ci - xiyi[0]) / xiyi[1]);
	Ic0 = (ci * (5 * ci - 4 * xi) * yi + 2 * (ci - xi) * (pow(ci - xi, 2) - 3 * pow(yi, 2)) * Ai + yi * (-3 * pow(ci - xi, 2) + pow(yi, 2)) * (L2i - L1i)) / (4 * pow(ci, 3) * M_PI);
	Ic1 = (1. / (4 * pow(ci, 3) * M_PI)) * 3 * (ci * (-3 * ci + 4 * xi) * yi +
		2 * ((pow(ci - xi, 2) * xi) + (2 * ci - 3 * xi) * pow(yi, 2)) * Ai + yi * (-(ci - 3 * xi) * (ci - xi) + pow(yi, 2)) * (L1i - L2i));
	Ic2 = (1. / (4 * pow(ci, 3) * M_PI)) * (-6 * (pow(xi, 3) - 3 * xi * pow(yi, 2) + ci * (-pow(xi, 2) + pow(yi, 2))) * Ai +
		3 * yi * (ci * (ci - 4 * xi) - (2 * ci * xi - 3 * pow(xi, 2) + pow(yi, 2)) * L1i + (2 * ci * xi - 3 * pow(xi, 2) + pow(yi, 2)) * L2i));
	/*It0 = (1. / (12 * pow(ci, 3) * M_PI)) * (ci * (-11 * pow(ci, 2) + 15 * ci * xi - 6 * pow(xi, 2) + 6 * pow(yi, 2)) -
		6 * yi * (-3 * pow(ci - xi, 2) + pow(yi, 2)) * Ai + 3 * (ci - xi) * (pow(ci - xi, 2) - 3 * pow(yi, 2)) * L2i +
		3 * (xi * (3 * pow(ci, 2) - 3 * ci * xi + pow(xi, 2)) + 3 * (ci - xi) * pow(yi, 2)) * L1i);
	It1 = -(1. / (4 * pow(ci, 3) * M_PI)) * 3 * ((1. / 3) * ci * (-2 * pow(ci, 2) + 9 * ci * xi - 6 * pow(xi, 2) + 6 * pow(yi, 2)) +
		2 * yi * (pow(ci, 2) - 4 * ci * xi + 3 * pow(xi, 2) - pow(yi, 2)) * Ai - ((pow(ci - xi, 2) * xi) + (2 * ci - 3 * xi) * pow(yi, 2)) * (L2i - L1i));
	It2 = (1. / (4 * pow(ci, 3) * M_PI)) * (ci * (pow(ci, 2) + 3 * ci * xi - 6 * pow(xi, 2) + 6 * pow(yi, 2)) -
		6 * yi * (2 * ci * xi - 3 * pow(xi, 2) + pow(yi, 2)) * Ai + 3 * ((ci - xi) * pow(xi, 2) - (ci - 3 * xi) * pow(yi, 2)) * (L2i - L1i));*/
	It0= -(1. / (12 * pow(ci, 3) * M_PI)) * (ci * (-11 * pow(ci, 2) + 15 * ci * xi - 6 * pow(xi, 2) + 6 * pow(yi, 2)) -
		6 * yi * (-3 * pow(ci - xi, 2) + pow(yi, 2)) * Ai + 3 * (ci - xi) * (pow(ci - xi, 2) - 3 * pow(yi, 2)) * L2i +
		3 * (xi * (3 * pow(ci, 2) - 3 * ci * xi + pow(xi, 2)) + 3 * (ci - xi) * pow(yi, 2)) * L1i);//new
	It1 = -(-5 * pow(ci, 3) - 12 * pow(ci, 2) * xi + 12 * ci * pow(xi, 2) - 12 * ci * pow(yi, 2) +
		12 * Ai * yi * (3 * ci * xi - 3 * pow(xi, 2) + pow(yi, 2)) +
		L2i * (3 * pow(ci, 3) - 9 * ci * pow(xi, 2) + 6 * pow(xi, 3) + 9 * ci * pow(yi, 2) - 18 * xi * pow(yi, 2)) +
		L1i * (9 * ci * pow(xi, 2) - 6 * pow(xi, 3) - 9 * ci * pow(yi, 2) + 18 * xi * pow(yi, 2))) / (12. * pow(ci, 3) * M_PI);//new
	It2= -(1. / (12 * pow(ci, 3) * M_PI)) * (-ci * (2 * pow(ci, 2) + 3 * ci * xi + 6 * pow(xi, 2) - 6 * pow(yi, 2)) -
		6 * yi * (-3 * pow(xi, 2) + pow(yi, 2)) * Ai + 3 * (pow(ci, 3) - pow(xi, 3) + 3 * xi * pow(yi, 2)) * L2i + 3 * xi * (pow(xi, 2) - 3 * pow(yi, 2)) * L1i);//new
	Ix0 = (1. / (192 * pow(ci, 3) * M_PI)) * yi * (ci * (-31 * pow(ci, 3) + 52 * pow(ci, 2) * xi - 42 * ci * pow(xi, 2) + 12 * pow(xi, 3) + 6 * (7 * ci - 6 * xi) * pow(yi, 2))
		+ 6 * (8 * (ci - xi) * (ci - xi - yi) * yi * (ci - xi + yi) * Ai + ((pow(ci - xi, 2)) + 2 * (ci - xi) * yi - pow(yi, 2)) * ((pow(ci - xi, 2)) + 2 * (-ci + xi) * yi - pow(yi, 2)) * L2i
			+ (-xi * (-2 * ci + xi) * (2 * pow(ci, 2) - 2 * ci * xi + pow(xi, 2)) + 6 * pow(ci - xi, 2) * pow(yi, 2) - pow(yi, 4)) * L1i));
	Ix1 = (1. / (192 * pow(ci, 3) * M_PI)) * yi * (
		-ci * (19 * pow(ci, 3) + 36 * pow(ci, 2) * xi + 78 * ci * (-pow(xi, 2) + pow(yi, 2)) + 36 * (pow(xi, 3) - 3 * xi * pow(yi, 2))) +
		6 * (
			8 * yi * (3 * pow(ci - xi, 2) * xi + (2 * ci - 3 * xi) * pow(yi, 2)) * Ai +
			((pow(ci - xi, 3) * (ci + 3 * xi)) + 6 * (ci - 3 * xi) * (ci - xi) * pow(yi, 2) - 3 * pow(yi, 4)) * L2i +
			(pow(xi, 2) * (6 * pow(ci, 2) - 8 * ci * xi + 3 * pow(xi, 2)) - 6 * (ci - 3 * xi) * (ci - xi) * pow(yi, 2) + 3 * pow(yi, 4)) * L1i
			));
	Ix2 = (1. / (192 * pow(ci, 3) * M_PI)) * yi * (
		-ci * (13 * pow(ci, 3) + 12 * pow(ci, 2) * xi + 30 * ci * (xi - yi) * (xi + yi) - 36 * (pow(xi, 3) - 3 * xi * pow(yi, 2))) +
		6 * (
			-8 * yi * (3 * pow(xi, 2) * (-ci + xi) + (ci - 3 * xi) * pow(yi, 2)) * Ai + (pow(ci, 4) - 4 * ci * (pow(xi, 3) - 3 * xi * pow(yi, 2)) +
				3 * (pow(xi, 4) - 6 * pow(xi, 2) * pow(yi, 2) + pow(yi, 4))) * L2i +
			((4 * ci - 3 * xi) * pow(xi, 3) + 6 * xi * (-2 * ci + 3 * xi) * pow(yi, 2) - 3 * pow(yi, 4)) * L1i
			));
	Iy0 = (1. / (14400 * pow(ci, 3) * M_PI)) * (
		ci * (107 * pow(ci, 4) - 535 * pow(ci, 3) * xi + 10 * pow(ci, 2) * (107 * pow(xi, 2) + 143 * pow(yi, 2)) - 30 * ci * (9 * pow(xi, 3) + 43 * xi * pow(yi, 2)) +
			60 * (pow(xi, 4) + 9 * pow(xi, 2) * pow(yi, 2) - 4 * pow(yi, 4))) +
		30 * (
			8 * pow(yi, 3) * (-5 * pow(ci - xi, 2) + pow(yi, 2)) * Ai -
			(ci - xi) * (pow(ci - xi, 4) + 10 * pow(ci - xi, 2) * pow(yi, 2) - 15 * pow(yi, 4)) *
			L2i -
			(pow(xi, 3) * (10 * pow(ci, 2) - 5 * ci * xi + pow(xi, 2)) + 10 * xi * (3 * pow(ci, 2) - 3 * ci * xi + pow(xi, 2)) * pow(yi, 2) + 15 * (ci - xi) * pow(yi, 4)) * L1i
			));

	Iy1 = (1. / (14400 * pow(ci, 3) * M_PI)) * (
		ci * (261 * pow(ci, 4) - 830 * pow(ci, 3) * xi +
			10 * pow(ci, 2) * (71 * pow(xi, 2) + 89 * pow(yi, 2)) + 120 * ci * (2 * pow(xi, 3) + 9 * xi * pow(yi, 2)) - 120 * (pow(xi, 4) + 9 * pow(xi, 2) * pow(yi, 2) - 4 * pow(yi, 4))) -
		480 * pow(yi, 3) * (5 * (ci - xi) * xi + pow(yi, 2)) * Ai -
		30 * ((pow(ci - xi, 4) * (3 * ci + 2 * xi)) + 10 * pow(ci - xi, 2) * (ci + 2 * xi) * pow(yi, 2) + 15 * (ci - 2 * xi) * pow(yi, 4)) * L2i -
		30 * ((5 * ci - 2 * xi) * pow(xi, 4) + 10 * (3 * ci - 2 * xi) * pow(xi, 2) * pow(yi, 2) - 15 * (ci - 2 * xi) * pow(yi, 4)) * L1i
		);
	Iy2 = (1. / (14400 * pow(ci, 3) * M_PI)) * (
		ci * (432 * pow(ci, 4) - 1035 * pow(ci, 3) * xi + 20 * pow(ci, 2) * (31 * pow(xi, 2) + 34 * pow(yi, 2)) + 30 * ci * (pow(xi, 3) + 7 * xi * pow(yi, 2)) +
			60 * (pow(xi, 4) + 9 * pow(xi, 2) * pow(yi, 2) - 4 * pow(yi, 4))) +
		240 * pow(yi, 3) * (-5 * pow(xi, 2) + pow(yi, 2)) * Ai -
		30 * ((pow(ci - xi, 3) * (6 * pow(ci, 2) + 3 * ci * xi + pow(xi, 2))) + 10 * (pow(ci, 3) - pow(xi, 3)) * pow(yi, 2) + 15 * xi * pow(yi, 4)) * L2i -
		30 * xi * (pow(xi, 4) + 10 * pow(xi, 2) * pow(yi, 2) - 15 * pow(yi, 4)) * L1i
		);
	Ie1 = (1. / (36 * pow(ci, 3) * M_PI)) * (
		ci * (5 * pow(ci, 2) + 12 * ci * xi + 12 * (-pow(xi, 2) + pow(yi, 2))) -
		12 * yi * (3 * (ci - xi) * xi + pow(yi, 2)) * Ai -
		3 * ((pow(ci - xi, 2) * (ci + 2 * xi)) + 3 * (ci - 2 * xi) * pow(yi, 2)) * L2i +
		3 * (-3 * ci * pow(xi, 2) + 2 * pow(xi, 3) + 3 * ci * pow(yi, 2) - 6 * xi * pow(yi, 2)) * L1i
		);
	Ie2 = (1. / (36 * pow(ci, 3) * M_PI)) * (
		ci * (2 * pow(ci, 2) + 3 * ci * xi + 6 * pow(xi, 2) - 6 * pow(yi, 2)) +
		6 * yi * (-3 * pow(xi, 2) + pow(yi, 2)) * Ai -
		3 * (pow(ci, 3) - pow(xi, 3) + 3 * xi * pow(yi, 2)) * L2i -
		3 * xi * (pow(xi, 2) - 3 * pow(yi, 2)) * L1i
		);
	values[0] = Ic0 + Ic0_1;
	values[1] = Ic1;
	values[2] = Ic2;
	values[3] = It0 ;
	values[4] = It1;
	values[5] = It2;
	values[6] = Ix0 + Ix0_1;
	values[7] = Ix1;
	values[8] = Ix2;
	values[9] = Iy0;
	values[10] = Iy1;
	values[11] = Iy2;
	values[12] = values[0];
	values[13] = values[1];
	values[14] = values[2];
	values[15] = It0 / (3);
	values[16] = Ie1;
	values[17] = Ie2;
}

//假设eta位于v1到v2的线段上并且参数位置为t即eta=(1-t)v1+t v2 未完成！
void CalBiharmonicThirdBasis_edge(OpenMesh::Vec2d& v0, OpenMesh::Vec2d& v1, OpenMesh::Vec2d& v2, OpenMesh::Vec2d& eta,double t,
	std::vector<double>& values) {
	values.resize(18);
	//v0 = OpenMesh::Vec2d(0, 2); v1 = OpenMesh::Vec2d(0, 0); v2 = OpenMesh::Vec2d(2, 0); eta = OpenMesh::Vec2d(1, 1);
	OpenMesh::Vec2d ei, ui, xiyi;
	double ci, L1i, L2i, Ai, xi, yi, Ic0, Ic0_1, Ic1, Ic2, It0_1, It0, It1, It2,
		Ix0_1, Ix0, Ix1, Ix2, Iy0, Iy1, Iy2, Ie1, Ie2, hatphiBH_1, hatphiH, hatphiBH;
	{//计算前一个phi的值
		ei = v1 - v0;
		ci = ei.norm();
		ui = eta - v0;
		xiyi = OpenMesh::Vec2d(ui[0] * ei[0] + ui[1] * ei[1], ui[1] * ei[0] - ui[0] * ei[1]);
		xiyi = xiyi / ci;
		xi = xiyi[0];
		yi = xiyi[1];
		if (abs(yi) < 1e-10) {
			Ic0_1 = 0;
		}
		L1i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1]);
		L2i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1] + ci * ci - 2 * ci * xiyi[0]);
		Ai = atan(xiyi[0] / xiyi[1]) + atan((ci - xiyi[0]) / xiyi[1]);
		Ic0_1 = (1. / (4 * pow(ci, 3) * M_PI)) * (ci * (ci + 4 * xi) * yi + 2 * (pow(xi, 3) - 3 * xi * pow(yi, 2)) * Ai -
			yi * (-3 * pow(xi, 2) + pow(yi, 2)) * (L2i - L1i));
		It0_1 = -(1. / (12 * pow(ci, 3) * M_PI)) * (-ci * (2 * pow(ci, 2) + 3 * ci * xi + 6 * pow(xi, 2) - 6 * pow(yi, 2)) -
			6 * yi * (-3 * pow(xi, 2) + pow(yi, 2)) * Ai + 3 * (pow(ci, 3) - pow(xi, 3) + 3 * xi * pow(yi, 2)) * L2i + 3 * xi * (pow(xi, 2) - 3 * pow(yi, 2)) * L1i);
		Ix0_1 = (1. / (192 * pow(ci, 3) * M_PI)) * yi * (
			-ci * (9 * pow(ci, 3) + 4 * pow(ci, 2) * xi + 6 * ci * pow(xi, 2) + 12 * pow(xi, 3)) + 6 * ci * (ci + 6 * xi) * pow(yi, 2) +
			48 * xi * (xi - yi) * yi * (xi + yi) * Ai + 6 * pow(ci, 4) * L2i + 6 * (pow(xi, 4) - 6 * pow(xi, 2) * pow(yi, 2) + pow(yi, 4)) * (-L2i + L1i));
	}
	ei = v2 - v1;
	ci = ei.norm();
	ui = eta - v1;
	xiyi = OpenMesh::Vec2d(ui[0] * ei[0] + ui[1] * ei[1], ui[1] * ei[0] - ui[0] * ei[1]);
	xiyi = xiyi / ci;
	xi = xiyi[0];
	yi = xiyi[1];
	L1i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1]);
	L2i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1] + ci * ci - 2 * ci * xiyi[0]);
	Ai = atan(xiyi[0] / xiyi[1]) + atan((ci - xiyi[0]) / xiyi[1]);
	Ic0 = (ci * (5 * ci - 4 * xi) * yi + 2 * (ci - xi) * (pow(ci - xi, 2) - 3 * pow(yi, 2)) * Ai + yi * (-3 * pow(ci - xi, 2) + pow(yi, 2)) * (L2i - L1i)) / (4 * pow(ci, 3) * M_PI);
	Ic1 = (1. / (4 * pow(ci, 3) * M_PI)) * 3 * (ci * (-3 * ci + 4 * xi) * yi +
		2 * ((pow(ci - xi, 2) * xi) + (2 * ci - 3 * xi) * pow(yi, 2)) * Ai + yi * (-(ci - 3 * xi) * (ci - xi) + pow(yi, 2)) * (L1i - L2i));
	Ic2 = (1. / (4 * pow(ci, 3) * M_PI)) * (-6 * (pow(xi, 3) - 3 * xi * pow(yi, 2) + ci * (-pow(xi, 2) + pow(yi, 2))) * Ai +
		3 * yi * (ci * (ci - 4 * xi) - (2 * ci * xi - 3 * pow(xi, 2) + pow(yi, 2)) * L1i + (2 * ci * xi - 3 * pow(xi, 2) + pow(yi, 2)) * L2i));
	/*It0 = (1. / (12 * pow(ci, 3) * M_PI)) * (ci * (-11 * pow(ci, 2) + 15 * ci * xi - 6 * pow(xi, 2) + 6 * pow(yi, 2)) -
		6 * yi * (-3 * pow(ci - xi, 2) + pow(yi, 2)) * Ai + 3 * (ci - xi) * (pow(ci - xi, 2) - 3 * pow(yi, 2)) * L2i +
		3 * (xi * (3 * pow(ci, 2) - 3 * ci * xi + pow(xi, 2)) + 3 * (ci - xi) * pow(yi, 2)) * L1i);
	It1 = -(1. / (4 * pow(ci, 3) * M_PI)) * 3 * ((1. / 3) * ci * (-2 * pow(ci, 2) + 9 * ci * xi - 6 * pow(xi, 2) + 6 * pow(yi, 2)) +
		2 * yi * (pow(ci, 2) - 4 * ci * xi + 3 * pow(xi, 2) - pow(yi, 2)) * Ai - ((pow(ci - xi, 2) * xi) + (2 * ci - 3 * xi) * pow(yi, 2)) * (L2i - L1i));
	It2 = (1. / (4 * pow(ci, 3) * M_PI)) * (ci * (pow(ci, 2) + 3 * ci * xi - 6 * pow(xi, 2) + 6 * pow(yi, 2)) -
		6 * yi * (2 * ci * xi - 3 * pow(xi, 2) + pow(yi, 2)) * Ai + 3 * ((ci - xi) * pow(xi, 2) - (ci - 3 * xi) * pow(yi, 2)) * (L2i - L1i));*/
	It0 = -(1. / (12 * pow(ci, 3) * M_PI)) * (ci * (-11 * pow(ci, 2) + 15 * ci * xi - 6 * pow(xi, 2) + 6 * pow(yi, 2)) -
		6 * yi * (-3 * pow(ci - xi, 2) + pow(yi, 2)) * Ai + 3 * (ci - xi) * (pow(ci - xi, 2) - 3 * pow(yi, 2)) * L2i +
		3 * (xi * (3 * pow(ci, 2) - 3 * ci * xi + pow(xi, 2)) + 3 * (ci - xi) * pow(yi, 2)) * L1i);//new
	It1 = -(-5 * pow(ci, 3) - 12 * pow(ci, 2) * xi + 12 * ci * pow(xi, 2) - 12 * ci * pow(yi, 2) +
		12 * Ai * yi * (3 * ci * xi - 3 * pow(xi, 2) + pow(yi, 2)) +
		L2i * (3 * pow(ci, 3) - 9 * ci * pow(xi, 2) + 6 * pow(xi, 3) + 9 * ci * pow(yi, 2) - 18 * xi * pow(yi, 2)) +
		L1i * (9 * ci * pow(xi, 2) - 6 * pow(xi, 3) - 9 * ci * pow(yi, 2) + 18 * xi * pow(yi, 2))) / (12. * pow(ci, 3) * M_PI);//new
	It2 = -(1. / (12 * pow(ci, 3) * M_PI)) * (-ci * (2 * pow(ci, 2) + 3 * ci * xi + 6 * pow(xi, 2) - 6 * pow(yi, 2)) -
		6 * yi * (-3 * pow(xi, 2) + pow(yi, 2)) * Ai + 3 * (pow(ci, 3) - pow(xi, 3) + 3 * xi * pow(yi, 2)) * L2i + 3 * xi * (pow(xi, 2) - 3 * pow(yi, 2)) * L1i);//new
	Ix0 = (1. / (192 * pow(ci, 3) * M_PI)) * yi * (ci * (-31 * pow(ci, 3) + 52 * pow(ci, 2) * xi - 42 * ci * pow(xi, 2) + 12 * pow(xi, 3) + 6 * (7 * ci - 6 * xi) * pow(yi, 2))
		+ 6 * (8 * (ci - xi) * (ci - xi - yi) * yi * (ci - xi + yi) * Ai + ((pow(ci - xi, 2)) + 2 * (ci - xi) * yi - pow(yi, 2)) * ((pow(ci - xi, 2)) + 2 * (-ci + xi) * yi - pow(yi, 2)) * L2i
			+ (-xi * (-2 * ci + xi) * (2 * pow(ci, 2) - 2 * ci * xi + pow(xi, 2)) + 6 * pow(ci - xi, 2) * pow(yi, 2) - pow(yi, 4)) * L1i));
	Ix1 = (1. / (192 * pow(ci, 3) * M_PI)) * yi * (
		-ci * (19 * pow(ci, 3) + 36 * pow(ci, 2) * xi + 78 * ci * (-pow(xi, 2) + pow(yi, 2)) + 36 * (pow(xi, 3) - 3 * xi * pow(yi, 2))) +
		6 * (
			8 * yi * (3 * pow(ci - xi, 2) * xi + (2 * ci - 3 * xi) * pow(yi, 2)) * Ai +
			((pow(ci - xi, 3) * (ci + 3 * xi)) + 6 * (ci - 3 * xi) * (ci - xi) * pow(yi, 2) - 3 * pow(yi, 4)) * L2i +
			(pow(xi, 2) * (6 * pow(ci, 2) - 8 * ci * xi + 3 * pow(xi, 2)) - 6 * (ci - 3 * xi) * (ci - xi) * pow(yi, 2) + 3 * pow(yi, 4)) * L1i
			));
	Ix2 = (1. / (192 * pow(ci, 3) * M_PI)) * yi * (
		-ci * (13 * pow(ci, 3) + 12 * pow(ci, 2) * xi + 30 * ci * (xi - yi) * (xi + yi) - 36 * (pow(xi, 3) - 3 * xi * pow(yi, 2))) +
		6 * (
			-8 * yi * (3 * pow(xi, 2) * (-ci + xi) + (ci - 3 * xi) * pow(yi, 2)) * Ai + (pow(ci, 4) - 4 * ci * (pow(xi, 3) - 3 * xi * pow(yi, 2)) +
				3 * (pow(xi, 4) - 6 * pow(xi, 2) * pow(yi, 2) + pow(yi, 4))) * L2i +
			((4 * ci - 3 * xi) * pow(xi, 3) + 6 * xi * (-2 * ci + 3 * xi) * pow(yi, 2) - 3 * pow(yi, 4)) * L1i
			));
	Iy0 = (1. / (14400 * pow(ci, 3) * M_PI)) * (
		ci * (107 * pow(ci, 4) - 535 * pow(ci, 3) * xi + 10 * pow(ci, 2) * (107 * pow(xi, 2) + 143 * pow(yi, 2)) - 30 * ci * (9 * pow(xi, 3) + 43 * xi * pow(yi, 2)) +
			60 * (pow(xi, 4) + 9 * pow(xi, 2) * pow(yi, 2) - 4 * pow(yi, 4))) +
		30 * (
			8 * pow(yi, 3) * (-5 * pow(ci - xi, 2) + pow(yi, 2)) * Ai -
			(ci - xi) * (pow(ci - xi, 4) + 10 * pow(ci - xi, 2) * pow(yi, 2) - 15 * pow(yi, 4)) *
			L2i -
			(pow(xi, 3) * (10 * pow(ci, 2) - 5 * ci * xi + pow(xi, 2)) + 10 * xi * (3 * pow(ci, 2) - 3 * ci * xi + pow(xi, 2)) * pow(yi, 2) + 15 * (ci - xi) * pow(yi, 4)) * L1i
			));

	Iy1 = (1. / (14400 * pow(ci, 3) * M_PI)) * (
		ci * (261 * pow(ci, 4) - 830 * pow(ci, 3) * xi +
			10 * pow(ci, 2) * (71 * pow(xi, 2) + 89 * pow(yi, 2)) + 120 * ci * (2 * pow(xi, 3) + 9 * xi * pow(yi, 2)) - 120 * (pow(xi, 4) + 9 * pow(xi, 2) * pow(yi, 2) - 4 * pow(yi, 4))) -
		480 * pow(yi, 3) * (5 * (ci - xi) * xi + pow(yi, 2)) * Ai -
		30 * ((pow(ci - xi, 4) * (3 * ci + 2 * xi)) + 10 * pow(ci - xi, 2) * (ci + 2 * xi) * pow(yi, 2) + 15 * (ci - 2 * xi) * pow(yi, 4)) * L2i -
		30 * ((5 * ci - 2 * xi) * pow(xi, 4) + 10 * (3 * ci - 2 * xi) * pow(xi, 2) * pow(yi, 2) - 15 * (ci - 2 * xi) * pow(yi, 4)) * L1i
		);
	Iy2 = (1. / (14400 * pow(ci, 3) * M_PI)) * (
		ci * (432 * pow(ci, 4) - 1035 * pow(ci, 3) * xi + 20 * pow(ci, 2) * (31 * pow(xi, 2) + 34 * pow(yi, 2)) + 30 * ci * (pow(xi, 3) + 7 * xi * pow(yi, 2)) +
			60 * (pow(xi, 4) + 9 * pow(xi, 2) * pow(yi, 2) - 4 * pow(yi, 4))) +
		240 * pow(yi, 3) * (-5 * pow(xi, 2) + pow(yi, 2)) * Ai -
		30 * ((pow(ci - xi, 3) * (6 * pow(ci, 2) + 3 * ci * xi + pow(xi, 2))) + 10 * (pow(ci, 3) - pow(xi, 3)) * pow(yi, 2) + 15 * xi * pow(yi, 4)) * L2i -
		30 * xi * (pow(xi, 4) + 10 * pow(xi, 2) * pow(yi, 2) - 15 * pow(yi, 4)) * L1i
		);
	Ie1 = (1. / (36 * pow(ci, 3) * M_PI)) * (
		ci * (5 * pow(ci, 2) + 12 * ci * xi + 12 * (-pow(xi, 2) + pow(yi, 2))) -
		12 * yi * (3 * (ci - xi) * xi + pow(yi, 2)) * Ai -
		3 * ((pow(ci - xi, 2) * (ci + 2 * xi)) + 3 * (ci - 2 * xi) * pow(yi, 2)) * L2i +
		3 * (-3 * ci * pow(xi, 2) + 2 * pow(xi, 3) + 3 * ci * pow(yi, 2) - 6 * xi * pow(yi, 2)) * L1i
		);
	Ie2 = (1. / (36 * pow(ci, 3) * M_PI)) * (
		ci * (2 * pow(ci, 2) + 3 * ci * xi + 6 * pow(xi, 2) - 6 * pow(yi, 2)) +
		6 * yi * (-3 * pow(xi, 2) + pow(yi, 2)) * Ai -
		3 * (pow(ci, 3) - pow(xi, 3) + 3 * xi * pow(yi, 2)) * L2i -
		3 * xi * (pow(xi, 2) - 3 * pow(yi, 2)) * L1i
		);
	values[0] = Ic0 + Ic0_1;
	values[1] = Ic1;
	values[2] = Ic2;
	values[3] = It0;
	values[4] = It1;
	values[5] = It2;
	values[6] = Ix0 + Ix0_1;
	values[7] = Ix1;
	values[8] = Ix2;
	values[9] = Iy0;
	values[10] = Iy1;
	values[11] = Iy2;
	values[12] = values[0];
	values[13] = values[1];
	values[14] = values[2];
	values[15] = It0 / (3);
	values[16] = Ie1;
	values[17] = Ie2;
}


//使用了新的t0,t1,t2
void CalBiharmonicFourthBasisNew(OpenMesh::Vec2d& v0, OpenMesh::Vec2d& v1, OpenMesh::Vec2d& v2, OpenMesh::Vec2d& eta,
	std::vector<double>& values) {
	values.resize(24);
	//v0 = OpenMesh::Vec2d(0, 2); v1 = OpenMesh::Vec2d(0, 0); v2 = OpenMesh::Vec2d(2, 0); eta = OpenMesh::Vec2d(1, 1);
	OpenMesh::Vec2d ei, ui, xiyi;
	double ci, L1i, L2i, Ai, xi, yi, Ic0, Ic0_1, Ic1, Ic2,Ic3,  It0, It1, It2,It3,
		Ix0_1, Ix0, Ix1, Ix2,Ix3, Iy0, Iy1, Iy2,Iy3, Ie1, Ie2,Ie3, hatphiBH_1, hatphiH, hatphiBH;
	{//计算前一个phi的值
		ei = v1 - v0;
		ci = ei.norm();
		ui = eta - v0;
		xiyi = OpenMesh::Vec2d(ui[0] * ei[0] + ui[1] * ei[1], ui[1] * ei[0] - ui[0] * ei[1]);
		xiyi = xiyi / ci;
		xi = xiyi[0];
		yi = xiyi[1];
		L1i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1]);
		L2i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1] + ci * ci - 2 * ci * xiyi[0]);
		Ai = atan(xiyi[0] / xiyi[1]) + atan((ci - xiyi[0]) / xiyi[1]);
		Ic0_1 = (3 * Ai * (pow(xi, 4) - 6 * pow(xi, 2) * pow(yi, 2) + pow(yi, 4)) +
			yi * (ci * (pow(ci, 2) + 3 * ci * xi + 9 * pow(xi, 2) - 3 * pow(yi, 2)) - 6 * L1i * (pow(xi, 3) - xi * pow(yi, 2)) +
				6 * L2i * (pow(xi, 3) - xi * pow(yi, 2)))) / (6. * pow(ci, 4) * M_PI);
		Ix0_1 = (yi * (-42 * pow(ci, 5) - 15 * pow(ci, 4) * xi + 20 * pow(ci, 3) * (-pow(xi, 2) + pow(yi, 2)) -
			30 * pow(ci, 2) * (pow(xi, 3) - 3 * xi * pow(yi, 2)) +
			60 * Ai * yi * (5 * pow(xi, 4) - 10 * pow(xi, 2) * pow(yi, 2) + pow(yi, 4)) -
			60 * ci * (pow(xi, 4) - 6 * pow(xi, 2) * pow(yi, 2) + pow(yi, 4)) +
			30 * (pow(ci, 5) - pow(xi, 5) + 10 * pow(xi, 3) * pow(yi, 2) - 5 * xi * pow(yi, 4)) *
			L2i + 30 * xi * (pow(xi, 4) - 10 * pow(xi, 2) * pow(yi, 2) + 5 * pow(yi, 4)) *
			L1i)) / (1200. * pow(ci, 4) * M_PI);
	}
	ei = v2 - v1;
	ci = ei.norm();
	ui = eta - v1;
	xiyi = OpenMesh::Vec2d(ui[0] * ei[0] + ui[1] * ei[1], ui[1] * ei[0] - ui[0] * ei[1]);
	xiyi = xiyi / ci;
	xi = xiyi[0];
	yi = xiyi[1];
	L1i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1]);
	L2i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1] + ci * ci - 2 * ci * xiyi[0]);
	Ai = atan(xiyi[0] / xiyi[1]) + atan((ci - xiyi[0]) / xiyi[1]);
	Ic0 = (yi * (ci * (13 * pow(ci, 2) - 21 * ci * xi + 9 * pow(xi, 2) - 3 * pow(yi, 2)) +
		6 * L1i * (ci - xi) * (pow(ci, 2) - 2 * ci * xi + pow(xi, 2) - pow(yi, 2)) -
		6 * L2i * (ci - xi) * (pow(ci, 2) - 2 * ci * xi + pow(xi, 2) - pow(yi, 2))) +
		3 * Ai * (pow(ci, 4) - 4 * pow(ci, 3) * xi + pow(xi, 4) - 6 * pow(xi, 2) * pow(yi, 2) + pow(yi, 4) +
			6 * pow(ci, 2) * (pow(xi, 2) - pow(yi, 2)) - 4 * ci * (pow(xi, 3) - 3 * xi * pow(yi, 2)))) / (6. * pow(ci, 4) * M_PI);
	Ic1 = (6 * Ai * (pow(ci, 3) * xi - pow(xi, 4) + 6 * pow(xi, 2) * pow(yi, 2) - pow(yi, 4) -
		3 * pow(ci, 2) * (pow(xi, 2) - pow(yi, 2)) + 3 * ci * (pow(xi, 3) - 3 * xi * pow(yi, 2))) +
		yi * (-3 * L1i * (pow(ci, 3) - 6 * pow(ci, 2) * xi + 9 * ci * pow(xi, 2) - 4 * pow(xi, 3) - 3 * ci * pow(yi, 2) +
			4 * xi * pow(yi, 2)) + 3 * L2i * (pow(ci, 3) - 6 * pow(ci, 2) * xi + 9 * ci * pow(xi, 2) - 4 * pow(xi, 3) -
				3 * ci * pow(yi, 2) + 4 * xi * pow(yi, 2)) + ci * (-11 * pow(ci, 2) + 30 * ci * xi + 6 * (-3 * pow(xi, 2) + pow(yi, 2))))) /
		(3. * pow(ci, 4) * M_PI);
	Ic2 = (3 * Ai * (pow(xi, 4) - 6 * pow(xi, 2) * pow(yi, 2) + pow(yi, 4) + pow(ci, 2) * (pow(xi, 2) - pow(yi, 2)) -
		2 * ci * (pow(xi, 3) - 3 * xi * pow(yi, 2))) + yi *
		(ci * (pow(ci, 2) - 9 * ci * xi + 9 * pow(xi, 2) - 3 * pow(yi, 2)) -
			3 * L1i * (pow(ci, 2) * xi - 3 * ci * pow(xi, 2) + 2 * pow(xi, 3) + ci * pow(yi, 2) - 2 * xi * pow(yi, 2)) +
			3 * L2i * (pow(ci, 2) * xi - 3 * ci * pow(xi, 2) + 2 * pow(xi, 3) + ci * pow(yi, 2) - 2 * xi * pow(yi, 2)))) / (pow(ci, 4) * M_PI);
	Ic3 = (-6 * Ai * (-(ci * pow(xi, 3)) + pow(xi, 4) + 3 * ci * xi * pow(yi, 2) - 6 * pow(xi, 2) * pow(yi, 2) + pow(yi, 4)) +
		yi * (ci * (pow(ci, 2) + 6 * ci * xi - 18 * pow(xi, 2) + 6 * pow(yi, 2)) -
			3 * L1i * (3 * ci * pow(xi, 2) - 4 * pow(xi, 3) - ci * pow(yi, 2) + 4 * xi * pow(yi, 2)) +
			3 * L2i * (3 * ci * pow(xi, 2) - 4 * pow(xi, 3) - ci * pow(yi, 2) + 4 * xi * pow(yi, 2)))) / (3. * pow(ci, 4) * M_PI);
	It0 = -(-25 * pow(ci, 4) + 52 * pow(ci, 3) * xi - 42 * pow(ci, 2) * pow(xi, 2) + 12 * ci * pow(xi, 3) + 42 * pow(ci, 2) * pow(yi, 2) -
		36 * ci * xi * pow(yi, 2) + 48 * Ai * (ci - xi) * yi * (pow(ci, 2) - 2 * ci * xi + pow(xi, 2) - pow(yi, 2)) +
		24 * pow(ci, 3) * xi * L1i - 36 * pow(ci, 2) * pow(xi, 2) * L1i +
		24 * ci * pow(xi, 3) * L1i - 6 * pow(xi, 4) * L1i +
		36 * pow(ci, 2) * pow(yi, 2) * L1i - 72 * ci * xi * pow(yi, 2) * L1i +
		36 * pow(xi, 2) * pow(yi, 2) * L1i - 6 * pow(yi, 4) * L1i +
		6 * pow(ci, 4) * L2i -
		24 * pow(ci, 3) * xi * L2i +
		36 * pow(ci, 2) * pow(xi, 2) * L2i -
		24 * ci * pow(xi, 3) * L2i +
		6 * pow(xi, 4) * L2i -
		36 * pow(ci, 2) * pow(yi, 2) * L2i +
		72 * ci * xi * pow(yi, 2) * L2i -
		36 * pow(xi, 2) * pow(yi, 2) * L2i +
		6 * pow(yi, 4) * L2i) / (24. * pow(ci, 4) * M_PI);//new
	It1 = -(-13 * pow(ci, 4) - 36 * pow(ci, 3) * xi + 78 * pow(ci, 2) * pow(xi, 2) - 36 * ci * pow(xi, 3) - 78 * pow(ci, 2) * pow(yi, 2) +
		108 * ci * xi * pow(yi, 2) + 48 * Ai * yi * (3 * pow(ci, 2) * xi - 6 * ci * pow(xi, 2) + 3 * pow(xi, 3) + 2 * ci * pow(yi, 2) -
			3 * xi * pow(yi, 2)) + 36 * pow(ci, 2) * pow(xi, 2) * L1i -
		48 * ci * pow(xi, 3) * L1i + 18 * pow(xi, 4) * L1i -
		36 * pow(ci, 2) * pow(yi, 2) * L1i + 144 * ci * xi * pow(yi, 2) * L1i -
		108 * pow(xi, 2) * pow(yi, 2) * L1i + 18 * pow(yi, 4) * L1i +
		6 * pow(ci, 4) * L2i -
		36 * pow(ci, 2) * pow(xi, 2) * L2i +
		48 * ci * pow(xi, 3) * L2i -
		18 * pow(xi, 4) * L2i +
		36 * pow(ci, 2) * pow(yi, 2) * L2i -
		144 * ci * xi * pow(yi, 2) * L2i +
		108 * pow(xi, 2) * pow(yi, 2) * L2i -
		18 * pow(yi, 4) * L2i) / (24. * pow(ci, 4) * M_PI);//new
	It2 = (7 * pow(ci, 4) + 12 * pow(ci, 3) * xi + 30 * pow(ci, 2) * pow(xi, 2) - 36 * ci * pow(xi, 3) - 30 * pow(ci, 2) * pow(yi, 2) +
		108 * ci * xi * pow(yi, 2) + 48 * Ai * yi * (-3 * ci * pow(xi, 2) + 3 * pow(xi, 3) + ci * pow(yi, 2) - 3 * xi * pow(yi, 2)) -
		24 * ci * pow(xi, 3) * L1i + 18 * pow(xi, 4) * L1i +
		72 * ci * xi * pow(yi, 2) * L1i - 108 * pow(xi, 2) * pow(yi, 2) * L1i +
		18 * pow(yi, 4) * L1i -
		6 * pow(ci, 4) * L2i +
		24 * ci * pow(xi, 3) * L2i -
		18 * pow(xi, 4) * L2i -
		72 * ci * xi * pow(yi, 2) * L2i +
		108 * pow(xi, 2) * pow(yi, 2) * L2i -
		18 * pow(yi, 4) * L2i) / (24. * pow(ci, 4) * M_PI);//new
	It3 = -(-3 * pow(ci, 4) - 4 * pow(ci, 3) * xi - 6 * pow(ci, 2) * pow(xi, 2) - 12 * ci * pow(xi, 3) + 6 * pow(ci, 2) * pow(yi, 2) +
		36 * ci * xi * pow(yi, 2) + 48 * Ai * xi * yi * (pow(xi, 2) - pow(yi, 2)) + 6 * pow(xi, 4) * L1i -
		36 * pow(xi, 2) * pow(yi, 2) * L1i + 6 * pow(yi, 4) * L1i +
		6 * pow(ci, 4) * L2i -
		6 * pow(xi, 4) * L2i +
		36 * pow(xi, 2) * pow(yi, 2) * L2i -
		6 * pow(yi, 4) * L2i) / (24. * pow(ci, 4) * M_PI);//new
	Ix0 = (yi * (ci * (-167 * pow(ci, 4) + 385 * pow(ci, 3) * xi - 470 * pow(ci, 2) * pow(xi, 2) + 270 * ci * pow(xi, 3) - 60 * pow(xi, 4)) +
		300 * Ai * pow(ci - xi, 4) * yi + 10 * ci * (47 * pow(ci, 2) - 81 * ci * xi + 36 * pow(xi, 2)) * pow(yi, 2) -
		600 * Ai * pow(ci - xi, 2) * pow(yi, 3) - 60 * ci * pow(yi, 4) + 60 * Ai * pow(yi, 5) +
		30 * (ci - xi) * (pow(ci - xi, 4) - 10 * pow(ci - xi, 2) * pow(yi, 2) + 5 * pow(yi, 4)) *
		L2i + 30 * (xi *
			(5 * pow(ci, 4) - 10 * pow(ci, 3) * xi + 10 * pow(ci, 2) * pow(xi, 2) - 5 * ci * pow(xi, 3) + pow(xi, 4)) +
			10 * pow(ci - xi, 3) * pow(yi, 2) + 5 * (-ci + xi) * pow(yi, 4)) * L1i)) /
		(1200. * pow(ci, 4) * M_PI);
	Ix1 = (yi * (ci * (-107 * pow(ci, 4) - 240 * pow(ci, 3) * xi + 830 * pow(ci, 2) * pow(xi, 2) - 780 * ci * pow(xi, 3) + 240 * pow(xi, 4)) +
		1200 * Ai * pow(ci - xi, 3) * xi * yi - 10 * ci * (83 * pow(ci, 2) - 234 * ci * xi + 144 * pow(xi, 2)) * pow(yi, 2) +
		1200 * Ai * (ci - 2 * xi) * (ci - xi) * pow(yi, 3) + 240 * ci * pow(yi, 4) - 240 * Ai * pow(yi, 5) +
		30 * (pow(ci - xi, 4) * (ci + 4 * xi) + 10 * (ci - 4 * xi) * pow(ci - xi, 2) * pow(yi, 2) + 5 * (-3 * ci + 4 * xi) * pow(yi, 4)) *
		L2i + 30 * (pow(xi, 2) *
			(10 * pow(ci, 3) - 20 * pow(ci, 2) * xi + 15 * ci * pow(xi, 2) - 4 * pow(xi, 3)) -
			10 * (ci - 4 * xi) * pow(ci - xi, 2) * pow(yi, 2) + 5 * (3 * ci - 4 * xi) * pow(yi, 4)) * L1i)) /
		(1200. * pow(ci, 4) * M_PI);
	Ix2 = (yi * (-(ci * (77 * pow(ci, 4) + 90 * pow(ci, 3) * xi + 270 * pow(ci, 2) * pow(xi, 2) - 720 * ci * pow(xi, 3) + 360 * pow(xi, 4))) +
		1800 * Ai * pow(ci - xi, 2) * pow(xi, 2) * yi + 270 * ci * (pow(ci, 2) - 8 * ci * xi + 8 * pow(xi, 2)) * pow(yi, 2) -
		600 * Ai * (pow(ci, 2) - 6 * ci * xi + 6 * pow(xi, 2)) * pow(yi, 3) - 360 * ci * pow(yi, 4) + 360 * Ai * pow(yi, 5) +
		30 * (pow(ci - xi, 3) * (pow(ci, 2) + 3 * ci * xi + 6 * pow(xi, 2)) + 30 * (ci - 2 * xi) * (ci - xi) * xi * pow(yi, 2) +
			15 * (ci - 2 * xi) * pow(yi, 4)) * L2i +
		30 * (pow(xi, 3) * (10 * pow(ci, 2) - 15 * ci * xi + 6 * pow(xi, 2)) - 30 * (ci - 2 * xi) * (ci - xi) * xi * pow(yi, 2) -
			15 * (ci - 2 * xi) * pow(yi, 4)) * L1i)) / (1200. * pow(ci, 4) * M_PI);
	Ix3 = (yi * (-57 * pow(ci, 5) - 40 * pow(ci, 4) * xi + 70 * pow(ci, 3) * (-pow(xi, 2) + pow(yi, 2)) -
		180 * pow(ci, 2) * (pow(xi, 3) - 3 * xi * pow(yi, 2)) -
		240 * Ai * yi * (5 * pow(xi, 4) - 10 * pow(xi, 2) * pow(yi, 2) + pow(yi, 4)) +
		240 * ci * (pow(xi, 4) + 5 * Ai * pow(xi, 3) * yi - 6 * pow(xi, 2) * pow(yi, 2) - 5 * Ai * xi * pow(yi, 3) + pow(yi, 4)) +
		30 * (pow(ci, 5) - 5 * ci * (pow(xi, 4) - 6 * pow(xi, 2) * pow(yi, 2) + pow(yi, 4)) +
			4 * (pow(xi, 5) - 10 * pow(xi, 3) * pow(yi, 2) + 5 * xi * pow(yi, 4))) * L2i +
		30 * ((5 * ci - 4 * xi) * pow(xi, 4) + 10 * pow(xi, 2) * (-3 * ci + 4 * xi) * pow(yi, 2) + 5 * (ci - 4 * xi) * pow(yi, 4)) *
		L1i)) / (1200. * pow(ci, 4) * M_PI);
	Iy0 = (ci * (117 * pow(ci, 5) - 702 * pow(ci, 4) * xi + 1755 * pow(ci, 3) * pow(xi, 2) - 740 * pow(ci, 2) * pow(xi, 3) +
		330 * ci * pow(xi, 4) - 60 * pow(xi, 5)) + 15 * ci *
		(157 * pow(ci, 3) - 228 * pow(ci, 2) * xi + 192 * ci * pow(xi, 2) - 56 * pow(xi, 3)) * pow(yi, 2) -
		2400 * Ai * pow(ci - xi, 3) * pow(yi, 3) + 30 * ci * (-43 * ci + 38 * xi) * pow(yi, 4) + 1440 * Ai * (ci - xi) * pow(yi, 5) -
		30 * (pow(ci - xi, 6) + 15 * pow(ci - xi, 4) * pow(yi, 2) - 45 * pow(ci - xi, 2) * pow(yi, 4) + 5 * pow(yi, 6)) *
		L2i - 30 * (-(pow(xi, 3) *
			(-20 * pow(ci, 3) + 15 * pow(ci, 2) * xi - 6 * ci * pow(xi, 2) + pow(xi, 3))) -
			15 * xi * (-2 * ci + xi) * (2 * pow(ci, 2) - 2 * ci * xi + pow(xi, 2)) * pow(yi, 2) + 45 * pow(ci - xi, 2) * pow(yi, 4) -
			5 * pow(yi, 6)) * L1i) / (28800. * pow(ci, 4) * M_PI);
	Iy1 = (ci * (97 * pow(ci, 5) - 368 * pow(ci, 4) * xi + 385 * pow(ci, 3) * pow(xi, 2) + 200 * pow(ci, 2) * pow(xi, 3) -
		210 * ci * pow(xi, 4) + 60 * pow(xi, 5)) + 5 * ci *
		(101 * pow(ci, 3) + 168 * pow(ci, 2) * xi - 360 * ci * pow(xi, 2) + 168 * pow(xi, 3)) * pow(yi, 2) -
		2400 * Ai * pow(ci - xi, 2) * xi * pow(yi, 3) + 30 * ci * (27 * ci - 38 * xi) * pow(yi, 4) + 480 * Ai * (-2 * ci + 3 * xi) * pow(yi, 5) -
		30 * (pow(ci - xi, 5) * (ci + xi) + 5 * pow(ci - xi, 3) * (ci + 3 * xi) * pow(yi, 2) + 15 * (ci - 3 * xi) * (ci - xi) * pow(yi, 4) -
			5 * pow(yi, 6)) * L2i -
		30 * (pow(xi, 4) * (5 * pow(ci, 2) - 4 * ci * xi + pow(xi, 2)) +
			5 * pow(xi, 2) * (6 * pow(ci, 2) - 8 * ci * xi + 3 * pow(xi, 2)) * pow(yi, 2) - 15 * (ci - 3 * xi) * (ci - xi) * pow(yi, 4) +
			5 * pow(yi, 6)) * L1i) / (9600. * pow(ci, 4) * M_PI);
	Iy2 = (ci * (164 * pow(ci, 5) - 462 * pow(ci, 4) * xi + 325 * pow(ci, 3) * pow(xi, 2) + 40 * pow(ci, 2) * pow(xi, 3) + 90 * ci * pow(xi, 4) -
		60 * pow(xi, 5)) + 5 * ci * (77 * pow(ci, 3) + 48 * pow(ci, 2) * xi + 144 * ci * pow(xi, 2) - 168 * pow(xi, 3)) * pow(yi, 2) -
		2400 * Ai * (ci - xi) * pow(xi, 2) * pow(yi, 3) + 30 * ci * (-11 * ci + 38 * xi) * pow(yi, 4) + 480 * Ai * (ci - 3 * xi) * pow(yi, 5) -
		30 * (pow(ci - xi, 4) * (2 * pow(ci, 2) + 2 * ci * xi + pow(xi, 2)) +
			5 * (pow(ci, 4) - 4 * ci * pow(xi, 3) + 3 * pow(xi, 4)) * pow(yi, 2) + 15 * (2 * ci - 3 * xi) * xi * pow(yi, 4) + 5 * pow(yi, 6)) *
		L2i - 30 * ((2 * ci - xi) * pow(xi, 5) + 5 * (4 * ci - 3 * xi) * pow(xi, 3) * pow(yi, 2) +
			15 * xi * (-2 * ci + 3 * xi) * pow(yi, 4) - 5 * pow(yi, 6)) * L1i) / (9600. * pow(ci, 4) * M_PI);
	Iy3 = (700 * pow(ci, 6) - 1608 * pow(ci, 5) * xi + 15 * pow(ci, 4) * (61 * pow(xi, 2) + 65 * pow(yi, 2)) +
		480 * Ai * pow(yi, 3) * (-5 * pow(xi, 3) + 3 * xi * pow(yi, 2)) + 20 * pow(ci, 3) * (pow(xi, 3) + 9 * xi * pow(yi, 2)) +
		30 * pow(ci, 2) * (pow(xi, 4) + 12 * pow(xi, 2) * pow(yi, 2) - 5 * pow(yi, 4)) +
		60 * ci * (pow(xi, 5) + 14 * pow(xi, 3) * pow(yi, 2) - 19 * xi * pow(yi, 4)) -
		30 * (10 * pow(ci, 6) - 24 * pow(ci, 5) * xi - pow(xi, 6) - 15 * pow(xi, 4) * pow(yi, 2) + 45 * pow(xi, 2) * pow(yi, 4) -
			5 * pow(yi, 6) + 15 * pow(ci, 4) * (pow(xi, 2) + pow(yi, 2))) * L2i -
		30 * (pow(xi, 6) + 15 * pow(xi, 4) * pow(yi, 2) - 45 * pow(xi, 2) * pow(yi, 4) + 5 * pow(yi, 6)) *
		L1i) / (28800. * pow(ci, 4) * M_PI);
	values[0] = Ic0 + Ic0_1;
	values[1] = Ic1;
	values[2] = Ic2;
	values[3] = Ic3;
	values[4] = It0;
	values[5] = It1;
	values[6] = It2;
	values[7] = It3;
	values[8] = Ix0 + Ix0_1;
	values[9] = Ix1;
	values[10] = Ix2;
	values[11] = Ix3;
	values[12] = Iy0;
	values[13] = Iy1;
	values[14] = Iy2;
	values[15] = Iy3;
	values[16] = values[0];
	values[17] = values[1];
	values[18] = values[2];
	values[19] = values[3];
	values[20] = It0 / (4);
	values[21] = It1 / (4);
	values[22] = It2 / (4);
	values[23] = It3 / (4);
}

//这里eta在v0到v1上，但不在v1上
void CalBiharmonicBasisBef(OpenMesh::Vec2d& v0, OpenMesh::Vec2d& v1, OpenMesh::Vec2d& v2, OpenMesh::Vec2d& eta, 
	double& ksiH, double& phiH, double& BHksi, double& BHphi) {
	OpenMesh::Vec2d ei, ui, xiyi;
	double ci, L1i, L2i, Ai, xi,yi,hatphiH_1, hatphiBH_1, hatphiH, hatphiBH;
	{//计算前一个phi的值
		ei = v1 - v0;
		ci = ei.norm();
		ui = eta - v0;
		xiyi = OpenMesh::Vec2d(ui[0] * ei[0] + ui[1] * ei[1], ui[1] * ei[0] - ui[0] * ei[1]);
		xiyi = xiyi / ci;
		xi = xiyi[0]; yi = xiyi[1];
		L1i = log(xi * xi + yi * yi);
		L2i = log(xi * xi + yi * yi + ci * ci - 2 * ci * xi);
		Ai = atan(xi / yi) + atan((ci - xi) / yi);
		hatphiH_1 = (2 * xi * Ai - yi * (L1i - L2i)) / (4 * M_PI * ci);
		hatphiBH_1 = (4 * Ai * xi * yi * yi - L2i * yi * (xi * xi - yi * yi - ci * ci)
			+ L1i * yi * (xi * xi - yi * yi) - 2 * yi * ci * (ci + xi)) / (16 * M_PI * ci);
		if (abs(yi) < 1e-4) {//x是否等于0不影响什么
			if (abs(ci - xi) < 1e-4) {
				std::cout << hatphiH_1 << "now" << xi / (4 * ci) << std::endl;
				hatphiH_1 = xi / (4 * ci);
				std::cout << hatphiBH_1 << "now" << 0 << std::endl;
				hatphiBH_1 = 0;
			}
			else if (xi > 0 && ci - xi > 0) {
				std::cout << hatphiH_1 << "now" << xi / (2 * ci) << std::endl;
				hatphiH_1 = xi / (2 * ci);
				std::cout << hatphiBH_1 << "now" << 0 << std::endl;
				hatphiBH_1 = 0;
			}
			else {
				std::cout << hatphiH_1 << "now" << 0 << std::endl;
				hatphiH_1 = 0;
				std::cout << hatphiBH_1 << "now" << 0 << std::endl;
				hatphiBH_1 = 0;
			}
			
		}
	}
	ei = v2 - v1;
	ci = ei.norm();
	ui = eta - v1;
	xiyi = OpenMesh::Vec2d(ui[0] * ei[0] + ui[1] * ei[1], ui[1] * ei[0] - ui[0] * ei[1]);
	xiyi = xiyi / ci;
	xi = xiyi[0]; yi = xiyi[1];
	L1i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1]);
	L2i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1] + ci * ci - 2 * ci * xiyi[0]);
	Ai = atan(xiyi[0] / xiyi[1]) + atan((ci - xiyi[0]) / xiyi[1]);
	hatphiH = (2 * xiyi[0] * Ai - xiyi[1] * (L1i - L2i)) / (4 * M_PI * ci);
	hatphiBH = (4 * Ai * xiyi[0] * xiyi[1] * xiyi[1] - L2i * xiyi[1] * (xiyi[0] * xiyi[0] - xiyi[1] * xiyi[1] - ci * ci)
		+ L1i * xiyi[1] * (xiyi[0] * xiyi[0] - xiyi[1] * xiyi[1]) - 2 * xiyi[1] * ci * (ci + xiyi[0])) / (16 * M_PI * ci);

	ksiH = (2 * Ai * yi + L1i * xi - 2 * ci + (ci - xi) * L2i) / (-4 * M_PI);
	phiH = (hatphiH_1 - hatphiH + Ai / (2 * M_PI));
	BHksi = (3 * L1i * xi * (3 * yi * yi + xi * xi)
		+ 3 * L2i * (ci - xi) * (ci * ci - 2 * ci * xi + 3 * yi * yi + xi * xi)
		+ 12 * Ai * pow(yi, 3) + 24 * (ci * ci * xi - ci * xi * xi) - 8 * ci * ci * ci - 30 * ci * pow(yi, 2)) / (-144 * M_PI);
	BHphi = (hatphiBH_1 - hatphiBH + (yi / (8 * M_PI)) * (2 * Ai * yi + L1i * xi - 3 * ci + L2i * (ci - xi)));
	std::cout << ksiH << " " << phiH << " " << BHksi << " " << BHphi << std::endl;
	if (abs(yi) < 1e-4) {//xi是否等于0或ci影响了关于L1i的乘法
		if (xi > 0 && ci-xi > 0) {
			std::cout << hatphiH << "now" << xi / (2 * ci) << std::endl;
			hatphiH = xi / (2 * ci);
			std::cout << hatphiBH << "now" << 0 << std::endl;
			hatphiBH = 0;
			ksiH = (2 * ci + (xi - ci) * L2i - xi * L1i) / (4 * M_PI);
			Ai =  M_PI;
			phiH = (hatphiH_1 - hatphiH + Ai / (2 * M_PI));
			BHksi = (-8 * ci * (ci * ci - 3 * ci * xi + 3 * xi * xi) + 3 * pow((ci - xi), 3) * L2i + 3 * pow(xi, 3) * L1i) / (-144 * M_PI);
			BHphi = hatphiBH_1;
			std::cout <<"new"<< ksiH << " " << phiH << " " << BHksi << " " << BHphi << std::endl;
		}
		else  {
			std::cout << hatphiH << "now" << 0 << std::endl;
			hatphiH = 0;
			std::cout << hatphiBH << "now" << 0 << std::endl;
			hatphiBH = 0;
			ksiH = (2 * ci + (xi - ci) * L2i - xi * L1i) / (4 * M_PI);
			Ai = 0;
			phiH = (hatphiH_1 - hatphiH + Ai / (2 * M_PI));
			BHksi = (-8 * ci * (ci * ci - 3 * ci * xi + 3 * xi * xi) + 3 * pow((ci - xi), 3) * L2i + 3 * pow(xi, 3) * L1i) / (-144 * M_PI);
			BHphi = hatphiBH_1;
			std::cout << "new" << ksiH << " " << phiH << " " << BHksi << " " << BHphi << std::endl;
		}
	}
}
//eta=v1的情形
void CalBiharmonicBasisonVertexs(OpenMesh::Vec2d& v0, OpenMesh::Vec2d& v1, OpenMesh::Vec2d& v2, 
	double& ksiH, double& phiH, double& BHksi, double& BHphi) {
	OpenMesh::Vec2d ei, ui, xiyi;
	double ci, L1i, L2i, Ai, hatphiH_1, hatphiBH_1, hatphiH, hatphiBH;
	ei = v2 - v1;
	ci = ei.norm();
	ksiH = (ci - ci * log(ci)) / (2 * M_PI);
	
	BHksi = (pow(ci,3)*(4-3*log(ci))) / (72 * M_PI);
	phiH = 1. / 2;
	BHphi = 0;
}
//eta=v2的情况
void CalBiharmonicBasisonVertexsNext(OpenMesh::Vec2d& v0, OpenMesh::Vec2d& v1, OpenMesh::Vec2d& v2,
	double& ksiH, double& phiH, double& BHksi, double& BHphi) {
	OpenMesh::Vec2d ei, ui, xiyi;
	double ci, L1i, L2i, Ai, hatphiH_1, hatphiBH_1, hatphiH, hatphiBH;
	{//计算前一个phi的值
		ei = v1 - v0;
		ci = ei.norm();
		ui = v2 - v0;
		xiyi = OpenMesh::Vec2d(ui[0] * ei[0] + ui[1] * ei[1], ui[1] * ei[0] - ui[0] * ei[1]);
		xiyi = xiyi / ci;
		L1i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1]);
		L2i = log(xiyi[0] * xiyi[0] + xiyi[1] * xiyi[1] + ci * ci - 2 * ci * xiyi[0]);
		Ai = atan(xiyi[0] / xiyi[1]) + atan((ci - xiyi[0]) / xiyi[1]);
		hatphiH_1 = (2. * xiyi[0] * Ai - xiyi[1] * (L1i - L2i)) / (4 * M_PI * ci);
		hatphiBH_1 = (4. * Ai * xiyi[0] * xiyi[1] * xiyi[1] - L2i * xiyi[1] * (xiyi[0] * xiyi[0] - xiyi[1] * xiyi[1] - ci * ci)
			+ L1i * xiyi[1] * (xiyi[0] * xiyi[0] - xiyi[1] * xiyi[1]) - 2 * xiyi[1] * ci * (ci + xiyi[0])) / (16 * M_PI * ci);
	}
	ei = v2 - v1;
	ci = ei.norm();

	ksiH = (ci-ci*log(ci)) / (2 * M_PI);

	BHksi = (pow(ci, 3) * (4 - 3 * log(ci))) / (72 * M_PI);
	phiH = hatphiH_1;
	BHphi = hatphiBH_1;
}

Mesh createMeshFromCurveCage(const std::vector<Mesh::Point>& curvecage2) {
	// 创建一个网格对象
	Mesh mesh;

	// 存储顶点句柄的向量
	std::vector<Mesh::VertexHandle> vhandles;

	// 将 curvecage2 中的点添加到网格的顶点
	for (const auto& point : curvecage2) {
		vhandles.push_back(mesh.add_vertex(point));
	}
	
	//// 按照顺序用边连接这些顶点
	//for (size_t i = 0; i < vhandles.size(); ++i) {
	//	Mesh::VertexHandle vh0 = vhandles[i];
	//	Mesh::VertexHandle vh1 = vhandles[i];
	//	Mesh::VertexHandle vh2 = vhandles[(i + 1) % vhandles.size()];
	//	std::vector<Mesh::VertexHandle> face_vhandles = { vh0, vh1, vh2 };
	//	mesh.add_face(face_vhandles);
	//}

	return mesh;
}

std::vector<std::vector<Mesh::Point>> CCpoints_fromCCmesh(const Mesh CC_mesh,int degree) {
	std::vector<std::vector<Mesh::Point>> CCpoints;
	int segs = CC_mesh.n_vertices() / degree;
	CCpoints.resize(segs);
	for (int i = 0; i < segs; i++)
	{
		for (int j = 0; j < degree+1; j++)
		{
			if (i * degree + j == CC_mesh.n_vertices()) {
				auto vh = CC_mesh.vertex_handle(0);
				CCpoints[i].push_back(CC_mesh.point(vh));
			}
			else {
				auto vh = CC_mesh.vertex_handle(i * degree + j);
				CCpoints[i].push_back(CC_mesh.point(vh));
			}
			
		}
	}
	return CCpoints;
}

std::vector<double> mvc(const Mesh::Point p, const std::vector<Mesh::Point> vts) {
	int n_v = vts.size();
	std::vector<double> w(n_v);
	double sum = 0;
	for (int i = 0; i < n_v; i++) {
		Mesh::Point v_left = vts[(i - 1) % (n_v )];
		Mesh::Point v = vts[i];
		Mesh::Point v_right = vts[(i+1)%n_v];
		double alpha_i_1 = acos((v - p).dot(v_left - p) / ((v - p).norm() * (v_left - p).norm()));
		double alpha_i = acos((v - p).dot(v_right - p) / ((v - p).norm() * (v_right - p).norm()));
		double wi = (tan(alpha_i_1 / 2) + tan(alpha_i / 2)) / (v - p).norm();
		w[i] = wi;
		sum += wi;

	}
	for (int i = 0; i < n_v; i++) {
		w[i] /= sum;
	}
	return w;
}

//计算积分，分子t的m次方,分母是t的1次方
double  F1_n(const Mesh::Point eta, const Mesh::Point c0, const Mesh::Point c1, int m)
{

	// 定义lambda函数
	auto Un = [](complex<double> x, int n) -> complex<double> {
		complex<double> sum = 0;
		for (int k = 1; k < n; k++) {
			sum += std::pow(x, k) / static_cast<double>(n-k);
		}
		return sum;
	};

	complex<double> com_c0(c0[0] - eta[0], c0[1] - eta[1]);
	complex<double> com_c1(c1[0], c1[1]);
	
	complex<double> w = - com_c0/com_c1;
	
	double result = imag(std::pow(w, m) * (std::log(1.0 - w) - std::log(-w)) + Un(w, m));
	result /= imag(w);
	result /= (2 * M_PI * norm(com_c1));//norm已经是平方
	return result;
}

//计算积分，分子t的m次方,分母是t的1次方
double  F1_n(const OpenMesh::Vec2d eta, const OpenMesh::Vec2d c0, const OpenMesh::Vec2d c1, int m)
{

	// 定义lambda函数
	auto Un = [](complex<double> x, int n) -> complex<double> {
		complex<double> sum = 0;
		for (int k = 1; k < n; k++) {
			sum += std::pow(x, k) / static_cast<double>(n - k);
		}
		return sum;
	};

	complex<double> com_c0(c0[0] - eta[0], c0[1] - eta[1]);
	complex<double> com_c1(c1[0], c1[1]);

	complex<double> w = -com_c0 / com_c1;

	double result = imag(std::pow(w, m) * (std::log(1.0 - w) - std::log(-w)) + Un(w, m));
	result /= imag(w);
	result /= (2 * M_PI * norm(com_c1));//norm已经是平方
	return result;
}

//计算积分，分子t的m次方,分母是t的2次方
double F2_n(const Mesh::Point eta, const Mesh::Point c0, const Mesh::Point c1, const Mesh::Point c2, int m)
{

	// 定义lambda函数
	auto Hyper = [](complex<double> x, int n) -> complex<double> {
		complex<double> sum = 0;
		for (int m = 1; m <= n; ++m) {
			sum += std::pow(x, m) / static_cast<double>(m);
		}
		return complex<double>(n + 1) / std::pow(x, n + 1) * (-std::log(1.0 - x) - sum);
	};

	complex<double> com_c0(c0[0]-eta[0], c0[1]-eta[1]);
	complex<double> com_c1(c1[0], c1[1]);
	complex<double> com_c2(c2[0], c2[1]);
	complex<double> w1 = (-com_c1 - sqrt(com_c1 * com_c1 - com_c0 * com_c2 * 4.0)) / (2.0 * com_c2);
	complex<double> w2 = (-com_c1 + sqrt(com_c1 * com_c1 - com_c0 * com_c2 * 4.0)) / (2.0 * com_c2);

	double a = w1.real(); double b = abs(w1.imag());
	double c = w2.real(); double d = abs(w2.imag());
	w1 = complex<double>(a, b);
	w2 = complex<double>(c, d);
	complex<double> w1_c = conj(w1);
	complex<double> w2_c = conj(w2);
	double result = imag(w1 * d * norm(w2) * (w1 * w1 - 2. * c * w1 + c * c + d * d) * Hyper(1. / w1_c, m) +
		                          w2 * b * norm(w1) * (w2 * w2 - 2. * a * w2 + a * a + b * b) * Hyper(1. / w2_c, m));
	result /= ( b * norm(w1) * ((b - d) * (b - d) + (a - c) * (a - c)) * norm(w2) * d * ((b + d) * (b + d) + (a - c) * (a - c)) * (m + 1));
	result /= (2 * M_PI*norm(com_c2));
	return result;
}

double F2_n(const OpenMesh::Vec2d eta, const OpenMesh::Vec2d c0, const OpenMesh::Vec2d c1, const OpenMesh::Vec2d c2, int m)
{

	// 定义lambda函数
	auto Hyper = [](complex<double> x, int n) -> complex<double> {
		complex<double> sum = 0;
		for (int m = 1; m <= n; ++m) {
			sum += std::pow(x, m) / static_cast<double>(m);
		}
		return complex<double>(n + 1) / std::pow(x, n + 1) * (-std::log(1.0 - x) - sum);
	};

	complex<double> com_c0(c0[0] - eta[0], c0[1] - eta[1]);
	complex<double> com_c1(c1[0], c1[1]);
	complex<double> com_c2(c2[0], c2[1]);
	complex<double> w1 = (-com_c1 - sqrt(com_c1 * com_c1 - com_c0 * com_c2 * 4.0)) / (2.0 * com_c2);
	complex<double> w2 = (-com_c1 + sqrt(com_c1 * com_c1 - com_c0 * com_c2 * 4.0)) / (2.0 * com_c2);

	double a = w1.real(); double b = abs(w1.imag());
	double c = w2.real(); double d = abs(w2.imag());
	w1 = complex<double>(a, b);
	w2 = complex<double>(c, d);
	complex<double> w1_c = conj(w1);
	complex<double> w2_c = conj(w2);
	double result = imag(w1 * d * norm(w2) * (w1 * w1 - 2. * c * w1 + c * c + d * d) * Hyper(1. / w1_c, m) +
		w2 * b * norm(w1) * (w2 * w2 - 2. * a * w2 + a * a + b * b) * Hyper(1. / w2_c, m));
	result /= (b * norm(w1) * ((b - d) * (b - d) + (a - c) * (a - c)) * norm(w2) * d * ((b + d) * (b + d) + (a - c) * (a - c)) * (m + 1));
	result /= (2 * M_PI * norm(com_c2));
	return result;
}
//输出0到n的值，n最大为9
vector<double> ALL_F2_n(const OpenMesh::Vec2d& eta, const OpenMesh::Vec2d& c0, const OpenMesh::Vec2d& c1, const OpenMesh::Vec2d& c2, const int n) {
	const int N = 10;
	// 预计算复数参数
	const complex<double> com_c0(c0[0] - eta[0], c0[1] - eta[1]);
	const complex<double> com_c1(c1[0], c1[1]);
	const complex<double> com_c2(c2[0], c2[1]);

	// 计算二次方程的根
	const complex<double> discriminant = com_c1 * com_c1 - 4.0 * com_c0 * com_c2;
	const complex<double> sqrt_disc = sqrt(discriminant);
	const complex<double> w1 = (-com_c1 - sqrt_disc) / (2.0 * com_c2);
	const complex<double> w2 = (-com_c1 + sqrt_disc) / (2.0 * com_c2);

	complex<double> w1_c = conj(w1);
	complex<double> w2_c = conj(w2);
	// 预计算公共项
	const double norm_w1 = norm(w1);  // |w1|²
	const double real_w1 = real(w1);  // Re(w1)
	const double imag_w1 = imag(w1);  // Im(w1)
	const double norm_w2 = norm(w2);
	const double real_w2 = real(w2);
	const double imag_w2 = imag(w2);

	// 预计算logs2（优化重复计算）
	array<complex<double>,2> logs2; // 改用vector
	logs2[0] = complex<double>(
		0.5 * log(1.0 + (1 - 2 * real_w1) / norm_w1),
		atan2(imag_w1, norm_w1 - real_w1)
	);
	logs2[1] = complex<double>(
		0.5 * log(1.0 + (1 - 2 * real_w2) / norm_w2),
		atan2(imag_w2, norm_w2 - real_w2)
	);
	
	double A = 2 * M_PI * norm(com_c2);
	std::array<std::complex<double>, 2> hs2;
	hs2[0] = A*w1.imag() * (w1 - w2) * (w1 - w2_c);
	hs2[1] = A*w2.imag() * (w2 - w1) * (w2 - w1_c);
	
	array<complex<double>,N> G1;
	array<complex<double>,N> G2;
	vector<double> results(n + 1);
	
	G1[0] = logs2[0] / (hs2[0]);
	G2[0] = logs2[1] / (hs2[1]);
	results[0] = imag(G1[0]) + imag(G2[0]);
	
	G1[1] = w1 * (G1[0]);
	G2[1] = w2 * (G2[0]);
	results[1] = imag(G1[1]) + imag(G2[1]);
	std::array<std::complex<double>, 2> yuxiang2;
	yuxiang2[0] = w1 / hs2[0];
	yuxiang2[1] = w2 / hs2[1];
	for (int i = 2; i <= n; i++) {
		G1[i] = w1 * G1[i - 1] + yuxiang2[0] / double(i - 1);
		G2[i] = w2 * G2[i - 1] + yuxiang2[1] / double(i - 1);
		results[i] = imag(G1[i]) + imag(G2[i]);
	}
	return results;
	
}

template <typename ContainerA, typename ContainerB>
polyvec multiplyPolynomials(const ContainerA& A, const ContainerB& B) {
	// 检查容器元素类型
	/*static_assert(std::is_arithmetic_v<typename ContainerA::value_type>,
		"ContainerA must contain arithmetic types");
	static_assert(std::is_arithmetic_v<typename ContainerB::value_type>,
		"ContainerB must contain arithmetic types");*/

	// 计算实际多项式次数
	const size_t m =  A.size() - 1;
	const size_t n =  B.size() - 1;


	// 初始化结果容器（m+n次多项式）
	polyvec result(m + n + 1, 0.0);

	// 三维循环展开优化
	for (size_t i = 0; i < A.size(); ++i) {
		const double a = A[i];
		if (a == 0) continue;  // 零系数优化

		for (size_t j = 0; j < B.size(); ++j) {
			result[i + j] += a * B[j];
		}
	}

	return result;
}
//n最高次的次数
template <typename ContainerA, typename ContainerB>
polyvec addPolynomials(const ContainerA& A, const ContainerB& B, int n) {
	// 预分配指定次数空间
	polyvec result(n + 1, 0);
	auto safe_access = [](const polyvec& poly, int index) {
		return (index < poly.size()) ? poly[index] : 0;
	};
	for (int i = 0; i <= n; ++i) {
		result[i] = safe_access(A, i) + safe_access(B, i);
	}
	return result;
}
template <typename ContainerA>
polyvec integratePolynomial(const ContainerA& poly, int n) {
	// 创建结果数组，大小比原多项式次数+2（包含积分常数项）
	polyvec result(n + 2, 0.0);

	// 设置积分常数项
	//result[0] = 0;

	// 逐项计算积分系数
	for (size_t i = 0; i <= n; ++i) {
		int exponent = i + 1;  // 当前项的原始指数
		result[i + 1] = static_cast<double>(poly[i]) / exponent;
	}

	return result;
}


double F2_n_new(const OpenMesh::Vec2d eta, const OpenMesh::Vec2d c0, const OpenMesh::Vec2d c1, const OpenMesh::Vec2d c2, int m)
{

	// gm lambda函数
	auto gm = [](int m, complex<double> w) -> complex<double> {
		complex<double> result = log(1.0 - 1.0 / w);  // log(1 - 1/w)

		// 计算Sum
		for (int k = 1; k <= m; ++k) {
			result += 1.0 / (static_cast<double>(k) * pow(w, k));  // 1 / (k * w^k)
		}

		return result * pow(w, m);
	};

	// dgm lambda函数
	auto dgm = [](int m, complex<double> w) -> complex<double> {
		complex<double> result = complex<double>(m) * w * complex<double>(m - 1) * log(1.0 - 1.0 / w);  // m * w * (m - 1) * log(1 - 1/w)

		// 计算Sum
		for (int k = 1; k <= m; ++k) {
			result += 1.0 / (static_cast<double>(k) * pow(w, k));  // Sum 1 / (k * w^k)
		}

		// 第二部分的Sum
		for (int k = 1; k <= m; ++k) {
			result += -1.0 / (pow(w, k + 1) * (w - 1.0));  // Sum -1 / (w^(k+1) * (w - 1))
		}

		return result;
	};

	complex<double> com_c0(c0[0] - eta[0], c0[1] - eta[1]);
	complex<double> com_c1(c1[0], c1[1]);
	complex<double> com_c2(c2[0], c2[1]);
	complex<double> w1 = (-com_c1 - sqrt(com_c1 * com_c1 - com_c0 * com_c2 * 4.0)) / (2.0 * com_c2);
	complex<double> w2 = (-com_c1 + sqrt(com_c1 * com_c1 - com_c0 * com_c2 * 4.0)) / (2.0 * com_c2);

	double a = w1.real(); double b = w1.imag();
	double c = w2.real(); double d = w2.imag();

	complex<double> w3, w4;
	if (abs(d) < 1e-6 || abs(b) < 1e-6) {
		if (abs(b) < 1e-6) {//w3是正常的
			w3 = w2;
			w4 = w1;
		}
		else {
			w3 = w1;
			w4 = w2;
		}
		complex<double> w3_c = conj(w3);
		complex<double> denominator3 = w3.imag() * (w3 - w4) * (w3 - w4);
		double wi = real(w4);
		double leijia1=0, leijia2=0;
		for (int k = 1; k < m + 1; k++) {
			leijia1 += 1. / (k * pow(wi, k));
			leijia2 += -1. / pow(wi, k + 1);
		}
		complex<double> gmp = m * pow(wi, m - 1) * (log(complex<double>(1 - 1. / wi,0)) + leijia1) + (1. / (wi * wi - wi) + leijia2) * pow(wi, m);
		std::cout << m * pow(wi, m - 1) * (log(complex<double>(1 - 1. / wi, 0)) + leijia1) << std::endl;
		std::cout << log(complex<double>(-1, 0)) << std::endl;
		double hi = real((wi - w3) * (wi - w3_c));
		complex<double> gmv = pow(wi, m) * (log(complex<double>(1 - 1. / wi, 0)) + leijia1);
		complex<double> hip = real(2 * wi - w3 - w3_c);
		double result = imag(gm(m, w3) / denominator3);
		w1 = complex<double>(a, b);
		w2 = complex<double>(c, d);
		complex<double> denominator1 = b * (w1 - w2) * (w1 - conj(w2));
		complex<double> denominator2 = d * (w2 - w1) * (w2 - conj(w1));
		std::cout << imag(gm(m, w1) / denominator1) << std::endl;
		std::cout << imag(gm(m, w2) / denominator2) << std::endl;
		std::cout << result << std::endl;
		std::cout << real(gmp * hi - hip * gmv) / (hi * hi) << std::endl;
		result += real(gmp * hi - hip * gmv) / (hi * hi);
		result /= (2 * M_PI * norm(com_c2));
		return result;
		
	}
	w1 = complex<double>(a, b);
	w2 = complex<double>(c, d);
	complex<double> w1_c = conj(w1);
	complex<double> w2_c = conj(w2);
	complex<double> denominator1 = b * (w1 - w2) * (w1 - w2_c);
	complex<double> denominator2 = d * (w2 - w1) * (w2 - w1_c);
	double result = imag(gm(m, w1) / denominator1) + imag(gm(m, w2) / denominator2);
	
	result /= (2 * M_PI * norm(com_c2));
	return result;
}

//计算积分，分子t的m次方,分母是t的2次方
double F2_que(const Mesh::Point eta, const Mesh::Point c0, const Mesh::Point c1, const Mesh::Point c2, int m)
{

	// 定义lambda函数
	auto Hyper = [](complex<double> x, int n) -> complex<double> {
		complex<double> sum = 0;
		for (int m = 1; m <= n; ++m) {
			sum += std::pow(x, m) / static_cast<double>(m);
		}
		return complex<double>(n + 1) / std::pow(x, n + 1) * (-std::log(1.0 - x) - sum);
	};

	complex<double> com_c0(c0[0] - eta[0], c0[1] - eta[1]);
	complex<double> com_c1(c1[0], c1[1]);
	complex<double> com_c2(c2[0], c2[1]);
	complex<double> w1 = (-com_c1 - sqrt(com_c1 * com_c1 - com_c0 * com_c2 * 4.0)) / (2.0 * com_c2);
	complex<double> w2 = (-com_c1 + sqrt(com_c1 * com_c1 - com_c0 * com_c2 * 4.0)) / (2.0 * com_c2);

	double a = w1.real(); double b = abs(w1.imag());
	double c = w2.real(); double d = abs(w2.imag());
	w1 = complex<double>(a, b);
	w2 = complex<double>(c, d);
	complex<double> w1_c = conj(w1);
	complex<double> w2_c = conj(w2);
	double result = imag(w1 * d * norm(w2) * (w1 * w1 - 2. * c * w1 + c * c + d * d) * Hyper(1. / w1_c, m) +
		w2 * b * norm(w1) * (w2 * w2 - 2. * a * w2 + a * a + b * b) * Hyper(1. / w2_c, m));
	result /= (b * norm(w1) * ((b - d) * (b - d) + (a - c) * (a - c)) * norm(w2) * d * ((b + d) * (b + d) + (a - c) * (a - c)) * (m + 1));
	result /= (2 * M_PI * norm(com_c2));
	return result;
}

//计算cauchy积分，分子t的m次方,分母是t的2次方
complex<double> cauchy_F2_n(const complex<double> z, const complex<double> z0, const complex<double> z1, const complex<double> z2, int m)
{

	// gm lambda函数
	auto gm = [](int m, complex<double> w) -> complex<double> {
		complex<double> result = log(1.0 - 1.0 / w);  // log(1 - 1/w)

		// 计算Sum
		for (int k = 1; k <= m; ++k) {
			result += 1.0 / (static_cast<double>(k) * pow(w, k));  // 1 / (k * w^k)
		}
		result *= pow(w, m);
		return result;
	};

	complex<double> com_c0 = z0 - z;
	complex<double> w1 = (-z1 - sqrt(z1 * z1 - com_c0 * z2 * 4.0)) / (2.0 * z2);
	complex<double> w2 = (-z1 + sqrt(z1 * z1 - com_c0 * z2 * 4.0)) / (2.0 * z2);

	complex<double> result = gm(m, w1) / (w1 - w2) + gm(m, w2) / (w2 - w1);
	result /= z2;
	return result;
}

complex<double> rationalInte(std::vector<complex<double>>& roots, std::vector<int>& root_orders, std::vector<complex<double>>& poly)
{
	assert(roots.size() == root_orders.size());
	int m = poly.size();//多项式次数
	int n = roots.size();//根的个数
	complex<double> result = 0;
	std::vector<complex<double>> Res(m,0);
	std::vector<complex<double>> logs(n);
	std::vector<complex<double>> dlogs(n);
	std::vector<complex<double>> h1(n,1);
	std::vector<complex<double>> dh1(n,1);
	std::vector<std::vector<complex<double>>> Res_j(n, std::vector<std::complex<double>>(m));
	// gm lambda函数
	auto gm = [](int m, complex<double> w) -> complex<double> {
		complex<double> result = log(1.0 - 1.0 / w);  // log(1 - 1/w)

		// 计算Sum
		for (int k = 1; k <= m; ++k) {
			result += 1.0 / (static_cast<double>(k) * pow(w, k));  // 1 / (k * w^k)
		}
		result *= pow(w, m);
		return result;
	};
	// dgm lambda函数
	auto dgm = [](int m, complex<double> w) -> complex<double> {
		complex<double> result = static_cast<double>(m) * log(1.0 - 1.0 / w) + 1.0 / (w - 1.0);  // m log(1 - 1/w)+ 1/(w-1)

		// 计算Sum
		for (int k = 1; k <= m; ++k) {
			result += static_cast<double>(m - k) / (static_cast<double>(k) * pow(w, k));  // 1 / (k * w^k)
		}
		result *= pow(w, m - 1);
		return result;
	};
	//为logs赋值
	for (int i = 0; i < n; i++)
	{
		double real_w1 = roots[i].real();
		double imag_w1 = roots[i].imag();
		double norm_w1 = norm(roots[i]);
		logs[i]= complex<double>(
			0.5 * log(1.0 + (1 - 2 * real_w1) / norm_w1),
			atan2(imag_w1, norm_w1 - real_w1)
		);
	}
	//为h1赋值
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < roots.size(); j++)
		{
			if (j != i) {
				h1[i] *= pow(roots[i] - roots[j], root_orders[j]);
			}

		}
		if (root_orders[i] == 1)
		{
		}
		if (root_orders[i] == 2)
		{
			for (int j = 0; j < roots.size(); j++)
			{
				if (j != i) {
					complex<double> dh2(1);
					for (int k = 0; k < roots.size(); k++) {
						if (k != i && k != j)
						{
							dh2 *= pow(roots[i] - roots[k], root_orders[k]);
						}
					}
					dh1[i] += (double(root_orders[j])) * pow(roots[i] - roots[j], root_orders[j] - 1) * dh2;//计算了dh1为h1的导数
				}
			}
		}
	}
	//计算n*m个res
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < m; j++)
		{
			if (j == 0)
			{
				if (root_orders[i] == 1) {
					Res_j[i][j] = logs[i] / h1[i];
				}
				if (root_orders[i] == 2) {
					Res_j[i][j] = (dgm(0, roots[i]) * h1[i] - dh1[i] * logs[i]) / pow(h1[i], 2);
				}
			}
			else {
				if (root_orders[i] == 1) {
					Res_j[i][j] = roots[i] * Res_j[i][j - 1] + 1. / (double(j) * h1[i]);
				}
				if (root_orders[i] == 2) {
					Res_j[i][j] = roots[i] * Res_j[i][j - 1] +gm(j-1,roots[i])/h1[i] - dh1[i] / (double(j) * pow(h1[i], 2));
				}
			}
		}
	}
	//遍历次数
	for (int i = 0; i < m; i++)
	{
		//遍历根
		for (int j = 0; j < n; j++) {
			Res[i] += Res_j[j][i];
		}
		result += poly[i] * Res[i];
	}
	return result;
}


std::vector<complex<double>> rationalIntes(std::vector<complex<double>>& roots, std::vector<int>& root_orders, std::vector<std::vector<complex<double>>>& poly)
{
	assert(roots.size() == root_orders.size());
	int P = poly.size();
	int m = 0;//最大的多项式次数
	for (const auto& innerpoly : poly) {
		m = std::max(m, int(innerpoly.size()));
	}
	int n = roots.size();//根的个数
	std::vector<complex<double>> result(P, 0);
	std::vector<complex<double>> Res(m, 0);
	std::vector<complex<double>> logs(n);
	std::vector<complex<double>> dlogs(n);
	std::vector<complex<double>> ddlogs(n);
	std::vector<complex<double>> h1(n, 1);
	std::vector<complex<double>> dh1(n, 0);
	std::vector<complex<double>> ddh1(n, 0);
	std::vector<std::vector<complex<double>>> Res_j(n, std::vector<std::complex<double>>(m));
	// gm lambda函数
	auto gm = [](int m, complex<double> w) -> complex<double> {
		complex<double> result = log(1.0 - 1.0 / w);  // log(1 - 1/w)

		// 计算Sum
		for (int k = 1; k <= m; ++k) {
			result += 1.0 / (static_cast<double>(k) * pow(w, k));  // 1 / (k * w^k)
		}
		result *= pow(w, m);
		return result;
	};
	// dgm lambda函数
	auto dgm = [](int m, complex<double> w) -> complex<double> {
		complex<double> result = static_cast<double>(m) * log(1.0 - 1.0 / w) + 1.0 / (w - 1.0);  // m log(1 - 1/w)+ 1/(w-1)

		// 计算Sum
		for (int k = 1; k <= m; ++k) {
			result += static_cast<double>(m - k) / (static_cast<double>(k) * pow(w, k));  // 1 / (k * w^k)
		}
		result *= pow(w, m - 1);
		return result;
	};
	// dgm lambda函数
	auto ddgm = [](int m, complex<double> w) -> complex<double> {
		complex<double> result = static_cast<double>(m - 1) * (static_cast<double>(m) * log(1.0 - 1.0 / w) + 1.0 / (w - 1.0))
			+ (static_cast<double>(m - 1) * w - static_cast<double>(m)) / ((w - 1.) * (w - 1.));  // m log(1 - 1/w)

		// 计算Sum
		for (int k = 1; k <= m; ++k) {
			result += static_cast<double>((m - 1) * (m - k)) / (static_cast<double>(k) * pow(w, k));  // 1 / (k * w^k)
			result += static_cast<double>(k - m) / (pow(w, k));
		}
		result *= pow(w, m - 2);
		return result;
	};
	//为logs赋值
	for (int i = 0; i < n; i++)
	{
		double real_w1 = roots[i].real();
		double imag_w1 = roots[i].imag();
		double norm_w1 = norm(roots[i]);
		logs[i] = complex<double>(
			0.5 * log(1.0 + (1 - 2 * real_w1) / norm_w1),
			atan2(imag_w1, norm_w1 - real_w1)
		);
	}
	//为h1赋值
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < roots.size(); j++)
		{
			if (j != i) {
				h1[i] *= pow(roots[i] - roots[j], root_orders[j]);
			}

		}
		if (root_orders[i] == 1)
		{
		}
		if (root_orders[i] == 2)
		{
			for (int j = 0; j < roots.size(); j++)
			{
				if (j != i) {
					complex<double> dh2(1);
					for (int k = 0; k < roots.size(); k++) {
						if (k != i && k != j)
						{
							dh2 *= pow(roots[i] - roots[k], root_orders[k]);
						}
					}
					dh1[i] += (double(root_orders[j])) * pow(roots[i] - roots[j], root_orders[j] - 1) * dh2;//计算了dh1为h1的导数
				}
			}
		}
		if (root_orders[i] == 3)
		{
			for (int j = 0; j < roots.size(); j++)
			{
				if (j != i) {
					complex<double> dh2(1);
					complex<double> dh3(0);
					for (int k = 0; k < roots.size(); k++) {
						if (k != i && k != j)
						{
							dh2 *= pow(roots[i] - roots[k], root_orders[k]);
							complex<double> dh4(1);
							for (int l = 0; l < roots.size(); l++) {
								if (l != i && l != j && l != k) {
									dh4 *= pow(roots[i] - roots[l], root_orders[l]);
								}
							}
							dh3 += (double(root_orders[k])) * pow(roots[i] - roots[k], root_orders[k] - 1) * dh4;
						}
					}
					dh1[i] += (double(root_orders[j])) * pow(roots[i] - roots[j], root_orders[j] - 1) * dh2;//计算了dh1为h1的导数
					ddh1[i] += (double(root_orders[j]) * double(root_orders[j] - 1)) * pow(roots[i] - roots[j], root_orders[j] - 2) * dh2
						+ (double(root_orders[j])) * pow(roots[i] - roots[j], root_orders[j] - 1) * dh3;//计算了dh1为h1的导数
				}
			}
		}
	}
	//计算n*m个res
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < m; j++)
		{
			if (j == 0)
			{
				if (root_orders[i] == 1) {
					Res_j[i][j] = logs[i] / h1[i];
				}
				if (root_orders[i] == 2) {
					Res_j[i][j] = (dgm(0, roots[i]) * h1[i] - dh1[i] * logs[i]) / pow(h1[i], 2);
				}
				if (root_orders[i] == 3) {
					Res_j[i][j] = (ddgm(0, roots[i]) * h1[i] * h1[i] - 2. * dgm(0, roots[i]) * h1[i] * dh1[i]
						+ 2. * logs[i] * dh1[i] * dh1[i] - h1[i] * logs[i] * ddh1[i]) / pow(h1[i], 3);
					Res_j[i][j] /= 2;
				}
			}
			else {
				if (root_orders[i] == 1) {
					Res_j[i][j] = roots[i] * Res_j[i][j - 1] + 1. / (double(j) * h1[i]);
				}
				if (root_orders[i] == 2) {
					//Res_j[i][j] = roots[i] * Res_j[i][j - 1] + gm(j - 1, roots[i]) / h1[i] - dh1[i] / (double(j) * pow(h1[i], 2));
					Res_j[i][j] = (dgm(j, roots[i]) * h1[i] - dh1[i] * gm(j , roots[i])) / pow(h1[i], 2);
				}
				if (root_orders[i] == 3) {
					Res_j[i][j] = (ddgm(j, roots[i]) * h1[i] * h1[i] - 2. * dgm(j, roots[i]) * h1[i] * dh1[i]
						+ 2. * gm(j, roots[i]) * dh1[i] * dh1[i] - h1[i] * gm(j, roots[i]) * ddh1[i]) / pow(h1[i], 3);
					Res_j[i][j] /= 2;
				}
			}
		}
	}
	for (int poly_id = 0; poly_id < P; poly_id++) {
		
		//遍历次数
		for (int i = 0; i < poly[poly_id].size(); i++)
		{
			Res[i] = 0;
			//遍历根
			for (int j = 0; j < n; j++) {
				Res[i] += Res_j[j][i];
			}
			result[poly_id] += poly[poly_id][i] * Res[i];
		}
	}
	return result;
}

std::array<complex<double>, 2> rationalIntes_121(std::array<complex<double>, 1>& roots, std::array<std::array<complex<double>, 2>, 2>& poly)
{
	int P = poly.size();//4
	int m = 2;//最大的多项式次数5
	int n = roots.size();//根的个数1
	std::array<complex<double>, 2> result;
	result.fill(std::complex<double>(0.0, 0.0));
	std::array<complex<double>, 1> Res;
	Res.fill(std::complex<double>(0.0, 0.0));
	std::array<complex<double>, 1> logs;
	std::array<complex<double>, 1> h1;
	h1.fill(std::complex<double>(1.0, 0.0));

	std::array<std::array<complex<double>, 2>, 2>Res_j;
	//为logs赋值
	for (int i = 0; i < n; i++)
	{
		double real_w1 = roots[i].real();
		double imag_w1 = roots[i].imag();
		double norm_w1 = norm(roots[i]);
		logs[i] = complex<double>(
			0.5 * log(1.0 + (1 - 2 * real_w1) / norm_w1),
			atan2(imag_w1, norm_w1 - real_w1)
		);
	}
	//为h1赋值
	for (int i = 0; i < n; i++)
	{

	}
	//计算n*m个res
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < m; j++)
		{
			if (j == 0)
			{
				Res_j[i][j] = logs[i] / h1[i];
			}
			else {
				Res_j[i][j] = roots[i] * Res_j[i][j - 1] + 1. / (double(j) * h1[i]);
			}
		}
	}
	for (int poly_id = 0; poly_id < P; poly_id++) {

		//遍历次数
		for (int i = 0; i < poly[poly_id].size(); i++)
		{
			Res[i] = 0;
			//遍历根
			for (int j = 0; j < n; j++) {
				Res[i] += Res_j[j][i];
			}
			result[poly_id] += poly[poly_id][i] * Res[i];
		}
	}
	return result;
}

std::array<complex<double>, 4> rationalIntes_123(std::array<complex<double>, 1>& roots, std::array<std::array<complex<double>, 4>, 4>& poly)
{
	int P = poly.size();//4
	int m = 4;//最大的多项式次数5
	int n = roots.size();//根的个数1
	std::array<complex<double>, 4> result;
	result.fill(std::complex<double>(0.0, 0.0));
	std::array<complex<double>, 1> Res;
	Res.fill(std::complex<double>(0.0, 0.0));
	std::array<complex<double>, 1> logs;
	std::array<complex<double>, 1> h1;
	h1.fill(std::complex<double>(1.0, 0.0));

	std::array<std::array<complex<double>, 4>, 2>Res_j;
	//为logs赋值
	for (int i = 0; i < n; i++)
	{
		double real_w1 = roots[i].real();
		double imag_w1 = roots[i].imag();
		double norm_w1 = norm(roots[i]);
		logs[i] = complex<double>(
			0.5 * log(1.0 + (1 - 2 * real_w1) / norm_w1),
			atan2(imag_w1, norm_w1 - real_w1)
		);
	}
	//为h1赋值
	for (int i = 0; i < n; i++)
	{
		
	}
	//计算n*m个res
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < m; j++)
		{
			if (j == 0)
			{
				Res_j[i][j] = logs[i] / h1[i];
			}
			else {
				Res_j[i][j] = roots[i] * Res_j[i][j - 1] + 1. / (double(j) * h1[i]);
			}
		}
	}
	for (int poly_id = 0; poly_id < P; poly_id++) {

		//遍历次数
		for (int i = 0; i < poly[poly_id].size(); i++)
		{
			Res[i] = 0;
			//遍历根
			for (int j = 0; j < n; j++) {
				Res[i] += Res_j[j][i];
			}
			result[poly_id] += poly[poly_id][i] * Res[i];
		}
	}
	return result;
}


std::array<complex<double>, 3> rationalIntes_2(std::array<complex<double>, 2>& roots, std::array<std::array<complex<double>, 4>, 3>& poly) {
	int P = poly.size();//3
	int m = 4;//最大的多项式次数5
	int n = roots.size();//根的个数2
	std::array<complex<double>, 3> result;
	result.fill(std::complex<double>(0.0, 0.0));
	std::array<complex<double>, 4> Res;
	Res.fill(std::complex<double>(0.0, 0.0));
	std::array<complex<double>, 2> logs;
	std::array<complex<double>, 2> h1;
	h1.fill(std::complex<double>(1.0, 0.0));

	std::array<std::array<complex<double>, 4>, 2>Res_j;
	//为logs赋值
	for (int i = 0; i < n; i++)
	{
		double real_w1 = roots[i].real();
		double imag_w1 = roots[i].imag();
		double norm_w1 = norm(roots[i]);
		logs[i] = complex<double>(
			0.5 * log(1.0 + (1 - 2 * real_w1) / norm_w1),
			atan2(imag_w1, norm_w1 - real_w1)
		);
	}
	//为h1赋值
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < roots.size(); j++)
		{
			if (j != i) {
				h1[i] *= (roots[i] - roots[j]);
			}

		}
	}
	//计算n*m个res
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < m; j++)
		{
			if (j == 0)
			{
				Res_j[i][j] = logs[i] / h1[i];
			}
			else {
				Res_j[i][j] = roots[i] * Res_j[i][j - 1] + 1. / (double(j) * h1[i]);
			}
		}
	}
	for (int poly_id = 0; poly_id < P; poly_id++) {

		//遍历次数
		for (int i = 0; i < poly[poly_id].size(); i++)
		{
			Res[i] = 0;
			//遍历根
			for (int j = 0; j < n; j++) {
				Res[i] += Res_j[j][i];
			}
			result[poly_id] += poly[poly_id][i] * Res[i];
		}
	}
	return result;
}

std::array<complex<double>, 4> rationalIntes_3(const std::array<complex<double>, 3>& roots, const std::array<std::array<complex<double>, 6>, 4>& poly) {
	int P = poly.size();//4
	int m = 6;//最大的多项式次数5
	int n = roots.size();//根的个数3
	std::array<complex<double>,4> result;
	result.fill(std::complex<double>(0.0, 0.0));
	std::array<complex<double>,6> Res ;
	Res.fill(std::complex<double>(0.0, 0.0));
	std::array<complex<double>,3> logs;
	std::array<complex<double>,3> h1;
	h1.fill(std::complex<double>(1.0, 0.0));
	
	std::array<std::array<complex<double>, 6>, 3>Res_j;
	//为logs赋值
	for (int i = 0; i < n; i++)
	{
		double real_w1 = roots[i].real();
		double imag_w1 = roots[i].imag();
		double norm_w1 = norm(roots[i]);
		logs[i] = complex<double>(
			0.5 * log(1.0 + (1 - 2 * real_w1) / norm_w1),
			atan2(imag_w1, norm_w1 - real_w1)
		);
	}
	//为h1赋值
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < roots.size(); j++)
		{
			if (j != i) {
				h1[i] *= (roots[i] - roots[j]);
			}

		}
	}
	//计算n*m个res
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < m; j++)
		{
			if (j == 0)
			{
				Res_j[i][j] = logs[i] / h1[i];
			}
			else {
					Res_j[i][j] = roots[i] * Res_j[i][j - 1] + 1. / (double(j) * h1[i]);				
			}
		}
	}
	for (int poly_id = 0; poly_id < P; poly_id++) {

		//遍历次数
		for (int i = 0; i < poly[poly_id].size(); i++)
		{
			Res[i] = 0;
			//遍历根
			for (int j = 0; j < n; j++) {
				Res[i] += Res_j[j][i];
			}
			result[poly_id] += poly[poly_id][i] * Res[i];
		}
	}
	return result;
}

//计算cauchy积分，分子t的m次方,分母是t的2次方
complex<double> cauchy_F3_n(const complex<double> z, const complex<double> z0, const complex<double> z1, const complex<double> z2, const complex<double> z3, int m)
{

	// gm lambda函数
	auto gm = [](int m, complex<double> w) -> complex<double> {
		complex<double> result = log(1.0 - 1.0 / w);  // log(1 - 1/w)

		// 计算Sum
		for (int k = 1; k <= m; ++k) {
			result += 1.0 / (static_cast<double>(k) * pow(w, k));  // 1 / (k * w^k)
		}
		result *= pow(w, m);
		return result;
	};

	complex<double> com_c0 = z0 - z;
	complex<double> com_c1=z1;
	complex<double> com_c2=z2;
	complex<double> com_c3=z3;
	complex<double> w1;
	complex<double> w2;
	complex<double> w3;
	Cardano(com_c3, com_c2, com_c1, com_c0, w1, w2, w3);

	complex<double> result = gm(m, w1) / ((w1 - w2)*(w1 - w3)) + gm(m, w2) / ((w2 - w1)*(w2-w3)) + gm(m, w3) / ((w3 - w1) * (w3 - w2));
	result /= z3;
	return result;
}

//计算cauchy积分的二阶导数，分子t的m次方,分母是t的2次方
complex<double> cauchy_D2F2_n(const complex<double> z, const complex<double> z0, const complex<double> z1, const complex<double> z2, int m)
{

	// gm lambda函数
	auto gm = [](int m, complex<double> w) -> complex<double> {
		complex<double> result = log(1.0 - 1.0 / w);  // log(1 - 1/w)

		// 计算Sum
		for (int k = 1; k <= m; ++k) {
			result += 1.0 / (static_cast<double>(k) * pow(w, k));  // 1 / (k * w^k)
		}
		result *= pow(w, m);
		return result;
	};

	// dgm lambda函数
	auto dgm = [](int m, complex<double> w) -> complex<double> {
		complex<double> result = static_cast<double>(m) *log(1.0 - 1.0 / w)+1.0/(w-1.0);  // m log(1 - 1/w)+ 1/(w-1)

		// 计算Sum
		for (int k = 1; k <= m; ++k) {
			result += static_cast<double>(m-k) / (static_cast<double>(k) * pow(w, k));  // 1 / (k * w^k)
		}
		result *= pow(w, m-1);
		return result;
	};

	// dgm lambda函数
	auto ddgm = [](int m, complex<double> w) -> complex<double> {
		complex<double> result = static_cast<double>(m - 1) * (static_cast<double>(m) * log(1.0 - 1.0 / w) + 1.0 / (w - 1.0))
			+ (static_cast<double>(m - 1) * w - static_cast<double>(m)) / ((w - 1.) * (w - 1.));  // m log(1 - 1/w)

		// 计算Sum
		for (int k = 1; k <= m; ++k) {
			result += static_cast<double>((m-1)*(m - k)) / (static_cast<double>(k) * pow(w, k));  // 1 / (k * w^k)
			result += static_cast<double>(k - m) / (pow(w, k));
		}
		result *= pow(w, m - 2);
		return result;
	};

	complex<double> com_c0 = z0 - z;
	complex<double> w1 = (-z1 - sqrt(z1 * z1 - com_c0 * z2 * 4.0)) / (2.0 * z2);
	complex<double> w2 = (-z1 + sqrt(z1 * z1 - com_c0 * z2 * 4.0)) / (2.0 * z2);

	complex<double> result1 = ddgm(m, w1) * pow(w1 - w2, 6) - 2. * dgm(m, w1) * 3. * pow(w1 - w2, 5) + gm(m, w1) * 18. * pow(w1 - w2, 4) - gm(m, w1) * 6. * pow(w1 - w2, 4);
	result1 /= 2.*pow(w1 - w2, 9);
	complex<double> result2 = ddgm(m, w2) * pow(w2 - w1, 6) - 2. * dgm(m, w2) * 3. * pow(w2 - w1, 5) + gm(m, w2) * 18. * pow(w2 - w1, 4) - gm(m, w2) * 6. * pow(w2 - w1, 4);
	result2 /= 2.*pow(w2 - w1, 9);
	complex<double> result = result1 + result2;
	result *= 2./pow(z2, 3);
	return result;
}

//计算cauchy积分的二阶导数，分子t的m次方,分母是t的2次方
complex<double> cauchy_D2F3_n(const complex<double> z, const complex<double> z0, const complex<double> z1, const complex<double> z2, const complex<double> z3, int m)
{

	// gm lambda函数
	auto gm = [](int m, complex<double> w) -> complex<double> {
		complex<double> result = log(1.0 - 1.0 / w);  // log(1 - 1/w)

		// 计算Sum
		for (int k = 1; k <= m; ++k) {
			result += 1.0 / (static_cast<double>(k) * pow(w, k));  // 1 / (k * w^k)
		}
		result *= pow(w, m);
		return result;
	};

	// dgm lambda函数
	auto dgm = [](int m, complex<double> w) -> complex<double> {
		complex<double> result = static_cast<double>(m) * log(1.0 - 1.0 / w) + 1.0 / (w - 1.0);  // m log(1 - 1/w)+ 1/(w-1)

		// 计算Sum
		for (int k = 1; k <= m; ++k) {
			result += static_cast<double>(m - k) / (static_cast<double>(k) * pow(w, k));  // 1 / (k * w^k)
		}
		result *= pow(w, m - 1);
		return result;
	};

	// dgm lambda函数
	auto ddgm = [](int m, complex<double> w) -> complex<double> {
		complex<double> result = static_cast<double>(m - 1) * (static_cast<double>(m) * log(1.0 - 1.0 / w) + 1.0 / (w - 1.0))
			+ (static_cast<double>(m - 1) * w - static_cast<double>(m)) / ((w - 1.) * (w - 1.));  // m log(1 - 1/w)

		// 计算Sum
		for (int k = 1; k <= m; ++k) {
			result += static_cast<double>((m - 1) * (m - k)) / (static_cast<double>(k) * pow(w, k));  // 1 / (k * w^k)
			result += static_cast<double>(k - m) / (pow(w, k));
		}
		result *= pow(w, m - 2);
		return result;
	};
	auto f = [](complex<double> w, complex<double> w2, complex<double> w3) -> complex<double> {
		complex<double> result =  pow(w - w2, 3) * pow(w - w3, 3) ;
		return result;
	};
	// df lambda函数
	auto df = []( complex<double> w, complex<double> w2, complex<double> w3) -> complex<double> {
		complex<double> result = 3. * pow(w - w2, 2) * pow(w - w3, 3) + 3. * pow(w - w3, 2) * pow(w - w2, 3);
		return result;
	};
	//
	auto ddf = [](complex<double> w, complex<double> w2, complex<double> w3) -> complex<double> {
		complex<double> result = 6. * pow(w - w2, 3) * (w - w3) + 18. * pow(w - w2, 2) * pow(w - w3, 2)+6.*(w-w2)*pow(w-w3,3);
		return result;
	};

	complex<double> com_c0 = z0 - z;
	complex<double> com_c1 = z1;
	complex<double> com_c2 = z2;
	complex<double> com_c3 = z3;
	complex<double> w1;
	complex<double> w2;
	complex<double> w3;
	Cardano(com_c3, com_c2, com_c1, com_c0, w1, w2, w3);

	complex<double> result1 = ddgm(m, w1) * f(w1,w2,w3)*f(w1,w2,w3) - 2. * dgm(m, w1) * f(w1, w2, w3) * df(w1, w2, w3)
		+2.* gm(m, w1) * df(w1,w2,w3)*df(w1,w2,w3) - gm(m, w1) * f(w1, w2, w3) * ddf(w1, w2, w3);
	result1 /= 2. * pow(f(w1, w2, w3), 3);
	complex<double> result2 = ddgm(m, w2) * f(w2, w1, w3) * f(w2, w1, w3) - 2. * dgm(m, w2) * f(w2, w1, w3) * df(w2, w1, w3)
		+ 2. * gm(m, w2) * df(w2, w1, w3) * df(w2, w1, w3) - gm(m, w2) * f(w2, w1, w3) * ddf(w2, w1, w3);
	result2 /= 2. * pow(f(w2, w1, w3), 3);
	complex<double> result3 = ddgm(m, w3) * f(w3, w1, w2) * f(w3, w1, w2) - 2. * dgm(m, w3) * f(w3, w1, w2) * df(w3, w1, w2)
		+ 2. * gm(m, w3) * df(w3, w1, w2) * df(w3, w1, w2) - gm(m, w3) * f(w3, w1, w2) * ddf(w3, w1, w2);
	result3 /= 2. * pow(f(w3, w1, w2), 3);
	complex<double> result = result1 + result2+result3;
	result *= 2. / pow(z3, 3);
	return result;
}

//计算积分，分子t的m次方,分母是t的2次方,分母是模长的四次方,没有2 PI
double D2F2_n(const Mesh::Point eta, const Mesh::Point c0, const Mesh::Point c1, const Mesh::Point c2, int m)
{

	// gm lambda函数
	auto gm = [](int m, complex<double> w) -> complex<double> {
		complex<double> result = log(1.0 - 1.0 / w);  // log(1 - 1/w)

		// 计算Sum
		for (int k = 1; k <= m; ++k) {
			result += 1.0 / (static_cast<double>(k) * pow(w, k));  // 1 / (k * w^k)
		}

		return result;
	};

	// dgm lambda函数
	auto dgm = [](int m, complex<double> w) -> complex<double> {
		complex<double> result = complex<double>(m) * w * complex<double>(m - 1) * log(1.0 - 1.0 / w);  // m * w * (m - 1) * log(1 - 1/w)

		// 计算Sum
		for (int k = 1; k <= m; ++k) {
			result += 1.0 / (static_cast<double>(k) * pow(w, k));  // Sum 1 / (k * w^k)
		}

		// 第二部分的Sum
		for (int k = 1; k <= m; ++k) {
			result += -1.0 / (pow(w, k + 1) * (w - 1.0));  // Sum -1 / (w^(k+1) * (w - 1))
		}

		return result;
	};


	complex<double> com_c0(c0[0] - eta[0], c0[1] - eta[1]);
	complex<double> com_c1(c1[0], c1[1]);
	complex<double> com_c2(c2[0], c2[1]);
	complex<double> w1 = (-com_c1 - sqrt(com_c1 * com_c1 - com_c0 * com_c2 * 4.0)) / (2.0 * com_c2);
	complex<double> w2 = (-com_c1 + sqrt(com_c1 * com_c1 - com_c0 * com_c2 * 4.0)) / (2.0 * com_c2);

	double a = w1.real(); double b = abs(w1.imag());
	double c = w2.real(); double d = abs(w2.imag());
	w1 = complex<double>(a, b);
	w2 = complex<double>(c, d);
	complex<double> w1_c = conj(w1);
	complex<double> w2_c = conj(w2);

	// 计算公式中的Re的分母部分
	complex<double> numerator1 = pow(w1 - w1_c, 3) * pow(w1 - w2, 3) * pow(w1 - w2_c, 3);
	complex<double> numerator2 = pow(w2 - w1_c, 3) * pow(w2 - w2_c, 3) * pow(w2 - w1, 3);

	
	complex<double> result1 =
		(dgm(m, w1) * (w1 - w1_c) * (w1 - w2) * (w1 - w2_c) 
			- 2.0 * ((w1 - w2) * (w1 - w2_c) + (w1 - w1_c) * (w1 - w2_c) + (w1 - w1_c) * (w1 - w2)) * gm(m, w1))/numerator1;
	complex<double> result2 =
		(dgm(m, w2) * (w2 - w1_c) * (w2 - w1) * (w2 - w2_c)
			- 2.0 * ((w2 - w1) * (w2 - w1_c) + (w2 - w2_c) * (w2 - w1_c) + (w2 - w2_c) * (w2 - w1)) * gm(m, w2)) / numerator2;

	double result = 2.0 * real(result1) + 2.0 * real(result2);
	result /= ( norm(com_c2) * norm(com_c2));
	return result;
}
//输入顺序为3，2，1，0次项系数
void Cardano(complex<double> a, complex<double> b, complex<double> c, complex<double>d, complex<double>& x1, complex<double>& x2, complex<double>& x3)
{
	complex<double> u = (9.0 * a * b * c - 27.0 * a * a * d - 2.0 * b * b * b) / (54.0 * a * a * a);
	complex<double> v = sqrt(3.0 * (4.0 * a * c * c * c - b * b * c * c - 18.0 * a * b * c * d + 27.0 * a * a * d * d + 4.0 * b * b * b * d)) / (18.0 * a * a);

	complex<double> m;
	if (norm(u + v) >= norm(u - v))
	{
		m = pow(u + v, 1.0 / 3.0);
	}
	else
	{
		m = pow(u - v, 1.0 / 3.0);
	}

	complex<double> n;
	if (norm(m) != 0)
	{
		n = (b * b - 3.0 * a * c) / (9.0 * a * a * m);
	}
	else
	{
		n = 0;
	}

	complex<double> omega1 = complex<double>(-0.5, sqrt(3.0) / 2.0);
	complex<double> omega2 = complex<double>(-0.5, -sqrt(3.0) / 2.0);

	x1 = m + n - b / (3.0 * a);
	x2 = omega1 * m + omega2 * n - b / (3.0 * a);
	x3 = omega2 * m + omega1 * n - b / (3.0 * a);
}

void Cubicsolve(complex<double> poly3, complex<double> poly2, complex<double> poly1, complex<double>poly0, complex<double>& x0, complex<double>& x1, complex<double>& x2)
{
	std::complex<double> zeta = std::complex<double>(-0.5, 0.8660254037844386);
	std::complex<double> zeta2 = std::complex<double>(-0.5, -0.8660254037844386);
	double third = 0.3333333333333333;
	std::complex<double> s0, s1, s2;
	std::complex<double> E1;  //x0+x1+x2
	std::complex<double> E2;  //x0*x1+x1*x2+x2*x0
	std::complex<double> E3;  //x0*x1*x2
	std::complex<double> A, B, a_1, E12, delta, A2;

	std::complex<double> val, x;
	a_1 = 1. / poly3;
	E1 = -poly2 * a_1;
	E2 = poly1 * a_1;
	E3 = -poly0 * a_1;

	s0 = E1;
	E12 = E1 * E1;
	A = 2.0 * E1 * E12 - 9.0 * E1 * E2 + 27.0 * E3;
	B = E12 - 3.0 * E2;
	//quadratic equation z^2 - A * z + B^3 where roots are equal to s1^3 and s2^3
	A2 = A * A;
	delta = std::sqrt(A2 - 4.0 * (B * B * B));

	// 定义立方根计算的 Lambda 表达式（立即调用）
	auto compute_cbrt = [](const std::complex<double>& z) {
		double r = std::abs(z);
		double theta = std::arg(z);
		double cbrt_r = std::cbrt(r);
		double cbrt_theta = theta / 3.0;
		return cbrt_r *
			std::complex<double>(std::cos(cbrt_theta), std::sin(cbrt_theta));
	};

	if (std::real(std::conj(A) * delta) >= 0.0)
	{  // scalar product to decide the sign yielding bigger magnitude
		s1 = compute_cbrt(0.5 * (A + delta));
	}
	else
	{
		s1 = compute_cbrt(0.5 * (A - delta));
	}
	if (s1.real() == 0.0 && s1.imag() == 0.0)
	{
		s2 = std::complex<double>(0, 0);
	}
	else
	{
		s2 = B / s1;
	}

	x0 = third * (s0 + s1 + s2);
	x1 = third * (s0 + s1 * zeta2 + s2 * zeta);
	x2 = third * (s0 + s1 * zeta + s2 * zeta2);
}

//计算积分，分子t的m次方,分母是t的3次方
double F3_n(const Mesh::Point eta, const Mesh::Point c0, const Mesh::Point c1, const Mesh::Point c2, const Mesh::Point c3, int m)
{

	auto accumulateSum =[](complex<double> w,int m) {
		complex<double> sum = 0.0;
		for (int k = 1; k <= m; ++k) {
			sum += 1.0 / static_cast<double>(k) * pow(w, m - k);
		}
		return sum;
	};


	complex<double> com_c0(c0[0] - eta[0], c0[1] - eta[1]);
	complex<double> com_c1(c1[0], c1[1]);
	complex<double> com_c2(c2[0], c2[1]);
	complex<double> com_c3(c3[0], c3[1]);
	complex<double> w1;
	complex<double> w2;
	complex<double> w3;
	Cardano(com_c3, com_c2, com_c1, com_c0, w1, w2, w3);
	

	double a = w1.real(); double b = abs(w1.imag());
	double c = w2.real(); double d = abs(w2.imag());
	double e = w3.real(); double f = abs(w3.imag());
	w1 = complex<double>(a, b);
	w2 = complex<double>(c, d);
	w3 = complex<double>(e, f);
	complex<double> w1_c = conj(w1);
	complex<double> w2_c = conj(w2);
	complex<double> w3_c = conj(w3);

	complex<double> term1 =- pow(w1_c, m) * log(1.0 - 1.0 / w1_c) - accumulateSum(w1_c, m);
	complex<double> denominator1 = b  * (w1_c - w2_c) * (w1_c - w2) * (w1_c - w3_c) * (w1_c - w3);

	complex<double> term2 = -pow(w2_c, m) * log(1.0 - 1.0 / w2_c) - accumulateSum(w2_c, m);
	complex<double> denominator2 = d * (w2_c - w1_c) * (w2_c - w1) * (w2_c - w3_c) * (w2_c - w3);

	complex<double> term3 = -pow(w3_c, m) * log(1.0 - 1.0 / w3_c) - accumulateSum(w3_c, m);
	complex<double> denominator3 = f * (w3_c - w1_c) * (w3_c - w1) * (w3_c - w2_c) * (w3_c - w2);

	double result = imag(term1 / denominator1) + imag(term2 / denominator2) + imag(term3 / denominator3);
	
	
	result /= (2 * M_PI * norm(com_c3));
	return result;
}

//计算积分，分子t的m次方,分母是t的3次方
double F3_n(const OpenMesh::Vec2d eta, const OpenMesh::Vec2d c0, const OpenMesh::Vec2d c1, const OpenMesh::Vec2d c2, const OpenMesh::Vec2d c3, int m)
{

	auto accumulateSum = [](complex<double> w, int m) {
		complex<double> sum = 0.0;
		for (int k = 1; k <= m; ++k) {
			sum += 1.0 / static_cast<double>(k) * pow(w, m - k);
		}
		return sum;
	};


	complex<double> com_c0(c0[0] - eta[0], c0[1] - eta[1]);
	complex<double> com_c1(c1[0], c1[1]);
	complex<double> com_c2(c2[0], c2[1]);
	complex<double> com_c3(c3[0], c3[1]);
	complex<double> w1;
	complex<double> w2;
	complex<double> w3;
	Cardano(com_c3, com_c2, com_c1, com_c0, w1, w2, w3);


	double a = w1.real(); double b = abs(w1.imag());
	double c = w2.real(); double d = abs(w2.imag());
	double e = w3.real(); double f = abs(w3.imag());
	w1 = complex<double>(a, b);
	w2 = complex<double>(c, d);
	w3 = complex<double>(e, f);
	complex<double> w1_c = conj(w1);
	complex<double> w2_c = conj(w2);
	complex<double> w3_c = conj(w3);

	complex<double> term1 = -pow(w1_c, m) * log(1.0 - 1.0 / w1_c) - accumulateSum(w1_c, m);
	complex<double> denominator1 = b * (w1_c - w2_c) * (w1_c - w2) * (w1_c - w3_c) * (w1_c - w3);

	complex<double> term2 = -pow(w2_c, m) * log(1.0 - 1.0 / w2_c) - accumulateSum(w2_c, m);
	complex<double> denominator2 = d * (w2_c - w1_c) * (w2_c - w1) * (w2_c - w3_c) * (w2_c - w3);

	complex<double> term3 = -pow(w3_c, m) * log(1.0 - 1.0 / w3_c) - accumulateSum(w3_c, m);
	complex<double> denominator3 = f * (w3_c - w1_c) * (w3_c - w1) * (w3_c - w2_c) * (w3_c - w2);

	double result = imag(term1 / denominator1) + imag(term2 / denominator2) + imag(term3 / denominator3);


	result /= (2 * M_PI * norm(com_c3));
	return result;
}

//输出0到n的值，n最大为什么
vector<double> ALL_F3_n(const OpenMesh::Vec2d& eta, const OpenMesh::Vec2d& c0, const OpenMesh::Vec2d& c1, const OpenMesh::Vec2d& c2, const OpenMesh::Vec2d& c3, const int n) {
	const int N = 15;
	// 预计算复数参数
	const complex<double> com_c0(c0[0] - eta[0], c0[1] - eta[1]);
	const complex<double> com_c1(c1[0], c1[1]);
	const complex<double> com_c2(c2[0], c2[1]);
	const complex<double> com_c3(c3[0], c3[1]);

	complex<double> w1;
	complex<double> w2;
	complex<double> w3;
	//Cardano(com_c3, com_c2, com_c1, com_c0, w1, w2, w3);
	Cubicsolve(com_c3, com_c2, com_c1, com_c0, w1, w2, w3);
	complex<double> w1_c = conj(w1);
	complex<double> w2_c = conj(w2);
	complex<double> w3_c = conj(w3);
	// 预计算公共项
	const double norm_w1 = norm(w1);  // |w1|²
	const double real_w1 = real(w1);  // Re(w1)
	const double imag_w1 = imag(w1);  // Im(w1)
	const double norm_w2 = norm(w2);
	const double real_w2 = real(w2);
	const double imag_w2 = imag(w2);
	const double norm_w3 = norm(w3);
	const double real_w3 = real(w3);
	const double imag_w3 = imag(w3);

	// 预计算logs2（优化重复计算）
	array<complex<double>, 3> logs3; // 改用vector
	logs3[0] = complex<double>(
		0.5 * log(1.0 + (1 - 2 * real_w1) / norm_w1),
		atan2(imag_w1, norm_w1 - real_w1)
	);
	logs3[1] = complex<double>(
		0.5 * log(1.0 + (1 - 2 * real_w2) / norm_w2),
		atan2(imag_w2, norm_w2 - real_w2)
	);
	logs3[2] = complex<double>(
		0.5 * log(1.0 + (1 - 2 * real_w3) / norm_w3),
		atan2(imag_w3, norm_w3 - real_w3)
	);

	double A = 2 * M_PI * norm(com_c3);
	std::array<std::complex<double>, 3> hs3;
	hs3[0] = A * w1.imag() * (w1 - w2) * (w1 - w2_c) * (w1 - w3) * (w1 - w3_c);
	hs3[1] = A * w2.imag() * (w2 - w1) * (w2 - w1_c) * (w2 - w3) * (w2 - w3_c);
	hs3[2] = A * w3.imag() * (w3 - w1) * (w3 - w1_c) * (w3 - w2) * (w3 - w2_c);

	array<complex<double>, N> G1;
	array<complex<double>, N> G2;
	array<complex<double>, N> G3;
	vector<double> results(n + 1);

	G1[0] = logs3[0] / (hs3[0]);
	G2[0] = logs3[1] / (hs3[1]);
	G3[0] = logs3[2] / (hs3[2]);
	results[0] = imag(G1[0]) + imag(G2[0]) + imag(G3[0]);

	G1[1] = w1 * (G1[0]);
	G2[1] = w2 * (G2[0]);
	G3[1] = w3 * (G3[0]);
	results[1] = imag(G1[1]) + imag(G2[1]) + imag(G3[1]);
	std::array<std::complex<double>, 3> yuxiang3;
	yuxiang3[0] = w1 / hs3[0];
	yuxiang3[1] = w2 / hs3[1];
	yuxiang3[2] = w3 / hs3[2];
	for (int i = 2; i <= n; i++) {
		G1[i] = w1 * G1[i - 1] + yuxiang3[0] / double(i - 1);
		G2[i] = w2 * G2[i - 1] + yuxiang3[1] / double(i - 1);
		G3[i] = w3 * G3[i - 1] + yuxiang3[2] / double(i - 1);
		results[i] = imag(G1[i]) + imag(G2[i]) + imag(G3[i]);
	}
	return results;

}

void partion_handles(const std::vector<Mesh::Point>& Handle_points,
	std::vector<std::complex<double>>& deform_cps,
	std::vector<std::complex<double>>& deform_cps_t)
{
	deform_cps.clear();
	deform_cps_t.clear();

	for (size_t i = 0; i < Handle_points.size(); ++i)
	{
		// 将Mesh::Point转为std::complex<double>，假设Mesh::Point有x和y两个分量
		std::complex<double> point(Handle_points[i][0], Handle_points[i][1]);

		// 奇偶分配
		if (i % 2 == 0)
		{
			deform_cps.push_back(point);
		}
		else
		{
			deform_cps_t.push_back(point);
		}
	}
}



Mesh::Point evaluate_coor(const std::vector<double> weight, const std::vector<Mesh::Point> ctps)
{
	assert(weight.size() == ctps.size());
	Mesh::Point result(0,0,0);
	for (int i = 0; i < weight.size(); i++)
	{
		result += weight[i] * ctps[i];
	}
	//std::cout << result << std::endl;
	return result;
}
std::vector<double> MeshViewerWidget::calculateDistortARAP(const Mesh& src, const Mesh& dst)
{
	const size_t num_vertices = src.n_vertices();
	//std::vector<double> vertEnergy(num_vertices,0); // 初始化为0
	const size_t num_faces = src.n_faces();
	std::vector<double> vertEnergy(num_faces, 0); // 初始化为0

	// 遍历所有面（三角形）
	for (const auto& fh:src.faces()) {
		// 获取原始网格和目标网格的顶点坐标
		std::array<Mesh::VertexHandle, 3> handles;
		int idx = 0;
		for (auto fv_it = src.cfv_iter(fh); fv_it.is_valid(); ++fv_it, ++idx) {
			handles[idx] = *fv_it;
		}

		OpenMesh::Vec2d src_v[3], dst_v[3];

		// 目标网格对应顶点的坐标（平面网格z=0）
		for (int i = 0; i < 3; ++i) {
			const auto& p_src = src.point(handles[i]);
			const auto& p_dst = dst.point(handles[i]); // 假设顶点索引完全对应
			src_v[i] = OpenMesh::Vec2d(p_src[0], p_src[1]);
			dst_v[i] = OpenMesh::Vec2d(p_dst[0], p_dst[1]);
		}

		// 构建边向量矩阵（从v0出发的边）
		Eigen::Matrix2d srcEdges, dstEdges;
		srcEdges.col(0) = Eigen::Vector2d(src_v[1].data()) - Eigen::Vector2d(src_v[0].data());
		srcEdges.col(1) = Eigen::Vector2d(src_v[2].data()) - Eigen::Vector2d(src_v[0].data());
		dstEdges.col(0) = Eigen::Vector2d(dst_v[1].data()) - Eigen::Vector2d(dst_v[0].data());
		dstEdges.col(1) = Eigen::Vector2d(dst_v[2].data()) - Eigen::Vector2d(dst_v[0].data());

		// 计算Jacobian矩阵 J = dstEdges * srcEdges^{-1}
		Eigen::Matrix2d srcEdgesInv;
		bool invertible;
		double determinant;
		srcEdges.computeInverseAndDetWithCheck(srcEdgesInv, determinant, invertible);

		if (!invertible || fabs(determinant) < 1e-10) { // 跳过退化三角形
			continue;
		}

		Eigen::Matrix2d J = dstEdges * srcEdgesInv;
		Eigen::JacobiSVD<Eigen::Matrix2d> svd(J);
		Eigen::Vector2d sigma = svd.singularValues();
		double sigma1 = sigma(0), sigma2 = sigma(1);
		double energy = log(sigma1/sigma2)* log(sigma1 / sigma2);
		//// 极分解求最佳旋转矩阵 R
		//Eigen::JacobiSVD<Eigen::Matrix2d> svd(J, Eigen::ComputeFullU | Eigen::ComputeFullV);
		//Eigen::Matrix2d U = svd.matrixU();
		//Eigen::Matrix2d V = svd.matrixV();
		//Eigen::Matrix2d R = U * V.transpose();

		//// 计算ARAP能量 ||J - R||_F^2
		//double energy = (J - R).squaredNorm();
		vertEnergy[fh.idx()] += energy; // 使用顶点索引直接定位
		// 将能量平均分配到三个顶点
		//energy /= 3.0;
		//for (int i = 0; i < 3; ++i) {
		//	vertEnergy[handles[i].idx()] += energy; // 使用顶点索引直接定位
		//}
	}

	return vertEnergy;
}

std::vector<double> MeshViewerWidget::calculateDistortSymDirichlet(const Mesh& src, const Mesh& dst)
{
	const size_t num_vertices = src.n_vertices();
	const size_t num_faces = src.n_faces();
	std::vector<double> vertEnergy(num_faces, 0); // 初始化为0

	// 遍历所有面（三角形）
	for (const auto& fh : mesh.faces()) {
		// 获取原始网格和目标网格的顶点坐标
		std::array<Mesh::VertexHandle, 3> handles;
		int idx = 0;
		for (auto fv_it = src.cfv_iter(fh); fv_it.is_valid(); ++fv_it, ++idx) {
			handles[idx] = *fv_it;
		}

		OpenMesh::Vec2d src_v[3], dst_v[3];

		// 目标网格对应顶点的坐标（平面网格z=0）
		for (int i = 0; i < 3; ++i) {
			const auto& p_src = src.point(handles[i]);
			const auto& p_dst = dst.point(handles[i]); // 假设顶点索引完全对应
			src_v[i] = OpenMesh::Vec2d(p_src[0], p_src[1]);
			dst_v[i] = OpenMesh::Vec2d(p_dst[0], p_dst[1]);
		}

		// 构建边向量矩阵（从v0出发的边）
		Eigen::Matrix2d srcEdges, dstEdges;
		srcEdges.col(0) = Eigen::Vector2d(src_v[1].data()) - Eigen::Vector2d(src_v[0].data());
		srcEdges.col(1) = Eigen::Vector2d(src_v[2].data()) - Eigen::Vector2d(src_v[0].data());
		dstEdges.col(0) = Eigen::Vector2d(dst_v[1].data()) - Eigen::Vector2d(dst_v[0].data());
		dstEdges.col(1) = Eigen::Vector2d(dst_v[2].data()) - Eigen::Vector2d(dst_v[0].data());

		// 计算Jacobian矩阵 J = dstEdges * srcEdges^{-1}
		Eigen::Matrix2d srcEdgesInv;
		bool invertible;
		double determinant;
		srcEdges.computeInverseAndDetWithCheck(srcEdgesInv, determinant, invertible);

		// 跳过退化三角形（行列式接近0或不可逆）
		if (!invertible || std::abs(determinant) < 1e-10) {
			continue;
		}

		Eigen::Matrix2d J = dstEdges * srcEdgesInv;

		//// 计算对称Dirichlet能量: tr(J^T J) + tr((J^{-1})^T J^{-1})
		//Eigen::Matrix2d J_inv;
		//J.computeInverseWithCheck(J_inv, invertible);
		//if (!invertible) {
		//	continue; // 二次检查J是否可逆
		//}

		//// 正向能量项: tr(J^T J)
		//double energy_forward = (J.transpose() * J).trace();

		//// 逆向能量项: tr((J^{-1})^T J^{-1}) = tr((J J^T)^{-1})
		//double energy_inverse = (J_inv.transpose() * J_inv).trace();

		//// 总能量
		//double energy = energy_forward + energy_inverse;

		// 计算Jacobian矩阵的奇异值σ1和σ2
		Eigen::JacobiSVD<Eigen::Matrix2d> svd(J);
		Eigen::Vector2d sigma = svd.singularValues();
		double sigma1 = sigma(0), sigma2 = sigma(1);

		// 根据公式计算对称Dirichlet能量: σ1² + σ2² + σ1⁻² + σ2⁻²
		double energy = (sigma1 * sigma1 + sigma2 * sigma2) + (1.0 / (sigma1 * sigma1) + 1.0 / (sigma2 * sigma2));
		//double energy = (sigma1 -1)*(sigma1 - 1) + (sigma2 - 1) * (sigma2 - 1);

		vertEnergy[fh.idx()] += energy; // 使用顶点索引直接定位
		// 将能量平均分配到三个顶点
		//energy /= 3.0;
		//for (int i = 0; i < 3; ++i) {
		//	vertEnergy[handles[i].idx()] += energy; // 使用顶点索引直接定位
		//}
	}

	return vertEnergy;
}

bool MeshViewerWidget::NearestVertex(OpenMesh::Vec3d objCor, OpenMesh::VertexHandle& minVh)
{
	double maxAllowedDis = avgEdgeLength * 0.5;
	double minDis = INFINITY;
	OpenMesh::VertexHandle mv;

	for (auto vh : mesh.vertices())
	{
		auto vp = mesh.point(vh);
		double dis = (objCor - vp).norm();
		if (dis < minDis)
		{
			minDis = dis;
			mv = vh;
		}
	}
	//std::cout << minDis << "," << maxAllowedDis << endl;
	if (minDis <= maxAllowedDis)
	{
		minVh = mv;
		return true;
	}
	else
	{
		return false;
	}
}

bool MeshViewerWidget::GetBoundaryVertices()
{
	// 遍历所有的边
	for (const auto& eh : mesh.edges())
	{
		// 如果是边界边
		if (mesh.is_boundary(eh))
		{
			// 获取半边句柄
			auto heh = mesh.halfedge_handle(eh, 0);

			// 获取两个顶点句柄
			auto vh0 = mesh.from_vertex_handle(heh);
			auto vh1 = mesh.to_vertex_handle(heh);

			// 获取顶点坐标并添加到数组中
			boundary_vertices.push_back(mesh.point(vh0));
			//boundary_vertices.push_back(mesh.point(vh1));
		}
	}
	return true;
}


VectorXd MeshViewerWidget::testmain(Eigen::MatrixXd &f, Eigen::MatrixXd &d)
{
	const int n = f.rows();
	// Set up parameters
	LBFGSParam<double> param;
	param.epsilon = 1e-10;
	param.max_iterations = 100;

	// Create solver and function object
	LBFGSSolver<double> solver(param);
	Rosenbrock fun(n,B,C,f,d);

	// Initial guess
	VectorXd x = VectorXd::Ones(n);
	// x will be overwritten to be the best point found
	double fx;
	int niter = solver.minimize(fun, x, fx);

	std::cout << niter << " iterations" << std::endl;
	std::cout << "x = \n" << x.transpose() << std::endl;
	std::cout << "f(x) = " << fx << std::endl;
	return x;
}

VectorXd MeshViewerWidget::testmain2(Eigen::MatrixXd& f, Eigen::MatrixXd& d)
{
	const int n = f.rows();
	int m = n / 2;
	// Set up parameters
	LBFGSBParam<double> param;
	param.epsilon = 1e-6;
	param.max_iterations = 50;

	// Create solver and function object
	LBFGSBSolver<double> solver(param);
	Rosenbrock2 fun(n, B, C, f, d);

	// Bounds
	VectorXd lb = VectorXd::Constant(m, 0.1);
	VectorXd ub = VectorXd::Constant(m, 100.0);

	// Initial guess
	VectorXd x = VectorXd::Ones(m);
	// x will be overwritten to be the best point found
	double fx;
	int niter = solver.minimize(fun, x, fx,lb,ub);

	std::cout << niter << " iterations" << std::endl;
	std::cout << "x = \n" << x.transpose() << std::endl;
	std::cout << "f(x) = " << fx << std::endl;

	MatrixXd X = MatrixXd::Zero(n, n);
	for (int i = 0; i < m; i++)
	{
		X(i, i) = 1;
		X(i+m, i+m) = 1;
	}
	MatrixXd Laplacian = B * f + C * X * d;
	std::cout << "beforeLf" << Laplacian << std::endl;
	for (int i = 0; i < m; i++)
	{
		X(i, i) = x[i];
		X(i + m, i + m) = x[i];
	}
	Laplacian = B * f + C * X * d;
	std::cout << "afterLf" << Laplacian << std::endl;
		
	return x;
}


VectorXd MeshViewerWidget::testmain2AAAP(Eigen::MatrixXd& f, Eigen::MatrixXd& d)
{
	const int n = f.rows();
	int m = n / 2;
	// Set up parameters
	LBFGSBParam<double> param;
	param.epsilon = 1e-6;
	param.max_iterations = 50;

	// Create solver and function object
	LBFGSBSolver<double> solver(param);
	Eigen::MatrixXd f2(2 * n, 2);
	f2 << f, f;
	Eigen::MatrixXd d2(2 * n, 2);
	d2 << d, d;
	/*std::cout << AAAB << std::endl;
	std::cout << AAAC << std::endl;*/
	Rosenbrock2AAAP fun(n, AAAB, AAAC, f2, d2);

	// Bounds
	VectorXd lb = VectorXd::Constant(m, 0.1);
	VectorXd ub = VectorXd::Constant(m, 100.0);

	// Initial guess
	VectorXd x = VectorXd::Ones(m);
	// x will be overwritten to be the best point found
	double fx;
	int niter = solver.minimize(fun, x, fx,lb,ub);

	std::cout << niter << " iterations" << std::endl;
	std::cout << "x = \n" << x.transpose() << std::endl;
	std::cout << "f(x) = " << fx << std::endl;

	MatrixXd X = MatrixXd::Zero(n, n);
	for (int i = 0; i < m; i++)
	{
		X(i, i) = 1;
		X(i + m, i + m) = 1;
	}
	MatrixXd Laplacian = B * f + C * X * d;
	std::cout << "beforeLf" << Laplacian << std::endl;
	for (int i = 0; i < m; i++)
	{
		X(i, i) = x[i];
		X(i + m, i + m) = x[i];
	}
	Laplacian = B * f + C * X * d;
	std::cout << "afterLf" << Laplacian << std::endl;

	return x;
}


std::vector<OpenMesh::Vec3d> MeshViewerWidget::GetSamplePointsWithOffset()
{
	std::vector<OpenMesh::Vec3d > sample_points;
	// 遍历所有的面
	for (const auto& fh : CC_mesh.faces())
	{
		// 获取面上的三个顶点句柄
		OpenMesh::Vec3d p0, p1, p2;
		int idx = 0;

		for (auto fv_it = CC_mesh.fv_iter(fh); fv_it.is_valid(); ++fv_it) {
			if (idx == 0)
				p0 = CC_mesh.point(*fv_it);
			else if (idx == 1)
				p1 = CC_mesh.point(*fv_it);
			else if (idx == 2)
				p2 = CC_mesh.point(*fv_it);
			++idx;
		}

		// 计算三角形的法向量
		auto edge1 = p1 - p0;  // 边P0->P1
		auto edge2 = p2 - p0;  // 边P0->P2
		auto normal = edge1 % edge2;  // 叉积，得到法向量
		normal = normal / normal.length();  // 归一化法向量

		// 偏移量：沿法向量负方向位移0.01的距离
		float offset = 0.01f;

		// 按照重心坐标计算四个采样点
		// 1. (2/3, 1/6, 1/6)
		auto point1 = (2.0 / 3.0) * p0 + (1.0 / 6.0) * p1 + (1.0 / 6.0) * p2;
		point1 -= offset * normal;  // 沿法向负方向移动

		// 2. (1/6, 2/3, 1/6)
		auto point2 = (1.0 / 6.0) * p0 + (2.0 / 3.0) * p1 + (1.0 / 6.0) * p2;
		point2 -= offset * normal;  // 沿法向负方向移动

		// 3. (1/6, 1/6, 2/3)
		auto point3 = (1.0 / 6.0) * p0 + (1.0 / 6.0) * p1 + (2.0 / 3.0) * p2;
		point3 -= offset * normal;  // 沿法向负方向移动

		// 4. (1/3, 1/3, 1/3)
		auto point4 = (1.0 / 3.0) * p0 + (1.0 / 3.0) * p1 + (1.0 / 3.0) * p2;
		point4 -= offset * normal;  // 沿法向负方向移动

		// 将四个采样点添加到数组中
		sample_points.push_back(point1);
		sample_points.push_back(point2);
		sample_points.push_back(point3);
		sample_points.push_back(point4);
	}
	return sample_points;
}


bool MeshViewerWidget::GetCBoundaryVertices()
{
	int total_samples = 1000;
	int num_curves = curvecage2.size();
	std::vector<int> samples_per_curve(num_curves);
	

	vector<double> edge_length(curvecage2.size());
	for (int i = 0; i < curvecage2.size(); i++)
	{
		BezierCurve BezierC(curvecage2[i], false);
		edge_length[i] = BezierC.approximateLength();
		std::cout << edge_length[i]<<std::endl;
	}
	double total_length = std::accumulate(edge_length.begin(), edge_length.end(), 0.0);
	std::vector<std::pair<double, int>> fractional_parts;
	int current_total_assigned_samples = 0;

	for (size_t i = 0; i < num_curves; ++i) {
		// Calculate the exact number of samples for this curve
		double exact_samples = (static_cast<double>(total_samples) * edge_length[i]) / total_length;

		// Assign the floor of the exact number
		int integer_samples = static_cast<int>(std::floor(exact_samples));
		samples_per_curve[i] = integer_samples;
		current_total_assigned_samples += integer_samples;

		// Store the fractional part and the original index
		fractional_parts.push_back({ exact_samples - integer_samples, static_cast<int>(i) });
	}

	// 3. Distribute the remainder
	int remainder = total_samples - current_total_assigned_samples;

	// Sort the curves by their fractional parts in descending order
	std::sort(fractional_parts.rbegin(), fractional_parts.rend());

	// Add 1 sample to the curves with the largest fractional parts until the remainder is zero
	for (int i = 0; i < remainder; ++i) {
		// The index of the curve to add a sample to is stored in the pair's second element
		samples_per_curve[fractional_parts[i].second]++;
	}


	std::vector<OpenMesh::Vec2d> curve_cage;
	curve_cage.resize(CC_points.size());
	for (int i = 0; i < curve_cage.size(); i++)
		curve_cage[i] = Vec322(CC_points[i]);
	//auto samplesP = offsetCage_samples(curve_cage, 1e-6, 20);
	auto samplesP = offsetCage_samples_adapt(curve_cage, 1e-6, samples_per_curve);
	Cboundary_vertices.resize(samplesP.size());
	for (int i = 0; i < samplesP.size(); i++)
		Cboundary_vertices[i] = Vec223(samplesP[i]);
	
	return true;
}

void MeshViewerWidget::ConstructMatrix3DOffset() {
	auto samplePoints = GetSamplePointsWithOffset();
	for (int i = 0; i < samplePoints.size(); i++)
	{
		int f_id = i / 4;
		int sp_id = i % 4;
		// 遍历所有面
		for (const auto& fh : CC_mesh.faces())
		{
			std::vector<OpenMesh::Vec3d> face_vertices;
			for (auto fv_it = CC_mesh.fv_iter(fh); fv_it.is_valid(); ++fv_it)
			{
				auto vh = *fv_it;
				auto point = CC_mesh.point(vh);
				face_vertices.push_back(point);
			}
			double ksiH, ksiBH;
			std::vector<double> phiBH, phiH;
			CalBiharmonicBasis3D(face_vertices[0], face_vertices[1], face_vertices[2], samplePoints[i], f_id, ksiBH, phiBH);
			CalGreenBasis3D(face_vertices[0], face_vertices[1], face_vertices[2], samplePoints[i], f_id, ksiH, phiH);
		}

	}
}


void MeshViewerWidget::ConstructMatrix4() {
	int m = linear_cage.size();
	// 定义四个 m * m 的矩阵 A, B, C, D，元素类型为 double
	A.resize(m, m); B.resize(m, m); C.resize(m, m); D.resize(m, m);
	Eigen::MatrixXd psiH(m, m); Eigen::MatrixXd psiBH(m, m); Eigen::MatrixXd phiH(m, m); Eigen::MatrixXd phiBH(m, m);
	Eigen::MatrixXd II = Eigen::MatrixXd::Identity(m, m);
	// 初始化或填充矩阵 A, B, C, D
	for (int i = 0; i < m; ++i) {
		OpenMesh::Vec2d vi = linear_cage[i];
		for (int j = 0; j < m; ++j) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			double v_psiH, v_psiBH, v_phiH, v_phiBH;
			if (j==i) {
				CalBiharmonicBasisonVertexs(v0, v1, v2,  v_psiH, v_phiH, v_psiBH, v_phiBH);
			}
			else if (j == (i - 1+m) % m) {
				CalBiharmonicBasisonVertexsNext(v0, v1, v2, v_psiH, v_phiH, v_psiBH, v_phiBH);
			}
			else if (j == (i + 1) % m)
			{
				//CalBiharmonicBasisonVertexsBef(v0, v1, v2, v_psiH, v_phiH, v_psiBH, v_phiBH);
			}
			else
			{
				CalBiharmonicBasis(v0, v1, v2, vi, v_psiH, v_phiH, v_psiBH, v_phiBH);
				//std::cout << v_psiH << std::endl;
			}
			psiH(i, j) = v_psiH;
			psiBH(i, j) = v_psiBH;
			phiH(i, j) = v_phiH;
			phiBH(i, j) = v_phiBH;
		}
	}
	std::cout << "ksiH" << psiH << std::endl;
	if (psiH.determinant() == 0) {
		std::cout << "ksiH is singular, cannot compute inverse" << std::endl;
	}
	std::cout << "determinant" << psiH.determinant() << std::endl;
	std::cout << "ksiH.inverse()" << psiH.inverse() << std::endl;
	std::cout << "phi" << phiH << std::endl;
	A = psiH.inverse() * (II - phiH);
	std::cout << "A" << A << std::endl;
	// Calculating matrix D: D = (phiBH + psiBH * A).inverse()
	D = (phiBH + psiBH * A).inverse();
	std::cout << "D" << D << std::endl;
	// Calculating matrix B: B = D * (I - phiH)
	B = D * (II - phiH);
	std::cout << "B" << B << std::endl;
	// Calculating matrix C: C = -D * psiH
	C = -D * psiH;
	std::cout << "C" << C << std::endl;
}

void MeshViewerWidget::ConstructMatrix4OffSet() {
	int m = linear_cage.size();
	std::vector<OpenMesh::Vec2d> offset_cage = offsetCage(linear_cage, 0.000001);
	// 定义四个 m * m 的矩阵 A, B, C, D，元素类型为 double
	A.resize(m, m); B.resize(m, m); C.resize(m, m); D.resize(m, m);
	Eigen::MatrixXd ksiH(m, m); Eigen::MatrixXd ksiBH(m, m); Eigen::MatrixXd phiH(m, m); Eigen::MatrixXd phiBH(m, m);
	Eigen::MatrixXd II = Eigen::MatrixXd::Identity(m, m);
	std::cout << II << std::endl;
	// 初始化或填充矩阵 A, B, C, D
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = offset_cage[i];
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j ];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			double v_ksiH, v_ksiBH, v_phiH, v_phiBH;
			CalBiharmonicBasisBef(v0, v1, v2, vi, v_ksiH, v_phiH, v_ksiBH, v_phiBH);//test
			//CalBiharmonicBasis(v0, v1, v2, vi, v_ksiH, v_phiH, v_ksiBH, v_phiBH);
			ksiH(i, j) = v_ksiH;  
			ksiBH(i, j) = v_ksiBH;//test
			phiH(i, j) = v_phiH;
			phiBH(i, j) = v_phiBH;  
		}
	}
	std::cout << "ksiH" << ksiH << std::endl;
	double condition_number = ksiH.norm() * ksiH.inverse().norm();
	std::cout << "Condition number: " << condition_number << std::endl;
	std::cout << "determinant" << ksiH.determinant() << std::endl;
	std::cout << "ksiH.inverse()" << ksiH.inverse() << std::endl;
	std::cout << "phi" << phiH << std::endl;
	A = ksiH.inverse() * (II - phiH);
	std::cout <<"A"<< A << std::endl;
	// Calculating matrix D: D = (phiBH + psiBH * A).inverse()
	D = (phiBH + ksiBH * A).inverse();
	std::cout << "D" << D << std::endl;
	// Calculating matrix B: B = D * (I - phiH)
	B = D * (II - phiH);
	std::cout << "B" << B << std::endl;
	// Calculating matrix C: C = -D * psiH
	C = -D * ksiH;
	std::cout << "C" << C << std::endl;
	Eigen::MatrixXd f(m, 2);
	for (int i = 0; i < m; ++i) {
		f(i, 0) = linear_cage[i][0];
		f(i, 1) = linear_cage[i][1];
	}
	Eigen::MatrixXd d(m, 2);
	for (int i = 0; i < m; ++i) {
		d(i, 0) = (linear_cage[(i + 1) % m] - linear_cage[i]).normalized()[1];
		d(i, 1) = -(linear_cage[(i + 1) % m] - linear_cage[i]).normalized()[0];
	}
	std::cout <<"f "<< f << std::endl;
	std::cout << "d " << d << std::endl;
	std::cout << "test1" << (II-phiH)*f - ksiH * d << std::endl;
	std::cout <<"test2"<< B * f + C * d << std::endl;
}
//直接virtual,多采样了点
void MeshViewerWidget::NewConstructMatrix4OffSet() {
	int m = linear_cage.size();
	std::vector<OpenMesh::Vec2d> offset_cage = offsetCage(linear_cage, 0.000001);
	auto linearcage2 = subdivideCage(offset_cage);
	offset_cage = linearcage2;
	// 定义四个 m * m 的矩阵 A, B, C, D，元素类型为 double
	A.resize(m, m); B.resize(m, m); C.resize(m, m); D.resize(m, m);
	Eigen::MatrixXd ksiH(2 * m, m); Eigen::MatrixXd ksiBH(2 * m, m); Eigen::MatrixXd phiH(2 * m, m); Eigen::MatrixXd phiBH(2 * m, m);
	Eigen::MatrixXd II = Eigen::MatrixXd::Identity(2 * m, m);
	Eigen::MatrixXd III = Eigen::MatrixXd::Zero(2 * m, m);
	// 初始化或填充矩阵 A, B, C, D
	for (int i = 0; i < 2 * m; i++) {
		OpenMesh::Vec2d vi = offset_cage[i];
		if (i % 2 == 0) {
			III(i, i / 2) = 1;
		}
		else {
			III(i, i / 2) = 1. / 2;
			III(i, (i / 2 + 1) % m) = 1. / 2;
		}
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			double v_ksiH, v_ksiBH, v_phiH, v_phiBH;
			CalBiharmonicBasis(v0, v1, v2, vi, v_ksiH, v_phiH, v_ksiBH, v_phiBH);
			ksiH(i, j) = v_ksiH;
			ksiBH(i, j) = v_ksiBH;//test
			phiH(i, j) = v_phiH;
			phiBH(i, j) = v_phiBH;
		}
	}
	Eigen::MatrixXd Phi_L = phiH; Eigen::MatrixXd M_L = III; Eigen::MatrixXd Ksi_L = ksiH;
	Eigen::MatrixXd Phi_V = phiH; Eigen::MatrixXd M_V = III; Eigen::MatrixXd Ksi_V = ksiH; Eigen::MatrixXd PhiBar_V = phiBH; Eigen::MatrixXd KsiBar_V = ksiBH;
	A.resize(2*m, 2 * m); B.resize(2*m, 2 * m);
	A << PhiBar_V, KsiBar_V;
	B << Phi_L - M_L, Ksi_L;
	Eigen::MatrixXd ATABTB_i = (A.transpose() * A + B.transpose() * B).inverse();
	Eigen::MatrixXd C_LD = ATABTB_i * A.transpose();
	Eigen::MatrixXd C_L = C_LD.topRows(m);
	Eigen::MatrixXd C_D = C_LD.bottomRows(m);
	
	A = C_D;
	B = M_V - Phi_V;
	C = -Ksi_V;
	NewCL = C_L;
}

void MeshViewerWidget::ConstructMatrix4OffSetTest() {
	int m = linear_cage.size();
	std::vector<OpenMesh::Vec2d> offset_cage = offsetCage(linear_cage, 0.000001);
	// 定义四个 m * m 的矩阵 A, B, C, D，元素类型为 double
	A.resize(2*m, 2*m); B.resize(m, m); C.resize(m, m); D.resize(m, m);
	Eigen::MatrixXd ksiH(2*m, m); Eigen::MatrixXd ksiBH(2 * m, 2 * m); Eigen::MatrixXd phiH(2*m, m); Eigen::MatrixXd phiBH(2 * m, 2 * m);
	Eigen::MatrixXd ksiH_2(2 * m, 2 * m); Eigen::MatrixXd phiH_2(2 * m, 2 * m);
	Eigen::MatrixXd II = Eigen::MatrixXd::Zero(2 * m, m);
	Eigen::MatrixXd dII = Eigen::MatrixXd::Zero(2 * m, 2 * m);
	//std::cout << II << std::endl;
	// 初始化或填充矩阵 A, B, C, D
	for (int i = 0; i < m; i++) {
		dII(i, i) = 1;
		II(i, i) = 1;
		OpenMesh::Vec2d vi = offset_cage[i];
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			double v_ksiH, v_ksiBH, v_phiH, v_phiBH;
			CalBiharmonicBasis(v0, v1, v2, vi, v_ksiH, v_phiH, v_ksiBH, v_phiBH);	
			phiH(i, j) = v_phiH;
			ksiH(i, j) = v_ksiH;
			std::vector<double> values;
			CalBiharmonicTwiceBasis(v0, v1, v2, vi, values);
			phiH_2(i, j) = values[0]; phiH_2(i, j + m) = values[1];
			ksiH_2(i, j) = values[10]; ksiH_2(i, j + m) = values[11];
			phiBH(i, j) = values[4]; phiBH(i, j + m) = values[5];
			ksiBH(i, j) = values[6]; ksiBH(i, j + m) = values[7];
		}
	}
	//边中点采样
	for (int i = 0; i < m; i++) {
		dII(i + m, i) = 1. / 4;
		dII(i + m, (i + 1) % m) = 1. / 4;
		dII(i + m, i + m) = 2. / 4;
		II(i + m, i) = 1. / 2;
		II(i + m, (i + 1) % m) = 1. / 2;
		OpenMesh::Vec2d vi = 1. / 2 * (offset_cage[i] + offset_cage[(i + 1) % m]);
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			double v_ksiH, v_ksiBH, v_phiH, v_phiBH;
			CalBiharmonicBasis(v0, v1, v2, vi, v_ksiH, v_phiH, v_ksiBH, v_phiBH);
			phiH(i+m, j) = v_phiH;
			ksiH(i+m, j) = v_ksiH;
			std::vector<double> values;
			CalBiharmonicTwiceBasis(v0, v1, v2, vi, values);
			phiH_2(i+m, j) = values[0]; phiH_2(i+m, j + m) = values[1];
			ksiH_2(i+m, j) = values[10]; ksiH_2(i+m, j + m) = values[11];
			phiBH(i+m, j) = values[4]; phiBH(i+m, j + m) = values[5];
			ksiBH(i+m, j) = values[6]; ksiBH(i+m, j + m) = values[7];
		}
	}
	std::cout << "ksiH_2" << ksiH_2 << std::endl;
	double condition_number = ksiH_2.norm() * ksiH_2.inverse().norm();
	std::cout << "Condition number: " << condition_number << std::endl;
	std::cout << "determinant" << ksiH_2.determinant() << std::endl;
	/*std::cout << "ksiH" << ksiH << std::endl;
	double condition_number = ksiH.norm() * ksiH.inverse().norm();
	std::cout << "Condition number: " << condition_number << std::endl;
	std::cout << "determinant" << ksiH.determinant() << std::endl;
	std::cout << "ksiH.inverse()" << ksiH.inverse() << std::endl;
	std::cout << "phi" << phiH << std::endl;*/
	A = ksiH_2.inverse() * (dII - phiH_2);
	//A = ksiH.inverse() * (II - phiH);
	// Calculating matrix D: D = (phiBH + psiBH * A).inverse()
	D = (phiBH + ksiBH * A).inverse();
	std::cout << "D" << D << std::endl;
	// Calculating matrix B: B = D * (I - phiH)
	B = D * (II - phiH);
	std::cout << "B" << B << std::endl;
	// Calculating matrix C: C = -D * psiH
	C = -D * ksiH;
	std::cout << "C" << C << std::endl;
	Eigen::MatrixXd f(m, 2);
	for (int i = 0; i < m; ++i) {
		f(i, 0) = linear_cage[i][0];
		f(i, 1) = linear_cage[i][1];
	}
	Eigen::MatrixXd d(m, 2);
	for (int i = 0; i < m; ++i) {
		d(i, 0) = (linear_cage[(i + 1) % m] - linear_cage[i])[1];
		d(i, 1) = -(linear_cage[(i + 1) % m] - linear_cage[i])[0];
	}
	std::cout << "f " << f << std::endl;
	std::cout << "d " << d << std::endl;
	std::cout << "test1" << (II - phiH) * f - ksiH * d << std::endl;
	std::cout << "test2" << B * f + C * d << std::endl;
}
//void MeshViewerWidget::ConstructMatrix4OffSetTest() {
//	int m = linear_cage.size();
//	std::vector<OpenMesh::Vec2d> offset_cage = offsetCage(linear_cage, 0.000001);
//	// 定义四个 m * m 的矩阵 A, B, C, D，元素类型为 double
//	A.resize(2*m, 2*m); B.resize(m, m); C.resize(m, m); D.resize(m, m);
//	Eigen::MatrixXd ksiH(2*m, m); Eigen::MatrixXd ksiBH(2 * m, 2 * m); Eigen::MatrixXd phiH(2*m, m); Eigen::MatrixXd phiBH(2 * m, 2 * m);
//	Eigen::MatrixXd ksiH_2(2 * m, 2 * m); Eigen::MatrixXd phiH_2(2 * m, 2 * m);
//	Eigen::MatrixXd II = Eigen::MatrixXd::Zero(2 * m, m);
//	Eigen::MatrixXd dII = Eigen::MatrixXd::Zero(2 * m, 2 * m);
//	//std::cout << II << std::endl;
//	// 初始化或填充矩阵 A, B, C, D
//	for (int i = 0; i < m; i++) {
//		dII(i, i) = 1;
//		II(i, i) = 1;
//		OpenMesh::Vec2d vi = offset_cage[i];
//		for (int j = 0; j < m; j++) {
//			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
//			OpenMesh::Vec2d v1 = linear_cage[j];
//			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
//			double v_ksiH, v_ksiBH, v_phiH, v_phiBH;
//			CalBiharmonicBasis(v0, v1, v2, vi, v_ksiH, v_phiH, v_ksiBH, v_phiBH);	
//			phiH(i, j) = v_phiH;
//			ksiH(i, j) = v_ksiH;
//			std::vector<double> values;
//			CalBiharmonicTwiceBasis(v0, v1, v2, vi, values);
//			phiH_2(i, j) = values[0]; phiH_2(i, j + m) = values[1];
//			ksiH_2(i, j) = values[10]; ksiH_2(i, j + m) = values[11];
//			phiBH(i, j) = values[4]; phiBH(i, j + m) = values[5];
//			ksiBH(i, j) = values[6]; ksiBH(i, j + m) = values[7];
//		}
//	}
//	//边中点采样
//	for (int i = 0; i < m; i++) {
//		dII(i + m, i) = 1. / 4;
//		dII(i + m, (i + 1) % m) = 1. / 4;
//		dII(i + m, i + m) = 2. / 4;
//		II(i + m, i) = 1. / 2;
//		II(i + m, (i + 1) % m) = 1. / 2;
//		OpenMesh::Vec2d vi = 1. / 2 * (offset_cage[i] + offset_cage[(i + 1) % m]);
//		for (int j = 0; j < m; j++) {
//			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
//			OpenMesh::Vec2d v1 = linear_cage[j];
//			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
//			double v_ksiH, v_ksiBH, v_phiH, v_phiBH;
//			CalBiharmonicBasis(v0, v1, v2, vi, v_ksiH, v_phiH, v_ksiBH, v_phiBH);
//			phiH(i+m, j) = v_phiH;
//			ksiH(i+m, j) = v_ksiH;
//			std::vector<double> values;
//			CalBiharmonicTwiceBasis(v0, v1, v2, vi, values);
//			phiH_2(i+m, j) = values[0]; phiH_2(i+m, j + m) = values[1];
//			ksiH_2(i+m, j) = values[10]; ksiH_2(i+m, j + m) = values[11];
//			phiBH(i+m, j) = values[4]; phiBH(i+m, j + m) = values[5];
//			ksiBH(i+m, j) = values[6]; ksiBH(i+m, j + m) = values[7];
//		}
//	}
//	std::cout << "ksiH_2" << ksiH_2 << std::endl;
//	double condition_number = ksiH_2.norm() * ksiH_2.inverse().norm();
//	std::cout << "Condition number: " << condition_number << std::endl;
//	std::cout << "determinant" << ksiH_2.determinant() << std::endl;
//	/*std::cout << "ksiH" << ksiH << std::endl;
//	double condition_number = ksiH.norm() * ksiH.inverse().norm();
//	std::cout << "Condition number: " << condition_number << std::endl;
//	std::cout << "determinant" << ksiH.determinant() << std::endl;
//	std::cout << "ksiH.inverse()" << ksiH.inverse() << std::endl;
//	std::cout << "phi" << phiH << std::endl;*/
//	A = ksiH_2.inverse() * (dII - phiH_2);
//	//A = ksiH.inverse() * (II - phiH);
//	// Calculating matrix D: D = (phiBH + psiBH * A).inverse()
//	D = (phiBH + ksiBH * A).inverse();
//	std::cout << "D" << D << std::endl;
//	// Calculating matrix B: B = D * (I - phiH)
//	B = D * (II - phiH);
//	std::cout << "B" << B << std::endl;
//	// Calculating matrix C: C = -D * psiH
//	C = -D * ksiH;
//	std::cout << "C" << C << std::endl;
//	Eigen::MatrixXd f(m, 2);
//	for (int i = 0; i < m; ++i) {
//		f(i, 0) = linear_cage[i][0];
//		f(i, 1) = linear_cage[i][1];
//	}
//	Eigen::MatrixXd d(m, 2);
//	for (int i = 0; i < m; ++i) {
//		d(i, 0) = (linear_cage[(i + 1) % m] - linear_cage[i])[1];
//		d(i, 1) = -(linear_cage[(i + 1) % m] - linear_cage[i])[0];
//	}
//	std::cout << "f " << f << std::endl;
//	std::cout << "d " << d << std::endl;
//	std::cout << "test1" << (II - phiH) * f - ksiH * d << std::endl;
//	std::cout << "test2" << B * f + C * d << std::endl;
//}

void MeshViewerWidget::ConstructMatrix4OffSetTestGauss() {
	int m = linear_cage.size();
	std::vector<OpenMesh::Vec2d> offset_cage = offsetCage(linear_cage, 0.000001);
	// 定义四个 m * m 的矩阵 A, B, C, D，元素类型为 double
	A.resize(2 * m, 2 * m); B.resize(m, m); C.resize(m, m); D.resize(m, m);
	Eigen::MatrixXd ksiH(2 * m, m); Eigen::MatrixXd ksiBH(2 * m, 2 * m); Eigen::MatrixXd phiH(2 * m, m); Eigen::MatrixXd phiBH(2 * m, 2 * m);
	Eigen::MatrixXd ksiH_2(2 * m, 2 * m); Eigen::MatrixXd phiH_2(2 * m, 2 * m);
	Eigen::MatrixXd II = Eigen::MatrixXd::Zero(2 * m, m);
	Eigen::MatrixXd dII = Eigen::MatrixXd::Zero(2 * m, 2 * m);
	//std::cout << II << std::endl;
	// 初始化或填充矩阵 A, B, C, D
	for (int i = 0; i < m; i++) {
		dII(i , i) = 0.7887 * 0.7887;
		dII(i , (i + 1) % m) = 0.2113 * 0.2113;
		dII(i , i + m) = 2.* 0.7887* 0.2113;
		II(i , i) = 0.7887;
		II(i , (i + 1) % m) = 0.2113;
		OpenMesh::Vec2d vi = 0.7887 *offset_cage[i]+ 0.2113 *offset_cage[(i + 1) % m];
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			double v_ksiH, v_ksiBH, v_phiH, v_phiBH;
			CalBiharmonicBasis(v0, v1, v2, vi, v_ksiH, v_phiH, v_ksiBH, v_phiBH);
			phiH(i, j) = v_phiH;
			ksiH(i, j) = v_ksiH;
			std::vector<double> values;
			CalBiharmonicTwiceBasis(v0, v1, v2, vi, values);
			phiH_2(i, j) = values[0]; phiH_2(i, j + m) = values[1];
			ksiH_2(i, j) = values[10]; ksiH_2(i, j + m) = values[11];
			phiBH(i, j) = values[4]; phiBH(i, j + m) = values[5];
			ksiBH(i, j) = values[6]; ksiBH(i, j + m) = values[7];
		}
	}
	//边gauss点2采样
	for (int i = 0; i < m; i++) {
		dII(i + m, i) = 0.2113 * 0.2113;
		dII(i + m, (i + 1) % m) = 0.7887 * 0.7887;
		dII(i + m, i + m) = 2. * 0.7887 * 0.2113;
		II(i + m, i) = 0.2113;
		II(i + m, (i + 1) % m) = 0.7887;
		OpenMesh::Vec2d vi = 0.2113 * offset_cage[i] + 0.7887 * offset_cage[(i + 1) % m];
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			double v_ksiH, v_ksiBH, v_phiH, v_phiBH;
			CalBiharmonicBasis(v0, v1, v2, vi, v_ksiH, v_phiH, v_ksiBH, v_phiBH);
			phiH(i + m, j) = v_phiH;
			ksiH(i + m, j) = v_ksiH;
			std::vector<double> values;
			CalBiharmonicTwiceBasis(v0, v1, v2, vi, values);
			phiH_2(i + m, j) = values[0]; phiH_2(i + m, j + m) = values[1];
			ksiH_2(i + m, j) = values[10]; ksiH_2(i + m, j + m) = values[11];
			phiBH(i + m, j) = values[4]; phiBH(i + m, j + m) = values[5];
			ksiBH(i + m, j) = values[6]; ksiBH(i + m, j + m) = values[7];
		}
	}
	std::cout << "ksiH_2" << ksiH_2 << std::endl;
	double condition_number = ksiH_2.norm() * ksiH_2.inverse().norm();
	std::cout << "Condition number: " << condition_number << std::endl;
	std::cout << "determinant" << ksiH_2.determinant() << std::endl;
	/*std::cout << "ksiH" << ksiH << std::endl;
	double condition_number = ksiH.norm() * ksiH.inverse().norm();
	std::cout << "Condition number: " << condition_number << std::endl;
	std::cout << "determinant" << ksiH.determinant() << std::endl;
	std::cout << "ksiH.inverse()" << ksiH.inverse() << std::endl;
	std::cout << "phi" << phiH << std::endl;*/
	A = ksiH_2.inverse() * (dII - phiH_2);
	//A = ksiH.inverse() * (II - phiH);
	// Calculating matrix D: D = (phiBH + psiBH * A).inverse()
	D = (phiBH + ksiBH * A).inverse();
	std::cout << "D" << D << std::endl;
	// Calculating matrix B: B = D * (I - phiH)
	B = D * (II - phiH);
	std::cout << "B" << B << std::endl;
	// Calculating matrix C: C = -D * psiH
	C = -D * ksiH;
	std::cout << "C" << C << std::endl;
	Eigen::MatrixXd f(m, 2);
	for (int i = 0; i < m; ++i) {
		f(i, 0) = linear_cage[i][0];
		f(i, 1) = linear_cage[i][1];
	}
	Eigen::MatrixXd d(m, 2);
	for (int i = 0; i < m; ++i) {
		d(i, 0) = (linear_cage[(i + 1) % m] - linear_cage[i])[1];
		d(i, 1) = -(linear_cage[(i + 1) % m] - linear_cage[i])[0];
	}
	std::cout << "f " << f << std::endl;
	std::cout << "d " << d << std::endl;
	std::cout << "test1" << (II - phiH) * f - ksiH * d << std::endl;
	std::cout << "test2" << B * f + C * d << std::endl;
}

void MeshViewerWidget::ConstructMatrix4OffSetTestVirtual() {
	int m = linear_cage.size();
	std::vector<OpenMesh::Vec2d> offset_cage = offsetCage(linear_cage, 0.000001);
	// 定义四个 m * m 的矩阵 A, B, C, D，元素类型为 double
	A.resize(2 * m, 2 * m); B.resize(m, m); C.resize(m, m); D.resize(m, m);
	Eigen::MatrixXd ksiH(4 * m, m); Eigen::MatrixXd ksiBH(4 * m, 2 * m); Eigen::MatrixXd phiH(4 * m, m); Eigen::MatrixXd phiBH(4 * m, 2 * m);
	Eigen::MatrixXd ksiH_2(4 * m, 2 * m); Eigen::MatrixXd phiH_2(4 * m, 2 * m);
	Eigen::MatrixXd II = Eigen::MatrixXd::Zero(4 * m, m);
	Eigen::MatrixXd dII = Eigen::MatrixXd::Zero(4 * m, 2 * m);
	//std::cout << II << std::endl;
	// 初始化或填充矩阵 A, B, C, D
	for (int i = 0; i < m; i++) {
		dII(i, i) = 1;
		II(i, i) = 1;
		OpenMesh::Vec2d vi = offset_cage[i];
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			double v_ksiH, v_ksiBH, v_phiH, v_phiBH;
			CalBiharmonicBasis(v0, v1, v2, vi, v_ksiH, v_phiH, v_ksiBH, v_phiBH);
			phiH(i, j) = v_phiH;
			ksiH(i, j) = v_ksiH;
			std::vector<double> values;
			CalBiharmonicTwiceBasis(v0, v1, v2, vi, values);
			phiH_2(i, j) = values[0]; phiH_2(i, j + m) = values[1];
			ksiH_2(i, j) = values[10]; ksiH_2(i, j + m) = values[11];
			phiBH(i, j) = values[4]; phiBH(i, j + m) = values[5];
			ksiBH(i, j) = values[6]; ksiBH(i, j + m) = values[7];
		}
	}
	//边中点采样
	for (int i = 0; i < m; i++) {
		dII(i + m, i) = 1. / 4;
		dII(i + m, (i + 1) % m) = 1. / 4;
		dII(i + m, i + m) = 2. / 4;
		II(i + m, i) = 1. / 2;
		II(i + m, (i + 1) % m) = 1. / 2;
		OpenMesh::Vec2d vi = 1. / 2 * (offset_cage[i] + offset_cage[(i + 1) % m]);
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			double v_ksiH, v_ksiBH, v_phiH, v_phiBH;
			CalBiharmonicBasis(v0, v1, v2, vi, v_ksiH, v_phiH, v_ksiBH, v_phiBH);
			phiH(i + m, j) = v_phiH;
			ksiH(i + m, j) = v_ksiH;
			std::vector<double> values;
			CalBiharmonicTwiceBasis(v0, v1, v2, vi, values);
			phiH_2(i + m, j) = values[0]; phiH_2(i + m, j + m) = values[1];
			ksiH_2(i + m, j) = values[10]; ksiH_2(i + m, j + m) = values[11];
			phiBH(i + m, j) = values[4]; phiBH(i + m, j + m) = values[5];
			ksiBH(i + m, j) = values[6]; ksiBH(i + m, j + m) = values[7];
		}
	}
	//virtual点
	//在边的1/4采样
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = 1. / 4 * (3 * offset_cage[i] + offset_cage[(i + 1) % m]);
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			double v_ksiH, v_ksiBH, v_phiH, v_phiBH;
			CalBiharmonicBasis(v0, v1, v2, vi, v_ksiH, v_phiH, v_ksiBH, v_phiBH);
			phiH(i + 2*m, j) = v_phiH;
			ksiH(i + 2*m, j) = v_ksiH;
			std::vector<double> values;
			CalBiharmonicTwiceBasis(v0, v1, v2, vi, values);
			phiH_2(i +2* m, j) = values[0]; phiH_2(i +2* m, j + m) = values[1];
			ksiH_2(i + 2*m, j) = values[10]; ksiH_2(i + 2*m, j + m) = values[11];
			phiBH(i + 2*m, j) = values[4]; phiBH(i + 2*m, j + m) = values[5];
			ksiBH(i + 2*m, j) = values[6]; ksiBH(i + 2*m, j + m) = values[7];
		}
		dII(i + 2*m, i) = 9. / 16;
		dII(i + 2*m, (i + 1) % m) = 1. / 16;
		dII(i + 2*m, i + m) = 6. / 16;
		II(i + 2*m, i) = 3. / 4;
		II(i + 2*m, (i + 1) % m) = 1. / 4;
	}
	//在边的3/4采样
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = 1. / 4 * (offset_cage[i] + 3 * offset_cage[(i + 1) % m]);
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			double v_ksiH, v_ksiBH, v_phiH, v_phiBH;
			CalBiharmonicBasis(v0, v1, v2, vi, v_ksiH, v_phiH, v_ksiBH, v_phiBH);
			phiH(i + 3 * m, j) = v_phiH;
			ksiH(i + 3 * m, j) = v_ksiH;
			std::vector<double> values;
			CalBiharmonicTwiceBasis(v0, v1, v2, vi, values);
			phiH_2(i + 3 * m, j) = values[0]; phiH_2(i + 3 * m, j + m) = values[1];
			ksiH_2(i + 3 * m, j) = values[10]; ksiH_2(i + 3 * m, j + m) = values[11];
			phiBH(i + 3 * m, j) = values[4]; phiBH(i + 3 * m, j + m) = values[5];
			ksiBH(i + 3 * m, j) = values[6]; ksiBH(i + 3 * m, j + m) = values[7];
		}
		dII(i + 3*m, i) = 1. / 16;
		dII(i + 3*m, (i + 1) % m) = 9. / 16;
		dII(i + 3*m, i + m) = 6. / 16;
		II(i + 3*m, i) = 1. / 4;
		II(i + 3*m, (i + 1) % m) = 3. / 4;
	}
	/*std::cout << "ksiH_2" << ksiH_2 << std::endl;
	double condition_number = ksiH_2.norm() * ksiH_2.inverse().norm();
	std::cout << "Condition number: " << condition_number << std::endl;
	std::cout << "determinant" << ksiH_2.determinant() << std::endl;*/
	/*std::cout << "ksiH" << ksiH << std::endl;
	double condition_number = ksiH.norm() * ksiH.inverse().norm();
	std::cout << "Condition number: " << condition_number << std::endl;
	std::cout << "determinant" << ksiH.determinant() << std::endl;
	std::cout << "ksiH.inverse()" << ksiH.inverse() << std::endl;
	std::cout << "phi" << phiH << std::endl;*/
	A = pseudoInverse(ksiH_2) * (dII - phiH_2);
	//A = ksiH.inverse() * (II - phiH);
	// Calculating matrix D: D = (phiBH + psiBH * A).inverse()
	D = pseudoInverse(phiBH + ksiBH * A);
	std::cout << "D" << D << std::endl;
	// Calculating matrix B: B = D * (I - phiH)
	B = D * (II - phiH);
	std::cout << "B" << B << std::endl;
	// Calculating matrix C: C = -D * psiH
	C = -D * ksiH;
	std::cout << "C" << C << std::endl;
	Eigen::MatrixXd f(m, 2);
	for (int i = 0; i < m; ++i) {
		f(i, 0) = linear_cage[i][0];
		f(i, 1) = linear_cage[i][1];
	}
	Eigen::MatrixXd d(m, 2);
	for (int i = 0; i < m; ++i) {
		d(i, 0) = (linear_cage[(i + 1) % m] - linear_cage[i])[1];
		d(i, 1) = -(linear_cage[(i + 1) % m] - linear_cage[i])[0];
	}
	std::cout << "f " << f << std::endl;
	std::cout << "d " << d << std::endl;
	std::cout << "test1" << (II - phiH) * f - ksiH * d << std::endl;
	std::cout << "test2" << B * f + C * d << std::endl;
}
void MeshViewerWidget::ConstructMatrix4OffSetTestVirtual2() {
	int m = linear_cage.size();
	int s_num = 8;
	std::vector<OpenMesh::Vec2d> offset_cage = offsetCage(linear_cage, 0.000001);
	// 定义四个 m * m 的矩阵 A, B, C, D，元素类型为 double
	A.resize(2 * m, 2 * m); B.resize(m, m); C.resize(m, m); D.resize(m, m);
	Eigen::MatrixXd ksiH(s_num * m, m); Eigen::MatrixXd ksiBH(s_num * m, 2 * m); Eigen::MatrixXd phiH(s_num * m, m); Eigen::MatrixXd phiBH(s_num * m, 2 * m);
	Eigen::MatrixXd ksiH_2(s_num * m, 2 * m); Eigen::MatrixXd phiH_2(s_num * m, 2 * m);
	Eigen::MatrixXd II = Eigen::MatrixXd::Zero(s_num * m, m);
	Eigen::MatrixXd dII = Eigen::MatrixXd::Zero(s_num * m, 2 * m);
	//std::cout << II << std::endl;
	for (int s = 0; s < s_num; s++) {
		//在边的s/8采样
		for (int i = 0; i < m; i++) {
			OpenMesh::Vec2d vi = 1. / 8. * ((8.-s) * offset_cage[i] +s* offset_cage[(i + 1) % m]);
			for (int j = 0; j < m; j++) {
				OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
				OpenMesh::Vec2d v1 = linear_cage[j];
				OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
				double v_ksiH, v_ksiBH, v_phiH, v_phiBH;
				CalBiharmonicBasis(v0, v1, v2, vi, v_ksiH, v_phiH, v_ksiBH, v_phiBH);
				phiH(i + s * m, j) = v_phiH;
				ksiH(i + s * m, j) = v_ksiH;
				std::vector<double> values;
				CalBiharmonicTwiceBasis(v0, v1, v2, vi, values);
				phiH_2(i + s * m, j) = values[0]; phiH_2(i + s * m, j + m) = values[1];
				ksiH_2(i + s * m, j) = values[10]; ksiH_2(i + s * m, j + m) = values[11];
				phiBH(i + s * m, j) = values[4]; phiBH(i + s * m, j + m) = values[5];
				ksiBH(i + s * m, j) = values[6]; ksiBH(i + s * m, j + m) = values[7];
			}
			dII(i + s * m, i) = (8. - s) * (8. - s) / 64.;
			dII(i + s * m, (i + 1) % m) = s * s / 64.;
			dII(i + s * m, i + m) = 2. * s * (8 - s) / 64.;
			II(i + s * m, i) = (8. - s) / 8;
			II(i + s * m, (i + 1) % m) = s / 8.;
		}
	}
	
	/*std::cout << "ksiH_2" << ksiH_2 << std::endl;
	double condition_number = ksiH_2.norm() * ksiH_2.inverse().norm();
	std::cout << "Condition number: " << condition_number << std::endl;
	std::cout << "determinant" << ksiH_2.determinant() << std::endl;*/
	/*std::cout << "ksiH" << ksiH << std::endl;
	double condition_number = ksiH.norm() * ksiH.inverse().norm();
	std::cout << "Condition number: " << condition_number << std::endl;
	std::cout << "determinant" << ksiH.determinant() << std::endl;
	std::cout << "ksiH.inverse()" << ksiH.inverse() << std::endl;
	std::cout << "phi" << phiH << std::endl;*/
	A = pseudoInverse(ksiH_2) * (dII - phiH_2);
	//A = ksiH.inverse() * (II - phiH);
	// Calculating matrix D: D = (phiBH + psiBH * A).inverse()
	D = pseudoInverse(phiBH + ksiBH * A);
	std::cout << "D" << D << std::endl;
	// Calculating matrix B: B = D * (I - phiH)
	B = D * (II - phiH);
	std::cout << "B" << B << std::endl;
	// Calculating matrix C: C = -D * psiH
	C = -D * ksiH;
	std::cout << "C" << C << std::endl;
	Eigen::MatrixXd f(m, 2);
	for (int i = 0; i < m; ++i) {
		f(i, 0) = linear_cage[i][0];
		f(i, 1) = linear_cage[i][1];
	}
	Eigen::MatrixXd d(m, 2);
	for (int i = 0; i < m; ++i) {
		d(i, 0) = (linear_cage[(i + 1) % m] - linear_cage[i])[1];
		d(i, 1) = -(linear_cage[(i + 1) % m] - linear_cage[i])[0];
	}
	std::cout << "f " << f << std::endl;
	std::cout << "d " << d << std::endl;
	std::cout << "test1" << (II - phiH) * f - ksiH * d << std::endl;
	std::cout << "test2" << B * f + C * d << std::endl;
}

void MeshViewerWidget::ConstructMatrix4OffSetTestVirtualGauss() {
	int m = linear_cage.size();
	std::vector<OpenMesh::Vec2d> offset_cage = offsetCage(linear_cage, 0.000001);
	// 定义四个 m * m 的矩阵 A, B, C, D，元素类型为 double
	A.resize(2 * m, 2 * m); B.resize(m, m); C.resize(m, m); D.resize(m, m);
	Eigen::MatrixXd ksiH(4 * m, m); Eigen::MatrixXd ksiBH(4 * m, 2 * m); Eigen::MatrixXd phiH(4 * m, m); Eigen::MatrixXd phiBH(4 * m, 2 * m);
	Eigen::MatrixXd ksiH_2(4 * m, 2 * m); Eigen::MatrixXd phiH_2(4 * m, 2 * m);
	Eigen::MatrixXd II = Eigen::MatrixXd::Zero(4 * m, m);
	Eigen::MatrixXd dII = Eigen::MatrixXd::Zero(4 * m, 2 * m);
	//std::cout << II << std::endl;
	// 初始化或填充矩阵 A, B, C, D
	for (int i = 0; i < m; i++) {
		dII(i, i) = 1;
		II(i, i) = 1;
		OpenMesh::Vec2d vi = offset_cage[i];
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			double v_ksiH, v_ksiBH, v_phiH, v_phiBH;
			CalBiharmonicBasis(v0, v1, v2, vi, v_ksiH, v_phiH, v_ksiBH, v_phiBH);
			phiH(i, j) = v_phiH;
			ksiH(i, j) = v_ksiH;
			std::vector<double> values;
			CalBiharmonicTwiceBasis(v0, v1, v2, vi, values);
			phiH_2(i, j) = values[0]; phiH_2(i, j + m) = values[1];
			ksiH_2(i, j) = values[10]; ksiH_2(i, j + m) = values[11];
			phiBH(i, j) = values[4]; phiBH(i, j + m) = values[5];
			ksiBH(i, j) = values[6]; ksiBH(i, j + m) = values[7];
		}
	}
	//边中点采样
	for (int i = 0; i < m; i++) {
		dII(i + m, i) = 1. / 4;
		dII(i + m, (i + 1) % m) = 1. / 4;
		dII(i + m, i + m) = 2. / 4;
		II(i + m, i) = 1. / 2;
		II(i + m, (i + 1) % m) = 1. / 2;
		OpenMesh::Vec2d vi = 1. / 2 * (offset_cage[i] + offset_cage[(i + 1) % m]);
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			double v_ksiH, v_ksiBH, v_phiH, v_phiBH;
			CalBiharmonicBasis(v0, v1, v2, vi, v_ksiH, v_phiH, v_ksiBH, v_phiBH);
			phiH(i + m, j) = v_phiH;
			ksiH(i + m, j) = v_ksiH;
			std::vector<double> values;
			CalBiharmonicTwiceBasis(v0, v1, v2, vi, values);
			phiH_2(i + m, j) = values[0]; phiH_2(i + m, j + m) = values[1];
			ksiH_2(i + m, j) = values[10]; ksiH_2(i + m, j + m) = values[11];
			phiBH(i + m, j) = values[4]; phiBH(i + m, j + m) = values[5];
			ksiBH(i + m, j) = values[6]; ksiBH(i + m, j + m) = values[7];
		}
	}
	//virtual点
	//在边的1/4采样
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = 0.7887 * offset_cage[i] + 0.2113* offset_cage[(i + 1) % m];
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			double v_ksiH, v_ksiBH, v_phiH, v_phiBH;
			CalBiharmonicBasis(v0, v1, v2, vi, v_ksiH, v_phiH, v_ksiBH, v_phiBH);
			phiH(i + 2 * m, j) = v_phiH;
			ksiH(i + 2 * m, j) = v_ksiH;
			std::vector<double> values;
			CalBiharmonicTwiceBasis(v0, v1, v2, vi, values);
			phiH_2(i + 2 * m, j) = values[0]; phiH_2(i + 2 * m, j + m) = values[1];
			ksiH_2(i + 2 * m, j) = values[10]; ksiH_2(i + 2 * m, j + m) = values[11];
			phiBH(i + 2 * m, j) = values[4]; phiBH(i + 2 * m, j + m) = values[5];
			ksiBH(i + 2 * m, j) = values[6]; ksiBH(i + 2 * m, j + m) = values[7];
		}
		dII(i + 2 * m, i) = 0.7887* 0.7887;
		dII(i + 2 * m, (i + 1) % m) = 0.2113* 0.2113;
		dII(i + 2 * m, i + m) = 2.* 0.7887* 0.2113;
		II(i + 2 * m, i) = 0.7887;
		II(i + 2 * m, (i + 1) % m) = 0.2113;
	}
	//在边的3/4采样
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = 0.2113 *offset_cage[i] + 0.7887 * offset_cage[(i + 1) % m];
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			double v_ksiH, v_ksiBH, v_phiH, v_phiBH;
			CalBiharmonicBasis(v0, v1, v2, vi, v_ksiH, v_phiH, v_ksiBH, v_phiBH);
			phiH(i + 3 * m, j) = v_phiH;
			ksiH(i + 3 * m, j) = v_ksiH;
			std::vector<double> values;
			CalBiharmonicTwiceBasis(v0, v1, v2, vi, values);
			phiH_2(i + 3 * m, j) = values[0]; phiH_2(i + 3 * m, j + m) = values[1];
			ksiH_2(i + 3 * m, j) = values[10]; ksiH_2(i + 3 * m, j + m) = values[11];
			phiBH(i + 3 * m, j) = values[4]; phiBH(i + 3 * m, j + m) = values[5];
			ksiBH(i + 3 * m, j) = values[6]; ksiBH(i + 3 * m, j + m) = values[7];
		}
		dII(i + 3 * m, i) = 0.2113* 0.2113;
		dII(i + 3 * m, (i + 1) % m) = 0.7887* 0.7887;
		dII(i + 3 * m, i + m) = 2* 0.7887* 0.2113;
		II(i + 3 * m, i) = 0.2113;
		II(i + 3 * m, (i + 1) % m) = 0.7887;
	}
	/*std::cout << "ksiH_2" << ksiH_2 << std::endl;
	double condition_number = ksiH_2.norm() * ksiH_2.inverse().norm();
	std::cout << "Condition number: " << condition_number << std::endl;
	std::cout << "determinant" << ksiH_2.determinant() << std::endl;*/
	/*std::cout << "ksiH" << ksiH << std::endl;
	double condition_number = ksiH.norm() * ksiH.inverse().norm();
	std::cout << "Condition number: " << condition_number << std::endl;
	std::cout << "determinant" << ksiH.determinant() << std::endl;
	std::cout << "ksiH.inverse()" << ksiH.inverse() << std::endl;
	std::cout << "phi" << phiH << std::endl;*/
	A = pseudoInverse(ksiH_2) * (dII - phiH_2);
	//A = ksiH.inverse() * (II - phiH);
	// Calculating matrix D: D = (phiBH + psiBH * A).inverse()
	D = pseudoInverse(phiBH + ksiBH * A);
	std::cout << "D" << D << std::endl;
	// Calculating matrix B: B = D * (I - phiH)
	B = D * (II - phiH);
	std::cout << "B" << B << std::endl;
	// Calculating matrix C: C = -D * psiH
	C = -D * ksiH;
	std::cout << "C" << C << std::endl;
	
}


void MeshViewerWidget::ConstructMatrix4OffSetTwice() {
	int m = linear_cage.size();
	std::vector<OpenMesh::Vec2d> offset_cage = offsetCage(linear_cage, 0.000001);
	// 定义四个 m * m 的矩阵 A, B, C, D，元素类型为 double
	A.resize(2 * m, 2 * m); B.resize(2 * m, 2 * m); C.resize(2 * m, 2 * m); D.resize(2 * m, 2 * m);
	Eigen::MatrixXd phiH(2 * m, 2 * m); Eigen::MatrixXd phiBH(2 * m, 2 * m);
	Eigen::MatrixXd ksiH(2 * m, 2 * m); Eigen::MatrixXd ksiBH(2 * m, 2 * m);
	Eigen::MatrixXd dH(2 * m, 2 * m); Eigen::MatrixXd eH(2 * m, 2 * m);
	Eigen::MatrixXd II = Eigen::MatrixXd::Zero(2 * m, 2 * m);
	// 初始化或填充矩阵 A, B, C, D
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = offset_cage[i];
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			std::vector<double> values;
			CalBiharmonicTwiceBasis(v0, v1, v2, vi, values);
			/*for (auto& v : values)
			{
				std::cout << v << " ";
			}
			std::cout << std::endl;
			Cal222BiharmonicBasis(v0, (v0 + v1) / 1.99, v1, (v1 + v2) / 1.99, v2, vi, values);
			for (auto& v : values)
			{
				std::cout << v << " ";
			}
			std::cout << std::endl;*/
			phiH(i, 0 + j) = values[0]; phiH(i, m + j) = values[1];
			phiBH(i, 0 + j) = values[2]; phiBH(i, m + j) = values[3];
			ksiH(i, 0 + j) = values[4]; ksiH(i, m + j) = values[5];
			ksiBH(i, 0 + j) = values[6]; ksiBH(i, m + j) = values[7];
			dH(i, 0 + j) = values[8]; dH(i, m + j) = values[9];
			eH(i, 0 + j) = values[10]; eH(i, m + j) = values[11];
		}
		II(i, i) = 1;
	}
	//在边的中间采样
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = 1. / 2 * (offset_cage[i] + offset_cage[(i + 1) % m]);
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			std::vector<double> values;
			CalBiharmonicTwiceBasis(v0, v1, v2, vi, values);
			phiH(i + m, 0 + j) = values[0]; phiH(i + m, m + j) = values[1];
			phiBH(i + m, 0 + j) = values[2]; phiBH(i + m, m + j) = values[3];
			ksiH(i + m, 0 + j) = values[4]; ksiH(i + m, m + j) = values[5];
			ksiBH(i + m, 0 + j) = values[6]; ksiBH(i + m, m + j) = values[7];
			dH(i + m, 0 + j) = values[8]; dH(i + m, m + j) = values[9];
			eH(i + m, 0 + j) = values[10]; eH(i + m, m + j) = values[11];
		}
		II(i + m, i + m) = 1./2;
		II(i + m, i ) = 1. / 4;
		II(i + m, (i + 1) % m ) = 1. / 4;
	}
	std::cout << "phiH" << phiH << std::endl;
	std::cout << "II" << II << std::endl;
	std::cout << "eH" << eH << std::endl;
	std::cout << "dH" << dH << std::endl;
	double condition_number = eH.norm() * eH.inverse().norm();
	std::cout << "Condition number: " << condition_number << std::endl;
	std::cout << "determinant" << eH.determinant() << std::endl;
	std::cout << "eH.inverse()" << eH.inverse() << std::endl;
	std::cout << "phi" << phiH << std::endl;
	A = eH.inverse() * (II - dH);
	std::cout << "A" << A << std::endl;
	// Calculating matrix D: D = (phiBH + psiBH * A).inverse()
	D = (ksiH + ksiBH * A).inverse();
	std::cout << "D" << D << std::endl;
	// Calculating matrix B: B = D * (I - phiH)
	B = D * (II - phiH);
	std::cout << "B" << B << std::endl;
	// Calculating matrix C: C = -D * psiH
	C = -D * phiBH;
	std::cout << "C" << C << std::endl;
	Eigen::MatrixXd f(2*m, 2);
	for (int i = 0; i < m; ++i) {
		f(i, 0) = linear_cage[i][0];
		f(i, 1) = linear_cage[i][1];

		f(i + m, 0) = (linear_cage[i][0] + linear_cage[(i + 1) % m][0])/2;
		f(i + m, 1) = (linear_cage[i][1] + linear_cage[(i + 1) % m][1])/2;
	}
	Eigen::MatrixXd d(2*m, 2);
	for (int i = 0; i < m; ++i) {
		d(i, 0) = linear_cage[i][1];
		d(i, 1) = -linear_cage[i][0];

		d(i + m, 0) = (linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 2;
		d(i + m, 1) = -(linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 2;
	}
	std::cout << "f " << f << std::endl;
	std::cout << "d " << d << std::endl;
	std::cout << "test1" << (II-phiH)*f - phiBH * d << std::endl;
	std::cout << "test2" << B * f + C * d << std::endl;
}

void MeshViewerWidget::ConstructMatrix4OffSetThird() {
	int m = linear_cage.size();
	std::vector<OpenMesh::Vec2d> offset_cage = offsetCage(linear_cage, 0.000001);
	// 定义四个 m * m 的矩阵 A, B, C, D，元素类型为 double
	A.resize(3 * m, 3 * m); B.resize(3 * m, 3 * m); C.resize(3 * m, 3 * m); D.resize(3 * m, 3 * m);
	Eigen::MatrixXd phiH(3 * m, 3 * m); Eigen::MatrixXd phiBH(3 * m, 3 * m);
	Eigen::MatrixXd ksiH(3 * m, 3 * m); Eigen::MatrixXd ksiBH(3 * m, 3 * m);
	Eigen::MatrixXd dH(3 * m, 3 * m); Eigen::MatrixXd eH(3 * m, 3 * m);
	Eigen::MatrixXd II = Eigen::MatrixXd::Zero(3 * m, 3 * m);
	// 初始化或填充矩阵 A, B, C, D
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = offset_cage[i];
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			std::vector<double> values;
			CalBiharmonicThirdBasis(v0, v1, v2, vi, values);
			phiH(i, 0 + j) = values[0]; phiH(i, m + j) = values[1]; phiH(i, 2 * m + j) = values[2];
			phiBH(i, 0 + j) = values[3]; phiBH(i, m + j) = values[4]; phiBH(i, 2 * m + j) = values[5];
			ksiH(i, 0 + j) = values[6]; ksiH(i, m + j) = values[7]; ksiH(i, 2 * m + j) = values[8];
			ksiBH(i, 0 + j) = values[9]; ksiBH(i, m + j) = values[10]; ksiBH(i, 2 * m + j) = values[11];
			dH(i, 0 + j) = values[12]; dH(i, m + j) = values[13]; dH(i, 2 * m + j) = values[14];
			eH(i, 0 + j) = values[15]; eH(i, m + j) = values[16]; eH(i, 2 * m + j) = values[17];
		}
		II(i, i) = 1;
	}
	//在边的1/3采样
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = 1. / 3 * (2 * offset_cage[i] + offset_cage[(i + 1) % m]);
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			std::vector<double> values;
			CalBiharmonicThirdBasis(v0, v1, v2, vi, values);
			phiH(i+m, 0 + j) = values[0]; phiH(i+m, m + j) = values[1]; phiH(i+m, 2 * m + j) = values[2];
			phiBH(i+m, 0 + j) = values[3]; phiBH(i+m, m + j) = values[4]; phiBH(i+m, 2 * m + j) = values[5];
			ksiH(i+m, 0 + j) = values[6]; ksiH(i+m, m + j) = values[7]; ksiH(i+m, 2 * m + j) = values[8];
			ksiBH(i+m, 0 + j) = values[9]; ksiBH(i+m, m + j) = values[10]; ksiBH(i+m, 2 * m + j) = values[11];
			dH(i+m, 0 + j) = values[12]; dH(i+m, m + j) = values[13]; dH(i+m, 2 * m + j) = values[14];
			eH(i+m, 0 + j) = values[15]; eH(i+m, m + j) = values[16]; eH(i+m, 2 * m + j) = values[17];
		}
		II(i + m, i) = 8. / 27;
		II(i + m, i + m) = 4. / 9;
		II(i + m, i + 2*m) = 2. / 9;
		II(i + m, (i + 1) % m) = 1. / 27;
	}
	//在边的2/3采样
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = 1. / 3 * ( offset_cage[i] +2* offset_cage[(i + 1) % m]);
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			std::vector<double> values;
			CalBiharmonicThirdBasis(v0, v1, v2, vi, values);
			phiH(i+2*m, 0 + j) = values[0]; phiH(i+2*m, m + j) = values[1]; phiH(i+2*m, 2 * m + j) = values[2];
			phiBH(i+2*m, 0 + j) = values[3]; phiBH(i+2*m, m + j) = values[4]; phiBH(i+2*m, 2 * m + j) = values[5];
			ksiH(i+2*m, 0 + j) = values[6]; ksiH(i+2*m, m + j) = values[7]; ksiH(i+2*m, 2 * m + j) = values[8];
			ksiBH(i+2*m, 0 + j) = values[9]; ksiBH(i+2*m, m + j) = values[10]; ksiBH(i+2*m, 2 * m + j) = values[11];
			dH(i+2*m, 0 + j) = values[12]; dH(i+2*m, m + j) = values[13]; dH(i+2*m, 2 * m + j) = values[14];
			eH(i+2*m, 0 + j) = values[15]; eH(i+2*m, m + j) = values[16]; eH(i+2*m, 2 * m + j) = values[17];
		}
		II(i + 2*m, i) = 1. / 27;
		II(i + 2*m, i + m) = 2. / 9;
		II(i + 2*m, i + 2 * m) = 4. / 9;
		II(i + 2*m, (i + 1) % m) = 8. / 27;
	}
	std::cout << "phiH" << phiH << std::endl;
	std::cout << "II" << II << std::endl;
	std::cout << "eH" << eH << std::endl;
	std::cout << "dH" << dH << std::endl;
	double condition_number = eH.norm() * eH.inverse().norm();
	std::cout << "Condition number: " << condition_number << std::endl;
	std::cout << "determinant" << eH.determinant() << std::endl;
	std::cout << "eH.inverse()" << eH.inverse() << std::endl;
	std::cout << "phi" << phiH << std::endl;
	A = eH.inverse() * (II - dH);
	std::cout << "A" << A << std::endl;
	// Calculating matrix D: D = (phiBH + psiBH * A).inverse()
	D = (ksiH + ksiBH * A).inverse();
	std::cout << "D" << D << std::endl;
	// Calculating matrix B: B = D * (I - phiH)
	B = D * (II - phiH);
	std::cout << "B" << B << std::endl;
	// Calculating matrix C: C = -D * psiH
	C = -D * phiBH;
	std::cout << "C" << C << std::endl;
	Eigen::MatrixXd f(3 * m, 2);
	for (int i = 0; i < m; ++i) {
		f(i, 0) = linear_cage[i][0];
		f(i, 1) = linear_cage[i][1];

		f(i + m, 0) = (2*linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 3;
		f(i + m, 1) = (2*linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 3;

		f(i + 2*m, 0) = ( linear_cage[i][0] +2* linear_cage[(i + 1) % m][0]) / 3;
		f(i + 2*m, 1) = ( linear_cage[i][1] +2* linear_cage[(i + 1) % m][1]) / 3;
	}
	Eigen::MatrixXd d(3 * m, 2);
	for (int i = 0; i < m; ++i) {
		d(i, 0) = linear_cage[i][1];
		d(i, 1) = -linear_cage[i][0];

		d(i + m, 0) = (2*linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 3;
		d(i + m, 1) = -(2*linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 3;

		d(i + 2*m, 0) = ( linear_cage[i][1] +2* linear_cage[(i + 1) % m][1]) / 3;
		d(i + 2*m, 1) = -( linear_cage[i][0] +2* linear_cage[(i + 1) % m][0]) / 3;
	}
	std::cout << "f " << f << std::endl;
	std::cout << "d " << d << std::endl;
	std::cout << "test1" << (II - phiH) * f - phiBH * d << std::endl;
	std::cout << "test2" << B * f + C * d << std::endl;
}

void MeshViewerWidget::ConstructMatrix4OffSetThirdVirtual() {
	int m = linear_cage.size();
	std::vector<OpenMesh::Vec2d> offset_cage = offsetCage(linear_cage, 0.000001);
	// 定义四个 m * m 的矩阵 A, B, C, D，元素类型为 double
	A.resize(3 * m, 3 * m); B.resize(3 * m, 3 * m); C.resize(3 * m, 3 * m); D.resize(3 * m, 3 * m);
	Eigen::MatrixXd phiH(6 * m, 3 * m); Eigen::MatrixXd phiBH(6 * m, 3 * m);
	Eigen::MatrixXd ksiH(6 * m, 3 * m); Eigen::MatrixXd ksiBH(6 * m, 3 * m);
	Eigen::MatrixXd dH(6 * m, 3 * m); Eigen::MatrixXd eH(6 * m, 3 * m);
	Eigen::MatrixXd II = Eigen::MatrixXd::Zero(6 * m, 3 * m);
	// 初始化或填充矩阵 A, B, C, D
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = offset_cage[i];
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			std::vector<double> values;
			CalBiharmonicThirdBasisNew(v0, v1, v2, vi, values);
			/*std::cout << "origin" << std::endl;
			for (auto& v : values)
			{
				std::cout << v << " ";
			}
			std::cout << std::endl;
			OpenMesh::Vec2d elk(1e-3, 1e-3);
			Cal323BiharmonicBasis(v0, (v0*2+v1)/3+elk,(v0+v1*2)/3-elk, v1, (v1 * 2 + v2) / 3+elk, (v1 + v2 * 2) / 3-elk, v2, vi, values);
			std::cout << "new"<<std::endl;
			for (auto& v : values)
			{
				std::cout << v << " ";
			}
			std::cout << std::endl;*/
			phiH(i, 0 + j) = values[0]; phiH(i, m + j) = values[1]; phiH(i, 2 * m + j) = values[2];
			phiBH(i, 0 + j) = values[3]; phiBH(i, m + j) = values[4]; phiBH(i, 2 * m + j) = values[5];
			ksiH(i, 0 + j) = values[6]; ksiH(i, m + j) = values[7]; ksiH(i, 2 * m + j) = values[8];
			ksiBH(i, 0 + j) = values[9]; ksiBH(i, m + j) = values[10]; ksiBH(i, 2 * m + j) = values[11];
			dH(i, 0 + j) = values[12]; dH(i, m + j) = values[13]; dH(i, 2 * m + j) = values[14];
			eH(i, 0 + j) = values[15]; eH(i, m + j) = values[16]; eH(i, 2 * m + j) = values[17];
		}
		II(i, i) = 1;
	}
	//在边的1/3采样
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = 1. / 3 * (2 * offset_cage[i] + offset_cage[(i + 1) % m]);
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			std::vector<double> values;
			CalBiharmonicThirdBasisNew(v0, v1, v2, vi, values);
			phiH(i + m, 0 + j) = values[0]; phiH(i + m, m + j) = values[1]; phiH(i + m, 2 * m + j) = values[2];
			phiBH(i + m, 0 + j) = values[3]; phiBH(i + m, m + j) = values[4]; phiBH(i + m, 2 * m + j) = values[5];
			ksiH(i + m, 0 + j) = values[6]; ksiH(i + m, m + j) = values[7]; ksiH(i + m, 2 * m + j) = values[8];
			ksiBH(i + m, 0 + j) = values[9]; ksiBH(i + m, m + j) = values[10]; ksiBH(i + m, 2 * m + j) = values[11];
			dH(i + m, 0 + j) = values[12]; dH(i + m, m + j) = values[13]; dH(i + m, 2 * m + j) = values[14];
			eH(i + m, 0 + j) = values[15]; eH(i + m, m + j) = values[16]; eH(i + m, 2 * m + j) = values[17];
		}
		II(i + m, i) = 8. / 27;
		II(i + m, i + m) = 4. / 9;
		II(i + m, i + 2 * m) = 2. / 9;
		II(i + m, (i + 1) % m) = 1. / 27;
	}
	//在边的2/3采样
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = 1. / 3 * (offset_cage[i] + 2 * offset_cage[(i + 1) % m]);
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			std::vector<double> values;
			CalBiharmonicThirdBasisNew(v0, v1, v2, vi, values);
			phiH(i + 2 * m, 0 + j) = values[0]; phiH(i + 2 * m, m + j) = values[1]; phiH(i + 2 * m, 2 * m + j) = values[2];
			phiBH(i + 2 * m, 0 + j) = values[3]; phiBH(i + 2 * m, m + j) = values[4]; phiBH(i + 2 * m, 2 * m + j) = values[5];
			ksiH(i + 2 * m, 0 + j) = values[6]; ksiH(i + 2 * m, m + j) = values[7]; ksiH(i + 2 * m, 2 * m + j) = values[8];
			ksiBH(i + 2 * m, 0 + j) = values[9]; ksiBH(i + 2 * m, m + j) = values[10]; ksiBH(i + 2 * m, 2 * m + j) = values[11];
			dH(i + 2 * m, 0 + j) = values[12]; dH(i + 2 * m, m + j) = values[13]; dH(i + 2 * m, 2 * m + j) = values[14];
			eH(i + 2 * m, 0 + j) = values[15]; eH(i + 2 * m, m + j) = values[16]; eH(i + 2 * m, 2 * m + j) = values[17];
		}
		II(i + 2 * m, i) = 1. / 27;
		II(i + 2 * m, i + m) = 2. / 9;
		II(i + 2 * m, i + 2 * m) = 4. / 9;
		II(i + 2 * m, (i + 1) % m) = 8. / 27;
	}
	//在边的1/6采样
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = 1. / 6 * (5*offset_cage[i] +  offset_cage[(i + 1) % m]);
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			std::vector<double> values;
			CalBiharmonicThirdBasis(v0, v1, v2, vi, values);
			phiH(i +  3 * m, 0 + j) = values[0]; phiH(i +  3 * m, m + j) = values[1]; phiH(i +   3 * m, 2 * m + j) = values[2];
			phiBH(i + 3 * m, 0 + j) = values[3]; phiBH(i + 3 * m, m + j) = values[4]; phiBH(i +  3 * m, 2 * m + j) = values[5];
			ksiH(i +  3 * m, 0 + j) = values[6]; ksiH(i +  3 * m, m + j) = values[7]; ksiH(i +   3 * m, 2 * m + j) = values[8];
			ksiBH(i + 3 * m, 0 + j) = values[9]; ksiBH(i + 3 * m, m + j) = values[10]; ksiBH(i + 3 * m, 2 * m + j) = values[11];
			dH(i +    3 * m, 0 + j) = values[12]; dH(i +   3 * m, m + j) = values[13]; dH(i +    3 * m, 2 * m + j) = values[14];
			eH(i +    3 * m, 0 + j) = values[15]; eH(i +   3 * m, m + j) = values[16]; eH(i +    3 * m, 2 * m + j) = values[17];
		}
		II(i + 3 * m, i) = 125. / 216;
		II(i + 3 * m, i + m) = 25. / 72;
		II(i + 3 * m, i + 2 * m) = 5. / 72;
		II(i + 3 * m, (i + 1) % m) = 1. / 216;
	}
	//在边的1/2采样
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = 1. / 2 * ( offset_cage[i] + offset_cage[(i + 1) % m]);
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			std::vector<double> values;
			CalBiharmonicThirdBasis(v0, v1, v2, vi, values);
			phiH(i +  4 * m, 0 + j) = values[0]; phiH(i +  4 * m, m + j) = values[1]; phiH(i +   4 * m, 2 * m + j) = values[2];
			phiBH(i + 4 * m, 0 + j) = values[3]; phiBH(i + 4 * m, m + j) = values[4]; phiBH(i +  4 * m, 2 * m + j) = values[5];
			ksiH(i +  4 * m, 0 + j) = values[6]; ksiH(i +  4 * m, m + j) = values[7]; ksiH(i +   4 * m, 2 * m + j) = values[8];
			ksiBH(i + 4 * m, 0 + j) = values[9]; ksiBH(i + 4 * m, m + j) = values[10]; ksiBH(i + 4 * m, 2 * m + j) = values[11];
			dH(i +    4 * m, 0 + j) = values[12]; dH(i +   4 * m, m + j) = values[13]; dH(i +    4 * m, 2 * m + j) = values[14];
			eH(i +    4 * m, 0 + j) = values[15]; eH(i +   4 * m, m + j) = values[16]; eH(i +    4 * m, 2 * m + j) = values[17];
		}
		II(i + 4 * m, i) = 1. / 8;
		II(i + 4 * m, i + m) = 3. / 8;
		II(i + 4 * m, i + 2 * m) = 3. / 8;
		II(i + 4 * m, (i + 1) % m) = 1. / 8;
	}
	//在边的5/6采样
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = 1. / 6 * ( offset_cage[i] + 5*offset_cage[(i + 1) % m]);
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			std::vector<double> values;
			CalBiharmonicThirdBasis(v0, v1, v2, vi, values);
			phiH(i +  5 * m, 0 + j) = values[0]; phiH(i +  5 * m, m + j) = values[1]; phiH(i +   5 * m, 2 * m + j) = values[2];
			phiBH(i + 5 * m, 0 + j) = values[3]; phiBH(i + 5 * m, m + j) = values[4]; phiBH(i +  5 * m, 2 * m + j) = values[5];
			ksiH(i +  5 * m, 0 + j) = values[6]; ksiH(i +  5 * m, m + j) = values[7]; ksiH(i +   5 * m, 2 * m + j) = values[8];
			ksiBH(i + 5 * m, 0 + j) = values[9]; ksiBH(i + 5 * m, m + j) = values[10]; ksiBH(i + 5 * m, 2 * m + j) = values[11];
			dH(i +    5 * m, 0 + j) = values[12]; dH(i +   5 * m, m + j) = values[13]; dH(i +    5 * m, 2 * m + j) = values[14];
			eH(i +    5 * m, 0 + j) = values[15]; eH(i +   5 * m, m + j) = values[16]; eH(i +    5 * m, 2 * m + j) = values[17];
		}
		II(i + 5 * m, i) = 1. / 216;
		II(i + 5 * m, i + m) = 5. / 72;
		II(i + 5 * m, i + 2 * m) = 25. / 72;
		II(i + 5 * m, (i + 1) % m) = 125. / 216;
	}
	/*std::cout << "phiH" << phiH << std::endl;
	std::cout << "II" << II << std::endl;
	std::cout << "eH" << eH << std::endl;
	std::cout << "dH" << dH << std::endl;
	double condition_number = eH.norm() * eH.inverse().norm();
	std::cout << "Condition number: " << condition_number << std::endl;
	std::cout << "determinant" << eH.determinant() << std::endl;
	std::cout << "eH.inverse()" << eH.inverse() << std::endl;
	std::cout << "phi" << phiH << std::endl;*/
	A = pseudoInverse(eH) * (II - dH);
	std::cout << "A" << A << std::endl;
	// Calculating matrix D: D = (phiBH + psiBH * A).inverse()
	D = pseudoInverse(ksiH + ksiBH * A);
	std::cout << "D" << D << std::endl;
	// Calculating matrix B: B = D * (I - phiH)
	B = D * (II - phiH);
	std::cout << "B" << B << std::endl;
	// Calculating matrix C: C = -D * psiH
	C = -D * phiBH;
	std::cout << "C" << C << std::endl;
	Eigen::MatrixXd f(3 * m, 2);
	for (int i = 0; i < m; ++i) {
		f(i, 0) = linear_cage[i][0];
		f(i, 1) = linear_cage[i][1];

		f(i + m, 0) = (2 * linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 3;
		f(i + m, 1) = (2 * linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 3;

		f(i + 2 * m, 0) = (linear_cage[i][0] + 2 * linear_cage[(i + 1) % m][0]) / 3;
		f(i + 2 * m, 1) = (linear_cage[i][1] + 2 * linear_cage[(i + 1) % m][1]) / 3;
	}
	Eigen::MatrixXd d(3 * m, 2);
	for (int i = 0; i < m; ++i) {
		d(i, 0) = linear_cage[i][1];
		d(i, 1) = -linear_cage[i][0];

		d(i + m, 0) = (2 * linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 3;
		d(i + m, 1) = -(2 * linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 3;

		d(i + 2 * m, 0) = (linear_cage[i][1] + 2 * linear_cage[(i + 1) % m][1]) / 3;
		d(i + 2 * m, 1) = -(linear_cage[i][0] + 2 * linear_cage[(i + 1) % m][0]) / 3;
	}
	std::cout << "f " << f << std::endl;
	std::cout << "d " << d << std::endl;
	std::cout << "test1" << (II - phiH) * f - phiBH * d << std::endl;
	std::cout << "test2" << B * f + C * d << std::endl;
}

void MeshViewerWidget::ConstructMatrix4OffSetThirdVirtualNew() {
	int m = linear_cage.size();
	std::vector<OpenMesh::Vec2d> offset_cage = offsetCage(linear_cage, 0.000001);
	// 定义四个 m * m 的矩阵 A, B, C, D，元素类型为 double
	A.resize(3 * m, 3 * m); B.resize(3 * m, 3 * m); C.resize(3 * m, 3 * m); D.resize(3 * m, 3 * m);
	Eigen::MatrixXd phiH(6 * m, 3 * m); Eigen::MatrixXd phiBH(6 * m, 3 * m);
	Eigen::MatrixXd ksiH(6 * m, 3 * m); Eigen::MatrixXd ksiBH(6 * m, 3 * m);
	Eigen::MatrixXd dH(6 * m, 3 * m); Eigen::MatrixXd eH(6 * m, 3 * m);
	Eigen::MatrixXd II = Eigen::MatrixXd::Zero(6 * m, 3 * m);
	// 初始化或填充矩阵 A, B, C, D
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = offset_cage[i];
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			std::vector<double> values;
			CalBiharmonicThirdBasisNew(v0, v1, v2, vi, values);
			/*std::cout << "origin" << std::endl;
			for (auto& v : values)
			{
				std::cout << v << " ";
			}
			std::cout << std::endl;
			OpenMesh::Vec2d elk(1e-3, 1e-3);*/
			/*Cal323BiharmonicBasisDebug1(v0, (v0*2+v1)/3,(v0+v1*2)/3, v1, (v1 * 2 + v2) / 3, (v1 + v2 * 2) / 3, v2, vi, values);
			std::cout << "new"<<std::endl;
			for (auto& v : values)
			{
				std::cout << v << " ";
			}
			std::cout << std::endl;*/
			phiH(i, 0 + j) = values[0]; phiH(i, m + j) = values[1]; phiH(i, 2 * m + j) = values[2];
			phiBH(i, 0 + j) = values[3]; phiBH(i, m + j) = values[4]; phiBH(i, 2 * m + j) = values[5];
			ksiH(i, 0 + j) = values[6]; ksiH(i, m + j) = values[7]; ksiH(i, 2 * m + j) = values[8];
			ksiBH(i, 0 + j) = values[9]; ksiBH(i, m + j) = values[10]; ksiBH(i, 2 * m + j) = values[11];
			dH(i, 0 + j) = values[12]; dH(i, m + j) = values[13]; dH(i, 2 * m + j) = values[14];
			eH(i, 0 + j) = values[15]; eH(i, m + j) = values[16]; eH(i, 2 * m + j) = values[17];
		}
		II(i, i) = 1;
	}
	//在边的1/3采样
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = 1. / 3 * (2 * offset_cage[i] + offset_cage[(i + 1) % m]);
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			std::vector<double> values;
			CalBiharmonicThirdBasisNew(v0, v1, v2, vi, values);
			
			phiH(i + m, 0 + j) = values[0]; phiH(i + m, m + j) = values[1]; phiH(i + m, 2 * m + j) = values[2];
			phiBH(i + m, 0 + j) = values[3]; phiBH(i + m, m + j) = values[4]; phiBH(i + m, 2 * m + j) = values[5];
			ksiH(i + m, 0 + j) = values[6]; ksiH(i + m, m + j) = values[7]; ksiH(i + m, 2 * m + j) = values[8];
			ksiBH(i + m, 0 + j) = values[9]; ksiBH(i + m, m + j) = values[10]; ksiBH(i + m, 2 * m + j) = values[11];
			dH(i + m, 0 + j) = values[12]; dH(i + m, m + j) = values[13]; dH(i + m, 2 * m + j) = values[14];
			eH(i + m, 0 + j) = values[15]; eH(i + m, m + j) = values[16]; eH(i + m, 2 * m + j) = values[17];
		}
		II(i + m, i) = 8. / 27;
		II(i + m, i + m) = 4. / 9;
		II(i + m, i + 2 * m) = 2. / 9;
		II(i + m, (i + 1) % m) = 1. / 27;
	}
	//在边的2/3采样
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = 1. / 3 * (offset_cage[i] + 2 * offset_cage[(i + 1) % m]);
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			std::vector<double> values;
			CalBiharmonicThirdBasisNew(v0, v1, v2, vi, values);
			
			phiH(i + 2 * m, 0 + j) = values[0]; phiH(i + 2 * m, m + j) = values[1]; phiH(i + 2 * m, 2 * m + j) = values[2];
			phiBH(i + 2 * m, 0 + j) = values[3]; phiBH(i + 2 * m, m + j) = values[4]; phiBH(i + 2 * m, 2 * m + j) = values[5];
			ksiH(i + 2 * m, 0 + j) = values[6]; ksiH(i + 2 * m, m + j) = values[7]; ksiH(i + 2 * m, 2 * m + j) = values[8];
			ksiBH(i + 2 * m, 0 + j) = values[9]; ksiBH(i + 2 * m, m + j) = values[10]; ksiBH(i + 2 * m, 2 * m + j) = values[11];
			dH(i + 2 * m, 0 + j) = values[12]; dH(i + 2 * m, m + j) = values[13]; dH(i + 2 * m, 2 * m + j) = values[14];
			eH(i + 2 * m, 0 + j) = values[15]; eH(i + 2 * m, m + j) = values[16]; eH(i + 2 * m, 2 * m + j) = values[17];
		}
		II(i + 2 * m, i) = 1. / 27;
		II(i + 2 * m, i + m) = 2. / 9;
		II(i + 2 * m, i + 2 * m) = 4. / 9;
		II(i + 2 * m, (i + 1) % m) = 8. / 27;
	}
	//在边的1/6采样
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = 1. / 6 * (5 * offset_cage[i] + offset_cage[(i + 1) % m]);
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			std::vector<double> values;
			CalBiharmonicThirdBasisNew(v0, v1, v2, vi, values);
			//Cal323BiharmonicBasisDebug1(v0, (v0 * 2 + v1) / 3, (v0 + v1 * 2) / 3, v1, (v1 * 2 + v2) / 3, (v1 + v2 * 2) / 3, v2, vi, values);
			phiH(i + 3 * m, 0 + j) = values[0]; phiH(i + 3 * m, m + j) = values[1]; phiH(i + 3 * m, 2 * m + j) = values[2];
			phiBH(i + 3 * m, 0 + j) = values[3]; phiBH(i + 3 * m, m + j) = values[4]; phiBH(i + 3 * m, 2 * m + j) = values[5];
			ksiH(i + 3 * m, 0 + j) = values[6]; ksiH(i + 3 * m, m + j) = values[7]; ksiH(i + 3 * m, 2 * m + j) = values[8];
			ksiBH(i + 3 * m, 0 + j) = values[9]; ksiBH(i + 3 * m, m + j) = values[10]; ksiBH(i + 3 * m, 2 * m + j) = values[11];
			dH(i + 3 * m, 0 + j) = values[12]; dH(i + 3 * m, m + j) = values[13]; dH(i + 3 * m, 2 * m + j) = values[14];
			eH(i + 3 * m, 0 + j) = values[15]; eH(i + 3 * m, m + j) = values[16]; eH(i + 3 * m, 2 * m + j) = values[17];
		}
		II(i + 3 * m, i) = 125. / 216;
		II(i + 3 * m, i + m) = 25. / 72;
		II(i + 3 * m, i + 2 * m) = 5. / 72;
		II(i + 3 * m, (i + 1) % m) = 1. / 216;
	}
	//在边的1/2采样
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = 1. / 2 * (offset_cage[i] + offset_cage[(i + 1) % m]);
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			std::vector<double> values;
			CalBiharmonicThirdBasisNew(v0, v1, v2, vi, values);
			//Cal323BiharmonicBasisDebug1(v0, (v0 * 2 + v1) / 3, (v0 + v1 * 2) / 3, v1, (v1 * 2 + v2) / 3, (v1 + v2 * 2) / 3, v2, vi, values);
			phiH(i + 4 * m, 0 + j) = values[0]; phiH(i + 4 * m, m + j) = values[1]; phiH(i + 4 * m, 2 * m + j) = values[2];
			phiBH(i + 4 * m, 0 + j) = values[3]; phiBH(i + 4 * m, m + j) = values[4]; phiBH(i + 4 * m, 2 * m + j) = values[5];
			ksiH(i + 4 * m, 0 + j) = values[6]; ksiH(i + 4 * m, m + j) = values[7]; ksiH(i + 4 * m, 2 * m + j) = values[8];
			ksiBH(i + 4 * m, 0 + j) = values[9]; ksiBH(i + 4 * m, m + j) = values[10]; ksiBH(i + 4 * m, 2 * m + j) = values[11];
			dH(i + 4 * m, 0 + j) = values[12]; dH(i + 4 * m, m + j) = values[13]; dH(i + 4 * m, 2 * m + j) = values[14];
			eH(i + 4 * m, 0 + j) = values[15]; eH(i + 4 * m, m + j) = values[16]; eH(i + 4 * m, 2 * m + j) = values[17];
		}
		II(i + 4 * m, i) = 1. / 8;
		II(i + 4 * m, i + m) = 3. / 8;
		II(i + 4 * m, i + 2 * m) = 3. / 8;
		II(i + 4 * m, (i + 1) % m) = 1. / 8;
	}
	//在边的5/6采样
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = 1. / 6 * (offset_cage[i] + 5 * offset_cage[(i + 1) % m]);
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			std::vector<double> values;
			CalBiharmonicThirdBasisNew(v0, v1, v2, vi, values);
			//Cal323BiharmonicBasisDebug1(v0, (v0 * 2 + v1) / 3, (v0 + v1 * 2) / 3, v1, (v1 * 2 + v2) / 3, (v1 + v2 * 2) / 3, v2, vi, values);
			phiH(i + 5 * m, 0 + j) = values[0]; phiH(i + 5 * m, m + j) = values[1]; phiH(i + 5 * m, 2 * m + j) = values[2];
			phiBH(i + 5 * m, 0 + j) = values[3]; phiBH(i + 5 * m, m + j) = values[4]; phiBH(i + 5 * m, 2 * m + j) = values[5];
			ksiH(i + 5 * m, 0 + j) = values[6]; ksiH(i + 5 * m, m + j) = values[7]; ksiH(i + 5 * m, 2 * m + j) = values[8];
			ksiBH(i + 5 * m, 0 + j) = values[9]; ksiBH(i + 5 * m, m + j) = values[10]; ksiBH(i + 5 * m, 2 * m + j) = values[11];
			dH(i + 5 * m, 0 + j) = values[12]; dH(i + 5 * m, m + j) = values[13]; dH(i + 5 * m, 2 * m + j) = values[14];
			eH(i + 5 * m, 0 + j) = values[15]; eH(i + 5 * m, m + j) = values[16]; eH(i + 5 * m, 2 * m + j) = values[17];
		}
		II(i + 5 * m, i) = 1. / 216;
		II(i + 5 * m, i + m) = 5. / 72;
		II(i + 5 * m, i + 2 * m) = 25. / 72;
		II(i + 5 * m, (i + 1) % m) = 125. / 216;
	}
	/*std::cout << "phiH" << phiH << std::endl;
	std::cout << "II" << II << std::endl;
	std::cout << "eH" << eH << std::endl;
	std::cout << "dH" << dH << std::endl;
	double condition_number = eH.norm() * eH.inverse().norm();
	std::cout << "Condition number: " << condition_number << std::endl;
	std::cout << "determinant" << eH.determinant() << std::endl;
	std::cout << "eH.inverse()" << eH.inverse() << std::endl;
	std::cout << "phi" << phiH << std::endl;*/
	A = pseudoInverse(eH) * (II - dH);
	//std::cout << "A" << A << std::endl;
	// Calculating matrix D: D = (phiBH + psiBH * A).inverse()
	D = pseudoInverse(ksiH + ksiBH * A);
	//std::cout << "D" << D << std::endl;
	// Calculating matrix B: B = D * (I - phiH)
	B = D * (II - phiH);
	//std::cout << "B" << B << std::endl;
	// Calculating matrix C: C = -D * psiH
	C = -D * phiBH;
	//std::cout << "C" << C << std::endl;
	/*Eigen::MatrixXd f(3 * m, 2);
	for (int i = 0; i < m; ++i) {
		f(i, 0) = linear_cage[i][0];
		f(i, 1) = linear_cage[i][1];

		f(i + m, 0) = (2 * linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 3;
		f(i + m, 1) = (2 * linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 3;

		f(i + 2 * m, 0) = (linear_cage[i][0] + 2 * linear_cage[(i + 1) % m][0]) / 3;
		f(i + 2 * m, 1) = (linear_cage[i][1] + 2 * linear_cage[(i + 1) % m][1]) / 3;
	}
	Eigen::MatrixXd d(3 * m, 2);
	for (int i = 0; i < m; ++i) {
		d(i, 0) = (-linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 3;
		d(i, 1) = -(-linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 3;

		d(i + m, 0) = (- linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 3;
		d(i + m, 1) = -(- linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 3;

		d(i + 2 * m, 0) = (-linear_cage[i][1] +  linear_cage[(i + 1) % m][1]) / 3;
		d(i + 2 * m, 1) = -(-linear_cage[i][0] +  linear_cage[(i + 1) % m][0]) / 3;
	}
	std::cout << "f " << f << std::endl;
	std::cout << "d " << d << std::endl;
	std::cout << "test1" << (II - phiH) * f - phiBH * d << std::endl;
	std::cout << "test2" << B * f + C * d << std::endl;*/
}


void MeshViewerWidget::ConstructMatrix4OffSetFourthVirtualNew() {
	int m = linear_cage.size();
	std::vector<OpenMesh::Vec2d> offset_cage = offsetCage(linear_cage, 0.000001);
	// 定义四个 m * m 的矩阵 A, B, C, D，元素类型为 double
	A.resize(4 * m, 4 * m); B.resize(4 * m, 4 * m); C.resize(4 * m, 4 * m); D.resize(4 * m, 4 * m);
	Eigen::MatrixXd phiH(8 * m, 4 * m); Eigen::MatrixXd phiBH(8 * m, 4 * m);
	Eigen::MatrixXd ksiH(8 * m, 4 * m); Eigen::MatrixXd ksiBH(8 * m, 4 * m);
	Eigen::MatrixXd dH(8 * m, 4 * m); Eigen::MatrixXd eH(8 * m, 4 * m);
	Eigen::MatrixXd II = Eigen::MatrixXd::Zero(8 * m, 4 * m);
	std::vector<double> s_values = { 0,1. / 8,2. / 8,3. / 8,4. / 8,5. / 8,6. / 8,7. / 8 };
	for (int s = 0; s < 8; s++) {
		for (int i = 0; i < m; i++) {
			OpenMesh::Vec2d vi = (1-s_values[s]) * offset_cage[i] + s_values[s]* offset_cage[(i + 1) % m];
			for (int j = 0; j < m; j++) {
				OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
				OpenMesh::Vec2d v1 = linear_cage[j];
				OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
				std::vector<double> values;
				CalBiharmonicFourthBasisNew(v0, v1, v2, vi, values);

				phiH(i+s*m, 0 + j) = values[0]; phiH(i+s*m, m + j) = values[1]; phiH(i+s*m, 2 * m + j) = values[2]; phiH(i+s*m, 3 * m + j) = values[3];
				phiBH(i+s*m, 0 + j) = values[4]; phiBH(i+s*m, m + j) = values[5]; phiBH(i+s*m, 2 * m + j) = values[6]; phiBH(i+s*m, 3 * m + j) = values[7];
				ksiH(i+s*m, 0 + j) = values[8]; ksiH(i+s*m, m + j) = values[9]; ksiH(i+s*m, 2 * m + j) = values[10]; ksiH(i+s*m, 3 * m + j) = values[11];
				ksiBH(i+s*m, 0 + j) = values[12]; ksiBH(i+s*m, m + j) = values[13]; ksiBH(i+s*m, 2 * m + j) = values[14]; ksiBH(i+s*m, 3 * m + j) = values[15];
				dH(i+s*m, 0 + j) = values[16]; dH(i+s*m, m + j) = values[17]; dH(i+s*m, 2 * m + j) = values[18]; dH(i+s*m, 3 * m + j) = values[19];
				eH(i+s*m, 0 + j) = values[20]; eH(i+s*m, m + j) = values[21]; eH(i+s*m, 2 * m + j) = values[22]; eH(i+s*m, 3 * m + j) = values[23];
			}
			II(i+s*m, i) = pow((1 - s_values[s]),4);
			II(i+s*m, i + m) = 4.* pow((1 - s_values[s]), 3)* s_values[s];
			II(i+s*m, i + 2 * m) = 6.* pow((1 - s_values[s]), 2) * pow((s_values[s]), 2);
			II(i + s * m, i + 3 * m) = 4. * pow((s_values[s]), 3) * (1-s_values[s]);
			II(i+s*m, (i + 1) % m) = pow(( s_values[s]), 4);
		}
	}
	
	/*std::cout << "phiH" << phiH << std::endl;
	std::cout << "II" << II << std::endl;
	std::cout << "eH" << eH << std::endl;
	std::cout << "dH" << dH << std::endl;
	double condition_number = eH.norm() * eH.inverse().norm();
	std::cout << "Condition number: " << condition_number << std::endl;
	std::cout << "determinant" << eH.determinant() << std::endl;
	std::cout << "eH.inverse()" << eH.inverse() << std::endl;
	std::cout << "phi" << phiH << std::endl;*/

	auto start_timek = std::chrono::high_resolution_clock::now();
	A = pseudoInverse(eH) * (II - dH);
	//std::cout << "A" << A << std::endl;
	// Calculating matrix D: D = (phiBH + psiBH * A).inverse()
	D = pseudoInverse(ksiH + ksiBH * A);
	//std::cout << "D" << D << std::endl;
	// Calculating matrix B: B = D * (I - phiH)
	B = D * (II - phiH);
	//std::cout << "B" << B << std::endl;
	// Calculating matrix C: C = -D * psiH
	C = -D * phiBH;
	//std::cout << "C" << C << std::endl;

	auto end_timek = std::chrono::high_resolution_clock::now();
	auto durationk = std::chrono::duration_cast<std::chrono::milliseconds>(end_timek - start_timek).count();
	std::cout << "求逆时间: " << durationk << " 毫秒" << std::endl;
	//exit(1);
	Eigen::MatrixXd f(4 * m, 2);
	for (int i = 0; i < m; ++i) {
		f(i, 0) = linear_cage[i][0];
		f(i, 1) = linear_cage[i][1];

		f(i + m, 0) = (3 * linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 4;
		f(i + m, 1) = (3 * linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 4;

		f(i + 2 * m, 0) = (2*linear_cage[i][0] + 2 * linear_cage[(i + 1) % m][0]) / 4;
		f(i + 2 * m, 1) = (2*linear_cage[i][1] + 2 * linear_cage[(i + 1) % m][1]) / 4;

		f(i + 3 * m, 0) = (1 * linear_cage[i][0] + 3 * linear_cage[(i + 1) % m][0]) / 4;
		f(i + 3 * m, 1) = (1 * linear_cage[i][1] + 3 * linear_cage[(i + 1) % m][1]) / 4;
	}
	Eigen::MatrixXd d(4 * m, 2);
	for (int i = 0; i < m; ++i) {
		d(i, 0) = (-linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 4;
		d(i, 1) = -(-linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 4;

		d(i + m, 0) = (-linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 4;
		d(i + m, 1) = -(-linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 4;

		d(i + 2 * m, 0) = (-linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 4;
		d(i + 2 * m, 1) = -(-linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 4;

		d(i + 3 * m, 0) = (-linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 4;
		d(i + 3 * m, 1) = -(-linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 4;
	}
	/*std::cout << "f " << f << std::endl;
	std::cout << "d " << d << std::endl;
	std::cout << "test1" << (II - phiH) * f - phiBH * d << std::endl;
	std::cout << "test2" << B * f + C * d << std::endl;*/
}



void MeshViewerWidget::ConstructMatrix4OffSetTwiceVirtual() {
	int m = linear_cage.size();
	std::vector<OpenMesh::Vec2d> offset_cage = offsetCage(linear_cage, 0.000001);
	// 定义四个 m * m 的矩阵 A, B, C, D，元素类型为 double
	A.resize(2 * m, 2 * m); B.resize(2 * m, 2 * m); C.resize(2 * m, 2 * m); D.resize(2 * m, 2 * m);
	Eigen::MatrixXd phiH(4 * m, 2 * m); Eigen::MatrixXd phiBH(4 * m, 2 * m);
	Eigen::MatrixXd ksiH(4 * m, 2 * m); Eigen::MatrixXd ksiBH(4 * m, 2 * m);
	Eigen::MatrixXd dH(4 * m, 2 * m); Eigen::MatrixXd eH(4 * m, 2 * m);
	Eigen::MatrixXd II = Eigen::MatrixXd::Zero(4 * m, 2 * m);
	// 初始化或填充矩阵 A, B, C, D
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = offset_cage[i];
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			std::vector<double> values;
			CalBiharmonicTwiceBasis(v0, v1, v2, vi, values);
			phiH(i, 0 + j) = values[0]; phiH(i, m + j) = values[1];
			phiBH(i, 0 + j) = values[2]; phiBH(i, m + j) = values[3];
			ksiH(i, 0 + j) = values[4]; ksiH(i, m + j) = values[5];
			ksiBH(i, 0 + j) = values[6]; ksiBH(i, m + j) = values[7];
			dH(i, 0 + j) = values[8]; dH(i, m + j) = values[9];
			eH(i, 0 + j) = values[10]; eH(i, m + j) = values[11];
		}
		II(i, i) = 1;
	}
	//在边的中间采样
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = 1. / 2 * (offset_cage[i] + offset_cage[(i + 1) % m]);
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			std::vector<double> values;
			CalBiharmonicTwiceBasis(v0, v1, v2, vi, values);
			phiH(i + m, 0 + j) = values[0]; phiH(i + m, m + j) = values[1];
			phiBH(i + m, 0 + j) = values[2]; phiBH(i + m, m + j) = values[3];
			ksiH(i + m, 0 + j) = values[4]; ksiH(i + m, m + j) = values[5];
			ksiBH(i + m, 0 + j) = values[6]; ksiBH(i + m, m + j) = values[7];
			dH(i + m, 0 + j) = values[8]; dH(i + m, m + j) = values[9];
			eH(i + m, 0 + j) = values[10]; eH(i + m, m + j) = values[11];
		}
		II(i + m, i + m) = 1. / 2;
		II(i + m, i) = 1. / 4;
		II(i + m, (i + 1) % m) = 1. / 4;
	}
	//在边的1/4采样
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = 1. / 4 * (3*offset_cage[i] + offset_cage[(i + 1) % m]);
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			std::vector<double> values;
			CalBiharmonicTwiceBasis(v0, v1, v2, vi, values);
			phiH(i + 2*m, 0 + j) = values[0]; phiH(i + 2*m, m + j) = values[1];
			phiBH(i + 2*m, 0 + j) = values[2]; phiBH(i + 2*m, m + j) = values[3];
			ksiH(i + 2*m, 0 + j) = values[4]; ksiH(i + 2*m, m + j) = values[5];
			ksiBH(i + 2*m, 0 + j) = values[6]; ksiBH(i + 2*m, m + j) = values[7];
			dH(i + 2*m, 0 + j) = values[8]; dH(i + 2*m, m + j) = values[9];
			eH(i + 2*m, 0 + j) = values[10]; eH(i + 2*m, m + j) = values[11];
		}
		II(i + 2*m, i + m) = 6. / 16;
		II(i + 2*m, i) =9. / 16;
		II(i + 2*m, (i + 1) % m) = 1. / 16;
	}
	//在边的3/4采样
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = 1. / 4 * (offset_cage[i] + 3*offset_cage[(i + 1) % m]);
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			std::vector<double> values;
			CalBiharmonicTwiceBasis(v0, v1, v2, vi, values);
			phiH(i + 3 * m, 0 + j) = values[0]; phiH(i + 3 * m, m + j) = values[1];
			phiBH(i + 3 * m, 0 + j) = values[2]; phiBH(i + 3 * m, m + j) = values[3];
			ksiH(i + 3 * m, 0 + j) = values[4]; ksiH(i + 3 * m, m + j) = values[5];
			ksiBH(i + 3 * m, 0 + j) = values[6]; ksiBH(i + 3 * m, m + j) = values[7];
			dH(i + 3 * m, 0 + j) = values[8]; dH(i + 3 * m, m + j) = values[9];
			eH(i + 3 * m, 0 + j) = values[10]; eH(i + 3 * m, m + j) = values[11];
		}
		II(i + 3 * m, i + m) = 6. / 16;
		II(i + 3 * m, i) = 1. / 16;
		II(i + 3 * m, (i + 1) % m) = 9. / 16;
	}
	/*std::cout << "phiH" << phiH << std::endl;
	std::cout << "II" << II << std::endl;
	std::cout << "eH" << eH << std::endl;
	std::cout << "dH" << dH << std::endl;*/
	
	A = pseudoInverse(eH) * (II - dH);
	std::cout << "A" << A << std::endl;
	// Calculating matrix D: D = (phiBH + psiBH * A).inverse()
	D = pseudoInverse(ksiH + ksiBH * A);
	std::cout << "D" << D << std::endl;
	// Calculating matrix B: B = D * (I - phiH)
	B = D * (II - phiH);
	std::cout << "B" << B << std::endl;
	// Calculating matrix C: C = -D * psiH
	C = -D * phiBH;
	std::cout << "C" << C << std::endl;
	Eigen::MatrixXd f(2 * m, 2);
	for (int i = 0; i < m; ++i) {
		f(i, 0) = linear_cage[i][0];
		f(i, 1) = linear_cage[i][1];

		f(i + m, 0) = (linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 2;
		f(i + m, 1) = (linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 2;
	}
	Eigen::MatrixXd d(2 * m, 2);
	for (int i = 0; i < m; ++i) {
		d(i, 0) = linear_cage[i][1];
		d(i, 1) = -linear_cage[i][0];

		d(i + m, 0) = (linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 2;
		d(i + m, 1) = -(linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 2;
	}
	std::cout << "f " << f << std::endl;
	std::cout << "d " << d << std::endl;
	std::cout << "test1" << (II - phiH) * f - phiBH * d << std::endl;
	std::cout << "test2" << B * f + C * d << std::endl;
}
//使用新的系数乘以边界上的切向量
void MeshViewerWidget::ConstructMatrix4OffSetTwiceVirtualNew() {
	int m = linear_cage.size();
	std::vector<OpenMesh::Vec2d> offset_cage = offsetCage(linear_cage, 0.000001);
	// 定义四个 m * m 的矩阵 A, B, C, D，元素类型为 double
	A.resize(2 * m, 2 * m); B.resize(2 * m, 2 * m); C.resize(2 * m, 2 * m); D.resize(2 * m, 2 * m);
	Eigen::MatrixXd phiH(4 * m, 2 * m); Eigen::MatrixXd phiBH(4 * m, 2 * m);
	Eigen::MatrixXd ksiH(4 * m, 2 * m); Eigen::MatrixXd ksiBH(4 * m, 2 * m);
	Eigen::MatrixXd dH(4 * m, 2 * m); Eigen::MatrixXd eH(4 * m, 2 * m);
	Eigen::MatrixXd II = Eigen::MatrixXd::Zero(4 * m, 2 * m);
	// 初始化或填充矩阵 A, B, C, D
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = offset_cage[i];
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			std::vector<double> values;
			CalBiharmonicTwiceBasisNew(v0, v1, v2, vi, values);
			/*std::cout << "Values: ";
			for (const double& value : values) {
				std::cout << value << " ";
			}
			std::cout << std::endl;
			OpenMesh::Vec2d elk(1e-3, 1e-3);
			Cal222BiharmonicBasis(v0, (v0 + v1) / 2+elk, v1, (v1 + v2) / 2+elk, v2, vi, values);
			std::cout << "222Values: ";
			for (const double& value : values) {
				std::cout << value << " ";
			}
			std::cout << std::endl;*/
			phiH(i, 0 + j) = values[0]; phiH(i, m + j) = values[1];
			phiBH(i, 0 + j) = values[2]; phiBH(i, m + j) = values[3];
			ksiH(i, 0 + j) = values[4]; ksiH(i, m + j) = values[5];
			ksiBH(i, 0 + j) = values[6]; ksiBH(i, m + j) = values[7];
			dH(i, 0 + j) = values[8]; dH(i, m + j) = values[9];
			eH(i, 0 + j) = values[10]; eH(i, m + j) = values[11];
		}
		II(i, i) = 1;
	}
	//在边的中间采样
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = 1. / 2 * (offset_cage[i] + offset_cage[(i + 1) % m]);
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			std::vector<double> values;
			CalBiharmonicTwiceBasisNew(v0, v1, v2, vi, values);
			phiH(i + m, 0 + j) = values[0]; phiH(i + m, m + j) = values[1];
			phiBH(i + m, 0 + j) = values[2]; phiBH(i + m, m + j) = values[3];
			ksiH(i + m, 0 + j) = values[4]; ksiH(i + m, m + j) = values[5];
			ksiBH(i + m, 0 + j) = values[6]; ksiBH(i + m, m + j) = values[7];
			dH(i + m, 0 + j) = values[8]; dH(i + m, m + j) = values[9];
			eH(i + m, 0 + j) = values[10]; eH(i + m, m + j) = values[11];
		}
		II(i + m, i + m) = 1. / 2;
		II(i + m, i) = 1. / 4;
		II(i + m, (i + 1) % m) = 1. / 4;
	}
	//在边的1/4采样
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = 1. / 4 * (3 * offset_cage[i] + offset_cage[(i + 1) % m]);
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			std::vector<double> values;
			CalBiharmonicTwiceBasisNew(v0, v1, v2, vi, values);
			phiH(i + 2 * m, 0 + j) = values[0]; phiH(i + 2 * m, m + j) = values[1];
			phiBH(i + 2 * m, 0 + j) = values[2]; phiBH(i + 2 * m, m + j) = values[3];
			ksiH(i + 2 * m, 0 + j) = values[4]; ksiH(i + 2 * m, m + j) = values[5];
			ksiBH(i + 2 * m, 0 + j) = values[6]; ksiBH(i + 2 * m, m + j) = values[7];
			dH(i + 2 * m, 0 + j) = values[8]; dH(i + 2 * m, m + j) = values[9];
			eH(i + 2 * m, 0 + j) = values[10]; eH(i + 2 * m, m + j) = values[11];
		}
		II(i + 2 * m, i + m) = 6. / 16;
		II(i + 2 * m, i) = 9. / 16;
		II(i + 2 * m, (i + 1) % m) = 1. / 16;
	}
	//在边的3/4采样
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = 1. / 4 * (offset_cage[i] + 3 * offset_cage[(i + 1) % m]);
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			std::vector<double> values;
			CalBiharmonicTwiceBasisNew(v0, v1, v2, vi, values);
			phiH(i + 3 * m, 0 + j) = values[0]; phiH(i + 3 * m, m + j) = values[1];
			phiBH(i + 3 * m, 0 + j) = values[2]; phiBH(i + 3 * m, m + j) = values[3];
			ksiH(i + 3 * m, 0 + j) = values[4]; ksiH(i + 3 * m, m + j) = values[5];
			ksiBH(i + 3 * m, 0 + j) = values[6]; ksiBH(i + 3 * m, m + j) = values[7];
			dH(i + 3 * m, 0 + j) = values[8]; dH(i + 3 * m, m + j) = values[9];
			eH(i + 3 * m, 0 + j) = values[10]; eH(i + 3 * m, m + j) = values[11];
		}
		II(i + 3 * m, i + m) = 6. / 16;
		II(i + 3 * m, i) = 1. / 16;
		II(i + 3 * m, (i + 1) % m) = 9. / 16;
	}
	/*std::cout << "phiH" << phiH << std::endl;
	std::cout << "II" << II << std::endl;
	std::cout << "eH" << eH << std::endl;
	std::cout << "dH" << dH << std::endl;*/

	A = pseudoInverse(eH) * (II - dH);
	//std::cout << "A" << A << std::endl;
	// Calculating matrix D: D = (phiBH + psiBH * A).inverse()
	D = pseudoInverse(ksiH + ksiBH * A);
	//std::cout << "D" << D << std::endl;
	// Calculating matrix B: B = D * (I - phiH)
	B = D * (II - phiH);
	//std::cout << "B" << B << std::endl;
	// Calculating matrix C: C = -D * psiH
	C = -D * phiBH;
	//std::cout << "C" << C << std::endl;
	//Eigen::MatrixXd f(2 * m, 2);
	//for (int i = 0; i < m; ++i) {
	//	f(i, 0) = linear_cage[i][0];
	//	f(i, 1) = linear_cage[i][1];

	//	f(i + m, 0) = (linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 2;
	//	f(i + m, 1) = (linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 2;
	//}
	//Eigen::MatrixXd d(2 * m, 2);
	//for (int i = 0; i < m; ++i) {
	//	d(i, 0) = (-linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 2;//y
	//	d(i, 1) =- (-linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 2;//-x

	//	d(i + m, 0) = (-linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 2;//y
	//	d(i + m, 1) = -(-linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 2;//-x
	//}
	//std::cout << "f " << f << std::endl;
	//std::cout << "d " << d << std::endl;
	//std::cout << "test1" << (II - phiH) * f - phiBH * d << std::endl;
	//std::cout << "test2" << B * f + C * d << std::endl;
}

void MeshViewerWidget::ConstructMatrix4OffSetTwiceVirtualNewWithDer() {
	int m = linear_cage.size();
	std::vector<OpenMesh::Vec2d> offset_cage = offsetCage(linear_cage, 0.000001);
	// 定义四个 m * m 的矩阵 A, B, C, D，元素类型为 double
	A.resize(2 * m, 2 * m); B.resize(2 * m, 2 * m); C.resize(2 * m, 2 * m); D.resize(2 * m, 2 * m);
	Eigen::MatrixXd phiH(4 * m, 2 * m); Eigen::MatrixXd phiBH(4 * m, 2 * m);
	Eigen::MatrixXd ksiH(4 * m, 2 * m); Eigen::MatrixXd ksiBH(4 * m, 2 * m);
	Eigen::MatrixXd phiHdx(3 * m, 2 * m); Eigen::MatrixXd phiBHdx(3 * m, 2 * m);
	Eigen::MatrixXd ksiHdx(3 * m, 2 * m); Eigen::MatrixXd ksiBHdx(3 * m, 2 * m);
	Eigen::MatrixXd phiHdy(3 * m, 2 * m); Eigen::MatrixXd phiBHdy(3 * m, 2 * m);
	Eigen::MatrixXd ksiHdy(3 * m, 2 * m); Eigen::MatrixXd ksiBHdy(3 * m, 2 * m);
	//Eigen::MatrixXd phiH_test(4 * m, 2 * m); Eigen::MatrixXd phiBH_test(4 * m, 2 * m);
	Eigen::MatrixXd dH(4 * m, 2 * m); Eigen::MatrixXd eH(4 * m, 2 * m);
	Eigen::MatrixXd II = Eigen::MatrixXd::Zero(4 * m, 2 * m);
	// 初始化或填充矩阵 A, B, C, D
	for (int i = 0; i < m; i++) {//我不在端点上采样计算梯度
		OpenMesh::Vec2d vi = offset_cage[i];
		for (int j = 0; j < m; j++) {
			vi = offset_cage[i];
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			std::vector<double> values;
			/*if (i == j) {
				CalBiharmonicTwiceBasisNewDerBoundary(v0, v1, v2, vi, values,0);
			}
			else if (i == (j+1)%m) {
				CalBiharmonicTwiceBasisNewDerBoundary(v0, v1, v2, vi, values, 1);
			}
			else if (i == (j - 1+m) % m) {
				CalBiharmonicTwiceBasisNewDerBoundary(v0, v1, v2, vi, values, -1);
			}
			else
				CalBiharmonicTwiceBasisNewDerBoundary(v0, v1, v2, vi, values, 6);*/
				CalBiharmonicTwiceBasisNewDer(v0, v1, v2, vi, values);
			phiH(i, 0 + j) = values[0]; phiH(i, m + j) = values[1];
			phiBH(i, 0 + j) = values[2]; phiBH(i, m + j) = values[3];
			ksiH(i, 0 + j) = values[4]; ksiH(i, m + j) = values[5];
			ksiBH(i, 0 + j) = values[6]; ksiBH(i, m + j) = values[7];
			dH(i, 0 + j) = values[8]; dH(i, m + j) = values[9];
			eH(i, 0 + j) = values[10]; eH(i, m + j) = values[11];
			/*{
				vi = OpenMesh::Vec2d(2, 2);
				CalBiharmonicTwiceBasisNewDer(v0, v1, v2, vi, values);
			}*/
			/*phiH_test(i, 0 + j) = values[0]; phiH_test(i, m + j) = values[1];
			phiBH_test(i, 0 + j) = values[2]; phiBH_test(i, m + j) = values[3];
			phiHdx(i, 0 + j) = values[12]; phiHdy(i, 0 + j) = values[13]; phiHdx(i, m + j) = values[14]; phiHdy(i, m + j) = values[15];
			phiBHdx(i, 0 + j) = values[16]; phiBHdy(i, 0 + j) = values[17]; phiBHdx(i, m + j) = values[18]; phiBHdy(i, m + j) = values[19];
			ksiHdx(i, 0 + j) = values[20]; ksiHdy(i, 0 + j) = values[21]; ksiHdx(i, m + j) = values[22]; ksiHdy(i, m + j) = values[23];
			ksiBHdx(i, 0 + j) = values[24]; ksiBHdy(i, 0 + j) = values[25]; ksiBHdx(i, m + j) = values[26]; ksiBHdy(i, m + j) = values[27];*/
		}
		II(i, i) = 1;
	}
	//在边的中间采样
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = 1. / 2 * (offset_cage[i] + offset_cage[(i + 1) % m]);
		for (int j = 0; j < m; j++) {
			vi = 1. / 2 * (offset_cage[i] + offset_cage[(i + 1) % m]);
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			std::vector<double> values;
			if (i == j) {
				CalBiharmonicTwiceBasisNewDerBoundary(v0, v1, v2, vi, values, 2);
			}
			else if (i == (j - 1+m) % m) {
				CalBiharmonicTwiceBasisNewDerBoundary(v0, v1, v2, vi, values, -2);
			}
			else
				CalBiharmonicTwiceBasisNewDerBoundary(v0, v1, v2, vi, values, 6);
		    //CalBiharmonicTwiceBasisNewDer(v0, v1, v2, vi, values);
			phiH(i + m, 0 + j) = values[0]; phiH(i + m, m + j) = values[1];
			phiBH(i + m, 0 + j) = values[2]; phiBH(i + m, m + j) = values[3];
			ksiH(i + m, 0 + j) = values[4]; ksiH(i + m, m + j) = values[5];
			ksiBH(i + m, 0 + j) = values[6]; ksiBH(i + m, m + j) = values[7];
			dH(i + m, 0 + j) = values[8]; dH(i + m, m + j) = values[9];
			eH(i + m, 0 + j) = values[10]; eH(i + m, m + j) = values[11];
			/*{
				vi = OpenMesh::Vec2d(3, 3);
				CalBiharmonicTwiceBasisNewDer(v0, v1, v2, vi, values);
			}*/
			phiHdx(i + 0*m, 0 + j) = values[12]; phiHdy(i + 0*m, 0 + j) = values[13]; phiHdx(i + 0*m, m + j) = values[14]; phiHdy(i + 0*m, m + j) = values[15];
			phiBHdx(i + 0*m, 0 + j) = values[16]; phiBHdy(i + 0*m, 0 + j) = values[17]; phiBHdx(i + 0*m, m + j) = values[18]; phiBHdy(i + 0*m, m + j) = values[19];
			ksiHdx(i + 0*m, 0 + j) = values[20]; ksiHdy(i + 0*m, 0 + j) = values[21]; ksiHdx(i + 0*m, m + j) = values[22]; ksiHdy(i + 0*m, m + j) = values[23];
			ksiBHdx(i + 0*m, 0 + j) = values[24]; ksiBHdy(i + 0*m, 0 + j) = values[25]; ksiBHdx(i + 0*m, m + j) = values[26]; ksiBHdy(i + 0*m, m + j) = values[27];
		}
		II(i + m, i + m) = 1. / 2;
		II(i + m, i) = 1. / 4;
		II(i + m, (i + 1) % m) = 1. / 4;
	}
	//在边的1/4采样
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = 1. / 4 * (3 * offset_cage[i] + offset_cage[(i + 1) % m]);
		for (int j = 0; j < m; j++) {
			vi = 1. / 4 * (3 * offset_cage[i] + offset_cage[(i + 1) % m]);
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			std::vector<double> values;
			if (i == j) {
				CalBiharmonicTwiceBasisNewDerBoundary(v0, v1, v2, vi, values, 2);
			}
			else if (i == (j - 1 + m) % m) {
				CalBiharmonicTwiceBasisNewDerBoundary(v0, v1, v2, vi, values, -2);
			}
			else
				CalBiharmonicTwiceBasisNewDerBoundary(v0, v1, v2, vi, values, 6);
			//CalBiharmonicTwiceBasisNewDer(v0, v1, v2, vi, values);
			phiH(i + 2 * m, 0 + j) = values[0]; phiH(i + 2 * m, m + j) = values[1];
			phiBH(i + 2 * m, 0 + j) = values[2]; phiBH(i + 2 * m, m + j) = values[3];
			ksiH(i + 2 * m, 0 + j) = values[4]; ksiH(i + 2 * m, m + j) = values[5];
			ksiBH(i + 2 * m, 0 + j) = values[6]; ksiBH(i + 2 * m, m + j) = values[7];
			dH(i + 2 * m, 0 + j) = values[8]; dH(i + 2 * m, m + j) = values[9];
			eH(i + 2 * m, 0 + j) = values[10]; eH(i + 2 * m, m + j) = values[11];
			/*{
				vi = OpenMesh::Vec2d(4, 4);
				CalBiharmonicTwiceBasisNewDer(v0, v1, v2, vi, values);
			}*/
			
			phiHdx(i + 1 * m, 0 + j) = values[12]; phiHdy(i + 1 * m, 0 + j) = values[13]; phiHdx(i + 1 * m, m + j) = values[14]; phiHdy(i + 1 * m, m + j) = values[15];
			phiBHdx(i + 1 * m, 0 + j) = values[16]; phiBHdy(i + 1 * m, 0 + j) = values[17]; phiBHdx(i + 1 * m, m + j) = values[18]; phiBHdy(i + 1 * m, m + j) = values[19];
			ksiHdx(i + 1 * m, 0 + j) = values[20]; ksiHdy(i + 1 * m, 0 + j) = values[21]; ksiHdx(i + 1 * m, m + j) = values[22]; ksiHdy(i + 1 * m, m + j) = values[23];
			ksiBHdx(i + 1 * m, 0 + j) = values[24]; ksiBHdy(i + 1 * m, 0 + j) = values[25]; ksiBHdx(i + 1 * m, m + j) = values[26]; ksiBHdy(i + 1 * m, m + j) = values[27];
		}
		II(i + 2 * m, i + m) = 6. / 16;
		II(i + 2 * m, i) = 9. / 16;
		II(i + 2 * m, (i + 1) % m) = 1. / 16;
	}
	//在边的3/4采样
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = 1. / 4 * (offset_cage[i] + 3 * offset_cage[(i + 1) % m]);
		for (int j = 0; j < m; j++) {
			vi = 1. / 4 * (offset_cage[i] + 3 * offset_cage[(i + 1) % m]);
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			std::vector<double> values;
			if (i == j) {
				CalBiharmonicTwiceBasisNewDerBoundary(v0, v1, v2, vi, values, 2);
			}
			else if (i == (j - 1 + m) % m) {
				CalBiharmonicTwiceBasisNewDerBoundary(v0, v1, v2, vi, values, -2);
			}
			else
				CalBiharmonicTwiceBasisNewDerBoundary(v0, v1, v2, vi, values, 6);
			//CalBiharmonicTwiceBasisNewDer(v0, v1, v2, vi, values);
			phiH(i + 3 * m, 0 + j) = values[0]; phiH(i + 3 * m, m + j) = values[1];
			phiBH(i + 3 * m, 0 + j) = values[2]; phiBH(i + 3 * m, m + j) = values[3];
			ksiH(i + 3 * m, 0 + j) = values[4]; ksiH(i + 3 * m, m + j) = values[5];
			ksiBH(i + 3 * m, 0 + j) = values[6]; ksiBH(i + 3 * m, m + j) = values[7];
			dH(i + 3 * m, 0 + j) = values[8]; dH(i + 3 * m, m + j) = values[9];
			eH(i + 3 * m, 0 + j) = values[10]; eH(i + 3 * m, m + j) = values[11];
			/*{
				vi = OpenMesh::Vec2d(5,5);
				CalBiharmonicTwiceBasisNewDer(v0, v1, v2, vi, values);
			}*/
			
			phiHdx(i + 2 * m, 0 + j) = values[12]; phiHdy(i + 2 * m, 0 + j) = values[13]; phiHdx(i + 2 * m, m + j) = values[14]; phiHdy(i + 2 * m, m + j) = values[15];
			phiBHdx(i + 2 * m, 0 + j) = values[16]; phiBHdy(i + 2 * m, 0 + j) = values[17]; phiBHdx(i + 2 * m, m + j) = values[18]; phiBHdy(i + 2 * m, m + j) = values[19];
			ksiHdx(i + 2 * m, 0 + j) = values[20]; ksiHdy(i + 2 * m, 0 + j) = values[21]; ksiHdx(i + 2 * m, m + j) = values[22]; ksiHdy(i + 2 * m, m + j) = values[23];
			ksiBHdx(i + 2 * m, 0 + j) = values[24]; ksiBHdy(i + 2 * m, 0 + j) = values[25]; ksiBHdx(i + 2 * m, m + j) = values[26]; ksiBHdy(i + 2 * m, m + j) = values[27];
		}
		II(i + 3 * m, i + m) = 6. / 16;
		II(i + 3 * m, i) = 1. / 16;
		II(i + 3 * m, (i + 1) % m) = 9. / 16;
	}
	/*std::cout << "phiH" << phiH << std::endl;
	std::cout << "II" << II << std::endl;
	std::cout << "eH" << eH << std::endl;
	std::cout << "dH" << dH << std::endl;*/

	A = pseudoInverse(eH) * (II - dH);
	std::cout << "A" << A << std::endl;
	// Calculating matrix D: D = (phiBH + psiBH * A).inverse()
	D = pseudoInverse(ksiH + ksiBH * A);
	std::cout << "D" << D << std::endl;
	// Calculating matrix B: B = D * (I - phiH)
	B = D * (II - phiH);
	std::cout << "B" << B << std::endl;
	// Calculating matrix C: C = -D * psiH
	C = -D * phiBH;
	std::cout << "C" << C << std::endl;
	std::cout << "ksiHdx" << ksiHdx << std::endl;
	std::cout << "ksiBHdx" << ksiBHdx << std::endl;
	////导数部分，x分量，整体
	//Eigen::MatrixXd Bx = phiHdx + (ksiHdx + ksiBHdx * A) * B;
	//Eigen::MatrixXd Cx = phiBHdx + (ksiHdx + ksiBHdx * A) * C;
	////y分量
	//Eigen::MatrixXd By = phiHdy + (ksiHdy + ksiBHdy * A) * B;
	//Eigen::MatrixXd Cy = phiBHdy + (ksiHdy + ksiBHdy * A) * C;
	// //导数部分，x分量，非调和部分
	Eigen::MatrixXd Bx =(ksiHdx + ksiBHdx * A) * B;
	Eigen::MatrixXd Cx = (ksiHdx + ksiBHdx * A) * C;
	//y分量
	Eigen::MatrixXd By =  (ksiHdy + ksiBHdy * A) * B;
	Eigen::MatrixXd Cy =  (ksiHdy + ksiBHdy * A) * C;
	//构造大的矩阵
	Eigen::MatrixXd DeriB(6 * m, 4 * m);
	DeriB.setZero();
	DeriB.block(0, 0, 3 * m, 2 * m) = Bx;
	DeriB.block(3 * m, 2 * m, 3 * m, 2 * m) = By;
	//std::cout << DeriB << std::endl;
	Eigen::MatrixXd DeriC(6 * m, 4 * m);
	DeriC.setZero();
	DeriC.block(0, 0, 3 * m, 2 * m) = Cx;
	DeriC.block(3 * m, 2 * m, 3 * m, 2 * m) = Cy;
	AAAB = DeriB;
	AAAC = DeriC;
	Eigen::MatrixXd f(2 * m, 2);
	for (int i = 0; i < m; ++i) {
		f(i, 0) = linear_cage[i][0];
		f(i, 1) = linear_cage[i][1];

		f(i + m, 0) = (linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 2;
		f(i + m, 1) = (linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 2;
	}
	Eigen::MatrixXd d(2 * m, 2);
	for (int i = 0; i < m; ++i) {
		d(i, 0) = (-linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 2;//y
		d(i, 1) = -(-linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 2;//-x

		d(i + m, 0) = (-linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 2;//y
		d(i + m, 1) = -(-linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 2;//-x
	}
	std::cout << "f " << f << std::endl;
	std::cout << "d " << d << std::endl;
	std::cout << "test1" << (II - phiH) * f - phiBH * d << std::endl;
	std::cout << "test2" << B * f + C * d << std::endl;

	std::cout << "test3" << phiHdx * f + phiBHdx * d << std::endl;
	std::cout << "test4" << phiHdy * f + phiBHdy * d << std::endl;

	std::cout << "test5" << Bx * f + Cx * d << std::endl;
	std::cout << "test6" << By * f + Cy * d << std::endl;

	//std::cout << "test5" << phiH_test * f + phiBH_test * d << std::endl;
}

void MeshViewerWidget::ConstructMatrix4OffSetTwiceVirtual2() {
	int m = linear_cage.size();
	std::vector<OpenMesh::Vec2d> offset_cage = offsetCage(linear_cage, 0.000001);
	// 定义四个 m * m 的矩阵 A, B, C, D，元素类型为 double
	A.resize(2 * m, 2 * m); B.resize(2 * m, 2 * m); C.resize(2 * m, 2 * m); D.resize(2 * m, 2 * m);
	Eigen::MatrixXd phiH(6 * m, 2 * m); Eigen::MatrixXd phiBH(6 * m, 2 * m);
	Eigen::MatrixXd ksiH(6 * m, 2 * m); Eigen::MatrixXd ksiBH(6 * m, 2 * m);
	Eigen::MatrixXd dH(6 * m, 2 * m); Eigen::MatrixXd eH(6 * m, 2 * m);
	Eigen::MatrixXd II = Eigen::MatrixXd::Zero(6 * m, 2 * m);
	// 初始化或填充矩阵 A, B, C, D
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = offset_cage[i];
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			std::vector<double> values;
			CalBiharmonicTwiceBasis(v0, v1, v2, vi, values);
			phiH(i, 0 + j) = values[0]; phiH(i, m + j) = values[1];
			phiBH(i, 0 + j) = values[2]; phiBH(i, m + j) = values[3];
			ksiH(i, 0 + j) = values[4]; ksiH(i, m + j) = values[5];
			ksiBH(i, 0 + j) = values[6]; ksiBH(i, m + j) = values[7];
			dH(i, 0 + j) = values[8]; dH(i, m + j) = values[9];
			eH(i, 0 + j) = values[10]; eH(i, m + j) = values[11];
		}
		II(i, i) = 1;
	}
	//在边的中间采样
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = 1. / 2 * (offset_cage[i] + offset_cage[(i + 1) % m]);
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			std::vector<double> values;
			CalBiharmonicTwiceBasis(v0, v1, v2, vi, values);
			phiH(i + m, 0 + j) = values[0]; phiH(i + m, m + j) = values[1];
			phiBH(i + m, 0 + j) = values[2]; phiBH(i + m, m + j) = values[3];
			ksiH(i + m, 0 + j) = values[4]; ksiH(i + m, m + j) = values[5];
			ksiBH(i + m, 0 + j) = values[6]; ksiBH(i + m, m + j) = values[7];
			dH(i + m, 0 + j) = values[8]; dH(i + m, m + j) = values[9];
			eH(i + m, 0 + j) = values[10]; eH(i + m, m + j) = values[11];
		}
		II(i + m, i + m) = 1. / 2;
		II(i + m, i) = 1. / 4;
		II(i + m, (i + 1) % m) = 1. / 4;
	}
	//在边的1/4采样
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = 1. / 4 * (3 * offset_cage[i] + offset_cage[(i + 1) % m]);
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			std::vector<double> values;
			CalBiharmonicTwiceBasis(v0, v1, v2, vi, values);
			phiH(i + 2 * m, 0 + j) = values[0]; phiH(i + 2 * m, m + j) = values[1];
			phiBH(i + 2 * m, 0 + j) = values[2]; phiBH(i + 2 * m, m + j) = values[3];
			ksiH(i + 2 * m, 0 + j) = values[4]; ksiH(i + 2 * m, m + j) = values[5];
			ksiBH(i + 2 * m, 0 + j) = values[6]; ksiBH(i + 2 * m, m + j) = values[7];
			dH(i + 2 * m, 0 + j) = values[8]; dH(i + 2 * m, m + j) = values[9];
			eH(i + 2 * m, 0 + j) = values[10]; eH(i + 2 * m, m + j) = values[11];
		}
		II(i + 2 * m, i + m) = 6. / 16;
		II(i + 2 * m, i) = 9. / 16;
		II(i + 2 * m, (i + 1) % m) = 1. / 16;
	}
	//在边的3/4采样
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = 1. / 4 * (offset_cage[i] + 3 * offset_cage[(i + 1) % m]);
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			std::vector<double> values;
			CalBiharmonicTwiceBasis(v0, v1, v2, vi, values);
			phiH(i + 3 * m, 0 + j) = values[0]; phiH(i + 3 * m, m + j) = values[1];
			phiBH(i + 3 * m, 0 + j) = values[2]; phiBH(i + 3 * m, m + j) = values[3];
			ksiH(i + 3 * m, 0 + j) = values[4]; ksiH(i + 3 * m, m + j) = values[5];
			ksiBH(i + 3 * m, 0 + j) = values[6]; ksiBH(i + 3 * m, m + j) = values[7];
			dH(i + 3 * m, 0 + j) = values[8]; dH(i + 3 * m, m + j) = values[9];
			eH(i + 3 * m, 0 + j) = values[10]; eH(i + 3 * m, m + j) = values[11];
		}
		II(i + 3 * m, i + m) = 6. / 16;
		II(i + 3 * m, i) = 1. / 16;
		II(i + 3 * m, (i + 1) % m) = 9. / 16;
	}
	//在边的1/8采样
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = 1. / 8 * (7 * offset_cage[i] + offset_cage[(i + 1) % m]);
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			std::vector<double> values;
			CalBiharmonicTwiceBasis(v0, v1, v2, vi, values);
			phiH(i + 4 * m, 0 + j) = values[0]; phiH(i + 4 * m, m + j) = values[1];
			phiBH(i + 4 * m, 0 + j) = values[2]; phiBH(i + 4 * m, m + j) = values[3];
			ksiH(i + 4 * m, 0 + j) = values[4]; ksiH(i + 4 * m, m + j) = values[5];
			ksiBH(i + 4 * m, 0 + j) = values[6]; ksiBH(i + 4 * m, m + j) = values[7];
			dH(i + 4 * m, 0 + j) = values[8]; dH(i + 4 * m, m + j) = values[9];
			eH(i + 4 * m, 0 + j) = values[10]; eH(i + 4 * m, m + j) = values[11];
		}
		II(i + 4 * m, i + m) = 14. / 64;
		II(i + 4 * m, i) = 49. / 64;
		II(i + 4 * m, (i + 1) % m) = 1. / 64;
	}
	//在边的3/4采样
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = 1. / 8 * (offset_cage[i] + 7 * offset_cage[(i + 1) % m]);
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			std::vector<double> values;
			CalBiharmonicTwiceBasis(v0, v1, v2, vi, values);
			phiH(i + 5 * m, 0 + j) = values[0]; phiH(i + 5 * m, m + j) = values[1];
			phiBH(i + 5 * m, 0 + j) = values[2]; phiBH(i + 5 * m, m + j) = values[3];
			ksiH(i + 5 * m, 0 + j) = values[4]; ksiH(i + 5 * m, m + j) = values[5];
			ksiBH(i + 5 * m, 0 + j) = values[6]; ksiBH(i + 5 * m, m + j) = values[7];
			dH(i + 5 * m, 0 + j) = values[8]; dH(i + 5 * m, m + j) = values[9];
			eH(i + 5 * m, 0 + j) = values[10]; eH(i + 5 * m, m + j) = values[11];
		}
		II(i + 5 * m, i + m) = 14. / 64;
		II(i + 5 * m, i) = 1. / 64;
		II(i + 5 * m, (i + 1) % m) = 49. / 64;
	}
	/*std::cout << "phiH" << phiH << std::endl;
	std::cout << "II" << II << std::endl;
	std::cout << "eH" << eH << std::endl;
	std::cout << "dH" << dH << std::endl;*/

	A = pseudoInverse(eH) * (II - dH);
	std::cout << "A" << A << std::endl;
	// Calculating matrix D: D = (phiBH + psiBH * A).inverse()
	D = pseudoInverse(ksiH + ksiBH * A);
	std::cout << "D" << D << std::endl;
	// Calculating matrix B: B = D * (I - phiH)
	B = D * (II - phiH);
	std::cout << "B" << B << std::endl;
	// Calculating matrix C: C = -D * psiH
	C = -D * phiBH;
	std::cout << "C" << C << std::endl;
	Eigen::MatrixXd f(2 * m, 2);
	for (int i = 0; i < m; ++i) {
		f(i, 0) = linear_cage[i][0];
		f(i, 1) = linear_cage[i][1];

		f(i + m, 0) = (linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 2;
		f(i + m, 1) = (linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 2;
	}
	Eigen::MatrixXd d(2 * m, 2);
	for (int i = 0; i < m; ++i) {
		d(i, 0) = linear_cage[i][1];
		d(i, 1) = -linear_cage[i][0];

		d(i + m, 0) = (linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 2;
		d(i + m, 1) = -(linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 2;
	}
	std::cout << "f " << f << std::endl;
	std::cout << "d " << d << std::endl;
	std::cout << "test1" << (II - phiH) * f - phiBH * d << std::endl;
	std::cout << "test2" << B * f + C * d << std::endl;
}

void MeshViewerWidget::ConstructMatrix4OffSetVirtual() {
	int m = linear_cage.size();
	std::vector<OpenMesh::Vec2d> offset_cage = offsetCage(linear_cage, 0.000001);
	auto linearcage2 = subdivideCage(offset_cage);
	offset_cage = linearcage2;
	// 定义四个 m * m 的矩阵 A, B, C, D，元素类型为 double
	A.resize(m, m); B.resize(m, m); C.resize(m, m); D.resize(m, m);
	Eigen::MatrixXd ksiH(2*m, m); Eigen::MatrixXd ksiBH(2*m, m); Eigen::MatrixXd phiH(2*m, m); Eigen::MatrixXd phiBH(2*m, m);
	Eigen::MatrixXd II = Eigen::MatrixXd::Identity(2*m, m);
	Eigen::MatrixXd III = Eigen::MatrixXd::Zero(2 * m, m);
	// 初始化或填充矩阵 A, B, C, D
	for (int i = 0; i < 2*m; i++) {
		OpenMesh::Vec2d vi = offset_cage[i];
		if (i % 2 == 0) {
			III(i, i / 2) = 1;
		}
		else {
			III(i, i / 2) = 1./2;
			III(i, (i / 2+1)%m) = 1. / 2;
		}
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			double v_ksiH, v_ksiBH, v_phiH, v_phiBH;
			CalBiharmonicBasis(v0, v1, v2, vi, v_ksiH, v_phiH, v_ksiBH, v_phiBH);
			ksiH(i, j) = v_ksiH;
			ksiBH(i, j) = v_ksiBH;//test
			phiH(i, j) = v_phiH;
			phiBH(i, j) = v_phiBH;
		}
	}
	/*std::cout << III << std::endl;
	std::cout << ksiH << std::endl;
	std::cout << "伪逆" << pseudoInverse(ksiH)*ksiH << std::endl;*/
	A = pseudoInverse(ksiH) * (III - phiH);
	//std::cout << "A" << A << std::endl;
	// Calculating matrix D: D = (phiBH + psiBH * A).inverse()
	D = pseudoInverse(phiBH + ksiBH * A);
	//std::cout << "D" << D << std::endl;
	// Calculating matrix B: B = D * (I - phiH)
	B = D * (III - phiH);
	//std::cout << "B" << B << std::endl;
	// Calculating matrix C: C = -D * psiH
	C = -D * ksiH;
	//std::cout << "C" << C << std::endl;
}
void MeshViewerWidget::ConstructMatrix4OffSetVirtual2() {
	int m = linear_cage.size();
	std::vector<OpenMesh::Vec2d> offset_cage = offsetCage(linear_cage, 0.000001);
	auto linearcage2 = subdivideCage(offset_cage);
	offset_cage = linearcage2;
	auto linearcage3 = subdivideCage(offset_cage);
	offset_cage = linearcage3;
	// 定义四个 m * m 的矩阵 A, B, C, D，元素类型为 double
	A.resize(m, m); B.resize(m, m); C.resize(m, m); D.resize(m, m);
	Eigen::MatrixXd ksiH(4 * m, m); Eigen::MatrixXd ksiBH(4 * m, m); Eigen::MatrixXd phiH(4 * m, m); Eigen::MatrixXd phiBH(4 * m, m);
	Eigen::MatrixXd II = Eigen::MatrixXd::Identity(2 * m, m);
	Eigen::MatrixXd III = Eigen::MatrixXd::Zero(4 * m, m);
	// 初始化或填充矩阵 A, B, C, D
	for (int i = 0; i < 4 * m; i++) {
		OpenMesh::Vec2d vi = offset_cage[i];
		if (i % 4 == 0) {
			III(i, i / 4) = 1;
		}
		else {
			if (i % 4 == 1) {
				III(i, i / 4) = 3. / 4;
				III(i, (i / 4 + 1) % m) = 1. / 4;
			}
			if (i % 4 == 2) {
				III(i, i / 4) = 2. / 4;
				III(i, (i / 4 + 1) % m) = 2. / 4;
			}
			if (i % 4 == 3) {
				III(i, i / 4) = 1. / 4;
				III(i, (i / 4 + 1) % m) = 3. / 4;
			}
		}
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			double v_ksiH, v_ksiBH, v_phiH, v_phiBH;
			CalBiharmonicBasis(v0, v1, v2, vi, v_ksiH, v_phiH, v_ksiBH, v_phiBH);
			ksiH(i, j) = v_ksiH;
			ksiBH(i, j) = v_ksiBH;//test
			phiH(i, j) = v_phiH;
			phiBH(i, j) = v_phiBH;
		}
	}
	std::cout << III << std::endl;
	std::cout << ksiH << std::endl;
	std::cout << "伪逆" << pseudoInverse(ksiH) * ksiH << std::endl;
	A = pseudoInverse(ksiH) * (III - phiH);
	std::cout << "A" << A << std::endl;
	// Calculating matrix D: D = (phiBH + psiBH * A).inverse()
	D = pseudoInverse(phiBH + ksiBH * A);
	std::cout << "D" << D << std::endl;
	// Calculating matrix B: B = D * (I - phiH)
	B = D * (III - phiH);
	std::cout << "B" << B << std::endl;
	// Calculating matrix C: C = -D * psiH
	C = -D * ksiH;
	std::cout << "C" << C << std::endl;
}

void MeshViewerWidget::ConstructMatrix4OffSetVirtual3() {
	int m = linear_cage.size();
	std::vector<OpenMesh::Vec2d> offset_cage = offsetCage(linear_cage, 0.000001);
	auto linearcage2 = subdivideCage(offset_cage);
	offset_cage = linearcage2;
	auto linearcage3 = subdivideCage(offset_cage);
	offset_cage = linearcage3;
	auto linearcage4 = subdivideCage(offset_cage);
	offset_cage = linearcage4;
	// 定义四个 m * m 的矩阵 A, B, C, D，元素类型为 double
	A.resize(m, m); B.resize(m, m); C.resize(m, m); D.resize(m, m);
	Eigen::MatrixXd ksiH(8 * m, m); Eigen::MatrixXd ksiBH(8 * m, m); Eigen::MatrixXd phiH(8 * m, m); Eigen::MatrixXd phiBH(8 * m, m);
	//Eigen::MatrixXd II = Eigen::MatrixXd::Identity(3 * m, m);
	Eigen::MatrixXd III = Eigen::MatrixXd::Zero(8 * m, m);
	// 初始化或填充矩阵 A, B, C, D
	for (int i = 0; i < 8 * m; i++) {
		OpenMesh::Vec2d vi = offset_cage[i];
		if (i % 8 == 0) {
			III(i, i / 8) = 1;
		}
		else {
			if (i % 8 == 1) {
				III(i, i / 8) = 7. / 8;
				III(i, (i / 8 + 1) % m) = 1. / 8;
			}
			if (i % 8 == 2) {
				III(i, i / 8) = 6. / 8;
				III(i, (i / 8 + 1) % m) = 2. / 8;
			}
			if (i % 8 == 3) {
				III(i, i / 8) = 5. / 8;
				III(i, (i / 8 + 1) % m) = 3. / 8;
			}
			if (i % 8 == 4) {
				III(i, i / 8) = 4. / 8;
				III(i, (i / 8 + 1) % m) = 4. / 8;
			}
			if (i % 8 == 5) {
				III(i, i / 8) = 3. / 8;
				III(i, (i / 8 + 1) % m) = 5. / 8;
			}
			if (i % 8 == 6) {
				III(i, i / 8) = 2. / 8;
				III(i, (i / 8 + 1) % m) = 6. / 8;
			}
			if (i % 8 == 7) {
				III(i, i / 8) = 1. / 8;
				III(i, (i / 8 + 1) % m) = 7. / 8;
			}
		}
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = linear_cage[(j - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[j];
			OpenMesh::Vec2d v2 = linear_cage[(j + 1) % m];
			double v_ksiH, v_ksiBH, v_phiH, v_phiBH;
			CalBiharmonicBasis(v0, v1, v2, vi, v_ksiH, v_phiH, v_ksiBH, v_phiBH);
			ksiH(i, j) = v_ksiH;
			ksiBH(i, j) = v_ksiBH;//test
			phiH(i, j) = v_phiH;
			phiBH(i, j) = v_phiBH;
		}
	}
	std::cout << III << std::endl;
	std::cout << ksiH << std::endl;
	std::cout << "伪逆" << pseudoInverse(ksiH) * ksiH << std::endl;
	A = pseudoInverse(ksiH) * (III - phiH);
	std::cout << "A" << A << std::endl;
	// Calculating matrix D: D = (phiBH + psiBH * A).inverse()
	D = pseudoInverse(phiBH + ksiBH * A);
	std::cout << "D" << D << std::endl;
	// Calculating matrix B: B = D * (I - phiH)
	B = D * (III - phiH);
	std::cout << "B" << B << std::endl;
	// Calculating matrix C: C = -D * psiH
	C = -D * ksiH;
	std::cout << "C" << C << std::endl;
}
void MeshViewerWidget::BH2ConstructMatrix4OffSet() {
	int m = curvecage2_real.size();
	auto offset_cage = offsetCage2(CC_points2d,1e-6);
	// 定义四个 m * m 的矩阵 A, B, C, D，元素类型为 double
	A.resize(2 * m, 2 * m); B.resize(2 * m, 2 * m); C.resize(2 * m, 2 * m); D.resize(2 * m, 2 * m);
	Eigen::MatrixXd phiH(2 * m, 2 * m); Eigen::MatrixXd phiBH(2 * m, 2 * m);
	Eigen::MatrixXd ksiH(2 * m, 2 * m); Eigen::MatrixXd ksiBH(2 * m, 2 * m);
	Eigen::MatrixXd dH(2 * m, 2 * m); Eigen::MatrixXd eH(2 * m, 2 * m);
	Eigen::MatrixXd II = Eigen::MatrixXd::Zero(2 * m, 2 * m);
	
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = offset_cage[2*i];
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = Vec322(curvecage2_real[(j - 1 + m) % m][0]);
			OpenMesh::Vec2d v01 = Vec322(curvecage2_real[(j - 1 + m) % m][1]);
			OpenMesh::Vec2d v1 = Vec322(curvecage2_real[(j - 1 + m) % m][2]);
			OpenMesh::Vec2d v12 = Vec322(curvecage2_real[j ][1]);
			OpenMesh::Vec2d v2 = Vec322(curvecage2_real[j][2]);
			std::vector<double> values;
			Cal222BiharmonicBasis(v0, v01, v1, v12, v2, vi, values);
			/*for (auto& v : values)
			{
				std::cout << v << " ";
			}
			std::cout << std::endl;
			Cal222BiharmonicBasis(v0, (v0 + v1) / 1.99, v1, (v1 + v2) / 1.99, v2, vi, values);
			for (auto& v : values)
			{
				std::cout << v << " ";
			}
			std::cout << std::endl;*/
			phiH(i, 0 + j) = values[0]; phiH(i, m + j) = values[1];
			phiBH(i, 0 + j) = values[2]; phiBH(i, m + j) = values[3];
			ksiH(i, 0 + j) = values[4]; ksiH(i, m + j) = values[5];
			ksiBH(i, 0 + j) = values[6]; ksiBH(i, m + j) = values[7];
			dH(i, 0 + j) = values[8]; dH(i, m + j) = values[9];
			eH(i, 0 + j) = values[10]; eH(i, m + j) = values[11];
		}
		II(i, i) = 1;
	}
	//在边的中间采样
	for (int i = 0; i < m; i++) {
		//i = 3;//testtttttttttttttt
		OpenMesh::Vec2d vi = offset_cage[2 * i + 1];
		for (int j = 0; j < m; j++) { 
			//j = 3;//testttttttttttt
			OpenMesh::Vec2d v0 = Vec322(curvecage2_real[(j - 1 + m) % m][0]);
			OpenMesh::Vec2d v01 = Vec322(curvecage2_real[(j - 1 + m) % m][1]);
			OpenMesh::Vec2d v1 = Vec322(curvecage2_real[(j - 1 + m) % m][2]);
			OpenMesh::Vec2d v12 = Vec322(curvecage2_real[j][1]);
			OpenMesh::Vec2d v2 = Vec322(curvecage2_real[j][2]);
			std::vector<double> values;
			Cal222BiharmonicBasis(v0, v01, v1, v12, v2, vi, values);
			phiH(i + m, 0 + j) = values[0]; phiH(i + m, m + j) = values[1];
			phiBH(i + m, 0 + j) = values[2]; phiBH(i + m, m + j) = values[3];
			ksiH(i + m, 0 + j) = values[4]; ksiH(i + m, m + j) = values[5];
			ksiBH(i + m, 0 + j) = values[6]; ksiBH(i + m, m + j) = values[7];
			dH(i + m, 0 + j) = values[8]; dH(i + m, m + j) = values[9];
			eH(i + m, 0 + j) = values[10]; eH(i + m, m + j) = values[11];
		}
		II(i + m, i + m) = 1. / 2;
		II(i + m, i) = 1. / 4;
		II(i + m, (i + 1) % m) = 1. / 4;
	}
	std::cout << "phiH" << phiH << std::endl;
	std::cout << "phiBH" << phiBH << std::endl;
	std::cout << "ksiH" << ksiH << std::endl;
	std::cout << "ksiBH" << ksiBH << std::endl;
	std::cout << "ksiH-1" << ksiH.inverse() << std::endl;

	A = (eH.inverse()) * (II - dH);
	std::cout << "A" << A << std::endl;
	// Calculating matrix D: D = (phiBH + psiBH * A).inverse()
	D = (ksiH + ksiBH * A).inverse();
	std::cout << "D" << D << std::endl;
	// Calculating matrix B: B = D * (I - phiH)
	B = D * (II - phiH);
	std::cout << "B" << B << std::endl;
	// Calculating matrix C: C = -D * psiH
	C = -D * phiBH;

	Eigen::MatrixXd f(2 * m, 2);
	for (int i = 0; i < m; ++i) {
		f(i, 0) = curvecage2_real[i][0][0];// linear_cage[i][0];
		f(i, 1) = curvecage2_real[i][0][1];//linear_cage[i][1];

		f(i + m, 0) = curvecage2_real[i][1][0];//(linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 2;
		f(i + m, 1) = curvecage2_real[i][1][1];//(linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 2;
	}
	Eigen::MatrixXd d(2 * m, 2);
	for (int i = 0; i < m; ++i) {
		d(i, 0) = curvecage2_real[i][1][1] - curvecage2_real[i][0][1];//(-linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 2;//y
		d(i, 1) = -(curvecage2_real[i][1][0] - curvecage2_real[i][0][0]);// -(-linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 2;//-x

		d(i + m, 0) = curvecage2_real[i][2][1] - curvecage2_real[i][1][1];//(-linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 2;//y
		d(i + m, 1) = -(curvecage2_real[i][2][0] - curvecage2_real[i][1][0]);//-(-linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 2;//-x
	}
	std::cout << "f " << f << std::endl;
	std::cout << "d " << d << std::endl;
	std::cout << "test1" << (II - phiH) * f - phiBH * d << std::endl;
	std::cout << "test2" << B * f + C * d << std::endl;
}

void MeshViewerWidget::BH2ConstructMatrix4OffSetVirtual() {
	int m = curvecage2_real.size();
	auto CC_points2dsub = subdivideCage2(CC_points2d);
	auto offset_cage = offsetCage2(CC_points2dsub, 1e-6);
	// 定义四个 m * m 的矩阵 A, B, C, D，元素类型为 double
	A.resize(2 * m, 2 * m); B.resize(2 * m, 2 * m); C.resize(2 * m, 2 * m); D.resize(2 * m, 2 * m);
	Eigen::MatrixXd phiH(4 * m, 2 * m); Eigen::MatrixXd phiBH(4 * m, 2 * m);
	Eigen::MatrixXd ksiH(4 * m, 2 * m); Eigen::MatrixXd ksiBH(4 * m, 2 * m);
	Eigen::MatrixXd dH(4 * m, 2 * m); Eigen::MatrixXd eH(4 * m, 2 * m);
	Eigen::MatrixXd II = Eigen::MatrixXd::Zero(4 * m, 2 * m);

	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = offset_cage[4 * i];
        //#pragma omp parallel for 
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = Vec322(curvecage2_real[(j - 1 + m) % m][0]);
			OpenMesh::Vec2d v01 = Vec322(curvecage2_real[(j - 1 + m) % m][1]);
			OpenMesh::Vec2d v1 = Vec322(curvecage2_real[(j - 1 + m) % m][2]);
			OpenMesh::Vec2d v12 = Vec322(curvecage2_real[j][1]);
			OpenMesh::Vec2d v2 = Vec322(curvecage2_real[j][2]);
			std::vector<double> values;
			Cal222BiharmonicBasis(v0, v01, v1, v12, v2, vi, values);

			phiH(i, 0 + j) = values[0]; phiH(i, m + j) = values[1];
			phiBH(i, 0 + j) = values[2]; phiBH(i, m + j) = values[3];
			ksiH(i, 0 + j) = values[4]; ksiH(i, m + j) = values[5];
			ksiBH(i, 0 + j) = values[6]; ksiBH(i, m + j) = values[7];
			dH(i, 0 + j) = values[8]; dH(i, m + j) = values[9];
			eH(i, 0 + j) = values[10]; eH(i, m + j) = values[11];
		}
		II(i, i) = 1;
	}
	//在边的1/4采样
	for (int i = 0; i < m; i++) {
		//i = 3;//testtttttttttttttt
		OpenMesh::Vec2d vi = offset_cage[4 * i + 1];
        //#pragma omp parallel for
		for (int j = 0; j < m; j++) {
			//j = 3;//testttttttttttt
			OpenMesh::Vec2d v0 = Vec322(curvecage2_real[(j - 1 + m) % m][0]);
			OpenMesh::Vec2d v01 = Vec322(curvecage2_real[(j - 1 + m) % m][1]);
			OpenMesh::Vec2d v1 = Vec322(curvecage2_real[(j - 1 + m) % m][2]);
			OpenMesh::Vec2d v12 = Vec322(curvecage2_real[j][1]);
			OpenMesh::Vec2d v2 = Vec322(curvecage2_real[j][2]);
			std::vector<double> values;
			Cal222BiharmonicBasis(v0, v01, v1, v12, v2, vi, values);
			phiH(i + m, 0 + j) = values[0]; phiH(i + m, m + j) = values[1];
			phiBH(i + m, 0 + j) = values[2]; phiBH(i + m, m + j) = values[3];
			ksiH(i + m, 0 + j) = values[4]; ksiH(i + m, m + j) = values[5];
			ksiBH(i + m, 0 + j) = values[6]; ksiBH(i + m, m + j) = values[7];
			dH(i + m, 0 + j) = values[8]; dH(i + m, m + j) = values[9];
			eH(i + m, 0 + j) = values[10]; eH(i + m, m + j) = values[11];
		}
		II(i + m, i + m) = 6. / 16;
		II(i + m, i) = 9. / 16;
		II(i + m, (i + 1) % m) = 1. / 16;
	}
	//在边的中间采样
	for (int i = 0; i < m; i++) {
		//i = 3;//testtttttttttttttt
		OpenMesh::Vec2d vi = offset_cage[4 * i + 2];
        #pragma omp parallel for
		for (int j = 0; j < m; j++) {
			//j = 3;//testttttttttttt
			OpenMesh::Vec2d v0 = Vec322(curvecage2_real[(j - 1 + m) % m][0]);
			OpenMesh::Vec2d v01 = Vec322(curvecage2_real[(j - 1 + m) % m][1]);
			OpenMesh::Vec2d v1 = Vec322(curvecage2_real[(j - 1 + m) % m][2]);
			OpenMesh::Vec2d v12 = Vec322(curvecage2_real[j][1]);
			OpenMesh::Vec2d v2 = Vec322(curvecage2_real[j][2]);
			std::vector<double> values;
			Cal222BiharmonicBasis(v0, v01, v1, v12, v2, vi, values);
			phiH(i + 2*m, 0 + j) = values[0]; phiH(i + 2*m, m + j) = values[1];
			phiBH(i + 2*m, 0 + j) = values[2]; phiBH(i + 2*m, m + j) = values[3];
			ksiH(i + 2*m, 0 + j) = values[4]; ksiH(i + 2*m, m + j) = values[5];
			ksiBH(i + 2*m, 0 + j) = values[6]; ksiBH(i + 2*m, m + j) = values[7];
			dH(i + 2*m, 0 + j) = values[8]; dH(i + 2*m, m + j) = values[9];
			eH(i + 2*m, 0 + j) = values[10]; eH(i + 2*m, m + j) = values[11];
		}
		II(i + 2*m, i + m) = 1. / 2;
		II(i + 2*m, i) = 1. / 4;
		II(i + 2*m, (i + 1) % m) = 1. / 4;
	}

	//在边的3/4采样
	for (int i = 0; i < m; i++) {
		//i = 3;//testtttttttttttttt
		OpenMesh::Vec2d vi = offset_cage[4 * i + 3];
        #pragma omp parallel for
		for (int j = 0; j < m; j++) {
			//j = 3;//testttttttttttt
			OpenMesh::Vec2d v0 = Vec322(curvecage2_real[(j - 1 + m) % m][0]);
			OpenMesh::Vec2d v01 = Vec322(curvecage2_real[(j - 1 + m) % m][1]);
			OpenMesh::Vec2d v1 = Vec322(curvecage2_real[(j - 1 + m) % m][2]);
			OpenMesh::Vec2d v12 = Vec322(curvecage2_real[j][1]);
			OpenMesh::Vec2d v2 = Vec322(curvecage2_real[j][2]);
			std::vector<double> values;
			Cal222BiharmonicBasis(v0, v01, v1, v12, v2, vi, values);
			phiH(i + 3*m, 0 + j) = values[0]; phiH(i +3* m, m + j) = values[1];
			phiBH(i + 3*m, 0 + j) = values[2]; phiBH(i +3* m, m + j) = values[3];
			ksiH(i + 3*m, 0 + j) = values[4]; ksiH(i +3* m, m + j) = values[5];
			ksiBH(i +3* m, 0 + j) = values[6]; ksiBH(i +3* m, m + j) = values[7];
			dH(i +3* m, 0 + j) = values[8]; dH(i +3* m, m + j) = values[9];
			eH(i +3* m, 0 + j) = values[10]; eH(i +3* m, m + j) = values[11];
		}
		II(i + 3*m, i + m) = 6. / 16;
		II(i + 3*m, i) = 1. / 16;
		II(i + 3*m, (i + 1) % m) = 9. / 16;
	}

	std::cout << "phiH" << phiH << std::endl;
	std::cout << "ksiH" << ksiH << std::endl;
	std::cout << "dH" << dH << std::endl;
	return;
	/*std::cout << "phiH" << phiH << std::endl;
	std::cout << "phiBH" << phiBH << std::endl;
	std::cout << "ksiH" << ksiH << std::endl;
	std::cout << "ksiBH" << ksiBH << std::endl;*/
	//std::cout << "ksiH-1" << ksiH.inverse() << std::endl;

	A = pseudoInverse(eH) * (II - dH);
	//std::cout << "A" << A << std::endl;
	// Calculating matrix D: D = (phiBH + psiBH * A).inverse()
	D = pseudoInverse(ksiH + ksiBH * A);
	//std::cout << "D" << D << std::endl;
	// Calculating matrix B: B = D * (I - phiH)
	B = D * (II - phiH);
	//std::cout << "B" << B << std::endl;
	// Calculating matrix C: C = -D * psiH
	C = -D * phiBH;

	//Eigen::MatrixXd f(2 * m, 2);
	//for (int i = 0; i < m; ++i) {
	//	f(i, 0) = curvecage2_real[i][0][0];// linear_cage[i][0];
	//	f(i, 1) = curvecage2_real[i][0][1];//linear_cage[i][1];

	//	f(i + m, 0) = curvecage2_real[i][1][0];//(linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 2;
	//	f(i + m, 1) = curvecage2_real[i][1][1];//(linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 2;
	//}
	//Eigen::MatrixXd d(2 * m, 2);
	//for (int i = 0; i < m; ++i) {
	//	d(i, 0) = curvecage2_real[i][1][1] - curvecage2_real[i][0][1];//(-linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 2;//y
	//	d(i, 1) = -(curvecage2_real[i][1][0] - curvecage2_real[i][0][0]);// -(-linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 2;//-x

	//	d(i + m, 0) = curvecage2_real[i][2][1] - curvecage2_real[i][1][1];//(-linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 2;//y
	//	d(i + m, 1) = -(curvecage2_real[i][2][0] - curvecage2_real[i][1][0]);//-(-linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 2;//-x
	//}
	//std::cout << "f " << f << std::endl;
	//std::cout << "d " << d << std::endl;
	//std::cout << "test1" << (II - phiH) * f - phiBH * d << std::endl;
	//std::cout << "test2" << B * f + C * d << std::endl;
}

void MeshViewerWidget::BH2ConstructMatrix4OffSetVirtual_edge() {
	int m = curvecage2_real.size();
	auto CC_points2dsub = subdivideCage2(CC_points2d);
	auto offset_cage = offsetCage2(CC_points2dsub, 1e-6);
	// 定义四个 m * m 的矩阵 A, B, C, D，元素类型为 double
	A.resize(2 * m, 2 * m); B.resize(2 * m, 2 * m); C.resize(2 * m, 2 * m); D.resize(2 * m, 2 * m);
	Eigen::MatrixXd phiH = Eigen::MatrixXd::Zero(4 * m, 2 * m);
	Eigen::MatrixXd phiBH = Eigen::MatrixXd::Zero(4 * m, 2 * m);
	Eigen::MatrixXd ksiH = Eigen::MatrixXd::Zero(4 * m, 2 * m);
	Eigen::MatrixXd ksiBH = Eigen::MatrixXd::Zero(4 * m, 2 * m);
	Eigen::MatrixXd dH = Eigen::MatrixXd::Zero(4 * m, 2 * m);
	Eigen::MatrixXd eH = Eigen::MatrixXd::Zero(4 * m, 2 * m);
	
	Eigen::MatrixXd II = Eigen::MatrixXd::Zero(4 * m, 2 * m);
#pragma omp parallel for 
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = offset_cage[4 * i];
		
		for (int j = 0; j < m; j++) {
			
			OpenMesh::Vec2d v1 = Vec322(curvecage2_real[(j - 1 + m) % m][2]);
			OpenMesh::Vec2d v12 = Vec322(curvecage2_real[j][1]);
			OpenMesh::Vec2d v2 = Vec322(curvecage2_real[j][2]);
			std::vector<double> values;
			Cal222BiharmonicBasis_edge( v1, v12, v2, vi, values);

			phiH(i, 0 + j) += values[0]; phiH(i, m + j) = values[1];
			phiBH(i, 0 + j) = values[2]; phiBH(i, m + j) = values[3];
			ksiH(i, 0 + j) += values[4]; ksiH(i, m + j) = values[5];
			ksiBH(i, 0 + j) = values[6]; ksiBH(i, m + j) = values[7];
			dH(i, 0 + j) += values[8]; dH(i, m + j) = values[9];
			eH(i, 0 + j) = values[10]; eH(i, m + j) = values[11];
			//0,4,8是需要加上的
			phiH(i, 0 + (j+1)%m) += values[12];
			ksiH(i, 0 + (j+1)%m) += values[13];
			dH(i, 0 + (j+1)%m) += values[14];
		}
		II(i, i) = 1;
	}
	//在边的1/4采样
#pragma omp parallel for 
	for (int i = 0; i < m; i++) {
		//i = 3;//testtttttttttttttt
		OpenMesh::Vec2d vi = offset_cage[4 * i + 1];
		
		for (int j = 0; j < m; j++) {
			//j = 3;//testttttttttttt
			
			OpenMesh::Vec2d v1 = Vec322(curvecage2_real[(j - 1 + m) % m][2]);
			OpenMesh::Vec2d v12 = Vec322(curvecage2_real[j][1]);
			OpenMesh::Vec2d v2 = Vec322(curvecage2_real[j][2]);
			std::vector<double> values;
			Cal222BiharmonicBasis_edge(v1, v12, v2, vi, values);
			phiH(i + m, 0 + j) += values[0]; phiH(i + m, m + j) = values[1];
			phiBH(i + m, 0 + j) = values[2]; phiBH(i + m, m + j) = values[3];
			ksiH(i + m, 0 + j) += values[4]; ksiH(i + m, m + j) = values[5];
			ksiBH(i + m, 0 + j) = values[6]; ksiBH(i + m, m + j) = values[7];
			dH(i + m, 0 + j) += values[8]; dH(i + m, m + j) = values[9];
			eH(i + m, 0 + j) = values[10]; eH(i + m, m + j) = values[11];
			//0,4,8是需要加上的
			phiH(i+m, 0 + (j + 1) % m) += values[12];
			ksiH(i+m, 0 + (j + 1) % m) += values[13];
			dH(i+m, 0 + (j + 1) % m) += values[14];
		}
		II(i + m, i + m) = 6. / 16;
		II(i + m, i) = 9. / 16;
		II(i + m, (i + 1) % m) = 1. / 16;
	}
	//在边的中间采样
#pragma omp parallel for 
	for (int i = 0; i < m; i++) {
		//i = 3;//testtttttttttttttt
		OpenMesh::Vec2d vi = offset_cage[4 * i + 2];

		for (int j = 0; j < m; j++) {
			//j = 3;//testttttttttttt
			
			OpenMesh::Vec2d v1 = Vec322(curvecage2_real[(j - 1 + m) % m][2]);
			OpenMesh::Vec2d v12 = Vec322(curvecage2_real[j][1]);
			OpenMesh::Vec2d v2 = Vec322(curvecage2_real[j][2]);
			std::vector<double> values;
			Cal222BiharmonicBasis_edge(v1, v12, v2, vi, values);
			phiH(i + 2 * m, 0 + j) += values[0]; phiH(i + 2 * m, m + j) = values[1];
			phiBH(i + 2 * m, 0 + j) = values[2]; phiBH(i + 2 * m, m + j) = values[3];
			ksiH(i + 2 * m, 0 + j) += values[4]; ksiH(i + 2 * m, m + j) = values[5];
			ksiBH(i + 2 * m, 0 + j) = values[6]; ksiBH(i + 2 * m, m + j) = values[7];
			dH(i + 2 * m, 0 + j) += values[8]; dH(i + 2 * m, m + j) = values[9];
			eH(i + 2 * m, 0 + j) = values[10]; eH(i + 2 * m, m + j) = values[11];
			//0,4,8是需要加上的
			phiH(i+2*m, 0 + (j + 1) % m) += values[12];
			ksiH(i+2*m, 0 + (j + 1) % m) += values[13];
			dH(i+2*m, 0 + (j + 1) % m) += values[14];
		}
		II(i + 2 * m, i + m) = 1. / 2;
		II(i + 2 * m, i) = 1. / 4;
		II(i + 2 * m, (i + 1) % m) = 1. / 4;
	}

	//在边的3/4采样
#pragma omp parallel for 
	for (int i = 0; i < m; i++) {
		//i = 3;//testtttttttttttttt
		OpenMesh::Vec2d vi = offset_cage[4 * i + 3];

		for (int j = 0; j < m; j++) {
			//j = 3;//testttttttttttt
			OpenMesh::Vec2d v1 = Vec322(curvecage2_real[(j - 1 + m) % m][2]);
			OpenMesh::Vec2d v12 = Vec322(curvecage2_real[j][1]);
			OpenMesh::Vec2d v2 = Vec322(curvecage2_real[j][2]);
			std::vector<double> values;
			Cal222BiharmonicBasis_edge(v1, v12, v2, vi, values);
			phiH(i + 3 * m, 0 + j) += values[0]; phiH(i + 3 * m, m + j) = values[1];
			phiBH(i + 3 * m, 0 + j) = values[2]; phiBH(i + 3 * m, m + j) = values[3];
			ksiH(i + 3 * m, 0 + j) += values[4]; ksiH(i + 3 * m, m + j) = values[5];
			ksiBH(i + 3 * m, 0 + j) = values[6]; ksiBH(i + 3 * m, m + j) = values[7];
			dH(i + 3 * m, 0 + j) += values[8]; dH(i + 3 * m, m + j) = values[9];
			eH(i + 3 * m, 0 + j) = values[10]; eH(i + 3 * m, m + j) = values[11];
			//0,4,8是需要加上的
			phiH(i+3*m, 0 + (j + 1) % m) += values[12];
			ksiH(i+3*m, 0 + (j + 1) % m) += values[13];
			dH(i+3*m, 0 + (j + 1) % m) += values[14];
		}
		II(i + 3 * m, i + m) = 6. / 16;
		II(i + 3 * m, i) = 1. / 16;
		II(i + 3 * m, (i + 1) % m) = 9. / 16;
	}
	/*std::cout << "phiH" << phiH << std::endl;
	std::cout << "ksiH" << ksiH << std::endl;
	std::cout << "dH" << dH << std::endl;
	exit(0);*/
	/*std::cout << "phiH" << phiH << std::endl;
	std::cout << "phiBH" << phiBH << std::endl;
	std::cout << "ksiH" << ksiH << std::endl;
	std::cout << "ksiBH" << ksiBH << std::endl;*/
	//std::cout << "ksiH-1" << ksiH.inverse() << std::endl;
	auto start_timek = std::chrono::high_resolution_clock::now();
	A = pseudoInverse(eH) * (II - dH);
	//std::cout << "A" << A << std::endl;
	// Calculating matrix D: D = (phiBH + psiBH * A).inverse()
	D = pseudoInverse(ksiH + ksiBH * A);
	//std::cout << "D" << D << std::endl;
	// Calculating matrix B: B = D * (I - phiH)
	B = D * (II - phiH);
	//std::cout << "B" << B << std::endl;
	// Calculating matrix C: C = -D * psiH
	C = -D * phiBH;

	auto end_timek = std::chrono::high_resolution_clock::now();
	auto durationk = std::chrono::duration_cast<std::chrono::milliseconds>(end_timek - start_timek).count();
	std::cout << "求逆时间: " << durationk << " 毫秒" << std::endl;
	//Eigen::MatrixXd f(2 * m, 2);
	//for (int i = 0; i < m; ++i) {
	//	f(i, 0) = curvecage2_real[i][0][0];// linear_cage[i][0];
	//	f(i, 1) = curvecage2_real[i][0][1];//linear_cage[i][1];

	//	f(i + m, 0) = curvecage2_real[i][1][0];//(linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 2;
	//	f(i + m, 1) = curvecage2_real[i][1][1];//(linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 2;
	//}
	//Eigen::MatrixXd d(2 * m, 2);
	//for (int i = 0; i < m; ++i) {
	//	d(i, 0) = curvecage2_real[i][1][1] - curvecage2_real[i][0][1];//(-linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 2;//y
	//	d(i, 1) = -(curvecage2_real[i][1][0] - curvecage2_real[i][0][0]);// -(-linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 2;//-x

	//	d(i + m, 0) = curvecage2_real[i][2][1] - curvecage2_real[i][1][1];//(-linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 2;//y
	//	d(i + m, 1) = -(curvecage2_real[i][2][0] - curvecage2_real[i][1][0]);//-(-linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 2;//-x
	//}
	//std::cout << "f " << f << std::endl;
	//std::cout << "d " << d << std::endl;
	//std::cout << "test1" << (II - phiH) * f - phiBH * d << std::endl;
	//std::cout << "test2" << B * f + C * d << std::endl;
}

void MeshViewerWidget::BH223ConstructMatrix4OffSetVirtual_edge() {
	int m = curvecage2_real.size();
	auto CC_points2dsub = subdivideCage2(CC_points2d);
	auto offset_cage = offsetCage2(CC_points2dsub, 1e-6);
	// 定义四个 m * m 的矩阵 A, B, C, D，元素类型为 double
	A.resize(3 * m, 3 * m); B.resize(3 * m, 3 * m); C.resize(3 * m, 3 * m); D.resize(3 * m, 3 * m);
	Eigen::MatrixXd phiH = Eigen::MatrixXd::Zero(6 * m, 3 * m);
	Eigen::MatrixXd phiBH = Eigen::MatrixXd::Zero(6 * m, 3 * m);
	Eigen::MatrixXd ksiH = Eigen::MatrixXd::Zero(6 * m, 3 * m);
	Eigen::MatrixXd ksiBH = Eigen::MatrixXd::Zero(6 * m, 3 * m);
	Eigen::MatrixXd dH = Eigen::MatrixXd::Zero(6 * m, 3 * m);
	Eigen::MatrixXd eH = Eigen::MatrixXd::Zero(6 * m, 3 * m);

	Eigen::MatrixXd II = Eigen::MatrixXd::Zero(6 * m, 3 * m);

	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = offset_cage[4 * i];
#pragma omp parallel for 
		for (int j = 0; j < m; j++) {

			OpenMesh::Vec2d v1 = Vec322(curvecage2_real[(j - 1 + m) % m][2]);
			OpenMesh::Vec2d v12 = Vec322(curvecage2_real[j][1]);
			OpenMesh::Vec2d v2 = Vec322(curvecage2_real[j][2]);
			std::vector<double> values;
			Cal222BiharmonicBasis_edge(v1, v12, v2, vi, values);

			phiH(i, 0 + j) += values[0]; phiH(i, m + j) = values[1];
			phiBH(i, 0 + j) = values[2]; phiBH(i, m + j) = values[3];
			ksiH(i, 0 + j) += values[4]; ksiH(i, m + j) = values[5];
			ksiBH(i, 0 + j) = values[6]; ksiBH(i, m + j) = values[7];
			dH(i, 0 + j) += values[8]; dH(i, m + j) = values[9];
			eH(i, 0 + j) = values[10]; eH(i, m + j) = values[11];
			//0,4,8是需要加上的
			phiH(i, 0 + (j + 1) % m) += values[12];
			ksiH(i, 0 + (j + 1) % m) += values[13];
			dH(i, 0 + (j + 1) % m) += values[14];
		}
		II(i, i) = 1;
	}
	//在边的1/4采样
	for (int i = 0; i < m; i++) {
		//i = 3;//testtttttttttttttt
		OpenMesh::Vec2d vi = offset_cage[4 * i + 1];
#pragma omp parallel for
		for (int j = 0; j < m; j++) {
			//j = 3;//testttttttttttt

			OpenMesh::Vec2d v1 = Vec322(curvecage2_real[(j - 1 + m) % m][2]);
			OpenMesh::Vec2d v12 = Vec322(curvecage2_real[j][1]);
			OpenMesh::Vec2d v2 = Vec322(curvecage2_real[j][2]);
			std::vector<double> values;
			Cal222BiharmonicBasis_edge(v1, v12, v2, vi, values);
			phiH(i + m, 0 + j) += values[0]; phiH(i + m, m + j) = values[1];
			phiBH(i + m, 0 + j) = values[2]; phiBH(i + m, m + j) = values[3];
			ksiH(i + m, 0 + j) += values[4]; ksiH(i + m, m + j) = values[5];
			ksiBH(i + m, 0 + j) = values[6]; ksiBH(i + m, m + j) = values[7];
			dH(i + m, 0 + j) += values[8]; dH(i + m, m + j) = values[9];
			eH(i + m, 0 + j) = values[10]; eH(i + m, m + j) = values[11];
			//0,4,8是需要加上的
			phiH(i + m, 0 + (j + 1) % m) += values[12];
			ksiH(i + m, 0 + (j + 1) % m) += values[13];
			dH(i + m, 0 + (j + 1) % m) += values[14];
		}
		II(i + m, i + m) = 6. / 16;
		II(i + m, i) = 9. / 16;
		II(i + m, (i + 1) % m) = 1. / 16;
	}
	//在边的中间采样
	for (int i = 0; i < m; i++) {
		//i = 3;//testtttttttttttttt
		OpenMesh::Vec2d vi = offset_cage[4 * i + 2];
#pragma omp parallel for
		for (int j = 0; j < m; j++) {
			//j = 3;//testttttttttttt

			OpenMesh::Vec2d v1 = Vec322(curvecage2_real[(j - 1 + m) % m][2]);
			OpenMesh::Vec2d v12 = Vec322(curvecage2_real[j][1]);
			OpenMesh::Vec2d v2 = Vec322(curvecage2_real[j][2]);
			std::vector<double> values;
			Cal222BiharmonicBasis_edge(v1, v12, v2, vi, values);
			phiH(i + 2 * m, 0 + j) += values[0]; phiH(i + 2 * m, m + j) = values[1];
			phiBH(i + 2 * m, 0 + j) = values[2]; phiBH(i + 2 * m, m + j) = values[3];
			ksiH(i + 2 * m, 0 + j) += values[4]; ksiH(i + 2 * m, m + j) = values[5];
			ksiBH(i + 2 * m, 0 + j) = values[6]; ksiBH(i + 2 * m, m + j) = values[7];
			dH(i + 2 * m, 0 + j) += values[8]; dH(i + 2 * m, m + j) = values[9];
			eH(i + 2 * m, 0 + j) = values[10]; eH(i + 2 * m, m + j) = values[11];
			//0,4,8是需要加上的
			phiH(i + 2 * m, 0 + (j + 1) % m) += values[12];
			ksiH(i + 2 * m, 0 + (j + 1) % m) += values[13];
			dH(i + 2 * m, 0 + (j + 1) % m) += values[14];
		}
		II(i + 2 * m, i + m) = 1. / 2;
		II(i + 2 * m, i) = 1. / 4;
		II(i + 2 * m, (i + 1) % m) = 1. / 4;
	}

	//在边的3/4采样
	for (int i = 0; i < m; i++) {
		//i = 3;//testtttttttttttttt
		OpenMesh::Vec2d vi = offset_cage[4 * i + 3];
#pragma omp parallel for
		for (int j = 0; j < m; j++) {
			//j = 3;//testttttttttttt
			OpenMesh::Vec2d v1 = Vec322(curvecage2_real[(j - 1 + m) % m][2]);
			OpenMesh::Vec2d v12 = Vec322(curvecage2_real[j][1]);
			OpenMesh::Vec2d v2 = Vec322(curvecage2_real[j][2]);
			std::vector<double> values;
			Cal222BiharmonicBasis_edge(v1, v12, v2, vi, values);
			phiH(i + 3 * m, 0 + j) += values[0]; phiH(i + 3 * m, m + j) = values[1];
			phiBH(i + 3 * m, 0 + j) = values[2]; phiBH(i + 3 * m, m + j) = values[3];
			ksiH(i + 3 * m, 0 + j) += values[4]; ksiH(i + 3 * m, m + j) = values[5];
			ksiBH(i + 3 * m, 0 + j) = values[6]; ksiBH(i + 3 * m, m + j) = values[7];
			dH(i + 3 * m, 0 + j) += values[8]; dH(i + 3 * m, m + j) = values[9];
			eH(i + 3 * m, 0 + j) = values[10]; eH(i + 3 * m, m + j) = values[11];
			//0,4,8是需要加上的
			phiH(i + 3 * m, 0 + (j + 1) % m) += values[12];
			ksiH(i + 3 * m, 0 + (j + 1) % m) += values[13];
			dH(i + 3 * m, 0 + (j + 1) % m) += values[14];
		}
		II(i + 3 * m, i + m) = 6. / 16;
		II(i + 3 * m, i) = 1. / 16;
		II(i + 3 * m, (i + 1) % m) = 9. / 16;
	}
	/*std::cout << "phiH" << phiH << std::endl;
	std::cout << "ksiH" << ksiH << std::endl;
	std::cout << "dH" << dH << std::endl;
	exit(0);*/
	/*std::cout << "phiH" << phiH << std::endl;
	std::cout << "phiBH" << phiBH << std::endl;
	std::cout << "ksiH" << ksiH << std::endl;
	std::cout << "ksiBH" << ksiBH << std::endl;*/
	//std::cout << "ksiH-1" << ksiH.inverse() << std::endl;

	A = pseudoInverse(eH) * (II - dH);
	//std::cout << "A" << A << std::endl;
	// Calculating matrix D: D = (phiBH + psiBH * A).inverse()
	D = pseudoInverse(ksiH + ksiBH * A);
	//std::cout << "D" << D << std::endl;
	// Calculating matrix B: B = D * (I - phiH)
	B = D * (II - phiH);
	//std::cout << "B" << B << std::endl;
	// Calculating matrix C: C = -D * psiH
	C = -D * phiBH;

	//Eigen::MatrixXd f(2 * m, 2);
	//for (int i = 0; i < m; ++i) {
	//	f(i, 0) = curvecage2_real[i][0][0];// linear_cage[i][0];
	//	f(i, 1) = curvecage2_real[i][0][1];//linear_cage[i][1];

	//	f(i + m, 0) = curvecage2_real[i][1][0];//(linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 2;
	//	f(i + m, 1) = curvecage2_real[i][1][1];//(linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 2;
	//}
	//Eigen::MatrixXd d(2 * m, 2);
	//for (int i = 0; i < m; ++i) {
	//	d(i, 0) = curvecage2_real[i][1][1] - curvecage2_real[i][0][1];//(-linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 2;//y
	//	d(i, 1) = -(curvecage2_real[i][1][0] - curvecage2_real[i][0][0]);// -(-linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 2;//-x

	//	d(i + m, 0) = curvecage2_real[i][2][1] - curvecage2_real[i][1][1];//(-linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 2;//y
	//	d(i + m, 1) = -(curvecage2_real[i][2][0] - curvecage2_real[i][1][0]);//-(-linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 2;//-x
	//}
	//std::cout << "f " << f << std::endl;
	//std::cout << "d " << d << std::endl;
	//std::cout << "test1" << (II - phiH) * f - phiBH * d << std::endl;
	//std::cout << "test2" << B * f + C * d << std::endl;
}

void MeshViewerWidget::BH3ConstructMatrix4OffSet() {
	int m = curvecage2_real.size();
	auto offset_cage = offsetCage(CC_points2d, 1e-6);
	//auto offset_cage = offsetCage3(CC_points2d, 1e-4);
	// 定义四个 m * m 的矩阵 A, B, C, D，元素类型为 double
	A.resize(3 * m, 3 * m); B.resize(3 * m, 3 * m); C.resize(3 * m, 3 * m); D.resize(3 * m, 3 * m);
	Eigen::MatrixXd phiH(3 * m, 3 * m); Eigen::MatrixXd phiBH(3 * m, 3 * m);
	Eigen::MatrixXd ksiH(3 * m, 3 * m); Eigen::MatrixXd ksiBH(3 * m, 3 * m);
	Eigen::MatrixXd dH(3 * m, 3 * m); Eigen::MatrixXd eH(3 * m, 3 * m);
	Eigen::MatrixXd II = Eigen::MatrixXd::Zero(3 * m, 3 * m);
	
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = offset_cage[3 * i];
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = Vec322(curvecage2_real[(j - 1 + m) % m][0]);
			OpenMesh::Vec2d v01 = Vec322(curvecage2_real[(j - 1 + m) % m][1]);
			OpenMesh::Vec2d v10 = Vec322(curvecage2_real[(j - 1 + m) % m][2]);
			OpenMesh::Vec2d v1 = Vec322(curvecage2_real[(j - 1 + m) % m][3]);
			OpenMesh::Vec2d v12 = Vec322(curvecage2_real[j][1]);
			OpenMesh::Vec2d v21 = Vec322(curvecage2_real[j][2]);
			OpenMesh::Vec2d v2 = Vec322(curvecage2_real[j][3]);
			std::vector<double> values;
			Cal323BiharmonicBasis(v0, v01, v10,v1, v12,v21, v2, vi, values);
			phiH(i, 0 + j) = values[0]; phiH(i, m + j) = values[1]; phiH(i, 2 * m + j) = values[2];
			phiBH(i, 0 + j) = values[3]; phiBH(i, m + j) = values[4]; phiBH(i, 2 * m + j) = values[5];
			ksiH(i, 0 + j) = values[6]; ksiH(i, m + j) = values[7]; ksiH(i, 2 * m + j) = values[8];
			ksiBH(i, 0 + j) = values[9]; ksiBH(i, m + j) = values[10]; ksiBH(i, 2 * m + j) = values[11];
			dH(i, 0 + j) = values[12]; dH(i, m + j) = values[13]; dH(i, 2 * m + j) = values[14];
			eH(i, 0 + j) = values[15]; eH(i, m + j) = values[16]; eH(i, 2 * m + j) = values[17];
		}
		II(i, i) = 1;
		std::cout << vi << std::endl;
		std::cout << curvecage2_real[i][0] << std::endl;
	}
	//在边的1/3采样
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = 8. / 27 * offset_cage[3 * i + 0] + 4. / 9 * offset_cage[3 * i + 1] + 2. / 9 * offset_cage[3 * i + 2] + 1. / 27 * offset_cage[(3 * i + 3) % (3 * m)];
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = Vec322(curvecage2_real[(j - 1 + m) % m][0]);
			OpenMesh::Vec2d v01 = Vec322(curvecage2_real[(j - 1 + m) % m][1]);
			OpenMesh::Vec2d v10 = Vec322(curvecage2_real[(j - 1 + m) % m][2]);
			OpenMesh::Vec2d v1 = Vec322(curvecage2_real[(j - 1 + m) % m][3]);
			OpenMesh::Vec2d v12 = Vec322(curvecage2_real[j][1]);
			OpenMesh::Vec2d v21 = Vec322(curvecage2_real[j][2]);
			OpenMesh::Vec2d v2 = Vec322(curvecage2_real[j][3]);
			std::vector<double> values;
			Cal323BiharmonicBasis(v0, v01, v10, v1, v12, v21, v2, vi, values);
			phiH(i + m, 0 + j) = values[0]; phiH(i + m, m + j) = values[1]; phiH(i + m, 2 * m + j) = values[2];
			phiBH(i + m, 0 + j) = values[3]; phiBH(i + m, m + j) = values[4]; phiBH(i + m, 2 * m + j) = values[5];
			ksiH(i + m, 0 + j) = values[6]; ksiH(i + m, m + j) = values[7]; ksiH(i + m, 2 * m + j) = values[8];
			ksiBH(i + m, 0 + j) = values[9]; ksiBH(i + m, m + j) = values[10]; ksiBH(i + m, 2 * m + j) = values[11];
			dH(i + m, 0 + j) = values[12]; dH(i + m, m + j) = values[13]; dH(i + m, 2 * m + j) = values[14];
			eH(i + m, 0 + j) = values[15]; eH(i + m, m + j) = values[16]; eH(i + m, 2 * m + j) = values[17];
		}
		II(i + m, i) = 8. / 27;
		II(i + m, i + m) = 4. / 9;
		II(i + m, i + 2 * m) = 2. / 9;
		II(i + m, (i + 1) % m) = 1. / 27;
		std::cout << vi << std::endl;
		std::cout << 8. / 27* curvecage2_real[i][0]+ 4. / 9 * curvecage2_real[i][1] +2. / 9 * curvecage2_real[i][2] + 1. / 27 * curvecage2_real[i][3] << std::endl;
	}
	//在边的2/3采样
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = 1. / 27 * offset_cage[3 * i + 0] + 2. / 9 * offset_cage[3 * i + 1] + 4. / 9 * offset_cage[3 * i + 2] + 8. / 27 * offset_cage[(3 * i + 3) % (3 * m)];
		for (int j = 0; j < m; j++) {
			OpenMesh::Vec2d v0 = Vec322(curvecage2_real[(j - 1 + m) % m][0]);
			OpenMesh::Vec2d v01 = Vec322(curvecage2_real[(j - 1 + m) % m][1]);
			OpenMesh::Vec2d v10 = Vec322(curvecage2_real[(j - 1 + m) % m][2]);
			OpenMesh::Vec2d v1 = Vec322(curvecage2_real[(j - 1 + m) % m][3]);
			OpenMesh::Vec2d v12 = Vec322(curvecage2_real[j][1]);
			OpenMesh::Vec2d v21 = Vec322(curvecage2_real[j][2]);
			OpenMesh::Vec2d v2 = Vec322(curvecage2_real[j][3]);
			std::vector<double> values;
			Cal323BiharmonicBasis(v0, v01, v10, v1, v12, v21, v2, vi, values);
			phiH(i + 2 * m, 0 + j) = values[0]; phiH(i + 2 * m, m + j) = values[1]; phiH(i + 2 * m, 2 * m + j) = values[2];
			phiBH(i + 2 * m, 0 + j) = values[3]; phiBH(i + 2 * m, m + j) = values[4]; phiBH(i + 2 * m, 2 * m + j) = values[5];
			ksiH(i + 2 * m, 0 + j) = values[6]; ksiH(i + 2 * m, m + j) = values[7]; ksiH(i + 2 * m, 2 * m + j) = values[8];
			ksiBH(i + 2 * m, 0 + j) = values[9]; ksiBH(i + 2 * m, m + j) = values[10]; ksiBH(i + 2 * m, 2 * m + j) = values[11];
			dH(i + 2 * m, 0 + j) = values[12]; dH(i + 2 * m, m + j) = values[13]; dH(i + 2 * m, 2 * m + j) = values[14];
			eH(i + 2 * m, 0 + j) = values[15]; eH(i + 2 * m, m + j) = values[16]; eH(i + 2 * m, 2 * m + j) = values[17];
		}
		II(i + 2 * m, i) = 1. / 27;
		II(i + 2 * m, i + m) = 2. / 9;
		II(i + 2 * m, i + 2 * m) = 4. / 9;
		II(i + 2 * m, (i + 1) % m) = 8. / 27;
		std::cout << vi << std::endl;
		std::cout << 1. / 27 * curvecage2_real[i][0] + 2. / 9 * curvecage2_real[i][1] + 4. / 9 * curvecage2_real[i][2] + 8. / 27 * curvecage2_real[i][3] << std::endl;
	}

	std::cout << "phiH" << phiH << std::endl;
	std::cout << "phiBH" << phiBH << std::endl;
	std::cout << "ksiH" << ksiH << std::endl;
	std::cout << "ksiBH" << ksiBH << std::endl;
	std::cout << "dH" << dH << std::endl;
	std::cout << "eH" << eH << std::endl;
	std::cout << "II" << II << std::endl;
	
	

	A = (eH.inverse()) * (II - dH);
	std::cout << "A" << A << std::endl;
	// Calculating matrix D: D = (phiBH + psiBH * A).inverse()
	D = (ksiH + ksiBH * A).inverse();
	std::cout << "D" << D << std::endl;
	// Calculating matrix B: B = D * (I - phiH)
	B = D * (II - phiH);
	std::cout << "B" << B << std::endl;
	// Calculating matrix C: C = -D * psiH
	C = -D * phiBH;

	Eigen::MatrixXd f(3 * m, 2);
	for (int i = 0; i < m; ++i) {
		f(i, 0) = curvecage2_real[i][0][0];// linear_cage[i][0];
		f(i, 1) = curvecage2_real[i][0][1];//linear_cage[i][1];

		f(i + m, 0) = curvecage2_real[i][1][0];//(linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 2;
		f(i + m, 1) = curvecage2_real[i][1][1];//(linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 2;

		f(i + 2 * m, 0) = curvecage2_real[i][2][0];
		f(i + 2 * m, 1) = curvecage2_real[i][2][1];
	}
	Eigen::MatrixXd d(3 * m, 2);
	for (int i = 0; i < m; ++i) {
		d(i, 0) = curvecage2_real[i][1][1] - curvecage2_real[i][0][1];//(-linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 2;//y
		d(i, 1) = -(curvecage2_real[i][1][0] - curvecage2_real[i][0][0]);// -(-linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 2;//-x

		d(i + m, 0) = curvecage2_real[i][2][1] - curvecage2_real[i][1][1];//(-linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 2;//y
		d(i + m, 1) = -(curvecage2_real[i][2][0] - curvecage2_real[i][1][0]);//-(-linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 2;//-x

		d(i + 2 * m, 0) = curvecage2_real[i][3][1] - curvecage2_real[i][2][1];
		d(i + 2 * m, 1) = -(curvecage2_real[i][3][0] - curvecage2_real[i][2][0]);
	}
	std::cout << "f " << f << std::endl;
	std::cout << "d " << d << std::endl;
	std::cout << "test1" << (II - phiH) * f - phiBH * d << std::endl;
	std::cout << "test2" << B * f + C * d << std::endl;
}
//增加一倍的采样点，还没写好
void MeshViewerWidget::BH3ConstructMatrix4OffSetVirtual() {
	int m = curvecage2_real.size();
	//auto CC_points2dsub = subdivideCage3(CC_points2d);
	auto offset_cage = offsetCage(CC_points2d, 1e-6);//1e-6
	// 定义四个 m * m 的矩阵 A, B, C, D，元素类型为 double
	A.resize(3 * m, 3 * m); B.resize(3 * m, 3 * m); C.resize(3 * m, 3 * m); D.resize(3 * m, 3 * m);
	Eigen::MatrixXd phiBH(6 * m, 3 * m);
	Eigen::MatrixXd ksiBH(6 * m, 3 * m);
	Eigen::MatrixXd eH(6 * m, 3 * m);
	Eigen::MatrixXd phiH = Eigen::MatrixXd::Zero(6 * m, 3 * m);
	Eigen::MatrixXd ksiH = Eigen::MatrixXd::Zero(6 * m, 3 * m);
	Eigen::MatrixXd dH = Eigen::MatrixXd::Zero(6 * m, 3 * m);
	Eigen::MatrixXd II = Eigen::MatrixXd::Zero(6 * m, 3 * m);
	/*for (auto p : offset_cage) {
		std::cout << p << std::endl;
	}*/
	/*for (int i = 0; i < 6 * m; i++) {
		OpenMesh::Vec2d vi = offset_cage[i];
		if (i % 6 == 0) {
			II(i, i) = 1;
		}
	}*/

	//t=0时计算
#pragma omp parallel for
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = offset_cage[3 * i];

		for (int j = 0; j < m; j++) {

			OpenMesh::Vec2d v1 = Vec322(curvecage2_real[(j - 1 + m) % m][3]);
			OpenMesh::Vec2d v12 = Vec322(curvecage2_real[j][1]);
			OpenMesh::Vec2d v21 = Vec322(curvecage2_real[j][2]);
			OpenMesh::Vec2d v2 = Vec322(curvecage2_real[j][3]);
			std::vector<double> values;
			Cal323BiharmonicBasis_edge( v1, v12, v21, v2, vi, values);
			phiH(i, 0 + j) += values[0]; phiH(i, m + j) = values[1]; phiH(i, 2 * m + j) = values[2];
			phiBH(i, 0 + j) = values[3]; phiBH(i, m + j) = values[4]; phiBH(i, 2 * m + j) = values[5];
			ksiH(i, 0 + j) += values[6]; ksiH(i, m + j) = values[7]; ksiH(i, 2 * m + j) = values[8];
			ksiBH(i, 0 + j) = values[9]; ksiBH(i, m + j) = values[10]; ksiBH(i, 2 * m + j) = values[11];
			dH(i, 0 + j) += values[12]; dH(i, m + j) = values[13]; dH(i, 2 * m + j) = values[14];
			eH(i, 0 + j) = values[15]; eH(i, m + j) = values[16]; eH(i, 2 * m + j) = values[17];
			//0,6,12
			phiH(i, (j + 1) % m) += values[18];
			ksiH(i, (j + 1) % m) += values[19];
			dH(i, (j + 1) % m) += values[20];
		}
		II(i, i) = 1;
		/*std::cout << vi << std::endl;
		std::cout << curvecage2_real[i][0] << std::endl;*/
	}
	//在边的1/3采样
#pragma omp parallel for
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = 8. / 27 * offset_cage[3 * i] + 4. / 9 * offset_cage[3 * i + 1] + 2. / 9 * offset_cage[3 * i + 2] + 1. / 27 * offset_cage[(3 * i + 3) % (3 * m)];

		for (int j = 0; j < m; j++) {
			
			OpenMesh::Vec2d v1 = Vec322(curvecage2_real[(j - 1 + m) % m][3]);
			OpenMesh::Vec2d v12 = Vec322(curvecage2_real[j][1]);
			OpenMesh::Vec2d v21 = Vec322(curvecage2_real[j][2]);
			OpenMesh::Vec2d v2 = Vec322(curvecage2_real[j][3]);
			std::vector<double> values;
			Cal323BiharmonicBasis_edge(v1, v12, v21, v2, vi, values);
			phiH(i + m, 0 + j) += values[0]; phiH(i + m, m + j) = values[1]; phiH(i + m, 2 * m + j) = values[2];
			phiBH(i + m, 0 + j) = values[3]; phiBH(i + m, m + j) = values[4]; phiBH(i + m, 2 * m + j) = values[5];
			ksiH(i + m, 0 + j) += values[6]; ksiH(i + m, m + j) = values[7]; ksiH(i + m, 2 * m + j) = values[8];
			ksiBH(i + m, 0 + j) = values[9]; ksiBH(i + m, m + j) = values[10]; ksiBH(i + m, 2 * m + j) = values[11];
			dH(i + m, 0 + j) += values[12]; dH(i + m, m + j) = values[13]; dH(i + m, 2 * m + j) = values[14];
			eH(i + m, 0 + j) = values[15]; eH(i + m, m + j) = values[16]; eH(i + m, 2 * m + j) = values[17];
			//0,6,12
			phiH(i + m, (j + 1) % m) += values[18];
			ksiH(i + m, (j + 1) % m) += values[19];
			dH(i + m, (j + 1) % m) += values[20];
		}
		II(i + m, i) = 8. / 27;
		II(i + m, i + m) = 4. / 9;
		II(i + m, i + 2 * m) = 2. / 9;
		II(i + m, (i + 1) % m) = 1. / 27;
		//std::cout << vi << std::endl;
		//std::cout << 8. / 27 * curvecage2_real[i][0] + 4. / 9 * curvecage2_real[i][1] + 2. / 9 * curvecage2_real[i][2] + 1. / 27 * curvecage2_real[i][3] << std::endl;
	}
	//在边的2/3采样
#pragma omp parallel for
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = 1. / 27 * offset_cage[3 * i] + 2. / 9 * offset_cage[3 * i + 1] + 4. / 9 * offset_cage[3 * i + 2] + 8. / 27 * offset_cage[(3 * i + 3) % (3 * m)];

		for (int j = 0; j < m; j++) {
			
			OpenMesh::Vec2d v1 = Vec322(curvecage2_real[(j - 1 + m) % m][3]);
			OpenMesh::Vec2d v12 = Vec322(curvecage2_real[j][1]);
			OpenMesh::Vec2d v21 = Vec322(curvecage2_real[j][2]);
			OpenMesh::Vec2d v2 = Vec322(curvecage2_real[j][3]);
			std::vector<double> values;
			Cal323BiharmonicBasis_edge(v1, v12, v21, v2, vi, values);
			phiH(i + 2 * m, 0 + j) += values[0]; phiH(i + 2 * m, m + j) = values[1]; phiH(i + 2 * m, 2 * m + j) = values[2];
			phiBH(i + 2 * m, 0 + j) = values[3]; phiBH(i + 2 * m, m + j) = values[4]; phiBH(i + 2 * m, 2 * m + j) = values[5];
			ksiH(i + 2 * m, 0 + j) += values[6]; ksiH(i + 2 * m, m + j) = values[7]; ksiH(i + 2 * m, 2 * m + j) = values[8];
			ksiBH(i + 2 * m, 0 + j) = values[9]; ksiBH(i + 2 * m, m + j) = values[10]; ksiBH(i + 2 * m, 2 * m + j) = values[11];
			dH(i + 2 * m, 0 + j) += values[12]; dH(i + 2 * m, m + j) = values[13]; dH(i + 2 * m, 2 * m + j) = values[14];
			eH(i + 2 * m, 0 + j) = values[15]; eH(i + 2 * m, m + j) = values[16]; eH(i + 2 * m, 2 * m + j) = values[17];
			//0,6,12
			phiH(i +2* m, (j + 1) % m) += values[18];
			ksiH(i +2* m, (j + 1) % m) += values[19];
			dH(i +2* m, (j + 1) % m) += values[20];
		}
		II(i + 2 * m, i) = 1. / 27;
		II(i + 2 * m, i + m) = 2. / 9;
		II(i + 2 * m, i + 2 * m) = 4. / 9;
		II(i + 2 * m, (i + 1) % m) = 8. / 27;
		//std::cout << vi << std::endl;
		//std::cout << 1. / 27 * curvecage2_real[i][0] + 2. / 9 * curvecage2_real[i][1] + 4. / 9 * curvecage2_real[i][2] + 8. / 27 * curvecage2_real[i][3] << std::endl;
	}
	//在边的1/6采样
#pragma omp parallel for
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = 125. / 216 * offset_cage[3 * i] + 25. / 72 * offset_cage[3 * i + 1] + 5. / 72 * offset_cage[3 * i + 2] + 1. / 216 * offset_cage[(3 * i + 3) % (3 * m)];
		for (int j = 0; j < m; j++) {
			
			OpenMesh::Vec2d v1 = Vec322(curvecage2_real[(j - 1 + m) % m][3]);
			OpenMesh::Vec2d v12 = Vec322(curvecage2_real[j][1]);
			OpenMesh::Vec2d v21 = Vec322(curvecage2_real[j][2]);
			OpenMesh::Vec2d v2 = Vec322(curvecage2_real[j][3]);
			std::vector<double> values;
			Cal323BiharmonicBasis_edge(v1, v12, v21, v2, vi, values);
			phiH(i + 3 * m, 0 + j) += values[0]; phiH(i + 3 * m, m + j) = values[1]; phiH(i + 3 * m, 2 * m + j) = values[2];
			phiBH(i + 3 * m, 0 + j) = values[3]; phiBH(i + 3 * m, m + j) = values[4]; phiBH(i + 3 * m, 2 * m + j) = values[5];
			ksiH(i + 3 * m, 0 + j) += values[6]; ksiH(i + 3 * m, m + j) = values[7]; ksiH(i + 3 * m, 2 * m + j) = values[8];
			ksiBH(i + 3 * m, 0 + j) = values[9]; ksiBH(i + 3 * m, m + j) = values[10]; ksiBH(i + 3 * m, 2 * m + j) = values[11];
			dH(i + 3 * m, 0 + j) += values[12]; dH(i + 3 * m, m + j) = values[13]; dH(i + 3 * m, 2 * m + j) = values[14];
			eH(i + 3 * m, 0 + j) = values[15]; eH(i + 3 * m, m + j) = values[16]; eH(i + 3 * m, 2 * m + j) = values[17];
			//0,6,12
			phiH(i + 3 * m, (j + 1) % m) += values[18];
			ksiH(i + 3 * m, (j + 1) % m) += values[19];
			dH(i + 3 * m, (j + 1) % m) += values[20];
		}
		II(i + 3 * m, i) = 125. / 216;
		II(i + 3 * m, i + m) = 25. / 72;
		II(i + 3 * m, i + 2 * m) = 5. / 72;
		II(i + 3 * m, (i + 1) % m) = 1. / 216;
	}

	//在边的1/2采样
#pragma omp parallel for
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = 1. / 8 * offset_cage[3 * i] + 3. / 8 * offset_cage[3 * i + 1] + 3. / 8 * offset_cage[3 * i + 2] + 1. / 8 * offset_cage[(3 * i + 3) % (3 * m)];

		for (int j = 0; j < m; j++) {
			
			OpenMesh::Vec2d v1 = Vec322(curvecage2_real[(j - 1 + m) % m][3]);
			OpenMesh::Vec2d v12 = Vec322(curvecage2_real[j][1]);
			OpenMesh::Vec2d v21 = Vec322(curvecage2_real[j][2]);
			OpenMesh::Vec2d v2 = Vec322(curvecage2_real[j][3]);
			std::vector<double> values;
			Cal323BiharmonicBasis_edge(v1, v12, v21, v2, vi, values);
			phiH(i + 4 * m, 0 + j) += values[0]; phiH(i + 4 * m, m + j) = values[1]; phiH(i + 4 * m, 2 * m + j) = values[2];
			phiBH(i + 4 * m, 0 + j) = values[3]; phiBH(i + 4 * m, m + j) = values[4]; phiBH(i + 4 * m, 2 * m + j) = values[5];
			ksiH(i + 4 * m, 0 + j) += values[6]; ksiH(i + 4 * m, m + j) = values[7]; ksiH(i + 4 * m, 2 * m + j) = values[8];
			ksiBH(i + 4 * m, 0 + j) = values[9]; ksiBH(i + 4 * m, m + j) = values[10]; ksiBH(i + 4 * m, 2 * m + j) = values[11];
			dH(i + 4 * m, 0 + j) += values[12]; dH(i + 4 * m, m + j) = values[13]; dH(i + 4 * m, 2 * m + j) = values[14];
			eH(i + 4 * m, 0 + j) = values[15]; eH(i + 4 * m, m + j) = values[16]; eH(i + 4 * m, 2 * m + j) = values[17];
			//0,6,12
			phiH(i + 4 * m, (j + 1) % m) += values[18];
			ksiH(i + 4 * m, (j + 1) % m) += values[19];
			dH(i + 4 * m, (j + 1) % m) += values[20];
		}
		II(i + 4 * m, i) = 1. / 8;
		II(i + 4 * m, i + m) = 3. / 8;
		II(i + 4 * m, i + 2 * m) = 3. / 8;
		II(i + 4 * m, (i + 1) % m) = 1. / 8;
	}

	//在边的5/6采样
#pragma omp parallel for
	for (int i = 0; i < m; i++) {
		OpenMesh::Vec2d vi = 1. / 216 * offset_cage[3 * i] + 5. / 72 * offset_cage[3 * i + 1] + 25. / 72 * offset_cage[3 * i + 2] + 125. / 216 * offset_cage[(3 * i + 3) % (3 * m)];

		for (int j = 0; j < m; j++) {
			
			OpenMesh::Vec2d v1 = Vec322(curvecage2_real[(j - 1 + m) % m][3]);
			OpenMesh::Vec2d v12 = Vec322(curvecage2_real[j][1]);
			OpenMesh::Vec2d v21 = Vec322(curvecage2_real[j][2]);
			OpenMesh::Vec2d v2 = Vec322(curvecage2_real[j][3]);
			std::vector<double> values;
			Cal323BiharmonicBasis_edge(v1, v12, v21, v2, vi, values);
			phiH(i + 5 * m, 0 + j) += values[0]; phiH(i + 5 * m, m + j) = values[1]; phiH(i + 5 * m, 2 * m + j) = values[2];
			phiBH(i + 5 * m, 0 + j) = values[3]; phiBH(i + 5 * m, m + j) = values[4]; phiBH(i + 5 * m, 2 * m + j) = values[5];
			ksiH(i + 5 * m, 0 + j) += values[6]; ksiH(i + 5 * m, m + j) = values[7]; ksiH(i + 5 * m, 2 * m + j) = values[8];
			ksiBH(i + 5 * m, 0 + j) = values[9]; ksiBH(i + 5 * m, m + j) = values[10]; ksiBH(i + 5 * m, 2 * m + j) = values[11];
			dH(i + 5 * m, 0 + j) += values[12]; dH(i + 5 * m, m + j) = values[13]; dH(i + 5 * m, 2 * m + j) = values[14];
			eH(i + 5 * m, 0 + j) = values[15]; eH(i + 5 * m, m + j) = values[16]; eH(i + 5 * m, 2 * m + j) = values[17];
			//0,6,12
			phiH(i + 5 * m, (j + 1) % m) += values[18];
			ksiH(i + 5 * m, (j + 1) % m) += values[19];
			dH(i + 5 * m, (j + 1) % m) += values[20];
		}
		II(i + 5 * m, i) = 1. / 216;
		II(i + 5 * m, i + m) = 5. / 72;
		II(i + 5 * m, i + 2 * m) = 25. / 72;
		II(i + 5 * m, (i + 1) % m) = 125. / 216;
	}

	/*std::cout << "phiH" << phiH << std::endl;
	std::cout << "phiBH" << phiBH << std::endl;
	std::cout << "ksiH" << ksiH << std::endl;
	std::cout << "ksiBH" << ksiBH << std::endl;
	std::cout << "dH" << dH << std::endl;
	std::cout << "eH" << eH << std::endl;
	std::cout << "II" << II << std::endl;*/

	auto start_timek = std::chrono::high_resolution_clock::now();
	

	A = (pseudoInverse(eH)) * (II - dH);
	//std::cout << "A" << A << std::endl;
	// Calculating matrix D: D = (phiBH + psiBH * A).inverse()
	D = pseudoInverse(ksiH + ksiBH * A);
	//std::cout << "D" << D << std::endl;
	// Calculating matrix B: B = D * (I - phiH)
	B = D * (II - phiH);
	//std::cout << "B" << B << std::endl;
	// Calculating matrix C: C = -D * psiH
	C = -D * phiBH;

	auto end_timek = std::chrono::high_resolution_clock::now();
	auto durationk = std::chrono::duration_cast<std::chrono::milliseconds>(end_timek - start_timek).count();
	std::cout << "矩阵计算、求逆时间: " << durationk << " 毫秒" << std::endl;
	//Eigen::MatrixXd f(3 * m, 2);
	//for (int i = 0; i < m; ++i) {
	//	f(i, 0) = curvecage2_real[i][0][0];// linear_cage[i][0];
	//	f(i, 1) = curvecage2_real[i][0][1];//linear_cage[i][1];

	//	f(i + m, 0) = curvecage2_real[i][1][0];//(linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 2;
	//	f(i + m, 1) = curvecage2_real[i][1][1];//(linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 2;

	//	f(i + 2 * m, 0) = curvecage2_real[i][2][0];
	//	f(i + 2 * m, 1) = curvecage2_real[i][2][1];
	//}
	//Eigen::MatrixXd d(3 * m, 2);
	//for (int i = 0; i < m; ++i) {
	//	d(i, 0) = curvecage2_real[i][1][1] - curvecage2_real[i][0][1];//(-linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 2;//y
	//	d(i, 1) = -(curvecage2_real[i][1][0] - curvecage2_real[i][0][0]);// -(-linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 2;//-x

	//	d(i + m, 0) = curvecage2_real[i][2][1] - curvecage2_real[i][1][1];//(-linear_cage[i][1] + linear_cage[(i + 1) % m][1]) / 2;//y
	//	d(i + m, 1) = -(curvecage2_real[i][2][0] - curvecage2_real[i][1][0]);//-(-linear_cage[i][0] + linear_cage[(i + 1) % m][0]) / 2;//-x

	//	d(i + 2 * m, 0) = curvecage2_real[i][3][1] - curvecage2_real[i][2][1];
	//	d(i + 2 * m, 1) = -(curvecage2_real[i][3][0] - curvecage2_real[i][2][0]);
	//}
	//std::cout << "f " << f << std::endl;
	//std::cout << "d " << d << std::endl;
	//std::cout << "test1" << (II - phiH) * f - phiBH * d << std::endl;
	//std::cout << "test2" << B * f + C * d << std::endl;
}

bool MeshViewerWidget::NearestCageVertex(OpenMesh::Vec3d objCor, OpenMesh::VertexHandle& minVh)
{
	//cal平均边长的一半
	double totalLength = 0.0;
	size_t numEdges = 0;
	// 获取所有顶点句柄
	std::vector<Mesh::VertexHandle> vhandles;
	for (const auto& vh : CC_mesh.vertices()) {
		vhandles.push_back(vh);
	}

	// 按顺序计算相邻顶点之间的距离
	for (size_t i = 0; i < vhandles.size(); ++i) {
		auto vh0 = vhandles[i];
		auto vh1 = vhandles[(i + 1) % vhandles.size()];  // 循环连接最后一个顶点和第一个顶点

		// 获取两个顶点的位置
		Mesh::Point p0 = CC_mesh.point(vh0);
		Mesh::Point p1 = CC_mesh.point(vh1);

		// 计算欧几里得距离
		double length = std::sqrt(
			std::pow(p1[0] - p0[0], 2) +
			std::pow(p1[1] - p0[1], 2) +
			std::pow(p1[2] - p0[2], 2)
		);

		totalLength += length;
		numEdges++;
	}

	double maxAllowedDis = totalLength/ numEdges * 0.5;
	double minDis = INFINITY;
	OpenMesh::VertexHandle mv;
	if (!useHandle) {
		for (auto vh : CC_mesh.vertices())
		{
			auto vp = CC_mesh.point(vh);
			double dis = (objCor - vp).norm();
			if (dis < minDis)
			{
				minDis = dis;
				mv = vh;
			}
		}
	}
	else {
		for (auto vh : Handle_mesh.vertices())
		{
			auto vp = Handle_mesh.point(vh);
			double dis = (objCor - vp).norm();
			/*if (dis < minDis && vh.idx() % 2 != 0)
			{
				minDis = dis;
				mv = vh;
			}*/
			if (dis < minDis )
			{
				minDis = dis;
				mv = vh;
			}
		}
	}
	//std::cout << minDis << "," << maxAllowedDis << endl;
	if (minDis <= maxAllowedDis)
	{
		minVh = mv;
		return true;
	}
	else
	{
		return false;
	}
}

bool MeshViewerWidget::NearestCageVertex(OpenMesh::Vec3d objCor, Mesh CC_meshX, OpenMesh::VertexHandle& minVh)
{
	minVh = OpenMesh::VertexHandle();
	//cal平均边长的一半
	double totalLength = 0.0;
	size_t numEdges = 0;
	// 获取所有顶点句柄
	std::vector<Mesh::VertexHandle> vhandles;
	for (const auto& vh : CC_meshX.vertices()) {
		vhandles.push_back(vh);
	}

	// 按顺序计算相邻顶点之间的距离
	for (size_t i = 0; i < vhandles.size(); ++i) {
		auto vh0 = vhandles[i];
		auto vh1 = vhandles[(i + 1) % vhandles.size()];  // 循环连接最后一个顶点和第一个顶点

		// 获取两个顶点的位置
		Mesh::Point p0 = CC_meshX.point(vh0);
		Mesh::Point p1 = CC_meshX.point(vh1);

		// 计算欧几里得距离
		double length = std::sqrt(
			std::pow(p1[0] - p0[0], 2) +
			std::pow(p1[1] - p0[1], 2) +
			std::pow(p1[2] - p0[2], 2)
		);

		totalLength += length;
		numEdges++;
	}

	double maxAllowedDis = totalLength / numEdges * 0.5;
	double minDis = INFINITY;
	OpenMesh::VertexHandle mv;
	if (!useHandle) {
		for (auto vh : CC_meshX.vertices())
		{
			auto vp = CC_meshX.point(vh);
			double dis = (objCor - vp).norm();
			if (dis < minDis)
			{
				minDis = dis;
				mv = vh;
			}
		}
	}
	else {
		for (auto vh : Handle_mesh.vertices())
		{
			auto vp = Handle_mesh.point(vh);
			double dis = (objCor - vp).norm();
			/*if (dis < minDis && vh.idx() % 2 != 0)
			{
				minDis = dis;
				mv = vh;
			}*/
			if (dis < minDis)
			{
				minDis = dis;
				mv = vh;
			}
		}
	}
	std::cout << minDis << "," << maxAllowedDis << endl;
	if (minDis <= maxAllowedDis)
	{
		minVh = mv;
		return true;
	}
	else
	{
		return false;
	}
}

//将1次bezier曲线的控制点转为多项式基的控制点
template <typename VecType>
void MeshViewerWidget::Bezier1Poly1(std::vector<std::vector<VecType>> curvecage2, std::vector<std::vector<VecType>>& curvecage2poly)
{
	curvecage2poly = curvecage2;
	for (int i = 0; i < curvecage2.size(); i++)
	{
		const VecType& P0 = curvecage2[i][0];
		const VecType& P1 = curvecage2[i][1];
		

		VecType a0 = P0;
		VecType a1 =(P1 - P0);
		

		curvecage2poly[i][0] = a0;
		curvecage2poly[i][1] = a1;
	}
}

//将2次bezier曲线的控制点转为多项式基的控制点
template <typename VecType>
void MeshViewerWidget::Bezier2Poly2(std::vector<std::vector<VecType>> curvecage2, std::vector<std::vector<VecType>>& curvecage2poly)
{
	curvecage2poly = curvecage2;
	for (int i = 0; i < curvecage2.size(); i++)
	{
		const VecType& P0 = curvecage2[i][0];
		const VecType& P1 = curvecage2[i][1];
		const VecType& P2 = curvecage2[i][2];

		VecType a0 = P0;
		VecType a1 = 2 * (P1 - P0);
		VecType a2 = P2 - 2 * P1 + P0;

		curvecage2poly[i][0] = a0;
		curvecage2poly[i][1] = a1;
		curvecage2poly[i][2] = a2;
	}
}

void MeshViewerWidget::Bezier2Poly2(myArray<3> curvecage2, myArray<3>& curvecage2poly)
{
	curvecage2poly = curvecage2;

	double P0 = curvecage2[0];
	double P1 = curvecage2[1];
	double P2 = curvecage2[2];

	double a0 = P0;
	double a1 = 2 * (P1 - P0);
	double a2 = P2 - 2 * P1 + P0;

	curvecage2poly[0] = a0;
	curvecage2poly[1] = a1;
	curvecage2poly[2] = a2;

}

//将3次bezier曲线的控制点转为多项式基的控制点
template <typename VecType>
void MeshViewerWidget::Bezier2Poly3(std::vector<std::vector<VecType>> curvecage2, std::vector<std::vector<VecType>>& curvecage2poly)
{
	curvecage2poly = curvecage2;
	for (int i = 0; i < curvecage2.size(); i++)
	{
		const VecType& P0 = curvecage2[i][0];
		const VecType& P1 = curvecage2[i][1];
		const VecType& P2 = curvecage2[i][2];
		const VecType& P3 = curvecage2[i][3];

		VecType a0 = P0;
		VecType a1 = 3 * (P1 - P0);
		VecType a2 = 3 * (P2 - 2 * P1 + P0);
		VecType a3 = P3 - 3 * P2 + 3 * P1 - P0;

		curvecage2poly[i][0] = a0;
		curvecage2poly[i][1] = a1;
		curvecage2poly[i][2] = a2;
		curvecage2poly[i][3] = a3;
	}
}


//将3次bezier曲线的控制点转为7次bezier的控制点,用于可视化
template <typename VecType>
void MeshViewerWidget::Bezier2Bezier7(std::vector<std::vector<VecType>> curvecage2, std::vector<std::vector<VecType>>& curvecage7)
{
	int n = 3, m = 7;
	curvecage7.resize(curvecage2.size());
	auto curvecage = curvecage2;
	auto shengjie = [](std::vector<VecType> points, std::vector<VecType> &points1) -> void {
		int n = points.size() - 1;
		points1.resize(points.size() + 1);
		points1[0] = points[0];
		points1[points.size()] = points[points.size() - 1];
		for (int i = 1; i < points.size(); i++)
		{
			points1[i] = (double)i / (n + 1.) * points[i - 1] + (1. - (double)i / (n + 1)) * points[i];
		}
	};
	for (int seg_i = 0; seg_i < curvecage2.size(); seg_i++) {
		for (int i = 0; i < m - n; i++)
		{
			shengjie(curvecage[seg_i], curvecage7[seg_i]);
			curvecage[seg_i] = curvecage7[seg_i];
		}
	}
	
}

//将2次bezier曲线的控制点转为1次bezier的控制点,用于可视化
template <typename VecType>
void MeshViewerWidget::Bezier2Bezier221(std::vector<std::vector<VecType>> curvecage2, std::vector<std::vector<VecType>>& curvecage1)
{
	curvecage1.clear();
	curvecage1.resize(curvecage2.size());
	for (int seg_i = 0; seg_i < curvecage2.size(); seg_i++) {
		curvecage1[seg_i].push_back(curvecage2[seg_i][0]);
		curvecage1[seg_i].push_back(curvecage2[seg_i][2]);
	}

}
//将3次bezier曲线的控制点转为1次bezier的控制点,用于可视化
template <typename VecType>
void MeshViewerWidget::Bezier2Bezier321(std::vector<std::vector<VecType>> curvecage2, std::vector<std::vector<VecType>>& curvecage1)
{
	curvecage1.clear();
	curvecage1.resize(curvecage2.size());
	for (int seg_i = 0; seg_i < curvecage2.size(); seg_i++) {
		curvecage1[seg_i].push_back(curvecage2[seg_i][0]);
		curvecage1[seg_i].push_back(curvecage2[seg_i][3]);
	}

}

//将3次bezier曲线的控制点转为2次bezier的控制点,用于可视化
template <typename VecType>
void MeshViewerWidget::Bezier2Bezier322(std::vector<std::vector<VecType>> curvecage2, std::vector<std::vector<VecType>>& curvecage1)
{
	curvecage1.clear();
	curvecage1.resize(curvecage2.size());
	for (int seg_i = 0; seg_i < curvecage2.size(); seg_i++) {
		curvecage1[seg_i].push_back(curvecage2[seg_i][0]);
		curvecage1[seg_i].push_back((curvecage2[seg_i][1] + curvecage2[seg_i][2]) / 2);
		curvecage1[seg_i].push_back(curvecage2[seg_i][3]);
	}

}

//将2次bezier曲线的控制点转为3次bezier的控制点,用于可视化
template <typename VecType>
void MeshViewerWidget::Bezier2Bezier223(std::vector<std::vector<VecType>> curvecage2, std::vector<std::vector<VecType>>& curvecage3)
{
	int n = 2, m = 3;
	curvecage3.resize(curvecage2.size());
	auto curvecage = curvecage2;
	auto shengjie = [](std::vector<VecType> points, std::vector<VecType>& points1) -> void {
		int n = points.size() - 1;
		points1.resize(points.size() + 1);
		points1[0] = points[0];
		points1[points.size()] = points[points.size() - 1];
		for (int i = 1; i < points.size(); i++)
		{
			points1[i] = (double)i / (n + 1.) * points[i - 1] + (1. - (double)i / (n + 1)) * points[i];
		}
	};
	for (int seg_i = 0; seg_i < curvecage2.size(); seg_i++) {
		for (int i = 0; i < m - n; i++)
		{
			shengjie(curvecage[seg_i], curvecage3[seg_i]);
			curvecage[seg_i] = curvecage3[seg_i];
		}
	}

}

//将2次bezier曲线的控制点转为7次bezier的控制点,用于可视化
template <typename VecType>
void MeshViewerWidget::Bezier2Bezier227(std::vector<std::vector<VecType>> curvecage2, std::vector<std::vector<VecType>>& curvecage3)
{
	int n = 2, m = 7;
	curvecage3.resize(curvecage2.size());
	auto curvecage = curvecage2;
	auto shengjie = [](std::vector<VecType> points, std::vector<VecType>& points1) -> void {
		int n = points.size() - 1;
		points1.resize(points.size() + 1);
		points1[0] = points[0];
		points1[points.size()] = points[points.size() - 1];
		for (int i = 1; i < points.size(); i++)
		{
			points1[i] = (double)i / (n + 1.) * points[i - 1] + (1. - (double)i / (n + 1)) * points[i];
		}
	};
	for (int seg_i = 0; seg_i < curvecage2.size(); seg_i++) {
		for (int i = 0; i < m - n; i++)
		{
			shengjie(curvecage[seg_i], curvecage3[seg_i]);
			curvecage[seg_i] = curvecage3[seg_i];
		}
	}

}


//将7次bezier曲线的控制点转为多项式基的控制点
template <typename VecType>
void MeshViewerWidget::Bezier2Poly7(std::vector<std::vector<VecType>> curvecage7, std::vector<std::vector<VecType>>& curvecage7poly)
{
	int degree = 7;
	curvecage7poly.resize(curvecage7.size());
	// Precompute binomial coefficients
	std::vector<std::vector<double>> binomials(degree + 1, std::vector<double>(degree + 1, 0));
	for (int n = 0; n <= degree; ++n) {
		binomials[n][0] = 1;
		for (int k = 1; k <= n; ++k) {
			binomials[n][k] = binomials[n - 1][k - 1] + binomials[n - 1][k];
		}
	}

	for (int c = 0; c < curvecage7.size(); ++c) {
		std::vector<VecType> poly(degree + 1, { 0, 0, 0 });
		// Calculate polynomial coefficients
		for (int k = 0; k <= degree; ++k) {
			VecType sum = { 0, 0, 0 };
			for (int i = 0; i <= degree; ++i) {
				for (int j = 0; j <= degree - i; ++j) {
					if (i + j == k) {
						double coeff = binomials[degree][i] * binomials[degree - i][j] * (j % 2 == 0 ? 1 : -1);
						sum = sum + curvecage7[c][i] * coeff;
					}
				}
			}
			poly[k] = sum;
		}
		curvecage7poly[c] = poly;
	}
}

//2到2的权重计算,次数m=2
void MeshViewerWidget::calculate_green_weight222(void)
{
	assert(degree == 2);
	auto arthono = [](const Mesh::Point& p) -> Mesh::Point {
		return Mesh::Point(p[1], -p[0], p[2]);
	};
	
	weights.resize(mesh.n_vertices());
	for (auto& weight : weights) {
		weight.resize(curvecage2.size()*(2*degree+1));//使用论文中的每段曲线使用幂基来计算
	}
	auto poly_Ctps = curvecage2;
	Bezier2Poly2(curvecage2, poly_Ctps);
	double max_err=0;
	for (int v_id = 0; v_id < mesh.n_vertices(); v_id++) {//v_id表示mesh中的点数
		auto vh = mesh.vertex_handle(v_id);
		Mesh::Point eta = mesh.point(vh);
		//Mesh::Point eta(0, 0, 0);
		Mesh::Point test_eta(0, 0, 0);//check equality
		for (int i = 0; i < curvecage2.size(); i++)
		{//i表示边界曲线的段数
			auto poly_Ctp = poly_Ctps[i];//每一段曲线，原来的poly_ctp
			auto c0 = poly_Ctp[0]; auto c1 = poly_Ctp[1]; auto c2 = poly_Ctp[2];
			double F0,F1,F2, F3, F4, F5;
			F0 = F2_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], 0);
			F1 = F2_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], 1);
			F2 = F2_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], 2);
			F3 = F2_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], 3);
			F4 = F2_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], 4);
			F5 = F2_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], 5);
			weights[v_id][5 * i + 0] = (c0 - eta).dot(arthono(c1)) * F0 + 2 * (c0 - eta).dot(arthono(c2)) * F1 + (c1).dot(arthono(c2)) * F2;
			weights[v_id][5 * i + 1] = (c0 - eta).dot(arthono(c1)) * F1 + 2 * (c0 - eta).dot(arthono(c2)) * F2 + (c1).dot(arthono(c2)) * F3;
			weights[v_id][5 * i + 2] = (c0 - eta).dot(arthono(c1)) * F2 + 2 * (c0 - eta).dot(arthono(c2)) * F3 + (c1).dot(arthono(c2)) * F4;
			weights[v_id][5 * i + 3] = (c0 - eta).dot(c1) * F1 + (c1.dot(c1) + 2 * (c0 - eta).dot(c2)) * F2 + 3 * (c1).dot(c2) * F3 + 2 * c2.dot(c2) * F4 - log(norm(c0 + c1 + c2 - eta)) / (2 * M_PI);
			weights[v_id][5 * i + 4] = (c0 - eta).dot(c1) * F2 + (c1.dot(c1) + 2 * (c0 - eta).dot(c2)) * F3 + 3 * (c1).dot(c2) * F4 + 2 * c2.dot(c2) * F5 - log(norm(c0 + c1 + c2 - eta)) / (2 * M_PI);
			test_eta += weights[v_id][5 * i + 0] * poly_Ctp[0];
			test_eta += weights[v_id][5 * i + 1] * poly_Ctp[1];
			test_eta += weights[v_id][5 * i + 2] * poly_Ctp[2];
			test_eta += weights[v_id][5 * i + 3] * arthono(poly_Ctp[1]);
			test_eta += weights[v_id][5 * i + 4] * arthono(poly_Ctp[2]);
		}
		//check
		/*std::cout << F2_n(Mesh::Point{ 0,0,0 }, Mesh::Point{ 1,0,0 }, Mesh::Point{ 0,1,0 }, Mesh::Point{ -0.5,1,0 }, 0) << std::endl;
		std::cout << F2_n(Mesh::Point{ 0,0,0 }, Mesh::Point{ 1,0,0 }, Mesh::Point{ 0,1,0 }, Mesh::Point{ -0.5,1,0 }, 1) << std::endl;
		std::cout << F2_n(Mesh::Point{ 0,0,0 }, Mesh::Point{ 1,0,0 }, Mesh::Point{ 0,1,0 }, Mesh::Point{ -0.5,1,0 }, 2) << std::endl;
		std::cout << F2_n(Mesh::Point{ 0,0,0 }, Mesh::Point{ 1,0,0 }, Mesh::Point{ 0,1,0 }, Mesh::Point{ -0.5,1,0 }, 5) << std::endl;*/
		//std::cout << eta << endl;
		//std::cout << "check:" << test_eta-eta << std::endl;
		if ((test_eta - eta).norm() > max_err)
			max_err = (test_eta - eta).norm();
	}
	std::cout << "max norm err:"<<max_err << std::endl;
	

}


//2到2的2阶导数权重的计算,次数m=2
void MeshViewerWidget::calculate_greenD2_weight222(void)
{
	assert(degree == 2);
	auto arthono = [](const Mesh::Point& p) -> Mesh::Point {
		return Mesh::Point(p[1], -p[0], p[2]);
	};

	weights.resize(mesh.n_vertices());
	for (auto& weight : weights) {
		weight.resize(curvecage2.size() * (2 * degree + 1));//使用论文中的每段曲线使用幂基来计算
	}
	auto poly_Ctps = curvecage2;
	Bezier2Poly2(curvecage2, poly_Ctps);
	double max_err = 0;
	for (int v_id = 0; v_id < mesh.n_vertices(); v_id++) {//v_id表示mesh中的点数
		auto vh = mesh.vertex_handle(v_id);
		Mesh::Point eta = mesh.point(vh);
		//Mesh::Point eta(0, 0, 0);
		Mesh::Point test_eta(0, 0, 0);//check equality
		for (int i = 0; i < curvecage2.size(); i++)
		{//i表示边界曲线的段数
			auto poly_Ctp = poly_Ctps[i];//每一段曲线，原来的poly_ctp
			auto c0 = poly_Ctp[0]; auto c1 = poly_Ctp[1]; auto c2 = poly_Ctp[2];
			double F0, F1, F2, F3, F4, F5;
			F0 = F2_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], 0);
			F1 = F2_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], 1);
			F2 = F2_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], 2);
			F3 = F2_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], 3);
			F4 = F2_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], 4);
			F5 = F2_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], 5);
			weights[v_id][5 * i + 0] = (c0 - eta).dot(arthono(c1)) * F0 + 2 * (c0 - eta).dot(arthono(c2)) * F1 + (c1).dot(arthono(c2)) * F2;
			weights[v_id][5 * i + 1] = (c0 - eta).dot(arthono(c1)) * F1 + 2 * (c0 - eta).dot(arthono(c2)) * F2 + (c1).dot(arthono(c2)) * F3;
			weights[v_id][5 * i + 2] = (c0 - eta).dot(arthono(c1)) * F2 + 2 * (c0 - eta).dot(arthono(c2)) * F3 + (c1).dot(arthono(c2)) * F4;
			weights[v_id][5 * i + 3] = (c0 - eta).dot(c1) * F1 + (c1.dot(c1) + 2 * (c0 - eta).dot(c2)) * F2 + 3 * (c1).dot(c2) * F3 + 2 * c2.dot(c2) * F4 - log(norm(c0 + c1 + c2 - eta)) / (2 * M_PI);
			weights[v_id][5 * i + 4] = (c0 - eta).dot(c1) * F2 + (c1.dot(c1) + 2 * (c0 - eta).dot(c2)) * F3 + 3 * (c1).dot(c2) * F4 + 2 * c2.dot(c2) * F5 - log(norm(c0 + c1 + c2 - eta)) / (2 * M_PI);
			test_eta += weights[v_id][5 * i + 0] * poly_Ctp[0];
			test_eta += weights[v_id][5 * i + 1] * poly_Ctp[1];
			test_eta += weights[v_id][5 * i + 2] * poly_Ctp[2];
			test_eta += weights[v_id][5 * i + 3] * arthono(poly_Ctp[1]);
			test_eta += weights[v_id][5 * i + 4] * arthono(poly_Ctp[2]);
		}
		//check
		/*std::cout << F2_n(Mesh::Point{ 0,0,0 }, Mesh::Point{ 1,0,0 }, Mesh::Point{ 0,1,0 }, Mesh::Point{ -0.5,1,0 }, 0) << std::endl;
		std::cout << F2_n(Mesh::Point{ 0,0,0 }, Mesh::Point{ 1,0,0 }, Mesh::Point{ 0,1,0 }, Mesh::Point{ -0.5,1,0 }, 1) << std::endl;
		std::cout << F2_n(Mesh::Point{ 0,0,0 }, Mesh::Point{ 1,0,0 }, Mesh::Point{ 0,1,0 }, Mesh::Point{ -0.5,1,0 }, 2) << std::endl;
		std::cout << F2_n(Mesh::Point{ 0,0,0 }, Mesh::Point{ 1,0,0 }, Mesh::Point{ 0,1,0 }, Mesh::Point{ -0.5,1,0 }, 5) << std::endl;*/
		//std::cout << eta << endl;
		//std::cout << "check:" << test_eta-eta << std::endl;
		if ((test_eta - eta).norm() > max_err)
			max_err = (test_eta - eta).norm();
	}
	std::cout << "max norm err:" << max_err << std::endl;


}

//1到1的1阶cauchy权重的计算,次数m=2
void MeshViewerWidget::calculate_cauchy_weight121(void)
{
	assert(degree == 1);
	auto arthono = [](const Mesh::Point& p) -> Mesh::Point {
		return Mesh::Point(p[1], -p[0], p[2]);
	};
	int N = CC_points.size();
	/*cauchyweights.resize(mesh.n_vertices());*/
	//standad_cauchyweights.clear();
	standad_cauchyweights.resize(mesh.n_vertices());
	/*for (auto& weight : cauchyweights) {
		weight.resize(curvecage2.size() * (degree + 1));
	}*/
	for (auto& stweight : standad_cauchyweights) {
		stweight.resize(curvecage2.size() * (degree), std::complex<double>(0.0, 0.0));
	}
	//std::vector<complex<double>> coor_e(degree + 1);
	auto poly_Ctps = curvecage2;
	Bezier1Poly1(curvecage2, poly_Ctps);
	double max_err = 0;
	std::chrono::duration<double> total_time(0.0);
	// --- Start Timing Block 1 ---
	auto start = std::chrono::high_resolution_clock::now();
#pragma omp parallel for
	for (int v_id = 0; v_id < mesh.n_vertices(); v_id++) {//v_id表示mesh中的点数
		auto vh = mesh.vertex_handle(v_id);
		Mesh::Point eta = mesh.point(vh);
		complex<double> z(eta[0], eta[1]);
		//Mesh::Point eta(0, 0, 0);
		complex<double> test_eta(0., 0.);//check equality
		std::array<complex<double>,2> coor_e;
		for (int i = 0; i < curvecage2.size(); i++)
		{//i表示边界曲线的段数
			auto poly_Ctp = poly_Ctps[i];//每一段曲线，原来的poly_ctp
			auto c0 = poly_Ctp[0]; auto c1 = poly_Ctp[1]; 
			complex<double> z0(c0[0], c0[1]), z1(c1[0], c1[1]);

			complex<double> com_c0 = z0 - z;
			complex<double> w1 = -com_c0 / z1;
			

			/*std::vector<std::complex<double>> roots_vec = { w1 };
			std::vector<int> root_orders_vec = { 1 };
			std::vector<std::complex<double>> poly_vec0 = { z1 };
			std::vector<std::complex<double>> poly_vec1 = { 0,z1 };
			std::vector<std::vector<std::complex<double>>> poly_vec = { poly_vec0,poly_vec1 };

			coor_e = rationalIntes(roots_vec, root_orders_vec, poly_vec);*/
			std::array<std::complex<double>, 1> roots_arr = { w1 };
			std::array<std::complex<double>, 2> poly_arr0 = { z1, 0 };
			std::array<std::complex<double>, 2> poly_arr1 = { 0,z1 };
			std::array<std::array<std::complex<double>, 2>, 2> poly_array = { poly_arr0,poly_arr1 };
			coor_e = rationalIntes_121(roots_arr, poly_array);
			/*std::cout << coor_e[0] << std::endl;
			std::cout << vcoor_e[0] << std::endl;*/
			for (auto& coor_e_inner : coor_e) {
				coor_e_inner /= (z1 * std::complex<double>(0, 2 * M_PI));
			}

			/*cauchyweights[v_id][3 * i + 0] = coor_e[0];
			cauchyweights[v_id][3 * i + 1] = coor_e[1];
			cauchyweights[v_id][3 * i + 2] = coor_e[2];*/

			standad_cauchyweights[v_id][i + 0] += coor_e[0] -  coor_e[1];
			standad_cauchyweights[v_id][(i + 1)%N] += coor_e[1] ;

			/*test_eta += cauchyweights[v_id][3 * i + 0] * z0;
			test_eta += cauchyweights[v_id][3 * i + 1] * z1;
			test_eta += cauchyweights[v_id][3 * i + 2] * z2;*/

		}
		////check
		//for (int i = 0; i < CC_points.size(); i++)
		//{
		//	complex<double> test_z0(CC_points[i][0], CC_points[i][1]);
		//	test_eta += standad_cauchyweights[v_id][i] * test_z0;
		//}
		///*std::cout << z << endl;
		//std::cout << "check:" << test_eta - z << std::endl;*/
		//if (abs(test_eta - z) > max_err)
		//	max_err = abs(test_eta - z);
	}
	auto end = std::chrono::high_resolution_clock::now();
	total_time = (end - start);
	std::cout << "Total time for calculation: " << total_time.count() << " seconds" << std::endl;
	std::cout << "121柯西权重max norm err:" << max_err << std::endl;
}

//1到1的1阶cauchy权重的计算,次数m=2
void MeshViewerWidget::calculate_cauchy_weight121(std::vector<std::vector<Mesh::Point>> curvecage, std::vector<std::vector<complex<double>>>& weights)
{
	//assert(degree == 1);
	auto arthono = [](const Mesh::Point& p) -> Mesh::Point {
		return Mesh::Point(p[1], -p[0], p[2]);
	};
	int N = 1 * curvecage.size();
	
	weights.resize(mesh.n_vertices());
	
	for (auto& stweight : weights) {
		stweight.resize(curvecage.size() * (1), std::complex<double>(0.0, 0.0));
	}
	//std::vector<complex<double>> coor_e(degree + 1);
	auto poly_Ctps = curvecage;
	Bezier1Poly1(curvecage, poly_Ctps);
	double max_err = 0;
	std::chrono::duration<double> total_time(0.0);
	// --- Start Timing Block 1 ---
	auto start = std::chrono::high_resolution_clock::now();
#pragma omp parallel for
	for (int v_id = 0; v_id < mesh.n_vertices(); v_id++) {//v_id表示mesh中的点数
		auto vh = mesh.vertex_handle(v_id);
		Mesh::Point eta = mesh.point(vh);
		complex<double> z(eta[0], eta[1]);
		//Mesh::Point eta(0, 0, 0);
		complex<double> test_eta(0., 0.);//check equality
		std::array<complex<double>, 2> coor_e;
		for (int i = 0; i < curvecage.size(); i++)
		{//i表示边界曲线的段数
			auto poly_Ctp = poly_Ctps[i];//每一段曲线，原来的poly_ctp
			auto c0 = poly_Ctp[0]; auto c1 = poly_Ctp[1];
			complex<double> z0(c0[0], c0[1]), z1(c1[0], c1[1]);

			complex<double> com_c0 = z0 - z;
			complex<double> w1 = -com_c0 / z1;


			
			std::array<std::complex<double>, 1> roots_arr = { w1 };
			std::array<std::complex<double>, 2> poly_arr0 = { z1, 0 };
			std::array<std::complex<double>, 2> poly_arr1 = { 0,z1 };
			std::array<std::array<std::complex<double>, 2>, 2> poly_array = { poly_arr0,poly_arr1 };
			coor_e = rationalIntes_121(roots_arr, poly_array);
			/*std::cout << coor_e[0] << std::endl;
			std::cout << vcoor_e[0] << std::endl;*/
			for (auto& coor_e_inner : coor_e) {
				coor_e_inner /= (z1 * std::complex<double>(0, 2 * M_PI));
			}

			weights[v_id][i + 0] += coor_e[0] - coor_e[1];
			weights[v_id][(i + 1) % N] += coor_e[1];

			

		}
		////check
		//for (int i = 0; i < CC_points.size(); i++)
		//{
		//	complex<double> test_z0(CC_points[i][0], CC_points[i][1]);
		//	test_eta += weights[v_id][i] * test_z0;
		//}
		///*std::cout << z << endl;
		//std::cout << "check:" << test_eta - z << std::endl;*/
		//if (abs(test_eta - z) > max_err)
		//	max_err = abs(test_eta - z);
	}
	auto end = std::chrono::high_resolution_clock::now();
	total_time = (end - start);
	std::cout << "Total time for calculation: " << total_time.count() << " seconds" << std::endl;
	std::cout << "121柯西权重max norm err:" << max_err << std::endl;
}


//2到2的2阶cauchy权重的计算,次数m=2
void MeshViewerWidget::calculate_cauchy_weight222(void)
{
	assert(degree == 2);
	auto arthono = [](const Mesh::Point& p) -> Mesh::Point {
		return Mesh::Point(p[1], -p[0], p[2]);
	};
	int N = CC_points.size();
	cauchyweights.resize(mesh.n_vertices());
	standad_cauchyweights.resize(mesh.n_vertices());
	for (auto& weight : cauchyweights) {
		weight.resize(curvecage2.size() * ( degree + 1));
	}
	for (auto& stweight : standad_cauchyweights) {
		stweight.resize(curvecage2.size() * (degree), std::complex<double>(0.0, 0.0));
	}
	std::array<complex<double>,3> coor_e;
	auto poly_Ctps = curvecage2;
	Bezier2Poly2(curvecage2, poly_Ctps);
	double max_err = 0;
	// --- Timing variables ---
	std::chrono::duration<double> total_time_w_calculation(0.0);
	std::chrono::duration<double> total_time_rationalIntes_call(0.0);
	// --- End Timing variables ---
	for (int v_id = 0; v_id < mesh.n_vertices(); v_id++) {//v_id表示mesh中的点数
		auto vh = mesh.vertex_handle(v_id);
		Mesh::Point eta = mesh.point(vh);
		complex<double> z(eta[0], eta[1]);
		//Mesh::Point eta(0, 0, 0);
		complex<double> test_eta(0., 0.);//check equality
		for (int i = 0; i < curvecage2.size(); i++)
		{//i表示边界曲线的段数
			auto poly_Ctp = poly_Ctps[i];//每一段曲线，原来的poly_ctp

			// --- Start Timing Block 1 ---
			auto start_w_calc = std::chrono::high_resolution_clock::now();
			auto c0 = poly_Ctp[0]; auto c1 = poly_Ctp[1]; auto c2 = poly_Ctp[2];
			complex<double> z0(c0[0], c0[1]), z1(c1[0], c1[1]), z2(c2[0], c2[1]);

			

			complex<double> com_c0 = z0 - z;
			complex<double> w1 = (-z1 - sqrt(z1 * z1 - com_c0 * z2 * 4.0)) / (2.0 * z2);
			complex<double> w2 = (-z1 + sqrt(z1 * z1 - com_c0 * z2 * 4.0)) / (2.0 * z2);

			auto end_w_calc = std::chrono::high_resolution_clock::now();
			total_time_w_calculation += (end_w_calc - start_w_calc);
			// --- End Timing Block 1 ---

			// --- Start Timing Block 2 ---
			auto start_rationalIntes = std::chrono::high_resolution_clock::now();

			std::array<std::complex<double>, 2> roots_arr = { w1,w2 };
			std::array<std::complex<double>, 4> poly_arr0 = { z1, std::complex<double>(2.0) * z2, 0,0 };
			std::array<std::complex<double>, 4> poly_arr1 = { 0,z1, std::complex<double>(2.0) * z2, 0 };
			std::array<std::complex<double>, 4> poly_arr2 = { 0,0,z1, std::complex<double>(2.0) * z2 };
			std::array<std::array<std::complex<double>, 4>, 3> poly_array = { poly_arr0,poly_arr1, poly_arr2};
			coor_e = rationalIntes_2(roots_arr, poly_array);

			for (auto& coor_e_inner : coor_e) {
				coor_e_inner /= (z2 * std::complex<double>(0, 2 * M_PI));
			}
			auto end_rationalIntes = std::chrono::high_resolution_clock::now();
			total_time_rationalIntes_call += (end_rationalIntes - start_rationalIntes);
			// --- End Timing Block 2 ---

			standad_cauchyweights[v_id][2 * i + 0] += coor_e[0] - 2. * coor_e[1]+coor_e[2];
			standad_cauchyweights[v_id][2 * i + 1] += 2.0 * coor_e[1] - 2.0 * coor_e[2];
			standad_cauchyweights[v_id][(2 * i + 2) % N] += coor_e[2];
			
			
		}
		//check
		for (int i = 0; i < CC_points.size(); i++)
		{
			complex<double> test_z0(CC_points[i][0], CC_points[i][1]);
			test_eta += standad_cauchyweights[v_id][i] * test_z0;
		}
		/*std::cout << z << endl;
		std::cout << "check:" << test_eta - z << std::endl;*/
		if (abs(test_eta - z) > max_err)
			max_err = abs(test_eta - z);
	}
	// --- Print Timing Results ---
	std::cout << "Total time for w1, w2 calculation: " << total_time_w_calculation.count() << " seconds" << std::endl;
	std::cout << "Total time for rationalIntes_2 calls: " << total_time_rationalIntes_call.count() << " seconds" << std::endl;
	// --- End Print Timing Results ---
	std::cout << "柯西权重max norm err:" << max_err << std::endl;
}

//2到2的2阶cauchy权重的计算,次数m=2
void MeshViewerWidget::calculate_cauchy_weight222_rational(void)
{
	assert(degree == 2);
	auto arthono = [](const Mesh::Point& p) -> Mesh::Point {
		return Mesh::Point(p[1], -p[0], p[2]);
	};
	int N = CC_points.size();
	cauchyweights.resize(mesh.n_vertices());
	standad_cauchyweights.resize(mesh.n_vertices());
	for (auto& weight : cauchyweights) {
		weight.resize(curvecage2.size() * (degree + 1));
	}
	for (auto& stweight : standad_cauchyweights) {
		stweight.resize(curvecage2.size() * (degree), std::complex<double>(0.0, 0.0));
	}
	std::vector<complex<double>> coor_e(degree + 1);
	auto poly_Ctps = curvecage2;
	Bezier2Poly2(curvecage2, poly_Ctps);
	auto poly_Ctps_rational = curvecage2;
	auto bezier_Ctps_rational = curvecage2;
	//有理的转化
	for (int i = 0; i < poly_Ctps.size(); i++) {
		bezier_Ctps_rational[i][0][0] *= bezier_Ctps_rational[i][0][2];
		bezier_Ctps_rational[i][1][0] *= bezier_Ctps_rational[i][1][2];
		bezier_Ctps_rational[i][2][0] *= bezier_Ctps_rational[i][2][2];
		bezier_Ctps_rational[i][0][1] *= bezier_Ctps_rational[i][0][2];
		bezier_Ctps_rational[i][1][1] *= bezier_Ctps_rational[i][1][2];
		bezier_Ctps_rational[i][2][1] *= bezier_Ctps_rational[i][2][2];
	}
	Bezier2Poly2(bezier_Ctps_rational, poly_Ctps_rational);
	//权重是curve_cage的z坐标
	double max_err = 0;
	for (int v_id = 0; v_id < mesh.n_vertices(); v_id++) {//v_id表示mesh中的点数
		auto vh = mesh.vertex_handle(v_id);
		Mesh::Point eta = mesh.point(vh);
		complex<double> z(eta[0], eta[1]);
		//Mesh::Point eta(0, 0, 0);
		complex<double> test_eta(0., 0.);//check equality
		for (int i = 0; i < curvecage2.size(); i++)
		{//i表示边界曲线的段数
			auto bezier_Ctp = curvecage2[i];
			auto poly_Ctp = poly_Ctps[i];//每一段曲线，原来的poly_ctp
			auto poly_Ctp_rational = poly_Ctps_rational[i];
			auto c0 = poly_Ctp_rational[0]; auto c1 = poly_Ctp_rational[1]; auto c2 = poly_Ctp_rational[2];
			complex<double> z0(c0[0], c0[1]), z1(c1[0], c1[1]), z2(c2[0], c2[1]);
			complex<double> wt0(poly_Ctp[0][2], 0);
			complex<double> wt1(poly_Ctp[1][2], 0);
			complex<double> wt2(poly_Ctp[2][2], 0);

			/*complex<double> z0(1, 1), z1(2, 2), z2(3, 1);
			z = complex<double>(4, 5);
			complex<double> wt0 (2,0);
			complex<double> wt1 (2, 0);
			complex<double> wt2 (1, 0);*/

			auto consolidate_roots_lambda =
				[](const std::vector<std::complex<double>>& input_roots,
					const std::vector<int>& input_orders,
					std::vector<std::complex<double>>& unique_roots,
					std::vector<int>& total_orders,
					double epsilon = 1e-9) -> void
			{
				// Check if input vector sizes match
				if (input_roots.size() != input_orders.size()) {
					std::cerr << "Error: Input root vector and order vector sizes do not match." << std::endl;
					// Clear output vectors to indicate error or no processing
					unique_roots.clear();
					total_orders.clear();
					return;
				}

				unique_roots.clear();
				total_orders.clear();
				unique_roots.reserve(input_roots.size()); // Reserve space for performance optimization
				total_orders.reserve(input_roots.size());

				for (size_t i = 0; i < input_roots.size(); ++i) {
					const auto& current_root = input_roots[i];
					int current_order = input_orders[i];

					bool found_match = false;
					// Iterate through roots already added to unique_roots to find a numerically close root
					for (size_t j = 0; j < unique_roots.size(); ++j) {
						// Use std::abs(complex) to calculate the magnitude of the complex number (distance from origin)
						// std::abs(c1 - c2) calculates the distance between two complex numbers c1 and c2
						if (std::abs(current_root - unique_roots[j]) < epsilon) {
							// Found a matching root, add the current root's order to the existing order
							total_orders[j] += current_order;
							found_match = true;
							break; // Found a match, no need to check other elements in unique_roots
						}
					}

					// If the current root is not close to any root in unique_roots,
					// add it as a new unique root to unique_roots
					if (!found_match) {
						unique_roots.push_back(current_root);
						total_orders.push_back(current_order);
					}
				}
			};

			complex<double> com_c0 = z0 - wt0 * z;
			complex<double> com_c1 = z1 - wt1 * z;
			complex<double> com_c2 = z2 - wt2 * z;
			complex<double> w1 = (-com_c1 - sqrt(com_c1 * com_c1 - com_c0 * com_c2 * 4.0)) / (2.0 * com_c2);
			complex<double> w2 = (-com_c1 + sqrt(com_c1 * com_c1 - com_c0 * com_c2 * 4.0)) / (2.0 * com_c2);

			complex<double> w3 = (-wt1 - sqrt(wt1 * wt1 - wt0 * wt2 * 4.0)) / (2.0 * wt2);
			complex<double> w4 = (-wt1 + sqrt(wt1 * wt1 - wt0 * wt2 * 4.0)) / (2.0 * wt2);

			std::vector<complex<double>> roots_vec = { w1, w2,w3,w4 };
			std::vector<int> root_orders_vec = { 1, 1 ,2 , 2 };
			std::vector<complex<double>> poly_vec0 = { -wt1 * z0 + wt0 * z1,-2. * wt2 * z0 + 2. * wt0 * z2,-wt2 * z1 + wt1 * z2 };
			std::vector<complex<double>> poly_vec1 = { 0,-wt1 * z0 + wt0 * z1,-2. * wt2 * z0 + 2. * wt0 * z2,-wt2 * z1 + wt1 * z2 };
			std::vector<complex<double>> poly_vec2 = { 0,0,-wt1 * z0 + wt0 * z1,-2. * wt2 * z0 + 2. * wt0 * z2,-wt2 * z1 + wt1 * z2 };
			std::vector<std::vector<complex<double>>> poly_vec = { poly_vec0,poly_vec1, poly_vec2 };

			std::vector<std::complex<double>> consolidated_roots;
			std::vector<int> consolidated_orders;
			consolidate_roots_lambda(roots_vec, root_orders_vec, consolidated_roots, consolidated_orders);

			coor_e = rationalIntes(consolidated_roots, consolidated_orders, poly_vec);
			for (auto& coor_e_inner : coor_e) {
				coor_e_inner /= ((z2 - z * wt2) * wt2 * wt2 * complex<double>(0, 2 * M_PI));
			}

			standad_cauchyweights[v_id][2 * i + 0] += (coor_e[0] - 2. * coor_e[1] + coor_e[2]);
			standad_cauchyweights[v_id][2 * i + 1] += (2.0 * coor_e[1] - 2.0 * coor_e[2]);
			standad_cauchyweights[v_id][(2 * i + 2) % N] += (coor_e[2]);


		}
		//check
		for (int i = 0; i < CC_points.size(); i++)
		{
			complex<double> test_z0(CC_points[i][0], CC_points[i][1]);
			test_eta += standad_cauchyweights[v_id][i] * test_z0 * CC_points[i][2];
		}
		/*std::cout << z << endl;
		std::cout << "check:" << test_eta - z << std::endl;*/
		if (std::isnan(test_eta.real()) || std::isnan(test_eta.imag())) {
			std::cout << "nan" << std::endl;
		}
		if (abs(test_eta - z) > max_err)
			max_err = abs(test_eta - z);
		
	}
	std::cout << "柯西权重max norm err:" << max_err << std::endl;
}

//1到3的2阶cauchy权重的计算,次数m=2
void MeshViewerWidget::calculate_cauchy_weight123(void)
{
	assert(degree == 3);
	auto arthono = [](const Mesh::Point& p) -> Mesh::Point {
		return Mesh::Point(p[1], -p[0], p[2]);
	};
	int N = CC_points.size();
	cauchyweights.resize(mesh.n_vertices());
	standad_cauchyweights.clear();
	standad_cauchyweights.resize(mesh.n_vertices());
	for (auto& weight : cauchyweights) {
		weight.resize(curvecage2.size() * (degree + 1));
	}
	for (auto& stweight : standad_cauchyweights) {
		stweight.resize(curvecage2.size() * (degree), std::complex<double>(0.0, 0.0));
	}
	//std::vector<complex<double>> coor_e(degree + 1);
	
	auto poly_Ctps = curvecage2;
	auto curvecage2end = curvecage2;
	for (int i = 0; i < curvecage2.size(); i++)
	{
		curvecage2end[i] = std::vector<OpenMesh::Vec3d>{ curvecage2[i][0],curvecage2[i][degree] };
	}
	Bezier1Poly1(curvecage2end, poly_Ctps);
	double max_err = 0;
	std::chrono::duration<double> total_time(0.0);
	// --- End Timing variables ---
	// --- Start Timing Block 1 ---
	auto start = std::chrono::high_resolution_clock::now();
#pragma omp parallel for
	for (int v_id = 0; v_id < mesh.n_vertices(); v_id++) {//v_id表示mesh中的点数
		auto vh = mesh.vertex_handle(v_id);
		Mesh::Point eta = mesh.point(vh);
		complex<double> z(eta[0], eta[1]);
		//Mesh::Point eta(0, 0, 0);
		complex<double> test_eta(0., 0.);//check equality
		std::array<complex<double>, 4> coor_e;
		for (int i = 0; i < curvecage2.size(); i++)
		{//i表示边界曲线的段数
			auto poly_Ctp = poly_Ctps[i];//每一段曲线，原来的poly_ctp
			auto c0 = poly_Ctp[0]; auto c1 = poly_Ctp[1];
			complex<double> z0(c0[0], c0[1]), z1(c1[0], c1[1]);

			complex<double> com_c0 = z0 - z;
			complex<double> w1 = -com_c0 / z1;


			/*std::vector<std::complex<double>> roots_vec = { w1 };
			std::vector<int> root_orders_vec = { 1 };
			std::vector<std::complex<double>> poly_vec0 = { z1 };
			std::vector<std::complex<double>> poly_vec1 = { 0,z1 };
			std::vector<std::complex<double>> poly_vec2 = { 0,0,z1 };
			std::vector<std::complex<double>> poly_vec3 = { 0,0,0,z1 };
			std::vector<std::vector<std::complex<double>>> poly_vec = { poly_vec0,poly_vec1,poly_vec2,poly_vec3 };

			coor_e = rationalIntes(roots_vec, root_orders_vec, poly_vec);*/
			std::array<std::complex<double>, 1> roots_arr = { w1 };
			std::array<std::complex<double>, 4> poly_arr0 = { z1};
			std::array<std::complex<double>, 4> poly_arr1 = { 0,z1};
			std::array<std::complex<double>, 4> poly_arr2 = { 0,0,z1 };
			std::array<std::complex<double>, 4> poly_arr3 = { 0,0,0,z1 };
			std::array<std::array<std::complex<double>, 4>, 4> poly_array = { poly_arr0,poly_arr1, poly_arr2, poly_arr3 };
			coor_e=rationalIntes_123(roots_arr, poly_array);
			/*std::cout << coor_e[0] << std::endl;
			std::cout << coor_etest[0] << std::endl;*/
			for (auto& coor_e_inner : coor_e) {
				coor_e_inner /= (z1 * std::complex<double>(0, 2 * M_PI));
			}

			/*cauchyweights[v_id][3 * i + 0] = coor_e[0];
			cauchyweights[v_id][3 * i + 1] = coor_e[1];
			cauchyweights[v_id][3 * i + 2] = coor_e[2];*/

			standad_cauchyweights[v_id][3 * i + 0] += coor_e[0] - 3. * coor_e[1] + 3. * coor_e[2] - coor_e[3];
			standad_cauchyweights[v_id][3 * i + 1] += 3.0 * coor_e[1] - 6.0 * coor_e[2] + 3. * coor_e[3];
			standad_cauchyweights[v_id][(3 * i + 2)] += 3. * coor_e[2] - 3. * coor_e[3];
			standad_cauchyweights[v_id][(3 * i + 3) % N] += coor_e[3];

		}
		////check
		//for (int i = 0; i < CC_points.size(); i++)
		//{
		//	complex<double> test_z0(CC_points[i][0], CC_points[i][1]);
		//	test_eta += standad_cauchyweights[v_id][i] * test_z0;
		//}
		///*std::cout << z << endl;
		//std::cout << "check:" << test_eta - z << std::endl;*/
		//if (abs(test_eta - z) > max_err)
		//	max_err = abs(test_eta - z);
	}
	auto end = std::chrono::high_resolution_clock::now();
	total_time = (end - start);
	std::cout << "Total time for calculation: " << total_time.count() << " seconds" << std::endl;
	std::cout << "柯西权重max norm err:" << max_err << std::endl;
}


//1到3的2阶cauchy权重的计算,次数m=2
void MeshViewerWidget::calculate_cauchy_weight123(std::vector<std::vector<Mesh::Point>> curvecage, std::vector<std::vector<complex<double>>>& weights)
{
	assert(degree == 3);
	auto arthono = [](const Mesh::Point& p) -> Mesh::Point {
		return Mesh::Point(p[1], -p[0], p[2]);
	};
	//int N = CC_points.size();
	int N = 3 * curvecage.size();
	weights.clear();
	weights.resize(mesh.n_vertices());
	
	for (auto& stweight : weights) {
		stweight.resize(curvecage.size() * (degree), std::complex<double>(0.0, 0.0));
	}
	//std::vector<complex<double>> coor_e(degree + 1);

	auto poly_Ctps = curvecage;
	auto curvecageend = curvecage;
	for (int i = 0; i < curvecage.size(); i++)
	{
		curvecageend[i] = std::vector<OpenMesh::Vec3d>{ curvecage[i][0],curvecage[i][degree] };
	}
	Bezier1Poly1(curvecageend, poly_Ctps);
	double max_err = 0;
	std::chrono::duration<double> total_time(0.0);
	// --- End Timing variables ---
	// --- Start Timing Block 1 ---
	auto start = std::chrono::high_resolution_clock::now();
#pragma omp parallel for
	for (int v_id = 0; v_id < mesh.n_vertices(); v_id++) {//v_id表示mesh中的点数
		auto vh = mesh.vertex_handle(v_id);
		Mesh::Point eta = mesh.point(vh);
		complex<double> z(eta[0], eta[1]);
		//Mesh::Point eta(0, 0, 0);
		complex<double> test_eta(0., 0.);//check equality
		std::array<complex<double>, 4> coor_e;
		for (int i = 0; i < curvecage.size(); i++)
		{//i表示边界曲线的段数
			auto poly_Ctp = poly_Ctps[i];//每一段曲线，原来的poly_ctp
			auto c0 = poly_Ctp[0]; auto c1 = poly_Ctp[1];
			complex<double> z0(c0[0], c0[1]), z1(c1[0], c1[1]);

			complex<double> com_c0 = z0 - z;
			complex<double> w1 = -com_c0 / z1;

			std::array<std::complex<double>, 1> roots_arr = { w1 };
			std::array<std::complex<double>, 4> poly_arr0 = { z1 };
			std::array<std::complex<double>, 4> poly_arr1 = { 0,z1 };
			std::array<std::complex<double>, 4> poly_arr2 = { 0,0,z1 };
			std::array<std::complex<double>, 4> poly_arr3 = { 0,0,0,z1 };
			std::array<std::array<std::complex<double>, 4>, 4> poly_array = { poly_arr0,poly_arr1, poly_arr2, poly_arr3 };
			coor_e = rationalIntes_123(roots_arr, poly_array);
			/*std::cout << coor_e[0] << std::endl;
			std::cout << coor_etest[0] << std::endl;*/
			for (auto& coor_e_inner : coor_e) {
				coor_e_inner /= (z1 * std::complex<double>(0, 2 * M_PI));
			}


			weights[v_id][3 * i + 0] += coor_e[0] - 3. * coor_e[1] + 3. * coor_e[2] - coor_e[3];
			weights[v_id][3 * i + 1] += 3.0 * coor_e[1] - 6.0 * coor_e[2] + 3. * coor_e[3];
			weights[v_id][(3 * i + 2)] += 3. * coor_e[2] - 3. * coor_e[3];
			weights[v_id][(3 * i + 3) % N] += coor_e[3];

		}
		
	}
	auto end = std::chrono::high_resolution_clock::now();
	total_time = (end - start);
	std::cout << "Total time for calculation: " << total_time.count() << " seconds" << std::endl;
	std::cout << "柯西权重max norm err:" << max_err << std::endl;
}

//3到3的2阶cauchy权重的计算,次数m=2
void MeshViewerWidget::calculate_cauchy_weight323(void)
{
	assert(degree == 3);
	auto arthono = [](const Mesh::Point& p) -> Mesh::Point {
		return Mesh::Point(p[1], -p[0], p[2]);
	};
	int N = CC_points.size();
	cauchyweights.clear();
	cauchyweights.resize(mesh.n_vertices());
	standad_cauchyweights.clear();
	standad_cauchyweights.resize(mesh.n_vertices());
	for (auto& weight : cauchyweights) {
		weight.resize(curvecage2.size() * (degree + 1));
	}
	for (auto& stweight : standad_cauchyweights) {
		stweight.resize(curvecage2.size() * (degree), std::complex<double>(0.0, 0.0));
	}
	
	auto poly_Ctps = curvecage2;
	Bezier2Poly3(curvecage2, poly_Ctps);
	double max_err = 0;
	// --- Timing variables ---
	std::chrono::duration<double> total_time_w_calculation(0.0);
	std::chrono::duration<double> total_time_rationalIntes_call(0.0);
	std::chrono::duration<double> total_time(0.0);
	// --- End Timing variables ---
	// --- Start Timing Block 1 ---
	auto start = std::chrono::high_resolution_clock::now();
//#pragma omp parallel for
	for (int v_id = 0; v_id < mesh.n_vertices(); v_id++) {//v_id表示mesh中的点数
		auto vh = mesh.vertex_handle(v_id);
		Mesh::Point eta = mesh.point(vh);
		complex<double> z(eta[0], eta[1]);
		//Mesh::Point eta(0, 0, 0);
		complex<double> test_eta(0., 0.);//check equality
		std::array<complex<double>, 4> coor_e;
		for (int i = 0; i < curvecage2.size(); i++)
		{//i表示边界曲线的段数
			auto poly_Ctp = poly_Ctps[i];//每一段曲线，原来的poly_ctp
			//// --- Start Timing Block 1 ---
			//auto start_w_calc = std::chrono::high_resolution_clock::now();

			auto c0 = poly_Ctp[0]; auto c1 = poly_Ctp[1]; auto c2 = poly_Ctp[2]; auto c3 = poly_Ctp[3];
			complex<double> z0(c0[0], c0[1]), z1(c1[0], c1[1]), z2(c2[0], c2[1]), z3(c3[0], c3[1]);

			
			complex<double> com_c0 = z0 - z;
			complex<double> com_c1 = z1;
			complex<double> com_c2 = z2;
			complex<double> com_c3 = z3;
			

			//auto end_w_calc = std::chrono::high_resolution_clock::now();
			//total_time_w_calculation += (end_w_calc - start_w_calc);
			//// --- End Timing Block 1 ---
			
			//// --- Start Timing Block 2 ---
			//auto start_rationalIntes = std::chrono::high_resolution_clock::now();

			
			
			std::array<std::complex<double>,6> poly_arr0 = { z1, std::complex<double>(2.0) * z2, std::complex<double>(3.0) * z3,0,0,0 };
			std::array<std::complex<double>,6> poly_arr1 = { 0,z1, std::complex<double>(2.0) * z2, std::complex<double>(3.0) * z3,0,0 };
			std::array<std::complex<double>,6> poly_arr2 = { 0,0,z1, std::complex<double>(2.0) * z2, std::complex<double>(3.0) * z3 ,0};
			std::array<std::complex<double>,6> poly_arr3 = { 0,0,0,z1, std::complex<double>(2.0) * z2, std::complex<double>(3.0) * z3 };
			std::array<std::array<std::complex<double>,6>,4> poly_array = { poly_arr0,poly_arr1, poly_arr2, poly_arr3 };
			//testing
			std::array< std::complex<double>, 4>denom = { com_c0,com_c1,com_c2,com_c3 };//分母
			for (int i = 0; i < 4; i++) {
				coor_e[i] = integrate_rational(poly_array[i], denom) / std::complex<double>(0, 2 * M_PI);
			}

			/*complex<double> w1;
			complex<double> w2;
			complex<double> w3;
			Cardano(com_c3, com_c2, com_c1, com_c0, w1, w2, w3);
			std::array<std::complex<double>, 3> roots_arr = { w1,w2,w3 };
			coor_e = rationalIntes_3(roots_arr, poly_array);
			for (auto& coor_e_inner : coor_e) {
				coor_e_inner /= (z3 * std::complex<double>(0, 2 * M_PI));
			}*/

			
			//auto end_rationalIntes = std::chrono::high_resolution_clock::now();
			//total_time_rationalIntes_call += (end_rationalIntes - start_rationalIntes);
			//// --- End Timing Block 2 ---

			standad_cauchyweights[v_id][3 * i + 0] += coor_e[0] - 3. * coor_e[1] + 3. * coor_e[2] - coor_e[3];
			standad_cauchyweights[v_id][3 * i + 1] += 3.0 * coor_e[1] - 6.0 * coor_e[2] + 3. * coor_e[3];
			standad_cauchyweights[v_id][(3 * i + 2)] += 3. * coor_e[2] - 3. * coor_e[3];
			standad_cauchyweights[v_id][(3 * i + 3)%N] += coor_e[3];

		}
		
	
		//check
		for (int i = 0; i < CC_points.size(); i++)
		{
			complex<double> test_z0(CC_points[i][0], CC_points[i][1]);
			test_eta += standad_cauchyweights[v_id][i] * test_z0;
		}
		///*std::cout << z << endl;
		//std::cout << "check:" << test_eta - z << std::endl;*/
		if (abs(test_eta - z) > max_err)
			max_err = abs(test_eta - z);
	}
	// --- Print Timing Results ---
	auto end = std::chrono::high_resolution_clock::now();
	total_time = (end - start);
	std::cout << "Total time for calculation: " << total_time.count() << " seconds" << std::endl;
	//std::cout << "Total time for w1, w2 calculation: " << total_time_w_calculation.count() << " seconds" << std::endl;
	//std::cout << "Total time for rationalIntes_2 calls: " << total_time_rationalIntes_call.count() << " seconds" << std::endl;
	// --- End Print Timing Results ---
	std::cout << "柯西权重max norm err:" << max_err << std::endl;
}
//重载
void MeshViewerWidget::calculate_cauchy_weight121(std::vector<complex<double>>cps)
{
	assert(degree == 1);
	int N = CC_points.size();
	cp_cauchyweights.clear();
	cp_cauchyweights.resize(cps.size());
	for (auto& weight : cp_cauchyweights) {
		weight.resize(N, std::complex<double>(0.0, 0.0));
	}
	std::vector<complex<double>> coor_e(degree + 1);
	auto poly_Ctps = curvecage2;
	Bezier1Poly1(curvecage2, poly_Ctps);
	double max_err = 0;
	for (int v_id = 0; v_id < cps.size(); v_id++) {//v_id表示mesh中的点数
		complex<double> z = cps[v_id];
		//Mesh::Point eta(0, 0, 0);
		complex<double> test_eta(0., 0.);//check equality
		for (int i = 0; i < curvecage2.size(); i++)
		{//i表示边界曲线的段数
			auto poly_Ctp = poly_Ctps[i];//每一段曲线，原来的poly_ctp
			auto c0 = poly_Ctp[0]; auto c1 = poly_Ctp[1];
			complex<double> z0(c0[0], c0[1]), z1(c1[0], c1[1]);

			complex<double> com_c0 = z0 - z;
			complex<double> w1 = -com_c0 / z1;


			std::vector<std::complex<double>> roots_vec = { w1 };
			std::vector<int> root_orders_vec = { 1 };
			std::vector<std::complex<double>> poly_vec0 = { z1 };
			std::vector<std::complex<double>> poly_vec1 = { 0,z1 };
			std::vector<std::vector<std::complex<double>>> poly_vec = { poly_vec0,poly_vec1 };

			coor_e = rationalIntes(roots_vec, root_orders_vec, poly_vec);
			for (auto& coor_e_inner : coor_e) {
				coor_e_inner /= (z1 * std::complex<double>(0, 2 * M_PI));
			}


			cp_cauchyweights[v_id][i + 0] += coor_e[0] - coor_e[1];
			cp_cauchyweights[v_id][(i + 1) % N] += coor_e[1];



		}
		//check
		for (int i = 0; i < CC_points.size(); i++)
		{
			complex<double> test_z0(CC_points[i][0], CC_points[i][1]);
			test_eta += cp_cauchyweights[v_id][i] * test_z0;
		}
		/*std::cout << z << endl;
		std::cout << "check:" << test_eta - z << std::endl;*/
		if (abs(test_eta - z) > max_err)
			max_err = abs(test_eta - z);
	}
	std::cout << "计算控制点的柯西权重max norm err:" << max_err << std::endl;
}

void MeshViewerWidget::calculate_cauchy_weight123(std::vector<complex<double>>cps)
{
	assert(degree == 3);
	auto arthono = [](const Mesh::Point& p) -> Mesh::Point {
		return Mesh::Point(p[1], -p[0], p[2]);
	};
	int N = CC_points.size();
	cp_cauchyweights.clear();
	cp_cauchyweights.resize(cps.size());
	for (auto& weight : cp_cauchyweights) {
		weight.resize(N, std::complex<double>(0.0, 0.0));
	}
	std::vector<complex<double>> coor_e(degree + 1);
	auto poly_Ctps = curvecage2;
	auto curvecage2end = curvecage2;
	for (int i = 0; i < curvecage2.size(); i++)
	{
		curvecage2end[i] = std::vector<OpenMesh::Vec3d>{ curvecage2[i][0],curvecage2[i][degree] };
	}
	Bezier1Poly1(curvecage2end, poly_Ctps);
	double max_err = 0;
	for (int v_id = 0; v_id < cps.size(); v_id++) {//v_id表示mesh中的点数
		complex<double> z = cps[v_id];
		//Mesh::Point eta(0, 0, 0);
		complex<double> test_eta(0., 0.);//check equality
		for (int i = 0; i < curvecage2.size(); i++)
		{//i表示边界曲线的段数
			auto poly_Ctp = poly_Ctps[i];//每一段曲线，原来的poly_ctp
			auto c0 = poly_Ctp[0]; auto c1 = poly_Ctp[1];
			complex<double> z0(c0[0], c0[1]), z1(c1[0], c1[1]);

			complex<double> com_c0 = z0 - z;
			complex<double> w1 = -com_c0 / z1;


			std::vector<std::complex<double>> roots_vec = { w1 };
			std::vector<int> root_orders_vec = { 1 };
			std::vector<std::complex<double>> poly_vec0 = { z1 };
			std::vector<std::complex<double>> poly_vec1 = { 0,z1 };
			std::vector<std::complex<double>> poly_vec2 = { 0,0,z1 };
			std::vector<std::complex<double>> poly_vec3 = { 0,0,0,z1 };
			std::vector<std::vector<std::complex<double>>> poly_vec = { poly_vec0,poly_vec1,poly_vec2,poly_vec3 };

			coor_e = rationalIntes(roots_vec, root_orders_vec, poly_vec);
			for (auto& coor_e_inner : coor_e) {
				coor_e_inner /= (z1 * std::complex<double>(0, 2 * M_PI));
			}

			/*cauchyweights[v_id][3 * i + 0] = coor_e[0];
			cauchyweights[v_id][3 * i + 1] = coor_e[1];
			cauchyweights[v_id][3 * i + 2] = coor_e[2];*/

			cp_cauchyweights[v_id][3 * i + 0] += coor_e[0] - 3. * coor_e[1] + 3. * coor_e[2] - coor_e[3];
			cp_cauchyweights[v_id][3 * i + 1] += 3.0 * coor_e[1] - 6.0 * coor_e[2] + 3. * coor_e[3];
			cp_cauchyweights[v_id][(3 * i + 2)] += 3. * coor_e[2] - 3. * coor_e[3];
			cp_cauchyweights[v_id][(3 * i + 3) % N] += coor_e[3];

		}
		//check
		for (int i = 0; i < CC_points.size(); i++)
		{
			complex<double> test_z0(CC_points[i][0], CC_points[i][1]);
			test_eta += cp_cauchyweights[v_id][i] * test_z0;
		}
		/*std::cout << z << endl;
		std::cout << "check:" << test_eta - z << std::endl;*/
		if (abs(test_eta - z) > max_err)
			max_err = abs(test_eta - z);
	}
	std::cout << "柯西权重max norm err:" << max_err << std::endl;
}
//重载
void MeshViewerWidget::calculate_cauchy_weight222(std::vector<complex<double>>cps)
{
	assert(degree == 2);
	int N = CC_points.size();
	cp_cauchyweights.clear();
	cp_cauchyweights.resize(cps.size());
	for (auto& weight : cp_cauchyweights) {
		weight.resize(N, std::complex<double>(0.0, 0.0));
	}
	std::vector<complex<double>> coor_e(degree + 1);
	auto poly_Ctps = curvecage2;
	Bezier2Poly2(curvecage2, poly_Ctps);
	double max_err = 0;
	for (int v_id = 0; v_id < cps.size(); v_id++) {//v_id表示mesh中的点数
		complex<double> z = cps[v_id];
		//Mesh::Point eta(0, 0, 0);
		complex<double> test_eta(0., 0.);//check equality
		for (int i = 0; i < curvecage2.size(); i++)
		{//i表示边界曲线的段数
			auto poly_Ctp = poly_Ctps[i];//每一段曲线，原来的poly_ctp
			auto c0 = poly_Ctp[0]; auto c1 = poly_Ctp[1]; auto c2 = poly_Ctp[2];
			complex<double> z0(c0[0], c0[1]), z1(c1[0], c1[1]), z2(c2[0], c2[1]);
			complex<double> F0, F1, F2, F3, F4, F5;
			F0 = cauchy_F2_n(z, z0, z1, z2, 0) / std::complex<double>(0, 2 * M_PI);
			F1 = cauchy_F2_n(z, z0, z1, z2, 1) / std::complex<double>(0, 2 * M_PI);
			F2 = cauchy_F2_n(z, z0, z1, z2, 2) / std::complex<double>(0, 2 * M_PI);
			F3 = cauchy_F2_n(z, z0, z1, z2, 3) / std::complex<double>(0, 2 * M_PI);

			coor_e[0] = 2.0 * z2 * F1 + z1 * F0;
			coor_e[1] = 2.0 * z2 * F2 + z1 * F1;
			coor_e[2] = 2.0 * z2 * F3 + z1 * F2;


			cp_cauchyweights[v_id][2 * i + 0] += coor_e[0] - 2. * coor_e[1]+coor_e[2];
			cp_cauchyweights[v_id][2 * i + 1] += 2.0 * coor_e[1] - 2.0 * coor_e[2];
			cp_cauchyweights[v_id][(2 * i + 2) % N] += coor_e[2];

			/*test_eta += coor_e[0] * z0;
			test_eta += coor_e[1] * z1;
			test_eta += coor_e[2] * z2;*/

			
		}
		//check
		for (int i = 0; i < CC_points.size(); i++)
		{
			complex<double> test_z0(CC_points[i][0], CC_points[i][1]);
			test_eta += cp_cauchyweights[v_id][i] * test_z0;
		}
		/*std::cout << z << endl;
		std::cout << "check:" << test_eta - z << std::endl;*/
		if (abs(test_eta - z) > max_err)
			max_err = abs(test_eta - z);
	}
	std::cout << "计算控制点的柯西权重max norm err:" << max_err << std::endl;
}

//重载
void MeshViewerWidget::calculate_cauchy_weight323(std::vector<complex<double>>cps)
{
	assert(degree == 3);
	int N = CC_points.size();

	cp_cauchyweights.resize(cps.size());
	for (auto& weight : cp_cauchyweights) {
		weight.resize(N, std::complex<double>(0.0, 0.0));
	}
	std::vector<complex<double>> coor_e(degree + 1);
	auto poly_Ctps = curvecage2;
	Bezier2Poly3(curvecage2, poly_Ctps);
	double max_err = 0;
	for (int v_id = 0; v_id < cps.size(); v_id++) {//v_id表示mesh中的点数
		complex<double> z = cps[v_id];
		//Mesh::Point eta(0, 0, 0);
		complex<double> test_eta(0., 0.);//check equality
		for (int i = 0; i < curvecage2.size(); i++)
		{//i表示边界曲线的段数
			auto poly_Ctp = poly_Ctps[i];//每一段曲线，原来的poly_ctp
			auto c0 = poly_Ctp[0]; auto c1 = poly_Ctp[1]; auto c2 = poly_Ctp[2]; auto c3 = poly_Ctp[3];
			complex<double> z0(c0[0], c0[1]), z1(c1[0], c1[1]), z2(c2[0], c2[1]), z3(c3[0], c3[1]);
			complex<double> F0, F1, F2, F3, F4, F5;
			F0 = cauchy_F3_n(z, z0, z1, z2, z3, 0) / std::complex<double>(0, 2 * M_PI);
			F1 = cauchy_F3_n(z, z0, z1, z2, z3, 1) / std::complex<double>(0, 2 * M_PI);
			F2 = cauchy_F3_n(z, z0, z1, z2, z3, 2) / std::complex<double>(0, 2 * M_PI);
			F3 = cauchy_F3_n(z, z0, z1, z2, z3, 3) / std::complex<double>(0, 2 * M_PI);
			F4 = cauchy_F3_n(z, z0, z1, z2, z3, 4) / std::complex<double>(0, 2 * M_PI);
			F5 = cauchy_F3_n(z, z0, z1, z2, z3, 5) / std::complex<double>(0, 2 * M_PI);

			coor_e[0] = 3.0 * z3 * F2 + 2.0 * z2 * F1 + z1 * F0;
			coor_e[1] = 3.0 * z3 * F3 + 2.0 * z2 * F2 + z1 * F1;
			coor_e[2] = 3.0 * z3 * F4 + 2.0 * z2 * F3 + z1 * F2;
			coor_e[3] = 3.0 * z3 * F5 + 2.0 * z2 * F4 + z1 * F3;


			cp_cauchyweights[v_id][3 * i + 0] += coor_e[0] - 3. * coor_e[1] + 3. * coor_e[2] - coor_e[3];
			cp_cauchyweights[v_id][3 * i + 1] += 3.0 * coor_e[1] - 6.0 * coor_e[2] + 3. * coor_e[3];
			cp_cauchyweights[v_id][(3 * i + 2)] += 3. * coor_e[2] - 3. * coor_e[3];
			cp_cauchyweights[v_id][(3 * i + 3) % N] += coor_e[3];

			/*test_eta += coor_e[0] * z0;
			test_eta += coor_e[1] * z1;
			test_eta += coor_e[2] * z2;*/


		}
		//check
		for (int i = 0; i < CC_points.size(); i++)
		{
			complex<double> test_z0(CC_points[i][0], CC_points[i][1]);
			test_eta += cp_cauchyweights[v_id][i] * test_z0;
		}
		/*std::cout << z << endl;
		std::cout << "check:" << test_eta - z << std::endl;*/
		if (abs(test_eta - z) > max_err)
			max_err = abs(test_eta - z);
	}
	std::cout << "计算控制点的柯西权重max norm err:" << max_err << std::endl;
}

//2到2的2阶cauchy权重的计算,次数m=2
void MeshViewerWidget::calculate_D2cauchy_weight222(void)
{
	assert(degree == 2);
	GetBoundaryVertices();
	int N = CC_points.size();
	D2cauchyweights.resize(boundary_vertices.size());
	for (auto& weight : D2cauchyweights) {
		weight.resize(CC_points.size(), std::complex<double>(0.0, 0.0));
	}
	std::vector<complex<double>> coor_e(degree + 1);
	auto poly_Ctps = curvecage2;
	Bezier2Poly2(curvecage2, poly_Ctps);
	double max_err = 0;
	for (int v_id = 0; v_id < boundary_vertices.size(); v_id++) {//v_id表示mesh中的点数
		Mesh::Point eta = boundary_vertices[v_id];
		complex<double> z(eta[0], eta[1]);
		
		for (int i = 0; i < curvecage2.size(); i++)
		{//i表示边界曲线的段数
			auto poly_Ctp = poly_Ctps[i];//每一段曲线，原来的poly_ctp
			auto c0 = poly_Ctp[0]; auto c1 = poly_Ctp[1]; auto c2 = poly_Ctp[2];
			complex<double> z0(c0[0], c0[1]), z1(c1[0], c1[1]), z2(c2[0], c2[1]);
			complex<double> F0, F1, F2, F3, F4, F5;
			F0 = cauchy_D2F2_n(z, z0, z1, z2, 0) / std::complex<double>(0, 2 * M_PI);
			F1 = cauchy_D2F2_n(z, z0, z1, z2, 1) / std::complex<double>(0, 2 * M_PI);
			F2 = cauchy_D2F2_n(z, z0, z1, z2, 2) / std::complex<double>(0, 2 * M_PI);
			F3 = cauchy_D2F2_n(z, z0, z1, z2, 3) / std::complex<double>(0, 2 * M_PI);

			coor_e[ 0] = 2.0 * z2 * F1 + z1 * F0;
			coor_e[ 1] = 2.0 * z2 * F2 + z1 * F1;
			coor_e[ 2] = 2.0 * z2 * F3 + z1 * F2;

			D2cauchyweights[v_id][2 * i + 0] += coor_e[0] - 2. * coor_e[1] + coor_e[2];
			D2cauchyweights[v_id][2 * i + 1] += 2.0 * coor_e[1] - 2.0 * coor_e[2];
			D2cauchyweights[v_id][(2 * i + 2) % N] += coor_e[2];
		}
		
	}
	std::cout << "max norm err:" << max_err << std::endl;
}

//1到1的1阶cage边界cauchy权重的计算,次数m=2
void MeshViewerWidget::calculate_D2cauchy_weight_CB121(void)
{
	assert(degree == 1);
	GetCBoundaryVertices();
	int N = CC_points.size();
	D2cauchyweights.resize(Cboundary_vertices.size());
	for (auto& weight : D2cauchyweights) {
		weight.resize(CC_points.size(), std::complex<double>(0.0, 0.0));
	}
	std::vector<complex<double>> coor_e(degree + 1);
	auto poly_Ctps = curvecage2;
	Bezier1Poly1(curvecage2, poly_Ctps);
	double max_err = 0;
	for (int v_id = 0; v_id < Cboundary_vertices.size(); v_id++) {//v_id表示mesh中的点数
		Mesh::Point eta = Cboundary_vertices[v_id];
		complex<double> z(eta[0], eta[1]);
		//z = complex<double>(0, 0);//testtttttttttttttttttttttttttttttttt
		for (int i = 0; i < curvecage2.size(); i++)
		{//i表示边界曲线的段数
			auto poly_Ctp = poly_Ctps[i];//每一段曲线，原来的poly_ctp
			auto c0 = poly_Ctp[0]; auto c1 = poly_Ctp[1];
			complex<double> z0(c0[0], c0[1]), z1(c1[0], c1[1]);

			complex<double> com_c0 = z0 - z;
			complex<double> w1 = -com_c0 / z1;

			/*w1 = complex<double>(1, 1);
			z1 = complex<double>(3, 4);*/
			std::vector<std::complex<double>> roots_vec = { w1 };
			std::vector<int> root_orders_vec = { 3 };
			std::vector<std::complex<double>> poly_vec0 = { z1,0 };
			std::vector<std::complex<double>> poly_vec1 = { 0,z1 };
			std::vector<std::vector<std::complex<double>>> poly_vec = { poly_vec0,poly_vec1 };

			coor_e = rationalIntes(roots_vec, root_orders_vec, poly_vec);
			//dprint(coor_e[0], coor_e[1]);
			for (auto& coor_e_inner : coor_e) {
				coor_e_inner /= (z1*z1*z1*0.5 * std::complex<double>(0, 2 * M_PI));
			}

			D2cauchyweights[v_id][i + 0] += coor_e[0] - coor_e[1];
			D2cauchyweights[v_id][(i + 1) % N] += coor_e[1];

		}

	}
	std::cout << "计算cage边界的二阶导数max norm err:" << max_err << std::endl;
}

//1到1的1阶cage边界cauchy权重的计算,次数m=2
void MeshViewerWidget::calculate_D2cauchy_weight_CB123(void)
{
	assert(degree == 3);
	GetCBoundaryVertices();
	int N = CC_points.size();
	D2cauchyweights.resize(Cboundary_vertices.size());
	for (auto& weight : D2cauchyweights) {
		weight.resize(CC_points.size(), std::complex<double>(0.0, 0.0));
	}
	std::vector<complex<double>> coor_e(degree + 1);
	auto poly_Ctps = curvecage2;
	auto curvecage2end = curvecage2;
	for (int i = 0; i < curvecage2.size(); i++)
	{
		curvecage2end[i] = std::vector<OpenMesh::Vec3d>{ curvecage2[i][0],curvecage2[i][degree] };
	}
	Bezier1Poly1(curvecage2end, poly_Ctps);
	double max_err = 0;
	for (int v_id = 0; v_id < Cboundary_vertices.size(); v_id++) {//v_id表示mesh中的点数
		Mesh::Point eta = Cboundary_vertices[v_id];
		complex<double> z(eta[0], eta[1]);
		//z = complex<double>(0, 0);//testtttttttttttttttttttttttttttttttt
		for (int i = 0; i < curvecage2.size(); i++)
		{//i表示边界曲线的段数
			auto poly_Ctp = poly_Ctps[i];//每一段曲线，原来的poly_ctp
			auto c0 = poly_Ctp[0]; auto c1 = poly_Ctp[1];
			complex<double> z0(c0[0], c0[1]), z1(c1[0], c1[1]);

			complex<double> com_c0 = z0 - z;
			complex<double> w1 = -com_c0 / z1;

			/*w1 = complex<double>(1, 1);
			z1 = complex<double>(3, 4);*/
			std::vector<std::complex<double>> roots_vec = { w1 };
			std::vector<int> root_orders_vec = { 3 };
			std::vector<std::complex<double>> poly_vec0 = { z1,0 };
			std::vector<std::complex<double>> poly_vec1 = { 0,z1 };
			std::vector<std::complex<double>> poly_vec2 = { 0,0,z1 };
			std::vector<std::complex<double>> poly_vec3 = { 0,0,0,z1 };
			std::vector<std::vector<std::complex<double>>> poly_vec = { poly_vec0,poly_vec1 ,poly_vec2,poly_vec3 };

			coor_e = rationalIntes(roots_vec, root_orders_vec, poly_vec);
			//dprint(coor_e[0], coor_e[1]);
			for (auto& coor_e_inner : coor_e) {
				coor_e_inner /= (z1 * z1 * z1 * 0.5 * std::complex<double>(0, 2 * M_PI));
			}

			D2cauchyweights[v_id][3 * i + 0] += coor_e[0] - 3. * coor_e[1] + 3. * coor_e[2] - coor_e[3];
			D2cauchyweights[v_id][3 * i + 1] += 3.0 * coor_e[1] - 6.0 * coor_e[2] + 3. * coor_e[3];
			D2cauchyweights[v_id][(3 * i + 2)] += 3. * coor_e[2] - 3. * coor_e[3];
			D2cauchyweights[v_id][(3 * i + 3) % N] += coor_e[3];

		}

	}
	std::cout << "计算cage边界的二阶导数max norm err:" << max_err << std::endl;
}

//2到2的2阶cage边界cauchy权重的计算,次数m=2
void MeshViewerWidget::calculate_D2cauchy_weight_CB222(void)
{
	assert(degree == 2);
	GetCBoundaryVertices();
	int N = CC_points.size();
	D2cauchyweights.resize(Cboundary_vertices.size());
	for (auto& weight : D2cauchyweights) {
		weight.resize(CC_points.size(), std::complex<double>(0.0, 0.0));
	}
	std::vector<complex<double>> coor_e(degree + 1);
	auto poly_Ctps = curvecage2;
	Bezier2Poly2(curvecage2, poly_Ctps);
	double max_err = 0;
	for (int v_id = 0; v_id < Cboundary_vertices.size(); v_id++) {//v_id表示mesh中的点数
		Mesh::Point eta = Cboundary_vertices[v_id];
		complex<double> z(eta[0], eta[1]);
		//z = complex<double>(0, 0);//testtttttttttttttttttttttttttttttttt
		for (int i = 0; i < curvecage2.size(); i++)
		{//i表示边界曲线的段数
			auto poly_Ctp = poly_Ctps[i];//每一段曲线，原来的poly_ctp
			auto c0 = poly_Ctp[0]; auto c1 = poly_Ctp[1]; auto c2 = poly_Ctp[2];
			complex<double> z0(c0[0], c0[1]), z1(c1[0], c1[1]), z2(c2[0], c2[1]);
			//z0 = complex<double>(1, 0); z1 = complex<double>(1, 1); z2 = complex<double>(-1, 1);//testttttttttttttttttttttttt
			complex<double> F0, F1, F2, F3, F4, F5;
			F0 = cauchy_D2F2_n(z, z0, z1, z2, 0) / std::complex<double>(0, 2 * M_PI);
			F1 = cauchy_D2F2_n(z, z0, z1, z2, 1) / std::complex<double>(0, 2 * M_PI);
			F2 = cauchy_D2F2_n(z, z0, z1, z2, 2) / std::complex<double>(0, 2 * M_PI);
			F3 = cauchy_D2F2_n(z, z0, z1, z2, 3) / std::complex<double>(0, 2 * M_PI);

			coor_e[0] = 2.0 * z2 * F1 + z1 * F0;
			coor_e[1] = 2.0 * z2 * F2 + z1 * F1;
			coor_e[2] = 2.0 * z2 * F3 + z1 * F2;

			D2cauchyweights[v_id][2 * i + 0] += coor_e[0] - 2. * coor_e[1] + coor_e[2];
			D2cauchyweights[v_id][2 * i + 1] += 2.0 * coor_e[1] - 2.0 * coor_e[2];
			D2cauchyweights[v_id][(2 * i + 2) % N] += coor_e[2];
		}

	}
	std::cout << "计算cage边界的二阶导数max norm err:" << max_err << std::endl;
}

//3到3的3阶cage边界cauchy权重的计算,次数m=2
void MeshViewerWidget::calculate_D2cauchy_weight_CB323(void)
{
	assert(degree == 3);
	GetCBoundaryVertices();
	int N = CC_points.size();
	D2cauchyweights.resize(Cboundary_vertices.size());
	for (auto& weight : D2cauchyweights) {
		weight.resize(CC_points.size(), std::complex<double>(0.0, 0.0));
	}
	std::vector<complex<double>> coor_e(degree + 1);
	auto poly_Ctps = curvecage2;
	Bezier2Poly3(curvecage2, poly_Ctps);
	double max_err = 0;
	for (int v_id = 0; v_id < Cboundary_vertices.size(); v_id++) {//v_id表示mesh中的点数
		Mesh::Point eta = Cboundary_vertices[v_id];
		complex<double> z(eta[0], eta[1]);
		//z = complex<double>(0, 0);//testtttttttttttttttttttttttttttttttt
		for (int i = 0; i < curvecage2.size(); i++)
		{//i表示边界曲线的段数
			auto poly_Ctp = poly_Ctps[i];//每一段曲线，原来的poly_ctp
			auto c0 = poly_Ctp[0]; auto c1 = poly_Ctp[1]; auto c2 = poly_Ctp[2]; auto c3 = poly_Ctp[3];
			complex<double> z0(c0[0], c0[1]), z1(c1[0], c1[1]), z2(c2[0], c2[1]), z3(c3[0], c3[1]);
			//z0 = complex<double>(1, 0); z1 = complex<double>(1, 1); z2 = complex<double>(-1, 1); z3 = complex<double>(0, 1);//testttttttttttttttttttttttt
			complex<double> F0, F1, F2, F3, F4, F5;
			F0 = cauchy_D2F3_n(z, z0, z1, z2, z3, 0) / std::complex<double>(0, 2 * M_PI);
			F1 = cauchy_D2F3_n(z, z0, z1, z2, z3, 1) / std::complex<double>(0, 2 * M_PI);
			F2 = cauchy_D2F3_n(z, z0, z1, z2, z3, 2) / std::complex<double>(0, 2 * M_PI);
			F3 = cauchy_D2F3_n(z, z0, z1, z2, z3, 3) / std::complex<double>(0, 2 * M_PI);
			F4 = cauchy_D2F3_n(z, z0, z1, z2, z3, 4) / std::complex<double>(0, 2 * M_PI);
			F5 = cauchy_D2F3_n(z, z0, z1, z2, z3, 5) / std::complex<double>(0, 2 * M_PI);

			coor_e[0] = 3.0 * z3 * F2 + 2.0 * z2 * F1 + z1 * F0;
			coor_e[1] = 3.0 * z3 * F3 + 2.0 * z2 * F2 + z1 * F1;
			coor_e[2] = 3.0 * z3 * F4 + 2.0 * z2 * F3 + z1 * F2;
			coor_e[3] = 3.0 * z3 * F5 + 2.0 * z2 * F4 + z1 * F3;


			D2cauchyweights[v_id][3 * i + 0] += coor_e[0] - 3. * coor_e[1] + 3. * coor_e[2] - coor_e[3];
			D2cauchyweights[v_id][3 * i + 1] += 3.0 * coor_e[1] - 6.0 * coor_e[2] + 3. * coor_e[3];
			D2cauchyweights[v_id][(3 * i + 2)] += 3. * coor_e[2] - 3. * coor_e[3];
			D2cauchyweights[v_id][(3 * i + 3) % N] += coor_e[3];
		}

	}
	std::cout << "计算cage边界的二阶导数max norm err:" << max_err << std::endl;
}

//2到1的权重计算,次数m=2
void MeshViewerWidget::calculate_green_weight221(void)
{
	assert(degree == 2);
	auto arthono = [](const Mesh::Point& p) -> Mesh::Point {
		return Mesh::Point(p[1], -p[0], p[2]);
	};

	weights.resize(mesh.n_vertices());
	int N = 2 * todegree + 1;
	for (auto& weight : weights) {
		weight.resize(curvecage2.size() * N);//使用论文中的每段曲线使用幂基来计算
	}
	auto poly_Ctps = curvecage2;
	Bezier2Poly2(curvecage2, poly_Ctps);
	double max_err = 0;
	for (int v_id = 0; v_id < mesh.n_vertices(); v_id++) {//v_id表示mesh中的点数
		auto vh = mesh.vertex_handle(v_id);
		Mesh::Point eta = mesh.point(vh);
		//Mesh::Point eta(0, 0, 0);
		Mesh::Point test_eta(0, 0, 0);//check equality
		for (int i = 0; i < curvecage2.size(); i++)
		{//i表示边界曲线的段数
			auto poly_Ctp = poly_Ctps[i];//每一段曲线，原来的poly_ctp
			auto c0 = poly_Ctp[0]; auto c1 = poly_Ctp[1]; auto c2 = poly_Ctp[2];
			double F0, F1, F2, F3, F4, F5;
			F0 = F2_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], 0);
			F1 = F2_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], 1);
			F2 = F2_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], 2);
			F3 = F2_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], 3);
			F4 = F2_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], 4);
			F5 = F2_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], 5);
			weights[v_id][N * i + 0] = (c0 - eta).dot(arthono(c1)) * F0 + 2 * (c0 - eta).dot(arthono(c2)) * F1 + (c1).dot(arthono(c2)) * F2;
			weights[v_id][N * i + 1] = (c0 - eta).dot(arthono(c1)) * F1 + 2 * (c0 - eta).dot(arthono(c2)) * F2 + (c1).dot(arthono(c2)) * F3;
			
			weights[v_id][N * i + 2] = (c0 - eta).dot(c1) * F1 + (c1.dot(c1) + 2 * (c0 - eta).dot(c2)) * F2 + 3 * (c1).dot(c2) * F3 + 2 * c2.dot(c2) * F4 - log(norm(c0 + c1 + c2 - eta)) / (2 * M_PI);
			
		}
		//check
	
		//std::cout << eta << endl;
		//std::cout << "check:" << test_eta-eta << std::endl;
		/*if ((test_eta - eta).norm() > max_err)
			max_err = (test_eta - eta).norm();*/
	}
	std::cout << "max norm err:" << max_err << std::endl;


}
//2到3的权重计算,次数m=2
void MeshViewerWidget::calculate_green_weight223(void)
{
	assert(degree == 2);
	auto arthono = [](const Mesh::Point& p) -> Mesh::Point {
		return Mesh::Point(p[1], -p[0], p[2]);
	};

	weights.resize(mesh.n_vertices());
	int N = 2 * todegree + 1;
	for (auto& weight : weights) {
		weight.resize(curvecage2.size() * N);//使用论文中的每段曲线使用幂基来计算
	}
	auto poly_Ctps = curvecage2;
	Bezier2Poly2(curvecage2, poly_Ctps);
	double max_err = 0;
	for (int v_id = 0; v_id < mesh.n_vertices(); v_id++) {//v_id表示mesh中的点数
		auto vh = mesh.vertex_handle(v_id);
		Mesh::Point eta = mesh.point(vh);
		//Mesh::Point eta(0, 0, 0);
		Mesh::Point test_eta(0, 0, 0);//check equality
		for (int i = 0; i < curvecage2.size(); i++)
		{//i表示边界曲线的段数
			auto poly_Ctp = poly_Ctps[i];//每一段曲线，原来的poly_ctp
			auto c0 = poly_Ctp[0]; auto c1 = poly_Ctp[1]; auto c2 = poly_Ctp[2];
			double F0, F1, F2, F3, F4, F5, F6;
			F0 = F2_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], 0);
			F1 = F2_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], 1);
			F2 = F2_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], 2);
			F3 = F2_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], 3);
			F4 = F2_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], 4);
			F5 = F2_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], 5);
			F6 = F2_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], 6);
			weights[v_id][N * i + 0] = (c0 - eta).dot(arthono(c1)) * F0 + 2 * (c0 - eta).dot(arthono(c2)) * F1 + (c1).dot(arthono(c2)) * F2;
			weights[v_id][N * i + 1] = (c0 - eta).dot(arthono(c1)) * F1 + 2 * (c0 - eta).dot(arthono(c2)) * F2 + (c1).dot(arthono(c2)) * F3;
			weights[v_id][N * i + 2] = (c0 - eta).dot(arthono(c1)) * F2 + 2 * (c0 - eta).dot(arthono(c2)) * F3 + (c1).dot(arthono(c2)) * F4;
			weights[v_id][N * i + 3] = (c0 - eta).dot(arthono(c1)) * F3 + 2 * (c0 - eta).dot(arthono(c2)) * F4 + (c1).dot(arthono(c2)) * F5;
			weights[v_id][N * i + 4] = (c0 - eta).dot(c1) * F1 + (c1.dot(c1) + 2 * (c0 - eta).dot(c2)) * F2 + 3 * (c1).dot(c2) * F3 + 2 * c2.dot(c2) * F4 - log(norm(c0 + c1 + c2 - eta)) / (2 * M_PI);
			weights[v_id][N * i + 5] = (c0 - eta).dot(c1) * F2 + (c1.dot(c1) + 2 * (c0 - eta).dot(c2)) * F3 + 3 * (c1).dot(c2) * F4 + 2 * c2.dot(c2) * F5 - log(norm(c0 + c1 + c2 - eta)) / (2 * M_PI);
			weights[v_id][N * i + 6] = (c0 - eta).dot(c1) * F3 + (c1.dot(c1) + 2 * (c0 - eta).dot(c2)) * F4 + 3 * (c1).dot(c2) * F5 + 2 * c2.dot(c2) * F6 - log(norm(c0 + c1 + c2 - eta)) / (2 * M_PI);
			
		}
		
	}
	std::cout << "max norm err:" << max_err << std::endl;


}

//2到7的权重计算,次数m=2
void MeshViewerWidget::calculate_green_weight227(void)
{
	assert(degree == 2);
	auto arthono = [](const Mesh::Point& p) -> Mesh::Point {
		return Mesh::Point(p[1], -p[0], p[2]);
	};

	weights.resize(mesh.n_vertices());
	int N = 2 * todegree + 1;
	for (auto& weight : weights) {
		weight.resize(curvecage2.size() * N);//使用论文中的每段曲线使用幂基来计算
	}
	auto poly_Ctps = curvecage2;
	Bezier2Poly2(curvecage2, poly_Ctps);
	double max_err = 0;
	for (int v_id = 0; v_id < mesh.n_vertices(); v_id++) {//v_id表示mesh中的点数
		auto vh = mesh.vertex_handle(v_id);
		Mesh::Point eta = mesh.point(vh);
		//Mesh::Point eta(0, 0, 0);
		Mesh::Point test_eta(0, 0, 0);//check equality
		for (int i = 0; i < curvecage2.size(); i++)
		{//i表示边界曲线的段数
			auto poly_Ctp = poly_Ctps[i];//每一段曲线，原来的poly_ctp
			auto c0 = poly_Ctp[0]; auto c1 = poly_Ctp[1]; auto c2 = poly_Ctp[2];
			double F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10;
			F0 = F2_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], 0);
			F1 = F2_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], 1);
			F2 = F2_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], 2);
			F3 = F2_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], 3);
			F4 = F2_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], 4);
			F5 = F2_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], 5);
			F6 = F2_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], 6);
			F7 = F2_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], 7);
			F8 = F2_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], 8);
			F9 = F2_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], 9);
			F10 = F2_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], 10);
			weights[v_id][N * i + 0] = (c0 - eta).dot(arthono(c1)) * F0 + 2 * (c0 - eta).dot(arthono(c2)) * F1 + (c1).dot(arthono(c2)) * F2;
			weights[v_id][N * i + 1] = (c0 - eta).dot(arthono(c1)) * F1 + 2 * (c0 - eta).dot(arthono(c2)) * F2 + (c1).dot(arthono(c2)) * F3;
			weights[v_id][N * i + 2] = (c0 - eta).dot(arthono(c1)) * F2 + 2 * (c0 - eta).dot(arthono(c2)) * F3 + (c1).dot(arthono(c2)) * F4;
			weights[v_id][N * i + 3] = (c0 - eta).dot(arthono(c1)) * F3 + 2 * (c0 - eta).dot(arthono(c2)) * F4 + (c1).dot(arthono(c2)) * F5;
			weights[v_id][N * i + 4] = (c0 - eta).dot(arthono(c1)) * F4 + 2 * (c0 - eta).dot(arthono(c2)) * F5 + (c1).dot(arthono(c2)) * F6;
			weights[v_id][N * i + 5] = (c0 - eta).dot(arthono(c1)) * F5 + 2 * (c0 - eta).dot(arthono(c2)) * F6 + (c1).dot(arthono(c2)) * F7;
			weights[v_id][N * i + 6] = (c0 - eta).dot(arthono(c1)) * F6 + 2 * (c0 - eta).dot(arthono(c2)) * F7 + (c1).dot(arthono(c2)) * F8;
			weights[v_id][N * i + 7] = (c0 - eta).dot(arthono(c1)) * F7 + 2 * (c0 - eta).dot(arthono(c2)) * F8 + (c1).dot(arthono(c2)) * F9;
			weights[v_id][N * i + 8] = (c0 - eta).dot(c1) * F1 + (c1.dot(c1) + 2 * (c0 - eta).dot(c2)) * F2 + 3 * (c1).dot(c2) * F3 + 2 * c2.dot(c2) * F4 - log(norm(c0 + c1 + c2 - eta)) / (2 * M_PI);
			weights[v_id][N * i + 9] = (c0 - eta).dot(c1) * F2 + (c1.dot(c1) + 2 * (c0 - eta).dot(c2)) * F3 + 3 * (c1).dot(c2) * F4 + 2 * c2.dot(c2) * F5 - log(norm(c0 + c1 + c2 - eta)) / (2 * M_PI);
			weights[v_id][N * i + 10] = (c0 - eta).dot(c1) * F3 + (c1.dot(c1) + 2 * (c0 - eta).dot(c2)) * F4 + 3 * (c1).dot(c2) * F5 + 2 * c2.dot(c2) * F6 - log(norm(c0 + c1 + c2 - eta)) / (2 * M_PI);
			weights[v_id][N * i + 11] = (c0 - eta).dot(c1) * F4 + (c1.dot(c1) + 2 * (c0 - eta).dot(c2)) * F5 + 3 * (c1).dot(c2) * F6 + 2 * c2.dot(c2) * F7 - log(norm(c0 + c1 + c2 - eta)) / (2 * M_PI);
			weights[v_id][N * i + 12] = (c0 - eta).dot(c1) * F5 + (c1.dot(c1) + 2 * (c0 - eta).dot(c2)) * F6 + 3 * (c1).dot(c2) * F7 + 2 * c2.dot(c2) * F8 - log(norm(c0 + c1 + c2 - eta)) / (2 * M_PI);
			weights[v_id][N * i + 13] = (c0 - eta).dot(c1) * F6 + (c1.dot(c1) + 2 * (c0 - eta).dot(c2)) * F7 + 3 * (c1).dot(c2) * F8 + 2 * c2.dot(c2) * F9 - log(norm(c0 + c1 + c2 - eta)) / (2 * M_PI);
			weights[v_id][N * i + 14] = (c0 - eta).dot(c1) * F7 + (c1.dot(c1) + 2 * (c0 - eta).dot(c2)) * F8 + 3 * (c1).dot(c2) * F9 + 2 * c2.dot(c2) * F10 - log(norm(c0 + c1 + c2 - eta)) / (2 * M_PI);


		}

	}
	std::cout << "max norm err:" << max_err << std::endl;


}


//特殊的1到3的权重计算，第一条边是三次的
void MeshViewerWidget::calculate_specialgreen_weight123(const std::vector<int>& sp_id)
{
	assert(degree == 3);
	auto arthono = [](const Mesh::Point& p) -> Mesh::Point {
		return Mesh::Point(p[1], -p[0], p[2]);
	};

	weights.resize(mesh.n_vertices());
	for (auto& weight : weights) {
		weight.resize(curvecage2.size() * (2 * degree + 1));//使用论文中的每段曲线使用幂基来计算
	}
	std::vector<std::vector<OpenMesh::Vec3d>> poly_Ctps;
	poly_Ctps.resize(curvecage2.size());
	std::vector<std::vector<OpenMesh::Vec3d>> poly_Ctps_pro = curvecage2;
	Bezier2Poly3(curvecage2, poly_Ctps_pro);
	for (auto spi : sp_id)
		poly_Ctps[spi] = poly_Ctps_pro[spi];
	//poly_Ctps[0] = poly_Ctps_pro[0];
	for (int i = 0; i < poly_Ctps.size(); i++)//从分为两拨
	{
		bool isspec = false;
		for (int spn = 0; spn < sp_id.size(); spn++) {
			if (i == sp_id[spn]) {
				isspec = true;
				poly_Ctps[i] = poly_Ctps_pro[i];
			}
		}
		if (isspec == false) {
			poly_Ctps[i].push_back(curvecage2[i][0]);
			poly_Ctps[i].push_back(curvecage2[i][3] - curvecage2[i][0]);
		}
	}

	double max_err = 0;
	for (int v_id = 0; v_id < mesh.n_vertices(); v_id++) {//v_id表示mesh中的点数
		auto vh = mesh.vertex_handle(v_id);
		Mesh::Point eta = mesh.point(vh);
		//Mesh::Point eta(0, 0, 0);
		Mesh::Point test_eta(0, 0, 0);//check equality
		for (auto i : sp_id)
		{//i表示边界曲线的段数,现在对于第一条边求三次的权重
			auto poly_Ctp = poly_Ctps[i];//每一段曲线，原来的poly_ctp
			auto c0 = poly_Ctp[0]; auto c1 = poly_Ctp[1]; auto c2 = poly_Ctp[2]; auto c3 = poly_Ctp[3];
			double F0, F1, F2, F3, F4, F5, F6, F7, F8;
			F0 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 0);
			F1 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 1);
			F2 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 2);
			F3 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 3);
			F4 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 4);
			F5 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 5);
			F6 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 6);
			F7 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 7);
			F8 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 8);
			weights[v_id][(2 * degree + 1) * i + 0] = (c0 - eta).dot(arthono(c1)) * F0 + 2 * (c0 - eta).dot(arthono(c2)) * F1
				+ (3 * (c0 - eta).dot(arthono(c3)) + 4 / 3 * (c1).dot(arthono(c2)) + 1 / 3 * c2.dot(arthono(c3))) * F2 + 2 * c1.dot(arthono(c3)) * F3 + c2.dot(arthono(c3)) * F4;

			weights[v_id][(2 * degree + 1) * i + 1] = (c0 - eta).dot(arthono(c1)) * F1 + 2 * (c0 - eta).dot(arthono(c2)) * F2
				+ (3 * (c0 - eta).dot(arthono(c3)) + 4 / 3 * (c1).dot(arthono(c2)) + 1 / 3 * c2.dot(arthono(c3))) * F3 + 2 * c1.dot(arthono(c3)) * F4 + c2.dot(arthono(c3)) * F5;

			weights[v_id][(2 * degree + 1) * i + 2] = (c0 - eta).dot(arthono(c1)) * F2 + 2 * (c0 - eta).dot(arthono(c2)) * F3
				+ (3 * (c0 - eta).dot(arthono(c3)) + 4 / 3 * (c1).dot(arthono(c2)) + 1 / 3 * c2.dot(arthono(c3))) * F4 + 2 * c1.dot(arthono(c3)) * F5 + c2.dot(arthono(c3)) * F6;

			weights[v_id][(2 * degree + 1) * i + 3] = (c0 - eta).dot(arthono(c1)) * F3 + 2 * (c0 - eta).dot(arthono(c2)) * F4
				+ (3 * (c0 - eta).dot(arthono(c3)) + 4 / 3 * (c1).dot(arthono(c2)) + 1 / 3 * c2.dot(arthono(c3))) * F5 + 2 * c1.dot(arthono(c3)) * F6 + c2.dot(arthono(c3)) * F7;

			weights[v_id][(2 * degree + 1) * i + 4] = (c0 - eta).dot(c1) * F1 + (c1.dot(c1) + 2 * (c0 - eta).dot(c2)) * F2 + (3 * (c1).dot(c2) + 3 * (c0 - eta).dot(c3)) * F3
				+ (2 * c2.dot(c2) + 4 * c1.dot(c3)) * F4 + 5 * c2.dot(c3) * F5 + 3 * c3.dot(c3) * F6 - log(norm(c0 + c1 + c2 + c3 - eta)) / (2 * M_PI);

			weights[v_id][(2 * degree + 1) * i + 5] = (c0 - eta).dot(c1) * F2 + (c1.dot(c1) + 2 * (c0 - eta).dot(c2)) * F3 + (3 * (c1).dot(c2) + 3 * (c0 - eta).dot(c3)) * F4
				+ (2 * c2.dot(c2) + 4 * c1.dot(c3)) * F5 + 5 * c2.dot(c3) * F6 + 3 * c3.dot(c3) * F7 - log(norm(c0 + c1 + c2 + c3 - eta)) / (2 * M_PI);

			weights[v_id][(2 * degree + 1) * i + 6] = (c0 - eta).dot(c1) * F3 + (c1.dot(c1) + 2 * (c0 - eta).dot(c2)) * F4 + (3 * (c1).dot(c2) + 3 * (c0 - eta).dot(c3)) * F5
				+ (2 * c2.dot(c2) + 4 * c1.dot(c3)) * F6 + 5 * c2.dot(c3) * F7 + 3 * c3.dot(c3) * F8 - log(norm(c0 + c1 + c2 + c3 - eta)) / (2 * M_PI);

			test_eta += weights[v_id][(2 * degree + 1) * i + 0] * poly_Ctp[0];
			test_eta += weights[v_id][(2 * degree + 1) * i + 1] * poly_Ctp[1];
			test_eta += weights[v_id][(2 * degree + 1) * i + 2] * poly_Ctp[2];
			test_eta += weights[v_id][(2 * degree + 1) * i + 3] * poly_Ctp[3];
			test_eta += weights[v_id][(2 * degree + 1) * i + 4] * arthono(poly_Ctp[1]);
			test_eta += weights[v_id][(2 * degree + 1) * i + 5] * arthono(poly_Ctp[2]);
			test_eta += weights[v_id][(2 * degree + 1) * i + 6] * arthono(poly_Ctp[3]);
		}
		for (int i = 0; i < curvecage2.size(); i++)
		{//i表示边界曲线的段数
			if (poly_Ctps[i].size() == 2) {
				auto poly_Ctp = poly_Ctps[i];//每一段曲线，原来的poly_ctp
				auto c0 = poly_Ctp[0]; auto c1 = poly_Ctp[1];
				double F0, F1, F2, F3, F4, F5, F6, F7, F8;
				F0 = F1_n(eta, poly_Ctp[0], poly_Ctp[1], 0);
				F1 = F1_n(eta, poly_Ctp[0], poly_Ctp[1], 1);
				F2 = F1_n(eta, poly_Ctp[0], poly_Ctp[1], 2);
				F3 = F1_n(eta, poly_Ctp[0], poly_Ctp[1], 3);
				F4 = F1_n(eta, poly_Ctp[0], poly_Ctp[1], 4);
				F5 = F1_n(eta, poly_Ctp[0], poly_Ctp[1], 5);
				F6 = F1_n(eta, poly_Ctp[0], poly_Ctp[1], 6);
				F7 = F1_n(eta, poly_Ctp[0], poly_Ctp[1], 7);
				F8 = F1_n(eta, poly_Ctp[0], poly_Ctp[1], 8);
				weights[v_id][(2 * degree + 1) * i + 0] = (c0 - eta).dot(arthono(c1)) * F0;

				weights[v_id][(2 * degree + 1) * i + 1] = (c0 - eta).dot(arthono(c1)) * F1;

				weights[v_id][(2 * degree + 1) * i + 2] = (c0 - eta).dot(arthono(c1)) * F2;

				weights[v_id][(2 * degree + 1) * i + 3] = (c0 - eta).dot(arthono(c1)) * F3;

				weights[v_id][(2 * degree + 1) * i + 4] = (c0 - eta).dot(c1) * F1 + (c1.dot(c1)) * F2 - log(norm(c0 + c1 - eta)) / (2 * M_PI);

				weights[v_id][(2 * degree + 1) * i + 5] = (c0 - eta).dot(c1) * F2 + (c1.dot(c1)) * F3 - log(norm(c0 + c1 - eta)) / (2 * M_PI);

				weights[v_id][(2 * degree + 1) * i + 6] = (c0 - eta).dot(c1) * F3 + (c1.dot(c1)) * F4 - log(norm(c0 + c1 - eta)) / (2 * M_PI);

				test_eta += weights[v_id][(2 * degree + 1) * i + 0] * poly_Ctp[0];
				test_eta += weights[v_id][(2 * degree + 1) * i + 1] * poly_Ctp[1];
				test_eta += weights[v_id][(2 * degree + 1) * i + 2] * (OpenMesh::Vec3d(0, 0, 0));
				test_eta += weights[v_id][(2 * degree + 1) * i + 3] * (OpenMesh::Vec3d(0, 0, 0));
				test_eta += weights[v_id][(2 * degree + 1) * i + 4] * arthono(poly_Ctp[1]);
				test_eta += weights[v_id][(2 * degree + 1) * i + 5] * (OpenMesh::Vec3d(0, 0, 0));
				test_eta += weights[v_id][(2 * degree + 1) * i + 6] * (OpenMesh::Vec3d(0, 0, 0));
			}
		}
		//check
		/*std::cout << F2_n(Mesh::Point{ 0,0,0 }, Mesh::Point{ 1,0,0 }, Mesh::Point{ 0,1,0 }, Mesh::Point{ -0.5,1,0 }, 0) << std::endl;
		std::cout << F2_n(Mesh::Point{ 0,0,0 }, Mesh::Point{ 1,0,0 }, Mesh::Point{ 0,1,0 }, Mesh::Point{ -0.5,1,0 }, 1) << std::endl;
		std::cout << F2_n(Mesh::Point{ 0,0,0 }, Mesh::Point{ 1,0,0 }, Mesh::Point{ 0,1,0 }, Mesh::Point{ -0.5,1,0 }, 2) << std::endl;
		std::cout << F2_n(Mesh::Point{ 0,0,0 }, Mesh::Point{ 1,0,0 }, Mesh::Point{ 0,1,0 }, Mesh::Point{ -0.5,1,0 }, 5) << std::endl;*/
		//std::cout << eta << endl;
		//std::cout << "check:" << test_eta - eta << std::endl;
		if ((test_eta - eta).norm() > max_err)
			max_err = (test_eta - eta).norm();
	}
	std::cout << "max norm err:" << max_err << std::endl;

}


//1到3的权重计算
void MeshViewerWidget::calculate_green_weight123(void)
{
	assert(degree == 3);
	auto arthono = [](const Mesh::Point& p) -> Mesh::Point {
		return Mesh::Point(p[1], -p[0], p[2]);
	};

	weights.resize(mesh.n_vertices());
	for (auto& weight : weights) {
		weight.resize(curvecage2.size() * (2 * degree + 1));//使用论文中的每段曲线使用幂基来计算
	}
	std::vector<std::vector<OpenMesh::Vec3d>> poly_Ctps;
	poly_Ctps.resize(curvecage2.size());
	for (int i = 0; i < poly_Ctps.size(); i++)
	{
		poly_Ctps[i].push_back(curvecage2[i][0]);
		poly_Ctps[i].push_back(curvecage2[i][3]-curvecage2[i][0]);
	}
	
	double max_err = 0;
	for (int v_id = 0; v_id < mesh.n_vertices(); v_id++) {//v_id表示mesh中的点数
		auto vh = mesh.vertex_handle(v_id);
		Mesh::Point eta = mesh.point(vh);
		//Mesh::Point eta(0, 0, 0);
		Mesh::Point test_eta(0, 0, 0);//check equality
		for (int i = 0; i < curvecage2.size(); i++)
		{//i表示边界曲线的段数
			auto poly_Ctp = poly_Ctps[i];//每一段曲线，原来的poly_ctp
			auto c0 = poly_Ctp[0]; auto c1 = poly_Ctp[1]; 
			double F0, F1, F2, F3, F4, F5, F6, F7, F8;
			F0 = F1_n(eta, poly_Ctp[0], poly_Ctp[1], 0);
			F1 = F1_n(eta, poly_Ctp[0], poly_Ctp[1], 1);
			F2 = F1_n(eta, poly_Ctp[0], poly_Ctp[1], 2);
			F3 = F1_n(eta, poly_Ctp[0], poly_Ctp[1], 3);
			F4 = F1_n(eta, poly_Ctp[0], poly_Ctp[1], 4);
			F5 = F1_n(eta, poly_Ctp[0], poly_Ctp[1], 5);
			F6 = F1_n(eta, poly_Ctp[0], poly_Ctp[1], 6);
			F7 = F1_n(eta, poly_Ctp[0], poly_Ctp[1], 7);
			F8 = F1_n(eta, poly_Ctp[0], poly_Ctp[1], 8);
			weights[v_id][(2 * degree + 1) * i + 0] = (c0 - eta).dot(arthono(c1)) * F0 ;

			weights[v_id][(2 * degree + 1) * i + 1] = (c0 - eta).dot(arthono(c1)) * F1 ;

			weights[v_id][(2 * degree + 1) * i + 2] = (c0 - eta).dot(arthono(c1)) * F2 ;

			weights[v_id][(2 * degree + 1) * i + 3] = (c0 - eta).dot(arthono(c1)) * F3 ;

			weights[v_id][(2 * degree + 1) * i + 4] = (c0 - eta).dot(c1) * F1 + (c1.dot(c1)) * F2  - log(norm(c0 + c1 - eta)) / (2 * M_PI);

			weights[v_id][(2 * degree + 1) * i + 5] = (c0 - eta).dot(c1) * F2 + (c1.dot(c1)) * F3  - log(norm(c0 + c1 - eta)) / (2 * M_PI);

			weights[v_id][(2 * degree + 1) * i + 6] = (c0 - eta).dot(c1) * F3 + (c1.dot(c1)) * F4  - log(norm(c0 + c1 - eta)) / (2 * M_PI);

			test_eta += weights[v_id][(2 * degree + 1) * i + 0] * poly_Ctp[0];
			test_eta += weights[v_id][(2 * degree + 1) * i + 1] * poly_Ctp[1];
			test_eta += weights[v_id][(2 * degree + 1) * i + 2] * (OpenMesh::Vec3d(0,0,0));
			test_eta += weights[v_id][(2 * degree + 1) * i + 3] * (OpenMesh::Vec3d(0, 0, 0));
			test_eta += weights[v_id][(2 * degree + 1) * i + 4] * arthono(poly_Ctp[1]);
			test_eta += weights[v_id][(2 * degree + 1) * i + 5] * (OpenMesh::Vec3d(0, 0, 0));
			test_eta += weights[v_id][(2 * degree + 1) * i + 6] * (OpenMesh::Vec3d(0, 0, 0));
		}
		//check
		/*std::cout << F2_n(Mesh::Point{ 0,0,0 }, Mesh::Point{ 1,0,0 }, Mesh::Point{ 0,1,0 }, Mesh::Point{ -0.5,1,0 }, 0) << std::endl;
		std::cout << F2_n(Mesh::Point{ 0,0,0 }, Mesh::Point{ 1,0,0 }, Mesh::Point{ 0,1,0 }, Mesh::Point{ -0.5,1,0 }, 1) << std::endl;
		std::cout << F2_n(Mesh::Point{ 0,0,0 }, Mesh::Point{ 1,0,0 }, Mesh::Point{ 0,1,0 }, Mesh::Point{ -0.5,1,0 }, 2) << std::endl;
		std::cout << F2_n(Mesh::Point{ 0,0,0 }, Mesh::Point{ 1,0,0 }, Mesh::Point{ 0,1,0 }, Mesh::Point{ -0.5,1,0 }, 5) << std::endl;*/
		//std::cout << eta << endl;
		//std::cout << "check:" << test_eta - eta << std::endl;
		if ((test_eta - eta).norm() > max_err)
			max_err = (test_eta - eta).norm();
	}
	std::cout << "max norm err:" << max_err << std::endl;

}

//1到1的权重计算
void MeshViewerWidget::calculate_green_weight121(void)
{
	assert(degree == 1);
	auto arthono = [](const Mesh::Point& p) -> Mesh::Point {
		return Mesh::Point(p[1], -p[0], p[2]);
	};

	weights.resize(mesh.n_vertices());
	for (auto& weight : weights) {
		weight.resize(curvecage2.size() * (2 * degree + 1));//使用论文中的每段曲线使用幂基来计算
	}
	std::vector<std::vector<OpenMesh::Vec3d>> poly_Ctps;
	poly_Ctps.resize(curvecage2.size());
	for (int i = 0; i < poly_Ctps.size(); i++)
	{
		poly_Ctps[i].push_back(curvecage2[i][0]);
		poly_Ctps[i].push_back(curvecage2[i][degree] - curvecage2[i][0]);
	}

	double max_err = 0;
	for (int v_id = 0; v_id < mesh.n_vertices(); v_id++) {//v_id表示mesh中的点数
		auto vh = mesh.vertex_handle(v_id);
		Mesh::Point eta = mesh.point(vh);
		//Mesh::Point eta(0, 0, 0);
		Mesh::Point test_eta(0, 0, 0);//check equality
		for (int i = 0; i < curvecage2.size(); i++)
		{//i表示边界曲线的段数
			auto poly_Ctp = poly_Ctps[i];//每一段曲线，原来的poly_ctp
			auto c0 = poly_Ctp[0]; auto c1 = poly_Ctp[1];
			double F0, F1, F2;
			F0 = F1_n(eta, poly_Ctp[0], poly_Ctp[1], 0);
			F1 = F1_n(eta, poly_Ctp[0], poly_Ctp[1], 1);
			F2 = F1_n(eta, poly_Ctp[0], poly_Ctp[1], 2);
			if (std::isnan(F0)) {
				std::cout << "F0 is NaN." << std::endl;
			}
			if (std::isnan(F1)) {
				std::cout << "F1 is NaN." << std::endl;
			}
			if (std::isnan(F2)) {
				std::cout << "F2 is NaN." << std::endl;
			}
			
			weights[v_id][(2 * degree + 1) * i + 0] = (c0 - eta).dot(arthono(c1)) * F0;

			weights[v_id][(2 * degree + 1) * i + 1] = (c0 - eta).dot(arthono(c1)) * F1;

			weights[v_id][(2 * degree + 1) * i + 2] = (c0 - eta).dot(c1) * F1 + (c1.dot(c1)) * F2 - log(norm(c0 + c1 - eta)) / (2 * M_PI);


			test_eta += weights[v_id][(2 * degree + 1) * i + 0] * poly_Ctp[0];
			test_eta += weights[v_id][(2 * degree + 1) * i + 1] * poly_Ctp[1];
			test_eta += weights[v_id][(2 * degree + 1) * i + 2] * arthono(poly_Ctp[1]);
			
		}
		//check
		/*std::cout << F2_n(Mesh::Point{ 0,0,0 }, Mesh::Point{ 1,0,0 }, Mesh::Point{ 0,1,0 }, Mesh::Point{ -0.5,1,0 }, 0) << std::endl;
		std::cout << F2_n(Mesh::Point{ 0,0,0 }, Mesh::Point{ 1,0,0 }, Mesh::Point{ 0,1,0 }, Mesh::Point{ -0.5,1,0 }, 1) << std::endl;
		std::cout << F2_n(Mesh::Point{ 0,0,0 }, Mesh::Point{ 1,0,0 }, Mesh::Point{ 0,1,0 }, Mesh::Point{ -0.5,1,0 }, 2) << std::endl;
		std::cout << F2_n(Mesh::Point{ 0,0,0 }, Mesh::Point{ 1,0,0 }, Mesh::Point{ 0,1,0 }, Mesh::Point{ -0.5,1,0 }, 5) << std::endl;*/
		//std::cout << eta << endl;
		//std::cout << "check:" << test_eta - eta << std::endl;
		if ((test_eta - eta).norm() > max_err)
			max_err = (test_eta - eta).norm();
	}
	std::cout << "max norm err:" << max_err << std::endl;

}
//3到1的权重计算
void MeshViewerWidget::calculate_green_weight321(void)
{
	assert(degree == 3);
	auto arthono = [](const Mesh::Point& p) -> Mesh::Point {
		return Mesh::Point(p[1], -p[0], p[2]);
	};

	weights.resize(mesh.n_vertices());
	int N = 2 * todegree + 1;
	for (auto& weight : weights) {
		weight.resize(curvecage2.size() * N);//使用论文中的每段曲线使用幂基来计算
	}
	auto poly_Ctps = curvecage2;
	Bezier2Poly3(curvecage2, poly_Ctps);
	double max_err = 0;
	for (int v_id = 0; v_id < mesh.n_vertices(); v_id++) {//v_id表示mesh中的点数
		auto vh = mesh.vertex_handle(v_id);
		Mesh::Point eta = mesh.point(vh);
		//Mesh::Point eta(0, 0, 0);
		Mesh::Point test_eta(0, 0, 0);//check equality
		for (int i = 0; i < curvecage2.size(); i++)
		{//i表示边界曲线的段数
			auto poly_Ctp = poly_Ctps[i];//每一段曲线，原来的poly_ctp
			auto c0 = poly_Ctp[0]; auto c1 = poly_Ctp[1]; auto c2 = poly_Ctp[2]; auto c3 = poly_Ctp[3];
			double F0, F1, F2, F3, F4, F5, F6, F7, F8;
			F0 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 0);
			F1 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 1);
			F2 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 2);
			F3 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 3);
			F4 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 4);
			F5 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 5);
			F6 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 6);
			F7 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 7);
			F8 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 8);
			weights[v_id][N * i + 0] = (c0 - eta).dot(arthono(c1)) * F0 + 2 * (c0 - eta).dot(arthono(c2)) * F1
				+ (3 * (c0 - eta).dot(arthono(c3)) + 4 / 3 * (c1).dot(arthono(c2)) + 1 / 3 * c2.dot(arthono(c3))) * F2 + 2 * c1.dot(arthono(c3)) * F3 + c2.dot(arthono(c3)) * F4;

			weights[v_id][N * i + 1] = (c0 - eta).dot(arthono(c1)) * F1 + 2 * (c0 - eta).dot(arthono(c2)) * F2
				+ (3 * (c0 - eta).dot(arthono(c3)) + 4 / 3 * (c1).dot(arthono(c2)) + 1 / 3 * c2.dot(arthono(c3))) * F3 + 2 * c1.dot(arthono(c3)) * F4 + c2.dot(arthono(c3)) * F5;

			weights[v_id][N * i + 2] = (c0 - eta).dot(c1) * F1 + (c1.dot(c1) + 2 * (c0 - eta).dot(c2)) * F2 + (3 * (c1).dot(c2) + 3 * (c0 - eta).dot(c3)) * F3
				+ (2 * c2.dot(c2) + 4 * c1.dot(c3)) * F4 + 5 * c2.dot(c3) * F5 + 3 * c3.dot(c3) * F6 - log(norm(c0 + c1 + c2 + c3 - eta)) / (2 * M_PI);

			test_eta += weights[v_id][N * i + 0] * poly_Ctp[0];
			test_eta += weights[v_id][N * i + 1] * poly_Ctp[1];
			test_eta += weights[v_id][N * i + 2] * arthono(poly_Ctp[1]);
			
		}
		
	}
	std::cout << "max norm err:" << max_err << std::endl;

}

//3到2的权重计算
void MeshViewerWidget::calculate_green_weight322(void)
{
	assert(degree == 3);
	auto arthono = [](const Mesh::Point& p) -> Mesh::Point {
		return Mesh::Point(p[1], -p[0], p[2]);
	};

	weights.resize(mesh.n_vertices());
	int N = 2 * todegree + 1;
	for (auto& weight : weights) {
		weight.resize(curvecage2.size() * N);//使用论文中的每段曲线使用幂基来计算
	}
	auto poly_Ctps = curvecage2;
	Bezier2Poly3(curvecage2, poly_Ctps);
	double max_err = 0;
	for (int v_id = 0; v_id < mesh.n_vertices(); v_id++) {//v_id表示mesh中的点数
		auto vh = mesh.vertex_handle(v_id);
		Mesh::Point eta = mesh.point(vh);
		//Mesh::Point eta(0, 0, 0);
		Mesh::Point test_eta(0, 0, 0);//check equality
		for (int i = 0; i < curvecage2.size(); i++)
		{//i表示边界曲线的段数
			auto poly_Ctp = poly_Ctps[i];//每一段曲线，原来的poly_ctp
			auto c0 = poly_Ctp[0]; auto c1 = poly_Ctp[1]; auto c2 = poly_Ctp[2]; auto c3 = poly_Ctp[3];
			double F0, F1, F2, F3, F4, F5, F6, F7, F8;
			F0 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 0);
			F1 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 1);
			F2 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 2);
			F3 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 3);
			F4 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 4);
			F5 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 5);
			F6 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 6);
			F7 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 7);
			F8 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 8);
			weights[v_id][N * i + 0] = (c0 - eta).dot(arthono(c1)) * F0 + 2 * (c0 - eta).dot(arthono(c2)) * F1
				+ (3 * (c0 - eta).dot(arthono(c3)) + 4 / 3 * (c1).dot(arthono(c2)) + 1 / 3 * c2.dot(arthono(c3))) * F2 + 2 * c1.dot(arthono(c3)) * F3 + c2.dot(arthono(c3)) * F4;

			weights[v_id][N * i + 1] = (c0 - eta).dot(arthono(c1)) * F1 + 2 * (c0 - eta).dot(arthono(c2)) * F2
				+ (3 * (c0 - eta).dot(arthono(c3)) + 4 / 3 * (c1).dot(arthono(c2)) + 1 / 3 * c2.dot(arthono(c3))) * F3 + 2 * c1.dot(arthono(c3)) * F4 + c2.dot(arthono(c3)) * F5;

			weights[v_id][N * i + 2] = (c0 - eta).dot(arthono(c1)) * F2 + 2 * (c0 - eta).dot(arthono(c2)) * F3
				+ (3 * (c0 - eta).dot(arthono(c3)) + 4 / 3 * (c1).dot(arthono(c2)) + 1 / 3 * c2.dot(arthono(c3))) * F4 + 2 * c1.dot(arthono(c3)) * F5 + c2.dot(arthono(c3)) * F6;

			weights[v_id][N * i + 3] = (c0 - eta).dot(c1) * F1 + (c1.dot(c1) + 2 * (c0 - eta).dot(c2)) * F2 + (3 * (c1).dot(c2) + 3 * (c0 - eta).dot(c3)) * F3
				+ (2 * c2.dot(c2) + 4 * c1.dot(c3)) * F4 + 5 * c2.dot(c3) * F5 + 3 * c3.dot(c3) * F6 - log(norm(c0 + c1 + c2 + c3 - eta)) / (2 * M_PI);

			weights[v_id][N * i + 4] = (c0 - eta).dot(c1) * F2 + (c1.dot(c1) + 2 * (c0 - eta).dot(c2)) * F3 + (3 * (c1).dot(c2) + 3 * (c0 - eta).dot(c3)) * F4
				+ (2 * c2.dot(c2) + 4 * c1.dot(c3)) * F5 + 5 * c2.dot(c3) * F6 + 3 * c3.dot(c3) * F7 - log(norm(c0 + c1 + c2 + c3 - eta)) / (2 * M_PI);

			test_eta += weights[v_id][N * i + 0] * poly_Ctp[0];
			test_eta += weights[v_id][N * i + 1] * poly_Ctp[1];
			test_eta += weights[v_id][N * i + 2] * poly_Ctp[2];
			test_eta += weights[v_id][N * i + 3] * arthono(poly_Ctp[1]);
			test_eta += weights[v_id][N * i + 4] * arthono(poly_Ctp[2]);

		}

	}
	std::cout << "max norm err:" << max_err << std::endl;

}
//3到3的权重计算
void MeshViewerWidget::calculate_green_weight323(void)
{
	assert(degree == 3);
	auto arthono = [](const Mesh::Point& p) -> Mesh::Point {
		return Mesh::Point(p[1], -p[0], p[2]);
	};

	weights.resize(mesh.n_vertices());
	for (auto& weight : weights) {
		weight.resize(curvecage2.size() * (2 * degree + 1));//使用论文中的每段曲线使用幂基来计算
	}
	auto poly_Ctps = curvecage2;
	Bezier2Poly3(curvecage2, poly_Ctps);
	double max_err = 0;
	for (int v_id = 0; v_id < mesh.n_vertices(); v_id++) {//v_id表示mesh中的点数
		auto vh = mesh.vertex_handle(v_id);
		Mesh::Point eta = mesh.point(vh);
		//Mesh::Point eta(0, 0, 0);
		Mesh::Point test_eta(0, 0, 0);//check equality
		for (int i = 0; i < curvecage2.size(); i++)
		{//i表示边界曲线的段数
			auto poly_Ctp = poly_Ctps[i];//每一段曲线，原来的poly_ctp
			auto c0 = poly_Ctp[0]; auto c1 = poly_Ctp[1]; auto c2 = poly_Ctp[2]; auto c3 = poly_Ctp[3];
			double F0, F1, F2, F3, F4, F5, F6, F7, F8;
			F0 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 0);
			F1 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 1);
			F2 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 2);
			F3 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 3);
			F4 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 4);
			F5 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 5);
			F6 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 6);
			F7 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 7);
			F8 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 8);
			weights[v_id][(2 * degree + 1) * i + 0] = (c0 - eta).dot(arthono(c1)) * F0 + 2 * (c0 - eta).dot(arthono(c2)) * F1
				+ (3 * (c0 - eta).dot(arthono(c3)) + 4 / 3 * (c1).dot(arthono(c2)) + 1 / 3 * c2.dot(arthono(c3))) * F2 + 2 * c1.dot(arthono(c3)) * F3 + c2.dot(arthono(c3)) * F4;

			weights[v_id][(2 * degree + 1) * i + 1] = (c0 - eta).dot(arthono(c1)) * F1 + 2 * (c0 - eta).dot(arthono(c2)) * F2
				+ (3 * (c0 - eta).dot(arthono(c3)) + 4 / 3 * (c1).dot(arthono(c2)) + 1 / 3 * c2.dot(arthono(c3))) * F3 + 2 * c1.dot(arthono(c3)) * F4 + c2.dot(arthono(c3)) * F5;

			weights[v_id][(2 * degree + 1) * i + 2] = (c0 - eta).dot(arthono(c1)) * F2 + 2 * (c0 - eta).dot(arthono(c2)) * F3
				+ (3 * (c0 - eta).dot(arthono(c3)) + 4 / 3 * (c1).dot(arthono(c2)) + 1 / 3 * c2.dot(arthono(c3))) * F4 + 2 * c1.dot(arthono(c3)) * F5 + c2.dot(arthono(c3)) * F6;

			weights[v_id][(2 * degree + 1) * i + 3] = (c0 - eta).dot(arthono(c1)) * F3 + 2 * (c0 - eta).dot(arthono(c2)) * F4
				+ (3 * (c0 - eta).dot(arthono(c3)) + 4 / 3 * (c1).dot(arthono(c2)) + 1 / 3 * c2.dot(arthono(c3))) * F5 + 2 * c1.dot(arthono(c3)) * F6 + c2.dot(arthono(c3)) * F7;

			weights[v_id][(2 * degree + 1) * i + 4] = (c0 - eta).dot(c1) * F1 + (c1.dot(c1) + 2 * (c0 - eta).dot(c2)) * F2 + (3 * (c1).dot(c2) + 3 * (c0 - eta).dot(c3)) * F3
				+ (2 * c2.dot(c2) + 4 * c1.dot(c3)) * F4 + 5 * c2.dot(c3) * F5 + 3 * c3.dot(c3) * F6 - log(norm(c0 + c1 + c2 + c3 - eta)) / (2 * M_PI);

			weights[v_id][(2 * degree + 1) * i + 5] = (c0 - eta).dot(c1) * F2 + (c1.dot(c1) + 2 * (c0 - eta).dot(c2)) * F3 + (3 * (c1).dot(c2) + 3 * (c0 - eta).dot(c3)) * F4
				+ (2 * c2.dot(c2) + 4 * c1.dot(c3)) * F5 + 5 * c2.dot(c3) * F6 + 3 * c3.dot(c3) * F7 - log(norm(c0 + c1 + c2 + c3 - eta)) / (2 * M_PI);

			weights[v_id][(2 * degree + 1) * i + 6] = (c0 - eta).dot(c1) * F3 + (c1.dot(c1) + 2 * (c0 - eta).dot(c2)) * F4 + (3 * (c1).dot(c2) + 3 * (c0 - eta).dot(c3)) * F5
				+ (2 * c2.dot(c2) + 4 * c1.dot(c3)) * F6 + 5 * c2.dot(c3) * F7 + 3 * c3.dot(c3) * F8 - log(norm(c0 + c1 + c2 + c3 - eta)) / (2 * M_PI);
			
			test_eta += weights[v_id][(2 * degree + 1) * i + 0] * poly_Ctp[0];
			test_eta += weights[v_id][(2 * degree + 1) * i + 1] * poly_Ctp[1];
			test_eta += weights[v_id][(2 * degree + 1) * i + 2] * poly_Ctp[2];
			test_eta += weights[v_id][(2 * degree + 1) * i + 3] * poly_Ctp[3];
			test_eta += weights[v_id][(2 * degree + 1) * i + 4] * arthono(poly_Ctp[1]);
			test_eta += weights[v_id][(2 * degree + 1) * i + 5] * arthono(poly_Ctp[2]);
			test_eta += weights[v_id][(2 * degree + 1) * i + 6] * arthono(poly_Ctp[3]);
		}
		//check
		/*std::cout << F2_n(Mesh::Point{ 0,0,0 }, Mesh::Point{ 1,0,0 }, Mesh::Point{ 0,1,0 }, Mesh::Point{ -0.5,1,0 }, 0) << std::endl;
		std::cout << F2_n(Mesh::Point{ 0,0,0 }, Mesh::Point{ 1,0,0 }, Mesh::Point{ 0,1,0 }, Mesh::Point{ -0.5,1,0 }, 1) << std::endl;
		std::cout << F2_n(Mesh::Point{ 0,0,0 }, Mesh::Point{ 1,0,0 }, Mesh::Point{ 0,1,0 }, Mesh::Point{ -0.5,1,0 }, 2) << std::endl;
		std::cout << F2_n(Mesh::Point{ 0,0,0 }, Mesh::Point{ 1,0,0 }, Mesh::Point{ 0,1,0 }, Mesh::Point{ -0.5,1,0 }, 5) << std::endl;*/
		//std::cout << eta << endl;
		//std::cout << "check:" << test_eta - eta << std::endl;
		if ((test_eta - eta).norm() > max_err)
			max_err = (test_eta - eta).norm();
	}
	std::cout << "max norm err:" << max_err << std::endl;

}
//3到7的权重计算
void MeshViewerWidget::calculate_green_weight327(void)
{
	assert(degree == 3);
	auto arthono = [](const Mesh::Point& p) -> Mesh::Point {
		return Mesh::Point(p[1], -p[0], p[2]);
	};

	weights.resize(mesh.n_vertices());
	for (auto& weight : weights) {
		weight.resize(curvecage2.size() * (2 * todegree + 1));//使用论文中的每段曲线使用幂基来计算
	}
	auto poly_Ctps = curvecage2;
	Bezier2Poly3(curvecage2, poly_Ctps);
	double max_err = 0;
	for (int v_id = 0; v_id < mesh.n_vertices(); v_id++) {//v_id表示mesh中的点数
		auto vh = mesh.vertex_handle(v_id);
		Mesh::Point eta = mesh.point(vh);
		//Mesh::Point eta(0, 0, 0);
		Mesh::Point test_eta(0, 0, 0);//check equality
		for (int i = 0; i < curvecage2.size(); i++)
		{//i表示边界曲线的段数
			auto poly_Ctp = poly_Ctps[i];//每一段曲线，原来的poly_ctp
			auto c0 = poly_Ctp[0]; auto c1 = poly_Ctp[1]; auto c2 = poly_Ctp[2]; auto c3 = poly_Ctp[3];
			double F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12;
			F0 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 0);
			F1 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 1);
			F2 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 2);
			F3 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 3);
			F4 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 4);
			F5 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 5);
			F6 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 6);
			F7 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 7);
			F8 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 8);
			F9 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 9);
			F10 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 10);
			F11 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 11);
			F12 = F3_n(eta, poly_Ctp[0], poly_Ctp[1], poly_Ctp[2], poly_Ctp[3], 12);
			weights[v_id][(2 * todegree + 1) * i + 0] = (c0 - eta).dot(arthono(c1)) * F0 + 2 * (c0 - eta).dot(arthono(c2)) * F1
				+ (3 * (c0 - eta).dot(arthono(c3)) + 4 / 3 * (c1).dot(arthono(c2)) + 1 / 3 * c2.dot(arthono(c3))) * F2 + 2 * c1.dot(arthono(c3)) * F3 + c2.dot(arthono(c3)) * F4;

			weights[v_id][(2 * todegree + 1) * i + 1] = (c0 - eta).dot(arthono(c1)) * F1 + 2 * (c0 - eta).dot(arthono(c2)) * F2
				+ (3 * (c0 - eta).dot(arthono(c3)) + 4 / 3 * (c1).dot(arthono(c2)) + 1 / 3 * c2.dot(arthono(c3))) * F3 + 2 * c1.dot(arthono(c3)) * F4 + c2.dot(arthono(c3)) * F5;

			weights[v_id][(2 * todegree + 1) * i + 2] = (c0 - eta).dot(arthono(c1)) * F2 + 2 * (c0 - eta).dot(arthono(c2)) * F3
				+ (3 * (c0 - eta).dot(arthono(c3)) + 4 / 3 * (c1).dot(arthono(c2)) + 1 / 3 * c2.dot(arthono(c3))) * F4 + 2 * c1.dot(arthono(c3)) * F5 + c2.dot(arthono(c3)) * F6;

			weights[v_id][(2 * todegree + 1) * i + 3] = (c0 - eta).dot(arthono(c1)) * F3 + 2 * (c0 - eta).dot(arthono(c2)) * F4
				+ (3 * (c0 - eta).dot(arthono(c3)) + 4 / 3 * (c1).dot(arthono(c2)) + 1 / 3 * c2.dot(arthono(c3))) * F5 + 2 * c1.dot(arthono(c3)) * F6 + c2.dot(arthono(c3)) * F7;

			weights[v_id][(2 * todegree + 1) * i + 4] = (c0 - eta).dot(arthono(c1)) * F4 + 2 * (c0 - eta).dot(arthono(c2)) * F5
				+ (3 * (c0 - eta).dot(arthono(c3)) + 4 / 3 * (c1).dot(arthono(c2)) + 1 / 3 * c2.dot(arthono(c3))) * F6 + 2 * c1.dot(arthono(c3)) * F7 + c2.dot(arthono(c3)) * F8;

			weights[v_id][(2 * todegree + 1) * i + 5] = (c0 - eta).dot(arthono(c1)) * F5 + 2 * (c0 - eta).dot(arthono(c2)) * F6
				+ (3 * (c0 - eta).dot(arthono(c3)) + 4 / 3 * (c1).dot(arthono(c2)) + 1 / 3 * c2.dot(arthono(c3))) * F7 + 2 * c1.dot(arthono(c3)) * F8 + c2.dot(arthono(c3)) * F9;

			weights[v_id][(2 * todegree + 1) * i + 6] = (c0 - eta).dot(arthono(c1)) * F6 + 2 * (c0 - eta).dot(arthono(c2)) * F7
				+ (3 * (c0 - eta).dot(arthono(c3)) + 4 / 3 * (c1).dot(arthono(c2)) + 1 / 3 * c2.dot(arthono(c3))) * F8 + 2 * c1.dot(arthono(c3)) * F9 + c2.dot(arthono(c3)) * F10;

			weights[v_id][(2 * todegree + 1) * i + 7] = (c0 - eta).dot(arthono(c1)) * F7 + 2 * (c0 - eta).dot(arthono(c2)) * F8
				+ (3 * (c0 - eta).dot(arthono(c3)) + 4 / 3 * (c1).dot(arthono(c2)) + 1 / 3 * c2.dot(arthono(c3))) * F9 + 2 * c1.dot(arthono(c3)) * F10 + c2.dot(arthono(c3)) * F11;

			weights[v_id][(2 * todegree + 1) * i + 8] = (c0 - eta).dot(c1) * F1 + (c1.dot(c1) + 2 * (c0 - eta).dot(c2)) * F2 + (3 * (c1).dot(c2) + 3 * (c0 - eta).dot(c3)) * F3
				+ (2 * c2.dot(c2) + 4 * c1.dot(c3)) * F4 + 5 * c2.dot(c3) * F5 + 3 * c3.dot(c3) * F6 - log(norm(c0 + c1 + c2 + c3 - eta)) / (2 * M_PI);

			weights[v_id][(2 * todegree + 1) * i + 9] = (c0 - eta).dot(c1) * F2 + (c1.dot(c1) + 2 * (c0 - eta).dot(c2)) * F3 + (3 * (c1).dot(c2) + 3 * (c0 - eta).dot(c3)) * F4
				+ (2 * c2.dot(c2) + 4 * c1.dot(c3)) * F5 + 5 * c2.dot(c3) * F6 + 3 * c3.dot(c3) * F7 - log(norm(c0 + c1 + c2 + c3 - eta)) / (2 * M_PI);

			weights[v_id][(2 * todegree + 1) * i + 10] = (c0 - eta).dot(c1) * F3 + (c1.dot(c1) + 2 * (c0 - eta).dot(c2)) * F4 + (3 * (c1).dot(c2) + 3 * (c0 - eta).dot(c3)) * F5
				+ (2 * c2.dot(c2) + 4 * c1.dot(c3)) * F6 + 5 * c2.dot(c3) * F7 + 3 * c3.dot(c3) * F8 - log(norm(c0 + c1 + c2 + c3 - eta)) / (2 * M_PI);

			weights[v_id][(2 * todegree + 1) * i + 11] = (c0 - eta).dot(c1) * F4 + (c1.dot(c1) + 2 * (c0 - eta).dot(c2)) * F5 + (3 * (c1).dot(c2) + 3 * (c0 - eta).dot(c3)) * F6
				+ (2 * c2.dot(c2) + 4 * c1.dot(c3)) * F7 + 5 * c2.dot(c3) * F8 + 3 * c3.dot(c3) * F9 - log(norm(c0 + c1 + c2 + c3 - eta)) / (2 * M_PI);

			weights[v_id][(2 * todegree + 1) * i + 12] = (c0 - eta).dot(c1) * F5 + (c1.dot(c1) + 2 * (c0 - eta).dot(c2)) * F6 + (3 * (c1).dot(c2) + 3 * (c0 - eta).dot(c3)) * F7
				+ (2 * c2.dot(c2) + 4 * c1.dot(c3)) * F8 + 5 * c2.dot(c3) * F9 + 3 * c3.dot(c3) * F10 - log(norm(c0 + c1 + c2 + c3 - eta)) / (2 * M_PI);

			weights[v_id][(2 * todegree + 1) * i + 13] = (c0 - eta).dot(c1) * F6 + (c1.dot(c1) + 2 * (c0 - eta).dot(c2)) * F7 + (3 * (c1).dot(c2) + 3 * (c0 - eta).dot(c3)) * F8
				+ (2 * c2.dot(c2) + 4 * c1.dot(c3)) * F9 + 5 * c2.dot(c3) * F10 + 3 * c3.dot(c3) * F11 - log(norm(c0 + c1 + c2 + c3 - eta)) / (2 * M_PI);

			weights[v_id][(2 * todegree + 1) * i + 14] = (c0 - eta).dot(c1) * F7 + (c1.dot(c1) + 2 * (c0 - eta).dot(c2)) * F8 + (3 * (c1).dot(c2) + 3 * (c0 - eta).dot(c3)) * F9
				+ (2 * c2.dot(c2) + 4 * c1.dot(c3)) * F10 + 5 * c2.dot(c3) * F11 + 3 * c3.dot(c3) * F12 - log(norm(c0 + c1 + c2 + c3 - eta)) / (2 * M_PI);
			std::vector<std::vector<Mesh::Point>> bezier_ctp7;
			std::vector<std::vector<Mesh::Point>> poly_Ctp7;
			Bezier2Bezier7({ curvecage2[i] }, bezier_ctp7);
			Bezier2Poly7(bezier_ctp7, poly_Ctp7);
			test_eta += weights[v_id][(2 * todegree + 1) * i + 0] * poly_Ctp7[0][0];
			test_eta += weights[v_id][(2 * todegree + 1) * i + 1] * poly_Ctp7[0][1];
			test_eta += weights[v_id][(2 * todegree + 1) * i + 2] * poly_Ctp7[0][2];
			test_eta += weights[v_id][(2 * todegree + 1) * i + 3] * poly_Ctp7[0][3];
			test_eta += weights[v_id][(2 * todegree + 1) * i + 4] * poly_Ctp7[0][4];
			test_eta += weights[v_id][(2 * todegree + 1) * i + 5] * poly_Ctp7[0][5];
			test_eta += weights[v_id][(2 * todegree + 1) * i + 6] * poly_Ctp7[0][6];
			test_eta += weights[v_id][(2 * todegree + 1) * i + 7] * poly_Ctp7[0][7];
			test_eta += weights[v_id][(2 * todegree + 1) * i + 8] * arthono(poly_Ctp7[0][1]);
			test_eta += weights[v_id][(2 * todegree + 1) * i + 9] * arthono(poly_Ctp7[0][2]);
			test_eta += weights[v_id][(2 * todegree + 1) * i + 10] * arthono(poly_Ctp7[0][3]);
			test_eta += weights[v_id][(2 * todegree + 1) * i + 11] * arthono(poly_Ctp7[0][4]);
			test_eta += weights[v_id][(2 * todegree + 1) * i + 12] * arthono(poly_Ctp7[0][5]);
			test_eta += weights[v_id][(2 * todegree + 1) * i + 13] * arthono(poly_Ctp7[0][6]);
			test_eta += weights[v_id][(2 * todegree + 1) * i + 14] * arthono(poly_Ctp7[0][7]);
		}
		//check
		/*std::cout << F2_n(Mesh::Point{ 0,0,0 }, Mesh::Point{ 1,0,0 }, Mesh::Point{ 0,1,0 }, Mesh::Point{ -0.5,1,0 }, 0) << std::endl;
		std::cout << F2_n(Mesh::Point{ 0,0,0 }, Mesh::Point{ 1,0,0 }, Mesh::Point{ 0,1,0 }, Mesh::Point{ -0.5,1,0 }, 1) << std::endl;
		std::cout << F2_n(Mesh::Point{ 0,0,0 }, Mesh::Point{ 1,0,0 }, Mesh::Point{ 0,1,0 }, Mesh::Point{ -0.5,1,0 }, 2) << std::endl;
		std::cout << F2_n(Mesh::Point{ 0,0,0 }, Mesh::Point{ 1,0,0 }, Mesh::Point{ 0,1,0 }, Mesh::Point{ -0.5,1,0 }, 5) << std::endl;*/
		//std::cout << eta << endl;
		//std::cout << "check:" << test_eta - eta << std::endl;
		if ((test_eta - eta).norm() > max_err)
			max_err = (test_eta - eta).norm();
	}
	std::cout << "max norm err:" << max_err << std::endl;

}

void MeshViewerWidget::calculate_bih_weight121(void) {

	auto arthono2d = [](const OpenMesh::Vec2d& p) -> OpenMesh::Vec2d {
		return OpenMesh::Vec2d(p[1], -p[0]);
	};
	int n = mesh.n_vertices();
	weights.resize(n);
	int m = linear_cage.size();
	for (auto& weight : weights) {
		weight.resize(2 * m);
	}
	BIH_green_weights = weights;
	BIH_else_weights = weights;
	double max_err = 0;
	for (int v_id = 0; v_id < n; v_id++) {//v_id表示mesh中的点数
		auto vh = mesh.vertex_handle(v_id);
		Mesh::Point eta3 = mesh.point(vh);
		OpenMesh::Vec2d eta(eta3[0], eta3[1]);
		//OpenMesh::Vec2d eta(10, 0);
		OpenMesh::Vec2d result(0, 0);
		Eigen::RowVectorXd alpha(m), beta(m), gamma(m), vphiH(m), vphiBH(m), vksiH(m), vksiBH(m);
		for (int i = 0; i < m; i++)
		{
			double phiH, phiBH, ksiH, ksiBH;
			OpenMesh::Vec2d v0 = linear_cage[(i - 1+m) % m];
			OpenMesh::Vec2d v1 = linear_cage[i];
			OpenMesh::Vec2d v2 = linear_cage[(i + 1) % m];
			CalBiharmonicBasis(v0, v1, v2, eta, ksiH, phiH, ksiBH, phiBH);
			vphiH(i) = phiH;
			vksiH(i) = ksiH;
			vksiBH(i) = ksiBH;//test
			vphiBH(i) = phiBH;
		}
		if (use_new)
		{
			gamma = vphiBH * NewCL + vksiBH * A;
		}
		else
		    gamma = vphiBH +vksiBH * A;
		alpha = vphiH +gamma * B;
		beta = vksiH +gamma * C;
		for (int i = 0; i < m; i++)
		{
			weights[v_id][2 * i] = alpha[i];
			weights[v_id][2 * i + 1] = beta[i];
			result += weights[v_id][2 * i] * linear_cage[i];
			result += weights[v_id][2 * i + 1] * arthono2d((linear_cage[(i + 1) % m] - linear_cage[i]).normalized());

			BIH_green_weights[v_id][2*i] = vphiH[i];
			BIH_green_weights[v_id][2*i + 1] = vksiH[i];
			BIH_else_weights[v_id][2*i] = alpha[i] - vphiH[i];
			BIH_else_weights[v_id][2*i + 1] = beta[i] - vksiH[i];
			/*result += vphiH[i] * linear_cage[i];
			result += vksiH[i] * arthono2d((linear_cage[(i + 1) % m] - linear_cage[i]));*/
			/*result += weights[v_id][2 * i] * linear_cage[i];
			result += weights[v_id][2 * i + 1] * arthono2d((linear_cage[(i + 1) % m] - linear_cage[i]));*/
		}
		if (mesh.is_boundary(vh)) {
			//if (abs(eta[0] - 1.00281) < 0.00001 && abs(eta[1] - 2.95555)<0.00001) {
			//	cout << "angle point!" << std::endl;
			//}
			//// 输出 beta
			//std::cout << "boundary "<<eta<<", a-sum:"<<alpha.sum() <<",alpha is:"<< alpha << std::endl;
			//std::cout <<"b-sum:"<< beta.cwiseAbs().sum() << ", beta is: " << beta << std::endl;
			/*std::cout << "gamma is: " << gamma << std::endl;
			std::cout << "vphiBH is: " << vphiBH << std::endl;
			std::cout << "vpsiBH is: " << vksiBH << std::endl;
			std::cout << "alpha-vphiH is: " << alpha-vphiH << std::endl;
			std::cout << "beta-vksiH is: " << beta - vksiH << std::endl;
			std::cout << "eta" << eta << std::endl;
			std::cout << result << std::endl;*/
		}
		/*std::cout << "alpha" << alpha << std::endl;
		std::cout << "beta" << beta << std::endl;
		std::cout << "gamma" << gamma << std::endl;*/
		
		if ((result - eta).norm() > max_err) {
			max_err = (result - eta).norm();
		}
		if ((result - eta).norm() > 0.1) {
			std::cout << v_id << ",";
			mesh.delete_vertex(vh);
		}
	}
	
	std::cout << "max norm err:" << max_err << std::endl;
}

void MeshViewerWidget::calculate_bih_weight121test(void) {

	auto arthono2d = [](const OpenMesh::Vec2d& p) -> OpenMesh::Vec2d {
		return OpenMesh::Vec2d(p[1], -p[0]);
	};
	int n = mesh.n_vertices();
	weights.resize(n);
	int m = linear_cage.size();
	for (auto& weight : weights) {
		weight.resize(2 * m);
	}
	double max_err1 = 0;
	double max_err2 = 0;
	for (int v_id = 0; v_id < n; v_id++) {//v_id表示mesh中的点数
		auto vh = mesh.vertex_handle(v_id);
		Mesh::Point eta3 = mesh.point(vh);
		OpenMesh::Vec2d eta(eta3[0], eta3[1]);
		//OpenMesh::Vec2d eta(10, 0);
		OpenMesh::Vec2d result1(0, 0);
		OpenMesh::Vec2d result2(0, 0);
		Eigen::RowVectorXd alpha(m), beta(m), gamma(2*m), vphiH(m), vphiBH(2*m), vksiH(m), vksiBH(2*m);
		for (int i = 0; i < m; i++)
		{
			double phiH, phiBH, ksiH, ksiBH;
			OpenMesh::Vec2d v0 = linear_cage[(i - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[i];
			OpenMesh::Vec2d v2 = linear_cage[(i + 1) % m];
			CalBiharmonicBasis(v0, v1, v2, eta, ksiH, phiH, ksiBH, phiBH);
			vphiH(i) = phiH;
			vksiH(i) = ksiH;
			std::vector<double> values;
			CalBiharmonicTwiceBasis(v0, v1, v2, eta, values);
			vphiBH(i) = values[4]; vphiBH(i + m) = values[5];
			vksiBH(i) = values[6]; vksiBH(i + m) = values[7];
		}
		/*std::cout << "A" << A << std::endl;
		std::cout << "gamma" << gamma << std::endl;*/
		gamma = vphiBH + vksiBH * A;
		alpha = vphiH +gamma * B;
		beta = vksiH +gamma * C;
		for (int i = 0; i < m; i++)
		{
			weights[v_id][2 * i] = alpha[i];
			weights[v_id][2 * i + 1] = beta[i];
			/*result += weights[v_id][2 * i] * linear_cage[i];
			result += weights[v_id][2 * i + 1] * arthono2d((linear_cage[(i + 1) % m] - linear_cage[i]).normalized());*/
			result1 += vphiH[i] * linear_cage[i];
			result1 += vksiH[i] * arthono2d((linear_cage[(i + 1) % m] - linear_cage[i]));
			result2 += alpha[i] * linear_cage[i];
			result2 += beta[i] * arthono2d((linear_cage[(i + 1) % m] - linear_cage[i]));
		}
		if (mesh.is_boundary(vh)) {
			if (abs(eta[0] - 1.00281) < 0.00001 && abs(eta[1] - 2.95555) < 0.00001) {
				cout << "angle point!" << std::endl;
			}
			// 输出 beta
			std::cout << "boundary " << eta << ", a-sum:" << alpha.sum() << ",alpha is:" << alpha << std::endl;
			std::cout << "b-sum:" << beta.cwiseAbs().sum() << ", beta is: " << beta << std::endl;
			/*std::cout << "gamma is: " << gamma << std::endl;
			std::cout << "vphiBH is: " << vphiBH << std::endl;
			std::cout << "vpsiBH is: " << vksiBH << std::endl;
			std::cout << "alpha-vphiH is: " << alpha-vphiH << std::endl;
			std::cout << "beta-vksiH is: " << beta - vksiH << std::endl;
			std::cout << "eta" << eta << std::endl;
			std::cout << result << std::endl;*/
		}
		/*std::cout << "alpha" << alpha << std::endl;
		std::cout << "beta" << beta << std::endl;
		std::cout << "gamma" << gamma << std::endl;*/

		if ((result1 - eta).norm() > max_err1) {
			max_err1 = (result1 - eta).norm();
		}
		if ((result2 - eta).norm() > max_err2) {
			max_err2 = (result2 - eta).norm();
		}
	}
	std::cout << "max norm err1:" << max_err1 << std::endl;
	std::cout << "max norm err2:" << max_err2 << std::endl;
}

//计算双调和坐标的1次到2次的权重
void MeshViewerWidget::calculate_bih_weight122(void) {

	auto arthono2d = [](const OpenMesh::Vec2d& p) -> OpenMesh::Vec2d {
		return OpenMesh::Vec2d(p[1], -p[0]);
	};
	int n = mesh.n_vertices();
	weights.resize(n);
	int m = linear_cage.size();
	for (auto& weight : weights) {
		weight.resize(4 * m);
	}
	double max_err = 0;
	for (int v_id = 0; v_id < n; v_id++) {//v_id表示mesh中的点数
		auto vh = mesh.vertex_handle(v_id);
		Mesh::Point eta3 = mesh.point(vh);
		OpenMesh::Vec2d eta(eta3[0], eta3[1]);
		//eta = OpenMesh::Vec2d(0.5, 0.5);
		//OpenMesh::Vec2d eta(10, 0);
		OpenMesh::Vec2d result(0, 0);
		Eigen::RowVectorXd alpha(degree * m), beta(degree * m), gamma(degree * m),
			vphiH(degree * m), vphiBH(degree * m), vksiH(degree * m), vksiBH(degree * m);
		for (int i = 0; i < m; i++)
		{
			std::vector<double> values;
			OpenMesh::Vec2d v0 = linear_cage[(i - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[i];
			OpenMesh::Vec2d v2 = linear_cage[(i + 1) % m];
			CalBiharmonicTwiceBasis(v0, v1, v2, eta, values);
			vphiH(i) = values[0]; vphiH(i+m) = values[1];
			vphiBH(i) = values[2]; vphiBH(i + m) = values[3];
			vksiH(i) = values[4]; vksiH(i + m) = values[5];
			vksiBH(i) = values[6]; vksiBH(i + m) = values[7];
		}
		gamma = vksiH +vksiBH * A;
		alpha = vphiH +gamma * B;
		beta = vphiBH +gamma * C;
		for (int i = 0; i < 2*m; i++)
		{
			weights[v_id][ i] = alpha[i];
			weights[v_id][i + 2*m] = beta[i];
			/*weights[v_id][i] = vphiH[i];
			weights[v_id][i + 2 * m] = vphiBH[i];*/
			
		}
		for (int i = 0; i < 2 * m; i++)
		{
			if (i < m) {
				result += weights[v_id][i] * linear_cage[i];
				result += weights[v_id][i+2*m] * arthono2d(linear_cage[i]);
			}
			else {
				result += weights[v_id][i] * (linear_cage[i-m] + linear_cage[(i-m + 1) % m])/2;
				result += weights[v_id][i+2*m] * arthono2d(linear_cage[i-m] + linear_cage[(i -m+ 1) % m]) / 2;
			}
		}
		/*std::cout <<"alpha"<< alpha << std::endl;
		std::cout << "beta" << beta << std::endl;
		std::cout << "eta" << eta << std::endl;
		std::cout << result << std::endl;*/
		if (mesh.is_boundary(vh)) {
			// 输出 beta
			std::cout << "boundary " << eta << ", a-sum:" << alpha.sum() << ",alpha is:" << alpha << std::endl;
			std::cout << "b-sum:" << beta.cwiseAbs().sum() << ", beta is: " << beta << std::endl;
			std::cout << "gamma is: " << gamma << std::endl;
			/*std::cout << "vphiH is: " << vphiH << std::endl;
			std::cout << "vphiBH is: " << vphiBH << std::endl;
			std::cout << "vpsiBH is: " << vksiBH << std::endl;*/
			std::cout << "eta" << eta << std::endl;
			std::cout << result << std::endl;
		}
		/*std::cout << "alpha" << alpha << std::endl;
		std::cout << "beta" << beta << std::endl;
		std::cout << "gamma" << gamma << std::endl;*/

		if ((result - eta).norm() > max_err) {
			max_err = (result - eta).norm();
		}
	}
	std::cout << "max norm err:" << max_err << std::endl;
}

//计算双调和坐标的1次到2次的权重
void MeshViewerWidget::calculate_bih_weight122New(void) {

	auto arthono2d = [](const OpenMesh::Vec2d& p) -> OpenMesh::Vec2d {
		return OpenMesh::Vec2d(p[1], -p[0]);
	};
	int n = mesh.n_vertices();
	weights.resize(n);
	int m = linear_cage.size();
	for (auto& weight : weights) {
		weight.resize(4 * m);
	}
	fake_weights = weights;
	double max_err = 0;
	for (int v_id = 0; v_id < n; v_id++) {//v_id表示mesh中的点数
		auto vh = mesh.vertex_handle(v_id);
		Mesh::Point eta3 = mesh.point(vh);
		OpenMesh::Vec2d eta(eta3[0], eta3[1]);
		//eta = OpenMesh::Vec2d(0.5, 0.5);
		//OpenMesh::Vec2d eta(10, 0);
		OpenMesh::Vec2d result(0, 0);
		Eigen::RowVectorXd alpha(degree * m), beta(degree * m), gamma(degree * m),
			vphiH(degree * m), vphiBH(degree * m), vksiH(degree * m), vksiBH(degree * m);
		for (int i = 0; i < m; i++)
		{
			std::vector<double> values;
			OpenMesh::Vec2d v0 = linear_cage[(i - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[i];
			OpenMesh::Vec2d v2 = linear_cage[(i + 1) % m];
			CalBiharmonicTwiceBasisNew(v0, v1, v2, eta, values);
			vphiH(i) = values[0]; vphiH(i + m) = values[1];
			vphiBH(i) = values[2]; vphiBH(i + m) = values[3];
			vksiH(i) = values[4]; vksiH(i + m) = values[5];
			vksiBH(i) = values[6]; vksiBH(i + m) = values[7];
		}
		gamma = vksiH + vksiBH * A;
		alpha = vphiH + gamma * B;
		beta = vphiBH + gamma * C;
		//auto fake_weights = weights;
		auto fake_result = result;
		auto fake_gamma = gamma;
		fake_gamma = vphiH + vphiBH * A;//注意这里命名不是paper里的
		auto fake_alpha = fake_gamma * B;
		auto fake_beta = fake_gamma * C;
		for (int i = 0; i < 2 * m; i++)
		{
			weights[v_id][i] = alpha[i];
			weights[v_id][i + 2 * m] = beta[i];
			//fake_weights[v_id][i] = alpha[i];//真实情况
			//fake_weights[v_id][i + 2 * m] = beta[i];
			/*fake_weights[v_id][i] = fake_alpha[i];
			fake_weights[v_id][i + 2 * m] = fake_beta[i];*/
			fake_weights[v_id][i] = alpha[i]-vphiH[i];//看非调和部分
			fake_weights[v_id][i + 2 * m] = beta[i] - vphiBH[i];
			//fake_weights[v_id][i] = vphiH[i];//看调和部分
			//fake_weights[v_id][i + 2 * m] = vphiBH[i];
			/*weights[v_id][i] = vphiH[i];
			weights[v_id][i + 2 * m] = vphiBH[i];*/

		}
		for (int i = 0; i < 2 * m; i++)
		{
			if (i < m) {
				result += weights[v_id][i] * linear_cage[i];
				result += weights[v_id][i + 2 * m] * arthono2d(linear_cage[(i+1)%m]- linear_cage[i])/2;
				fake_result += fake_weights[v_id][i] * linear_cage[i];
				fake_result += fake_weights[v_id][i + 2 * m] * arthono2d(linear_cage[(i + 1) % m] - linear_cage[i]) / 2;
			}
			else {
				result += weights[v_id][i] * (linear_cage[i - m] + linear_cage[(i - m + 1) % m]) / 2;
				result += weights[v_id][i + 2 * m] * arthono2d(-linear_cage[i - m] + linear_cage[(i - m + 1) % m]) / 2;
				fake_result += fake_weights[v_id][i] * (linear_cage[i - m] + linear_cage[(i - m + 1) % m]) / 2;
				fake_result += fake_weights[v_id][i + 2 * m] * arthono2d(-linear_cage[i - m] + linear_cage[(i - m + 1) % m]) / 2;
			}
		}
		//mesh.set_point(vh, Mesh::Point(eta3[0], eta3[1], fake_result[0]));
		/*std::cout <<"alpha"<< alpha << std::endl;
		std::cout << "beta" << beta << std::endl;
		std::cout << "eta" << eta << std::endl;
		std::cout << result << std::endl;*/
		if (mesh.is_boundary(vh)) {
			// 输出 beta
			//std::cout << "boundary " << eta << ", a-sum:" << alpha.sum() << ",alpha is:" << alpha << std::endl;
			//std::cout << "b-sum:" << beta.cwiseAbs().sum() << ", beta is: " << beta << std::endl;
			//std::cout << "gamma is: " << gamma << std::endl;
			///*std::cout << "vphiH is: " << vphiH << std::endl;
			//std::cout << "vphiBH is: " << vphiBH << std::endl;
			//std::cout << "vpsiBH is: " << vksiBH << std::endl;*/
			//std::cout << "eta" << eta << std::endl;
			//std::cout << result << std::endl;
		}
		/*std::cout << "alpha" << alpha << std::endl;
		std::cout << "beta" << beta << std::endl;
		std::cout << "gamma" << gamma << std::endl;*/

		if ((result - eta).norm() > max_err) {
			max_err = (result - eta).norm();
		}
	}
	std::cout << "max norm err:" << max_err << std::endl;
}

//计算双调和坐标的2次到2次的权重，新的切向
void MeshViewerWidget::calculate_bih_weight222New(void) {

	auto arthono2d = [](const OpenMesh::Vec2d& p) -> OpenMesh::Vec2d {
		return OpenMesh::Vec2d(p[1], -p[0]);
	};
	int n = mesh.n_vertices();
	
	weights.resize(n);
	int m = curvecage2_real.size();
	for (auto& weight : weights) {
		weight.resize(4 * m);
	}
	fake_weights = weights;
	double max_err = 0;
    #pragma omp parallel for
	for (int v_id = 0; v_id < n; v_id++) {//v_id表示mesh中的点数
		auto vh = mesh.vertex_handle(v_id);
		Mesh::Point eta3 = mesh.point(vh);
		OpenMesh::Vec2d eta(eta3[0], eta3[1]);
		//eta = OpenMesh::Vec2d(0.5, 0.5);
		//OpenMesh::Vec2d eta(1, 0.5);
		OpenMesh::Vec2d result(0, 0);
		Eigen::RowVectorXd alpha(degree * m), beta(degree * m), gamma(degree * m),
			vphiH(degree * m), vphiBH(degree * m), vksiH(degree * m), vksiBH(degree * m);
		vphiH = Eigen::RowVectorXd::Zero(degree * m);
		vksiH = Eigen::RowVectorXd::Zero(degree * m);
#pragma omp parallel for
		for (int i = 0; i < m; i++)
		{
			OpenMesh::Vec2d v1 = Vec322(curvecage2_real[(i - 1 + m) % m][2]);
			OpenMesh::Vec2d v12 = Vec322(curvecage2_real[i][1]);
			OpenMesh::Vec2d v2 = Vec322(curvecage2_real[i][2]);
			std::vector<double> values;
			Cal222BiharmonicBasis_edge(v1, v12, v2, eta, values);
			vphiH(i) += values[0]; vphiH(i + m) = values[1];
			vphiBH(i) = values[2]; vphiBH(i + m) = values[3];
			vksiH(i) += values[4]; vksiH(i + m) = values[5];
			vksiBH(i) = values[6]; vksiBH(i + m) = values[7];

			vphiH((i+1)%m) += values[12];
			vksiH((i + 1) % m) += values[13];

		}
		gamma = vksiH + vksiBH * A;
		alpha = vphiH + gamma * B;
		beta = vphiBH + gamma * C;
		//auto fake_weights = weights;
		//auto fake_result = result;
		//auto fake_gamma = gamma;
		//fake_gamma = vphiH + vphiBH * A;//注意这里命名不是paper里的
		//auto fake_alpha = fake_gamma * B;
		//auto fake_beta = fake_gamma * C;
		for (int i = 0; i < 2 * m; i++)
		{
			weights[v_id][i] = alpha[i];
			weights[v_id][i + 2 * m] = beta[i];
			//fake_weights[v_id][i] = alpha[i];//真实情况
			//fake_weights[v_id][i + 2 * m] = beta[i];
			/*fake_weights[v_id][i] = fake_alpha[i];
			fake_weights[v_id][i + 2 * m] = fake_beta[i];*/
			//fake_weights[v_id][i] = alpha[i] - vphiH[i];//看非调和部分
			//fake_weights[v_id][i + 2 * m] = beta[i] - vphiBH[i];
			//fake_weights[v_id][i] = vphiH[i];//看调和部分
			//fake_weights[v_id][i + 2 * m] = vphiBH[i];
			/*weights[v_id][i] = vphiH[i];
			weights[v_id][i + 2 * m] = vphiBH[i];*/

		}
		for (int i = 0; i < 2 * m; i++)
		{
			if (i < m) {
				result += weights[v_id][i] * Vec322(curvecage2_real[i][0]);
				result += weights[v_id][i + 2 * m] * arthono2d(Vec322(curvecage2_real[i][1]- curvecage2_real[i][0])) ;
				/*fake_result += fake_weights[v_id][i] * linear_cage[i];
				fake_result += fake_weights[v_id][i + 2 * m] * arthono2d(linear_cage[(i + 1) % m] - linear_cage[i]) / 2;*/
			}
			else {
				result += weights[v_id][i] * Vec322(curvecage2_real[i-m][1]);
				result += weights[v_id][i + 2 * m] * arthono2d(Vec322(curvecage2_real[i-m][2] - curvecage2_real[i-m][1]));
				/*fake_result += fake_weights[v_id][i] * (linear_cage[i - m] + linear_cage[(i - m + 1) % m]) / 2;
				fake_result += fake_weights[v_id][i + 2 * m] * arthono2d(-linear_cage[i - m] + linear_cage[(i - m + 1) % m]) / 2;*/
			}
		}
		//mesh.set_point(vh, Mesh::Point(eta3[0], eta3[1], fake_result[0]));
		/*std::cout <<"alpha"<< alpha << std::endl;
		std::cout << "beta" << beta << std::endl;
		std::cout << "eta" << eta << std::endl;
		std::cout << result << std::endl;*/
		
		//if (mesh.is_boundary(vh)) {
		//	//输出 beta
		//	std::cout << "boundary " << eta << ", a-sum:" << alpha.sum() << ",alpha is:" << alpha << std::endl;
		//	std::cout << "b-sum:" << beta.cwiseAbs().sum() << ", beta is: " << beta << std::endl;
		//}

		//std::cout << "eta" << eta << std::endl;
		//std::cout << result << std::endl;
		if ((result - eta).norm() > max_err) {
			max_err = (result - eta).norm();
		}
	}
	std::cout << "max norm err:" << max_err << std::endl;
}

//计算双调和坐标的3次到3次的权重，新的切向
void MeshViewerWidget::calculate_bih_weight323New(void) {

	auto arthono2d = [](const OpenMesh::Vec2d& p) -> OpenMesh::Vec2d {
		return OpenMesh::Vec2d(p[1], -p[0]);
	};
	int n = mesh.n_vertices();

	weights.resize(n);
	int m = curvecage2_real.size();
	for (auto& weight : weights) {
		weight.resize(6 * m);
	}
	fake_weights = weights;
	BIH_green_weights = weights;
	BIH_else_weights = weights;
	double max_err = 0;
#pragma omp parallel for
	for (int v_id = 0; v_id < n; v_id++) {//v_id表示mesh中的点数
		auto vh = mesh.vertex_handle(v_id);
		Mesh::Point eta3 = mesh.point(vh);
		OpenMesh::Vec2d eta(eta3[0], eta3[1]);
		//eta = OpenMesh::Vec2d(0.5, 0.5);
		//OpenMesh::Vec2d eta(1, 0.5);
		OpenMesh::Vec2d result(0, 0);
		Eigen::RowVectorXd alpha(degree * m), beta(degree * m), gamma(degree * m),
			vphiH(degree * m), vphiBH(degree * m), vksiH(degree * m), vksiBH(degree * m);
		vphiH = Eigen::RowVectorXd::Zero(degree * m);
		vksiH = Eigen::RowVectorXd::Zero(degree * m);
//#pragma omp parallel for
		for (int i = 0; i < m; i++)
		{
			OpenMesh::Vec2d v1 = Vec322(curvecage2_real[(i - 1 + m) % m][3]);
			OpenMesh::Vec2d v12 = Vec322(curvecage2_real[i][1]);
			OpenMesh::Vec2d v21 = Vec322(curvecage2_real[i][2]);
			OpenMesh::Vec2d v2 = Vec322(curvecage2_real[i][3]);
			std::vector<double> values;
			Cal323BiharmonicBasis_edge(v1, v12, v21, v2, eta, values);
			vphiH(i) += values[0]; vphiH(i + m) = values[1]; vphiH(i + 2 * m) = values[2];
			vphiBH(i) = values[3]; vphiBH(i + m) = values[4]; vphiBH(i + 2 * m) = values[5];
			vksiH(i) += values[6]; vksiH(i + m) = values[7]; vksiH(i + 2 * m) = values[8];
			vksiBH(i) = values[9]; vksiBH(i + m) = values[10]; vksiBH(i + 2 * m) = values[11];

			vphiH((i + 1) % m) += values[18];
			vksiH((i + 1) % m) += values[19];
		}
		gamma = vksiH + vksiBH * A;
		alpha = vphiH + 1.0*gamma * B;
		beta = vphiBH + 1.0*gamma * C;
		//alpha = vphiH +  gamma * B;//
		//beta = vphiBH +  gamma * C;//
		//auto fake_weights = weights;
		//auto fake_result = result;
		//auto fake_gamma = gamma;
		//fake_gamma = vphiH + vphiBH * A;//注意这里命名不是paper里的
		//auto fake_alpha = fake_gamma * B;
		//auto fake_beta = fake_gamma * C;
		for (int i = 0; i < degree * m; i++)
		{
			weights[v_id][i] = alpha[i];
			weights[v_id][i + degree * m] = beta[i];

			BIH_green_weights[v_id][i] = vphiH[i];
			BIH_green_weights[v_id][i + degree * m] = vphiBH[i];
			BIH_else_weights[v_id][i] = alpha[i]- vphiH[i];
			BIH_else_weights[v_id][i + degree * m] = beta[i]-vphiBH[i];
			
			/*weights[v_id][i] = vphiH[i];
			weights[v_id][i + 2 * m] = vphiBH[i];*/

		}
		for (int i = 0; i < degree * m; i++)
		{
			if (i < m) {
				result += weights[v_id][i] * Vec322(curvecage2_real[i][0]);
				result += weights[v_id][i + degree * m] * arthono2d(Vec322(curvecage2_real[i][1] - curvecage2_real[i][0]));
				
			}
			else if(i<2*m)
			{
				result += weights[v_id][i] * Vec322(curvecage2_real[i - m][1]);
				result += weights[v_id][i + degree * m] * arthono2d(Vec322(curvecage2_real[i - m][2] - curvecage2_real[i - m][1]));
				
			}
			else {
				result += weights[v_id][i] * Vec322(curvecage2_real[i - 2*m][2]);
				result += weights[v_id][i + degree * m] * arthono2d(Vec322(curvecage2_real[i - 2*m][3] - curvecage2_real[i - 2*m][2]));
			}
		}
		//if (mesh.is_boundary(vh)) {
		//	 //输出 beta
		//	std::cout << "boundary " << eta << ", a-sum:" << alpha.sum() << ",alpha is:" << alpha << std::endl;
		//	std::cout << "b-sum:" << beta.cwiseAbs().sum() << ", beta is: " << beta << std::endl;
		//}

		/*std::cout << "eta" << eta << std::endl;
		std::cout << result << std::endl;*/
		if ((result - eta).norm() > max_err) {
			max_err = (result - eta).norm();
		}
	}
	std::cout << "max norm err:" << max_err << std::endl;
}

//计算双调和坐标的1次到3次的权重
void MeshViewerWidget::calculate_bih_weight123(void) {

	auto arthono2d = [](const OpenMesh::Vec2d& p) -> OpenMesh::Vec2d {
		return OpenMesh::Vec2d(p[1], -p[0]);
	};
	int n = mesh.n_vertices();
	weights.resize(n);
	int m = linear_cage.size();
	for (auto& weight : weights) {
		weight.resize(2*degree * m);
	}
	double max_err = 0;
	for (int v_id = 0; v_id < n; v_id++) {//v_id表示mesh中的点数
		auto vh = mesh.vertex_handle(v_id);
		Mesh::Point eta3 = mesh.point(vh);
		OpenMesh::Vec2d eta(eta3[0], eta3[1]);
		//eta = OpenMesh::Vec2d(0.5, 0.5);
		//OpenMesh::Vec2d eta(10, 0);
		OpenMesh::Vec2d result(0, 0);
		Eigen::RowVectorXd alpha(degree * m), beta(degree * m), gamma(degree * m),
			vphiH(degree * m), vphiBH(degree * m), vksiH(degree * m), vksiBH(degree * m);
		for (int i = 0; i < m; i++)
		{
			std::vector<double> values;
			OpenMesh::Vec2d v0 = linear_cage[(i - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[i];
			OpenMesh::Vec2d v2 = linear_cage[(i + 1) % m];
			CalBiharmonicThirdBasis(v0, v1, v2, eta, values);
			vphiH(i) = values[0]; vphiH(i + m) = values[1]; vphiH(i + 2*m) = values[2];
			vphiBH(i) = values[3]; vphiBH(i + m) = values[4]; vphiBH(i + 2*m) = values[5];
			vksiH(i) = values[6]; vksiH(i + m) = values[7]; vksiH(i + 2*m) = values[8];
			vksiBH(i) = values[9]; vksiBH(i + m) = values[10]; vksiBH(i +2* m) = values[11];
		}
		gamma = vksiH + vksiBH * A;
		alpha = vphiH + gamma * B;
		beta = vphiBH + gamma * C;
		for (int i = 0; i < degree * m; i++)
		{
			weights[v_id][i] = alpha[i];
			weights[v_id][i + degree * m] = beta[i];
			/*weights[v_id][i] = vphiH[i];
			weights[v_id][i + 3 * m] = vphiBH[i];*/

		}
		for (int i = 0; i < degree * m; i++)
		{
			if (i < m) {
				result += weights[v_id][i] * linear_cage[i];
				result += weights[v_id][i + degree * m] * arthono2d(linear_cage[i]);
			}
			else if(i<2*m){
				result += weights[v_id][i] * (2*linear_cage[i - m] + linear_cage[(i - m + 1) % m]) / 3;
				result += weights[v_id][i + 3 * m] * arthono2d(2 * linear_cage[i - m] + linear_cage[(i - m + 1) % m]) /3;
			}
			else 
			{
				result += weights[v_id][i] * ( linear_cage[i - 2*m] +2* linear_cage[(i - 2*m + 1) % m]) / 3;
				result += weights[v_id][i + 3 * m] * arthono2d( linear_cage[i -2* m] +2* linear_cage[(i -2* m + 1) % m]) / 3;
			}
		}
		/*std::cout <<"alpha"<< alpha << std::endl;
		std::cout << "beta" << beta << std::endl;
		std::cout << "eta" << eta << std::endl;
		std::cout << result << std::endl;*/
		if (mesh.is_boundary(vh)) {
			// 输出 beta
			std::cout << "boundary " << eta << ", a-sum:" << alpha.sum() << ",alpha is:" << alpha << std::endl;
			std::cout << "b-sum:" << beta.cwiseAbs().sum() << ", beta is: " << beta << std::endl;
			std::cout << "gamma is: " << gamma << std::endl;
			/*std::cout << "vphiH is: " << vphiH << std::endl;
			std::cout << "vphiBH is: " << vphiBH << std::endl;
			std::cout << "vpsiBH is: " << vksiBH << std::endl;*/
			std::cout << "eta" << eta << std::endl;
			std::cout << result << std::endl;
		}
		/*std::cout << "alpha" << alpha << std::endl;
		std::cout << "beta" << beta << std::endl;
		std::cout << "gamma" << gamma << std::endl;*/

		if ((result - eta).norm() > max_err) {
			max_err = (result - eta).norm();
		}
	}
	std::cout << "max norm err:" << max_err << std::endl;
}


//计算双调和坐标的1次到3次的权重
void MeshViewerWidget::calculate_bih_weight123New(void) {

	auto arthono2d = [](const OpenMesh::Vec2d& p) -> OpenMesh::Vec2d {
		return OpenMesh::Vec2d(p[1], -p[0]);
	};
	int n = mesh.n_vertices();
	weights.resize(n);
	int m = linear_cage.size();
	for (auto& weight : weights) {
		weight.resize(2 * degree * m);
	}
	BIH_green_weights = weights;
	BIH_else_weights = weights;
	double max_err = 0;
	for (int v_id = 0; v_id < n; v_id++) {//v_id表示mesh中的点数
		auto vh = mesh.vertex_handle(v_id);
		Mesh::Point eta3 = mesh.point(vh);
		OpenMesh::Vec2d eta(eta3[0], eta3[1]);
		//eta = OpenMesh::Vec2d(0.5, 0.5);
		//OpenMesh::Vec2d eta(10, 0);
		OpenMesh::Vec2d result(0, 0);
		Eigen::RowVectorXd alpha(degree * m), beta(degree * m), gamma(degree * m),
			vphiH(degree * m), vphiBH(degree * m), vksiH(degree * m), vksiBH(degree * m);
		for (int i = 0; i < m; i++)
		{
			std::vector<double> values;
			OpenMesh::Vec2d v0 = linear_cage[(i - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[i];
			OpenMesh::Vec2d v2 = linear_cage[(i + 1) % m];
			CalBiharmonicThirdBasisNew(v0, v1, v2, eta, values);
			//Cal323BiharmonicBasisDebug1(v0, (v0 * 2 + v1) / 3, (v0 + v1 * 2) / 3, v1, (v1 * 2 + v2) / 3, (v1 + v2 * 2) / 3, v2, eta, values);
			vphiH(i) = values[0]; vphiH(i + m) = values[1]; vphiH(i + 2 * m) = values[2];
			vphiBH(i) = values[3]; vphiBH(i + m) = values[4]; vphiBH(i + 2 * m) = values[5];
			vksiH(i) = values[6]; vksiH(i + m) = values[7]; vksiH(i + 2 * m) = values[8];
			vksiBH(i) = values[9]; vksiBH(i + m) = values[10]; vksiBH(i + 2 * m) = values[11];
		}
		gamma = vksiH + vksiBH * A;
		alpha = vphiH + gamma * B;
		beta = vphiBH + gamma * C;
		/*alpha = vphiH ;
		beta = vphiBH ;*/
		for (int i = 0; i < degree * m; i++)
		{
			weights[v_id][i] = alpha[i];
			weights[v_id][i + degree * m] = beta[i];
			BIH_green_weights[v_id][i] = vphiH[i];
			BIH_green_weights[v_id][i + degree * m] = vphiBH[i];
			BIH_else_weights[v_id][i] = alpha[i]-vphiH[i];
			BIH_else_weights[v_id][i + degree * m] = beta[i]- vphiBH[i];
			/*weights[v_id][i] = vphiH[i];
			weights[v_id][i + 3 * m] = vphiBH[i];*/

		}
		for (int i = 0; i < degree * m; i++)
		{
			if (i < m) {
				result += weights[v_id][i] * linear_cage[i];
				result += weights[v_id][i + degree * m] * arthono2d((linear_cage[(i + 1) % m] - linear_cage[i])/3);
			}
			else if (i < 2 * m) {
				result += weights[v_id][i] * (2 * linear_cage[i - m] + linear_cage[(i - m + 1) % m]) / 3;
				result += weights[v_id][i + 3 * m] * arthono2d((linear_cage[(i-m + 1) % m] - linear_cage[i-m]) / 3);
			}
			else
			{
				result += weights[v_id][i] * (linear_cage[i - 2 * m] + 2 * linear_cage[(i - 2 * m + 1) % m]) / 3;
				result += weights[v_id][i + 3 * m] * arthono2d((linear_cage[(i - 2*m + 1) % m] - linear_cage[i - 2*m]) / 3);
			}
		}
		/*std::cout <<"alpha"<< alpha << std::endl;
		std::cout << "beta" << beta << std::endl;
		std::cout << "eta" << eta << std::endl;
		std::cout << result << std::endl;*/
		//if (mesh.is_boundary(vh)) {
		//	// 输出 beta
		//	std::cout << "boundary " << eta << ", a-sum:" << alpha.sum() << ",alpha is:" << alpha << std::endl;
		//	std::cout << "b-sum:" << beta.cwiseAbs().sum() << ", beta is: " << beta << std::endl;
		//	std::cout << "gamma is: " << gamma << std::endl;
		//	/*std::cout << "vphiH is: " << vphiH << std::endl;
		//	std::cout << "vphiBH is: " << vphiBH << std::endl;
		//	std::cout << "vpsiBH is: " << vksiBH << std::endl;*/
		//	std::cout << "eta" << eta << std::endl;
		//	std::cout << result << std::endl;
		//}
		/*std::cout << "alpha" << alpha << std::endl;
		std::cout << "beta" << beta << std::endl;
		std::cout << "gamma" << gamma << std::endl;*/

		if ((result - eta).norm() > max_err) {
			max_err = (result - eta).norm();
		}
	}
	std::cout << "max norm err:" << max_err << std::endl;
}


//计算双调和坐标的1次到3次的权重
void MeshViewerWidget::calculate_bih_weight124New(void) {

	auto arthono2d = [](const OpenMesh::Vec2d& p) -> OpenMesh::Vec2d {
		return OpenMesh::Vec2d(p[1], -p[0]);
	};
	int n = mesh.n_vertices();
	weights.resize(n);
	int m = linear_cage.size();
	for (auto& weight : weights) {
		weight.resize(2 * degree * m);
	}
	BIH_green_weights = weights;
	BIH_else_weights = weights;
	double max_err = 0;
	for (int v_id = 0; v_id < n; v_id++) {//v_id表示mesh中的点数
		auto vh = mesh.vertex_handle(v_id);
		Mesh::Point eta3 = mesh.point(vh);
		OpenMesh::Vec2d eta(eta3[0], eta3[1]);
		//eta = OpenMesh::Vec2d(0.5, 0.5);
		//OpenMesh::Vec2d eta(10, 0);
		OpenMesh::Vec2d result(0, 0);
		Eigen::RowVectorXd alpha(degree * m), beta(degree * m), gamma(degree * m),
			vphiH(degree * m), vphiBH(degree * m), vksiH(degree * m), vksiBH(degree * m);
		for (int i = 0; i < m; i++)
		{
			std::vector<double> values;
			OpenMesh::Vec2d v0 = linear_cage[(i - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[i];
			OpenMesh::Vec2d v2 = linear_cage[(i + 1) % m];
			CalBiharmonicFourthBasisNew(v0, v1, v2, eta, values);
			//Cal323BiharmonicBasisDebug1(v0, (v0 * 2 + v1) / 3, (v0 + v1 * 2) / 3, v1, (v1 * 2 + v2) / 3, (v1 + v2 * 2) / 3, v2, eta, values);
			vphiH(i) = values[0]; vphiH(i + m) = values[1]; vphiH(i + 2 * m) = values[2]; vphiH(i + 3 * m) = values[3];
			vphiBH(i) = values[4]; vphiBH(i + m) = values[5]; vphiBH(i + 2 * m) = values[6]; vphiBH(i + 3 * m) = values[7];
			vksiH(i) = values[8]; vksiH(i + m) = values[9]; vksiH(i + 2 * m) = values[10]; vksiH(i + 3 * m) = values[11];
			vksiBH(i) = values[12]; vksiBH(i + m) = values[13]; vksiBH(i + 2 * m) = values[14]; vksiBH(i + 3 * m) = values[15];
		}
		gamma = vksiH + vksiBH * A;
		alpha = vphiH + gamma * B;
		beta = vphiBH + gamma * C;
		/*alpha = vphiH ;
		beta = vphiBH ;*/
		for (int i = 0; i < degree * m; i++)
		{
			weights[v_id][i] = alpha[i];
			weights[v_id][i + degree * m] = beta[i];
			BIH_green_weights[v_id][i] = vphiH[i];
			BIH_green_weights[v_id][i + degree * m] = vphiBH[i];
			BIH_else_weights[v_id][i] = alpha[i] - vphiH[i];
			BIH_else_weights[v_id][i + degree * m] = beta[i] - vphiBH[i];
			/*weights[v_id][i] = vphiH[i];
			weights[v_id][i + 3 * m] = vphiBH[i];*/

		}
		for (int i = 0; i < degree * m; i++)
		{
			if (i < m) {
				result += weights[v_id][i] * linear_cage[i];
				result += weights[v_id][i + degree * m] * arthono2d((linear_cage[(i + 1) % m] - linear_cage[i]) / 4);
			}
			else if (i < 2 * m) {
				result += weights[v_id][i] * (3 * linear_cage[i - m] + linear_cage[(i - m + 1) % m]) / 4;
				result += weights[v_id][i + degree * m] * arthono2d((linear_cage[(i - m + 1) % m] - linear_cage[i - m]) / 4);
			}
			else if (i < 3 * m) {
				result += weights[v_id][i] * (2 * linear_cage[i -2* m] +2* linear_cage[(i -2* m + 1) % m]) / 4;
				result += weights[v_id][i + degree * m] * arthono2d((linear_cage[(i -2* m + 1) % m] - linear_cage[i - 2*m]) / 4);
			}
			else
			{
				result += weights[v_id][i] * (linear_cage[i - 3 * m] + 3 * linear_cage[(i - 3 * m + 1) % m]) / 4;
				result += weights[v_id][i + degree * m] * arthono2d((linear_cage[(i - 3 * m + 1) % m] - linear_cage[i - 3 * m]) / 4);
			}
		}
		/*std::cout <<"alpha"<< alpha << std::endl;
		std::cout << "beta" << beta << std::endl;
		std::cout << "eta" << eta << std::endl;
		std::cout << result << std::endl;*/
		if (mesh.is_boundary(vh)) {
			// 输出 beta
			std::cout << "boundary " << eta << ", a-sum:" << alpha.sum() << ",alpha is:" << alpha << std::endl;
			std::cout << "b-sum:" << beta.cwiseAbs().sum() << ", beta is: " << beta << std::endl;
			std::cout << "gamma is: " << gamma << std::endl;
			/*std::cout << "vphiH is: " << vphiH << std::endl;
			std::cout << "vphiBH is: " << vphiBH << std::endl;
			std::cout << "vpsiBH is: " << vksiBH << std::endl;*/
			std::cout << "eta" << eta << std::endl;
			std::cout << result << std::endl;
		}
		/*std::cout << "alpha" << alpha << std::endl;
		std::cout << "beta" << beta << std::endl;
		std::cout << "gamma" << gamma << std::endl;*/

		if ((result - eta).norm() > max_err) {
			max_err = (result - eta).norm();
		}
	}
	std::cout << "max norm err:" << max_err << std::endl;
}

void MeshViewerWidget::calculate_bih_weight1213D(void) {

	auto arthono2d = [](const OpenMesh::Vec2d& p) -> OpenMesh::Vec2d {
		return OpenMesh::Vec2d(p[1], -p[0]);
	};
	int n = mesh.n_vertices();
	weights.resize(n);
	int m = linear_cage.size();
	for (auto& weight : weights) {
		weight.resize(2 * m);
	}
	double max_err = 0;
	for (int v_id = 0; v_id < n; v_id++) {//v_id表示mesh中的点数
		auto vh = mesh.vertex_handle(v_id);
		Mesh::Point eta3 = mesh.point(vh);
		OpenMesh::Vec2d eta(eta3[0], eta3[1]);
		//OpenMesh::Vec2d eta(10, 0);
		OpenMesh::Vec2d result(0, 0);
		Eigen::RowVectorXd alpha(m), beta(m), gamma(m), vphiH(m), vphiBH(m), vksiH(m), vksiBH(m);
		for (int i = 0; i < m; i++)
		{
			double phiH, phiBH, ksiH, ksiBH;
			OpenMesh::Vec2d v0 = linear_cage[(i - 1 + m) % m];
			OpenMesh::Vec2d v1 = linear_cage[i];
			OpenMesh::Vec2d v2 = linear_cage[(i + 1) % m];
			CalBiharmonicBasis(v0, v1, v2, eta, ksiH, phiH, ksiBH, phiBH);
			vphiH(i) = phiH;
			vksiH(i) = ksiH;
			vksiBH(i) = ksiBH;//test
			vphiBH(i) = phiBH;
		}
		gamma = vphiBH + vksiBH * A;
		alpha =/* vphiH +*/gamma * B;
		beta = /*vksiH +*/gamma * C;
		for (int i = 0; i < m; i++)
		{
			weights[v_id][2 * i] = alpha[i];
			weights[v_id][2 * i + 1] = beta[i];
			/*result += weights[v_id][2 * i] * linear_cage[i];
			result += weights[v_id][2 * i + 1] * arthono2d((linear_cage[(i + 1) % m] - linear_cage[i]).normalized());*/
			result += vphiH[i] * linear_cage[i];
			result += vksiH[i] * arthono2d((linear_cage[(i + 1) % m] - linear_cage[i]));
		}
		if (mesh.is_boundary(vh)) {
			if (abs(eta[0] - 1.00281) < 0.00001 && abs(eta[1] - 2.95555) < 0.00001) {
				cout << "angle point!" << std::endl;
			}
			// 输出 beta
			std::cout << "boundary " << eta << ", a-sum:" << alpha.sum() << ",alpha is:" << alpha << std::endl;
			std::cout << "b-sum:" << beta.cwiseAbs().sum() << ", beta is: " << beta << std::endl;
			/*std::cout << "gamma is: " << gamma << std::endl;
			std::cout << "vphiBH is: " << vphiBH << std::endl;
			std::cout << "vpsiBH is: " << vksiBH << std::endl;
			std::cout << "alpha-vphiH is: " << alpha-vphiH << std::endl;
			std::cout << "beta-vksiH is: " << beta - vksiH << std::endl;
			std::cout << "eta" << eta << std::endl;
			std::cout << result << std::endl;*/
		}
		/*std::cout << "alpha" << alpha << std::endl;
		std::cout << "beta" << beta << std::endl;
		std::cout << "gamma" << gamma << std::endl;*/

		if ((result - eta).norm() > max_err) {
			max_err = (result - eta).norm();
		}
	}
	std::cout << "max norm err:" << max_err << std::endl;
}

//根据degree将CCpoints放进curvecage2里
void MeshViewerWidget::ccPoints2BezierSegs(void)
{
	for (int i = 0; i < curvecage2.size(); i++)
	{
		for (int j = 0; j < degree + 1; j++)
		{
			curvecage2[i][j] = CC_points[i * degree + j];
		}
	}
}

//根据curvecage2和坐标确定deformedmesh的顶点位置
void MeshViewerWidget::deform_mesh_from_cc(Mesh &deformedmesh)
{
	auto arthono = [](const OpenMesh::Vec3d& p) -> OpenMesh::Vec3d {//left( -y, x)
		return OpenMesh::Vec3d(p[1], -p[0], p[2]);
	};
	auto arthono2d = [](const OpenMesh::Vec2d& p) -> OpenMesh::Vec2d {
		return OpenMesh::Vec2d(p[1], -p[0]);
	};
	auto curvecage2poly = curvecage2;
	if (useGBC) {
		std::cout << "GBC bianxing" << std::endl;

		
		for (int i = 0; i < deformedmesh.n_vertices(); i++)
		{
			auto vh = deformedmesh.vertex_handle(i);
			auto point = mesh.point(vh);
			auto weight = weights[i];
			

			OpenMesh::Vec3d new_point(0, 0, 0);
			for (int j = 0; j < weight.size(); j++)
			{
				new_point += weight[j] * CC_points[j];
			}
			OpenMesh::Vec3d new_point3(new_point[0], new_point[1], 0);
			deformedmesh.set_point(vh, new_point3);
		}
		return;
	}
	if (useCauchy) {
		//std::cout << "Cauchy bianxing" << std::endl;


		for (int v_id = 0; v_id < deformedmesh.n_vertices(); v_id++)
		{
			auto vh = deformedmesh.vertex_handle(v_id);
			complex<double> newz(0, 0);
			for (int i = 0; i < CC_points.size(); i++)
			{
				complex<double> test_z0(CC_points[i][0], CC_points[i][1]);
				if (!use_rational) {
					newz += standad_cauchyweights[v_id][i] * test_z0;
				}
				else {
					newz += standad_cauchyweights[v_id][i] * test_z0*CC_points[i][2];
				}
			}
			OpenMesh::Vec3d new_point3(newz.real(), newz.imag(), 0);
			deformedmesh.set_point(vh, new_point3);
		}
		return;
	}
	if (usebih && degree == 1) {
		std::cout << "bianxing" << std::endl;
		//curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
		auto CC_points_real = CC_points;
		for (int i = 0; i < dividecages; i++)
		{
			auto linearcage1 = subdivideCage(CC_points_real);
			CC_points_real = linearcage1;
		}
		
		int m = linear_cage.size();
		sj.resize(m);
		//Eigen::MatrixXd f(m, 2);
		//Eigen::MatrixXd d(m, 2);
		//VectorXd X_diag = VectorXd::Ones(m);
		//for (int i = 0; i < m; i++)
		//{
		//	f(i, 0) = CC_points_real[i][0]; f(i, 1) = CC_points_real[i][1];
		//	OpenMesh::Vec2d diff = OpenMesh::Vec2d(
		//		CC_points_real[(i + 1) % m][0] - CC_points_real[i][0],
		//		CC_points_real[(i + 1) % m][1] - CC_points_real[i][1]
		//	);
		//	d(i, 0) = arthono2d(diff).normalized()[0];
		//	d(i, 1) = arthono2d(diff).normalized()[1];
		//}
		//{
		//	LapLspoints.clear();
		//	Eigen::MatrixXd points = B * f + C * d;
		//	std::cout << points << std::endl;
		//	// 遍历 Eigen::MatrixXd points 的每一行，并将其转换为 OpenMesh::Vec2d
		//	for (int i = 0; i < points.rows(); ++i) {
		//		// 将 Eigen::RowVectorXd 转换为 OpenMesh::Vec2d
		//		OpenMesh::Vec2d point(points(i, 0), points(i, 1));
		//		LapLspoints.push_back(point);
		//	}
		//}
		//X_diag=testmain(f, d);
		for (int i = 0; i < m; i++)
		{
			//sj[i] = (linear_cage[(i + 1) % m] - linear_cage[i]).length() / linear_length[i];//相似边界
			//sj[i] = X_diag[i];
			//std::cout << sj[i] << " ";
			if (NormalControl == 1)
				sj[i] = 1;//正交边界jacobi
			else if(NormalControl==2)
				sj[i] = (linear_cage[(i + 1) % m] - linear_cage[i]).length() / linear_length[i];//相似边界
		}
		// 逐个元素相加
		for (size_t i = 0; i < BIH_green_weights.size(); ++i) {
			for (size_t j = 0; j < BIH_green_weights[i].size(); ++j) {
				weights[i][j] = BIH_green_weights[i][j] + bezierPointSize * BIH_else_weights[i][j];
			}
		}
		for (int i = 0; i < deformedmesh.n_vertices(); i++)
		{
			auto vh = deformedmesh.vertex_handle(i);
			auto point = mesh.point(vh);
			auto weight = weights[i];
			OpenMesh::Vec2d new_point(0, 0);
			for (int j = 0; j < linear_cage.size(); j++)
			{
				//new_point += linear_cage[j] * weight[2 * j];
				//new_point += arthono2d((linear_cage[(j + 1) % m] - linear_cage[j])/linear_length[j]/*.normalized()*/ ) * weight[2 * j+1];
				new_point += OpenMesh::Vec2d(CC_points_real[j][0], CC_points_real[j][1]) * weight[2*j];
				new_point += arthono2d(OpenMesh::Vec2d(CC_points_real[(j + 1) % m][0]- CC_points_real[j][0], 
					CC_points_real[(j + 1) % m][1] - CC_points_real[j][1]) ).normalized()*sj[j] * weight[2 * j + 1];
				
			}
			OpenMesh::Vec3d new_point3(new_point[0], new_point[1], 0);
			deformedmesh.set_point(vh, new_point3);
		}
		return;
	}
	if (usebih && degree == 2) {
		std::cout << "bianxing" << std::endl;
		auto CC_points_real = CC_points;
		for (int i = 0; i < dividecages; i++)
		{
			auto linearcage1 = subdivideCage2(CC_points_real);
			CC_points_real = linearcage1;
		}
		/*auto linearcage1 = subdivideCage2(CC_points);
		auto CC_points_real = linearcage1;
		auto linearcage2 = subdivideCage2(CC_points_real);
		CC_points_real = linearcage2;
		auto linearcage3 = subdivideCage2(CC_points_real);
		CC_points_real = linearcage3;*/
		
		int m = CC_points_real.size()/degree;
		//int m = curvecage2_real.size();
		sj.resize(2*m);
		VectorXd X_diag =1* VectorXd::Ones( m);
		//设置sj
		//{
		//		Eigen::MatrixXd f(2 * m, 2);
		//		for (int i = 0; i < m; ++i) {
		//			f(i, 0) = CC_points_real[2 * i][0];
		//			f(i, 1) = CC_points_real[2 * i][1];

		//			f(i + m, 0) = CC_points_real[2 * i + 1][0];
		//			f(i + m, 1) = CC_points_real[2 * i + 1][1];
		//		}
		//		Eigen::MatrixXd d(2 * m, 2);
		//		for (int i = 0; i < m; ++i) {
		//			d(i, 0) = CC_points_real[2 * i + 1][1] - CC_points_real[2 * i][1];
		//			d(i, 1) = -(CC_points_real[2 * i + 1][0] - CC_points_real[2 * i][0]);

		//			d(i + m, 0) = CC_points_real[(2 * i + 2) % (2 * m)][1] - CC_points_real[2 * i + 1][1];
		//			d(i + m, 1) = -(CC_points_real[(2 * i + 2) % (2 * m)][0] - CC_points_real[2 * i + 1][0]);
		//		}
		//		if (use_aaap) {
		//			X_diag = testmain2AAAP(f, d);
		//		}
		//		else {
		//			X_diag = testmain2(f, d); //X_diag.tail(2) /= 10.0; X_diag[m - 6] *= 3.0;
		//			//X_diag = VectorXd::Ones(m);
		//		}
		//}
		for (int i = 0; i <  m; i++)
		{
			//sj[i] = 1;//标准设置
			//sj[i + m] = 1;
			sj[i] = X_diag[i];//标准设置
			sj[i + m] = X_diag[i];
			//std::cout << sj[i] << " ";
		}
		for (int i = 0; i < deformedmesh.n_vertices(); i++)
		{
			auto vh = deformedmesh.vertex_handle(i);
			auto point = mesh.point(vh);
			auto weight = weights[i];
			OpenMesh::Vec2d new_point(0, 0);
			OpenMesh::Vec2d fake_new_point(0, 0);
			for (int j = 0; j < 2 * m; j++)
			{
				if (j < m) {
					/*new_point += weights[i][j] * linear_cage[j];
					new_point += weights[i][j + 2 * m] * arthono2d(linear_cage[j]);*/
					/*new_point += weights[i][j] * OpenMesh::Vec2d(CC_points_real[2 * j][0], CC_points_real[2 * j][1]);
					new_point += weights[i][j + 2 * m] * arthono2d(OpenMesh::Vec2d(CC_points_real[2 * j][0], CC_points_real[2 * j][1]));*/
					new_point += weights[i][j] * OpenMesh::Vec2d(CC_points_real[2 * j][0], CC_points_real[2 * j][1]);
					new_point += weights[i][j + 2 * m]*sj[j] * arthono2d(OpenMesh::Vec2d(CC_points_real[2 * j+1][0]- CC_points_real[2 * j ][0],
						CC_points_real[2 * j+1][1]- CC_points_real[2 * j][1]));//为新的切向设置的
					fake_new_point += fake_weights[i][j] * OpenMesh::Vec2d(CC_points_real[2 * j][0], CC_points_real[2 * j][1]);
					fake_new_point += fake_weights[i][j + 2 * m] * sj[j] * arthono2d(OpenMesh::Vec2d(CC_points_real[2 * j + 1][0] - CC_points_real[2 * j][0],
						CC_points_real[2 * j + 1][1] - CC_points_real[2 * j][1]));//为新的切向设置的
				}
				else {
					/*new_point += weights[i][j] * (linear_cage[j - m] + linear_cage[(j - m + 1) % m]) / 2;
					new_point += weights[i][j + 2 * m] * arthono2d(linear_cage[j - m] + linear_cage[(j - m + 1) % m]) / 2;*/
					new_point += weights[i][j] * OpenMesh::Vec2d(CC_points_real[2 * (j - m) + 1][0], CC_points_real[2 * (j - m) + 1][1]);
					new_point += weights[i][j + 2 * m]*sj[j] * arthono2d(OpenMesh::Vec2d(CC_points_real[(2 * (j - m) + 2)%(2*m)][0] - CC_points_real[2 * (j - m) + 1][0],
						CC_points_real[(2 * (j - m) + 2) % (2 * m)][1]-CC_points_real[2 * (j - m) + 1][1])) ;
					fake_new_point += fake_weights[i][j] * OpenMesh::Vec2d(CC_points_real[2 * (j - m) + 1][0], CC_points_real[2 * (j - m) + 1][1]);
					fake_new_point += fake_weights[i][j + 2 * m] * sj[j] * arthono2d(OpenMesh::Vec2d(CC_points_real[(2 * (j - m) + 2) % (2 * m)][0] - CC_points_real[2 * (j - m) + 1][0],
						CC_points_real[(2 * (j - m) + 2) % (2 * m)][1] - CC_points_real[2 * (j - m) + 1][1]));
				}
			}
			OpenMesh::Vec3d new_point3(new_point[0], new_point[1], 0);
			/*OpenMesh::Vec3d new_point3(new_point[0], new_point[1], fake_new_point[0]);*/
			deformedmesh.set_point(vh, new_point3);
		}
		return;
	}
	if (usebih && degree == 3) {
		std::cout << "bianxing" << std::endl;
		
		auto CC_points_real = CC_points;
		for (int i = 0; i < dividecages; i++)
		{
			auto linearcage1 = subdivideCage3(CC_points_real);
			CC_points_real = linearcage1;
		}
		
		
		//int m = curvecage2_real.size();
		int m = CC_points_real.size()/(degree);
		sj.resize(3*m);
		VectorXd X_diag = VectorXd::Ones(3*m);
		/*Eigen::MatrixXd f(3 * m, 2);
		for (int i = 0; i < m; ++i) {
			f(i, 0) = CC_points_real[3*i][0];
			f(i, 1) = CC_points_real[3*i][1];

			f(i + m, 0) = CC_points_real[3*i+1][0];
			f(i + m, 1) = CC_points_real[3*i+1][1];

			f(i + 2 * m, 0) = CC_points_real[3*i + 2][0];
			f(i + 2 * m, 1) = CC_points_real[3*i + 2][1];
		}
		Eigen::MatrixXd d(3 * m, 2);
		for (int i = 0; i < m; ++i) {
			d(i, 0) = CC_points_real[3 * i][1];
			d(i, 1) = -CC_points_real[3 * i][0];

			d(i + m, 0) = CC_points_real[3 * i + 1][1];
			d(i + m, 1) = -CC_points_real[3 * i + 1][0];

			d(i + 2 * m, 0) = CC_points_real[3 * i + 2][1];
			d(i + 2 * m, 1) = -CC_points_real[3 * i + 2][0];
		}
		X_diag = testmain(f, d);*/
		for (int i = 0; i < 3*m; i++)
		{
			if (NormalControl == 1)
				sj[i] = 1;//标准设置
			else if (NormalControl == 2)
				sj[i] = X_diag[i];
			std::cout << sj[i] << " ";
		}
		// 逐个元素相加
		for (size_t i = 0; i < BIH_green_weights.size(); ++i) {
			for (size_t j = 0; j < BIH_green_weights[i].size(); ++j) {
				weights[i][j] = BIH_green_weights[i][j] + bezierPointSize* BIH_else_weights[i][j];
			}
		}
		for (int i = 0; i < deformedmesh.n_vertices(); i++)
		{
			auto vh = deformedmesh.vertex_handle(i);
			auto point = mesh.point(vh);
			auto weight = weights[i];
			/*std::vector<double> weight(weights[i].size());
			for (size_t j = 0; j < weights[i].size(); ++j) {
				weight[j] = (1 - greenWeightBih) * BIH_green_weights[i][j] + greenWeightBih * weights[i][j];
			}*/

			OpenMesh::Vec2d new_point(0, 0);
			for (int j = 0; j < 3 * m; j++)
			{
				if (j < m) {
					/*new_point += weights[i][j] * linear_cage[j];
					new_point += weights[i][j + 2 * m] * arthono2d(linear_cage[j]);*/
					/*new_point += weights[i][j] * OpenMesh::Vec2d(CC_points_real[3 * j][0], CC_points_real[3 * j][1]);
					new_point += weights[i][j + 3 * m] * sj[3*j]*arthono2d(OpenMesh::Vec2d(CC_points_real[3 * j][0], CC_points_real[3 * j][1]));*/
					new_point += weight[j] * OpenMesh::Vec2d(CC_points_real[3 * j][0], CC_points_real[3 * j][1]);
					new_point += weight[j + 3 * m] * sj[3*j] * arthono2d(OpenMesh::Vec2d(CC_points_real[3 * j + 1][0] - CC_points_real[3 * j][0],
						CC_points_real[3 * j + 1][1] - CC_points_real[3 * j][1]));//为新的切向设置的
				}
				else if(j<2*m){
					/*new_point += weights[i][j] * (linear_cage[j - m] + linear_cage[(j - m + 1) % m]) / 2;
					new_point += weights[i][j + 2 * m] * arthono2d(linear_cage[j - m] + linear_cage[(j - m + 1) % m]) / 2;*/
					/*new_point += weights[i][j] * OpenMesh::Vec2d(CC_points_real[3 * (j - m) + 1][0], CC_points_real[3 * (j - m) + 1][1]);
					new_point += weights[i][j + 3 * m] * sj[3 * (j - m) + 1]*arthono2d(OpenMesh::Vec2d(CC_points_real[3 * (j - m) + 1][0], CC_points_real[3 * (j - m) + 1][1]));*/
					new_point += weight[j] * OpenMesh::Vec2d(CC_points_real[3 * (j - m) + 1][0], CC_points_real[3 * (j - m) + 1][1]);
					new_point += weight[j + 3 * m] * sj[3 * (j - m) + 1] * arthono2d(OpenMesh::Vec2d(CC_points_real[(3 * (j - m) + 2) % (3 * m)][0] - CC_points_real[3 * (j - m) + 1][0],
						CC_points_real[(3 * (j - m) + 2) % (3 * m)][1] - CC_points_real[3 * (j - m) + 1][1]));
				}
				else
				{
					/*new_point += weights[i][j] * OpenMesh::Vec2d(CC_points_real[3 * (j - 2*m) + 2][0], CC_points_real[3 * (j - 2*m) + 2][1]);
					new_point += weights[i][j + 3 * m] *sj[3 * (j - 2 * m) + 2]* arthono2d(OpenMesh::Vec2d(CC_points_real[3 * (j - 2*m) + 2][0], CC_points_real[3 * (j - 2*m) + 2][1]));*/
					new_point += weight[j] * OpenMesh::Vec2d(CC_points_real[3 * (j - 2*m) + 2][0], CC_points_real[3 * (j - 2*m) + 2][1]);
					new_point += weight[j + 3 * m] * sj[3 * (j - 2*m) + 2] * arthono2d(OpenMesh::Vec2d(CC_points_real[(3 * (j - 2*m) + 3) % (3 * m)][0] - CC_points_real[3 * (j - 2*m) +2][0],
						CC_points_real[(3 * (j - 2*m) + 3) % (3 * m)][1] - CC_points_real[3 * (j - 2*m) + 2][1]));
				}
			}
			OpenMesh::Vec3d new_point3(new_point[0], new_point[1], 0);
			deformedmesh.set_point(vh, new_point3);
		}
		return;
	}
	if (usebih && degree == 4) {
		std::cout << "bianxing" << std::endl;

		auto CC_points_real = CC_points;
		for (int i = 0; i < dividecages; i++)
		{
			auto linearcage1 = subdivideCage4(CC_points_real);
			CC_points_real = linearcage1;
		}


		//int m = curvecage2_real.size();
		int m = CC_points_real.size() / (degree);
		sj.resize(4 * m);
		VectorXd X_diag = VectorXd::Ones(4 * m);
		/*Eigen::MatrixXd f(3 * m, 2);
		for (int i = 0; i < m; ++i) {
			f(i, 0) = CC_points_real[3*i][0];
			f(i, 1) = CC_points_real[3*i][1];

			f(i + m, 0) = CC_points_real[3*i+1][0];
			f(i + m, 1) = CC_points_real[3*i+1][1];

			f(i + 2 * m, 0) = CC_points_real[3*i + 2][0];
			f(i + 2 * m, 1) = CC_points_real[3*i + 2][1];
		}
		Eigen::MatrixXd d(3 * m, 2);
		for (int i = 0; i < m; ++i) {
			d(i, 0) = CC_points_real[3 * i][1];
			d(i, 1) = -CC_points_real[3 * i][0];

			d(i + m, 0) = CC_points_real[3 * i + 1][1];
			d(i + m, 1) = -CC_points_real[3 * i + 1][0];

			d(i + 2 * m, 0) = CC_points_real[3 * i + 2][1];
			d(i + 2 * m, 1) = -CC_points_real[3 * i + 2][0];
		}
		X_diag = testmain(f, d);*/
		for (int i = 0; i < 4 * m; i++)
		{
			sj[i] = 1;//标准设置
			std::cout << sj[i] << " ";
		}
		for (int i = 0; i < deformedmesh.n_vertices(); i++)
		{
			auto vh = deformedmesh.vertex_handle(i);
			auto point = mesh.point(vh);
			//auto weight = weights[i];
			std::vector<double> weight(weights[i].size());
			for (size_t j = 0; j < weights[i].size(); ++j) {
				weight[j] = (1 - greenWeightBih) * BIH_green_weights[i][j] + greenWeightBih * weights[i][j];
			}

			OpenMesh::Vec2d new_point(0, 0);
			for (int j = 0; j < 4 * m; j++)
			{
				if (j < m) {
					new_point += weight[j] * OpenMesh::Vec2d(CC_points_real[4 * j][0], CC_points_real[4 * j][1]);
					new_point += weight[j + 4 * m] * sj[4 * j] * arthono2d(OpenMesh::Vec2d(CC_points_real[4 * j + 1][0] - CC_points_real[4 * j][0],
						CC_points_real[4 * j + 1][1] - CC_points_real[4 * j][1]));//为新的切向设置的
				}
				else if (j < 2 * m) {
					new_point += weight[j] * OpenMesh::Vec2d(CC_points_real[4 * (j - m) + 1][0], CC_points_real[4 * (j - m) + 1][1]);
					new_point += weight[j + 4 * m] * sj[4 * (j - m) + 1] * arthono2d(OpenMesh::Vec2d(CC_points_real[(4 * (j - m) + 2) % (4 * m)][0] - CC_points_real[4 * (j - m) + 1][0],
						CC_points_real[(4 * (j - m) + 2) % (4 * m)][1] - CC_points_real[4 * (j - m) + 1][1]));
				}
				else if (j < 3 * m) {
					new_point += weight[j] * OpenMesh::Vec2d(CC_points_real[4 * (j - 2*m) + 2][0], CC_points_real[4 * (j - 2*m) + 2][1]);
					new_point += weight[j + 4 * m] * sj[4 * (j - 2 * m) + 2] * arthono2d(OpenMesh::Vec2d(CC_points_real[(4 * (j - 2 * m) + 3) % (4 * m)][0] - CC_points_real[4 * (j - 2 * m) + 2][0],
						CC_points_real[(4 * (j - 2 * m) + 3) % (4 * m)][1] - CC_points_real[4 * (j - 2 * m) + 2][1]));
				}
				else
				{
					new_point += weight[j] * OpenMesh::Vec2d(CC_points_real[4 * (j - 3 * m) + 3][0], CC_points_real[4 * (j - 3 * m) + 3][1]);
					new_point += weight[j + 4 * m] * sj[4 * (j - 3 * m) + 3] * arthono2d(OpenMesh::Vec2d(CC_points_real[(4 * (j - 3 * m) + 4) % (4 * m)][0] - CC_points_real[4 * (j - 3 * m) + 3][0],
						CC_points_real[(4 * (j - 3 * m) + 4) % (4 * m)][1] - CC_points_real[4 * (j - 3 * m) + 3][1]));
				}
			}
			OpenMesh::Vec3d new_point3(new_point[0], new_point[1], 0);
			deformedmesh.set_point(vh, new_point3);
		}
		return;
	}
	if (usecvm) {
		//cal mvcGn
		int N = curvecage2.size();
		if (1) {
			std::vector<OpenMesh::Vec3d> t_e(N);
			std::vector<OpenMesh::Vec3d> n_e(N);
			for (int i = 0; i < N; i++)
			{
				mvcGt[2 * i] = 3 * (curvecage2[i][1] - curvecage2[i][0])/mvcL[i];
				mvcGt[2 * i + 1] = 3 * (curvecage2[i][2] - curvecage2[i][3]) / mvcL[i];
				n_e[i] = arthono((curvecage2[i][3] - curvecage2[i][0])).normalized();//每条边的单位法向
				t_e[i] = (curvecage2[i][3] - curvecage2[i][0]).normalized();//每条边的单位切向
			}
			for (int i = 0; i < N; i++)
			{
				int index = (i - 1) % N;
				if (index < 0) {
					index += N;
				}
				Eigen::Matrix2d A;
				Eigen::Matrix2d B;
				OpenMesh::Vec3d Bx = -mvcGt[2 * index + 1][0] * t_e[index] - mvcGt[2 * i][0] * t_e[i];
				OpenMesh::Vec3d By = -mvcGt[2 * index + 1][1] * t_e[index] - mvcGt[2 * i][1] * t_e[i];
				// 为矩阵A和B赋值
				A << n_e[i][0], -n_e[index][0],
					n_e[i][1], -n_e[index][1];
				B << Bx[0], By[0],
					Bx[1], By[1];
				//solve gn
				Eigen::Matrix2d X = A.inverse() * B;
				//std::cout << X << std::endl;
				mvcGn[2 * index + 1] = OpenMesh::Vec3d(X(1, 0), X(1, 1), 0);
				mvcGn[2 * i] = OpenMesh::Vec3d(X(0, 0), X(0, 1), 0);
				std::cout << "x的梯度" << mvcGt[2 * i][0] * t_e[i] + mvcGn[2 * i][0] * n_e[i] << std::endl;
				std::cout << "y的梯度" << mvcGt[2 * i][1] * t_e[i] + mvcGn[2 * i][1] * n_e[i] << std::endl;
				std::cout << mvcGt[2 * i][0] * t_e[i] + mvcGn[2 * i][0] * n_e[i] - (-mvcGt[2 * index + 1][0] * t_e[index] + mvcGn[2 * index + 1][0] * n_e[index]) << std::endl;
				std::cout << mvcGt[2 * i][1] * t_e[i] + mvcGn[2 * i][1] * n_e[i] - (-mvcGt[2 * index + 1][1] * t_e[index] + mvcGn[2 * index + 1][1] * n_e[index]) << std::endl;

			}
		}
		for (int i = 0; i < deformedmesh.n_vertices(); i++)
		{
			auto vh = deformedmesh.vertex_handle(i);
			auto point = mesh.point(vh);
			auto weight = weights[i];
			OpenMesh::Vec3d new_point(0, 0, point[2]);
			for (int j = 0; j < curvecage2.size(); j++)
			{
				new_point += curvecage2[j][0] * weight[5*j];
				new_point += mvcGt[2 * j] * weight[5 * j + 1];
				new_point += mvcGt[2 * j+1] * weight[5 * j +2];
				new_point += -mvcGn[2 * j] * weight[5 * j + 3];
				new_point += -mvcGn[2 * j + 1] * weight[5 * j + 4];
			}
			
			deformedmesh.set_point(vh, new_point);
		}
		return;
	}
	if (!highdegree) {
		if (degree == 2)
			Bezier2Poly2(curvecage2, curvecage2poly);
		else if (degree == 3)
			Bezier2Poly3(curvecage2, curvecage2poly);
		else if (degree == 1)
			Bezier1Poly1(curvecage2, curvecage2poly);
		std::vector < Mesh::Point> cpts(curvecage2poly.size() * (2 * degree + 1));
		for (int i = 0; i < curvecage2poly.size(); i++)
		{
			for (int j = 0; j < degree + 1; j++)
			{
				cpts[i * (2 * degree + 1) + j] = curvecage2poly[i][j];
			}
			for (int j = 1; j < degree + 1; j++)
			{
				cpts[i * (2 * degree + 1) + degree + j] = arthono(curvecage2poly[i][j]);
			}
		}
		for (int i = 0; i < deformedmesh.n_vertices(); i++)
		{
			auto vh = deformedmesh.vertex_handle(i);
			auto weight = weights[i];
			auto new_point = evaluate_coor(weight, cpts);
			deformedmesh.set_point(vh, new_point);
		}
	}
	else {
		if (todegree == 1) {
			Bezier1Poly1(curvecage2, curvecage2poly);
		}
		if (todegree == 2) {
			Bezier2Poly2(curvecage2, curvecage2poly);
		}
		if (todegree == 3) {
			Bezier2Poly3(curvecage2, curvecage2poly);
		}
		if (todegree == 7) {
			Bezier2Poly7(curvecage2, curvecage2poly);
		}
		std::vector < Mesh::Point> cpts(curvecage2poly.size() * (2 * todegree + 1));
		for (int i = 0; i < curvecage2poly.size(); i++)
		{
			for (int j = 0; j < todegree + 1; j++)
			{
				cpts[i * (2 * todegree + 1) + j] = curvecage2poly[i][j];
			}
			for (int j = 1; j < todegree + 1; j++)
			{
				cpts[i * (2 * todegree + 1) + todegree + j] = arthono(curvecage2poly[i][j]);
			}
		}
		for (int i = 0; i < deformedmesh.n_vertices(); i++)
		{
			auto vh = deformedmesh.vertex_handle(i);
			auto weight = weights[i];
			auto new_point = evaluate_coor(weight, cpts);
			deformedmesh.set_point(vh, new_point);
		}
	}
}


void MeshViewerWidget::deform_mesh_from_cc(Mesh& deformedmesh, std::vector<Mesh::Point > CC_pointsX, std::vector<std::vector<complex<double>>>& weights)
{
	auto arthono = [](const OpenMesh::Vec3d& p) -> OpenMesh::Vec3d {//left( -y, x)
		return OpenMesh::Vec3d(p[1], -p[0], p[2]);
	};
	auto arthono2d = [](const OpenMesh::Vec2d& p) -> OpenMesh::Vec2d {
		return OpenMesh::Vec2d(p[1], -p[0]);
	};
	if (useCauchy) {
		std::cout << "Cauchy bianxing" << std::endl;


		for (int v_id = 0; v_id < deformedmesh.n_vertices(); v_id++)
		{
			auto vh = deformedmesh.vertex_handle(v_id);
			complex<double> newz(0, 0);
			for (int i = 0; i < CC_pointsX.size(); i++)
			{
				complex<double> test_z0(CC_pointsX[i][0], CC_pointsX[i][1]);
				if (!use_rational) {
					newz += weights[v_id][i] * test_z0;
				}
				else {
					newz += weights[v_id][i] * test_z0 * CC_pointsX[i][2];
				}
			}
			OpenMesh::Vec3d new_point3(newz.real(), newz.imag(), 0);
			deformedmesh.set_point(vh, new_point3);
		}
		return;
	}
}

//根据curvecage2和坐标确定deformedmesh的顶点位置
void MeshViewerWidget::deform_cage_from_handles(void)
{
	Mesh deformedMesh;
	deformedMesh.assign(mesh);
	partion_handles(Handle_points, deform_cps, deform_cps_t);
	

	double lambda = p2pweight;//lambda

	int n = CC_points.size();
	int p = deform_cps.size();
	int k = Cboundary_vertices.size();//
	// 将std::vector转换为Eigen矩阵
	Eigen::MatrixXcd C(p, n);
	for (int i = 0; i < p; ++i) {
		for (int j = 0; j < n; ++j) {
			C(i, j) = cp_cauchyweights[i][j];
		}
	}


	Eigen::MatrixXcd D(k, n);
	for (int i = 0; i < k; ++i) {
		for (int j = 0; j < n; ++j) {
			D(i, j) = lambda * D2cauchyweights[i][j];
		}
	}

	Eigen::VectorXcd f(p);
	for (int i = 0; i < p; ++i) {
		f(i) = deform_cps_t[i];
	}
	/*Eigen::VectorXcd CC_points_comp(n);
	for (int i = 0; i < n; i++) {
		CC_points_comp[i] = std::complex<double>(CC_points[i][0], CC_points[i][1]);
	}
	std::cout << C * CC_points_comp - f<<std :: endl;*/

	// 创建零向量 0（k 维）
	Eigen::VectorXcd zero_vec = Eigen::VectorXcd::Zero(k);
	// 创建 A 矩阵，通过垂直拼接 C 和 D
	Eigen::MatrixXcd A(p + k, n);
	A << C, D;

	// 创建 b 向量，通过垂直拼接 f 和 0 向量
	Eigen::VectorXcd b(p + k);
	b << f, zero_vec;

	//// 计算 C^T * C 和 D^T * D
	//Eigen::MatrixXcd CtC = C.adjoint() * C;  // C^T * C
	//Eigen::MatrixXcd DtD = D.adjoint() * D;  // D^T * D

	//// 构建 (C^T * C + lambda^2 * D^T * D)
	//Eigen::MatrixXcd A = CtC +  DtD;

	//// 构建 C^T * f
	//Eigen::VectorXcd b = C.adjoint() * f;

	// 解方程组 A * u = b
	Eigen::VectorXcd u = A.colPivHouseholderQr().solve(b);
	//std::cout << u << std::endl;
	std::cout << "C*u-f" << std::endl;
	std::cout << C * u - f << std::endl;
	//更新ccPoints
	for (int i = 0; i < CC_points.size(); i++)
	{
		CC_points[i][0] = real(u[i]);
		CC_points[i][1] = imag(u[i]);
	}

	Eigen::MatrixXcd Cauchyweight(mesh.n_vertices(), n);
	for (int i = 0; i < mesh.n_vertices(); ++i) {
		for (int j = 0; j < n; ++j) {
			Cauchyweight(i, j) = standad_cauchyweights[i][j];
		}
	}
	Eigen::VectorXcd coors = Cauchyweight * u;
	for (int i = 0; i < deformedMesh.n_vertices(); i++)
	{
		auto vh = deformedMesh.vertex_handle(i);
		auto new_point = OpenMesh::Vec3d(real(coors[i]), imag(coors[i]), 0);
		deformedMesh.set_point(vh, new_point);
	}
	CC_mesh = createMeshFromCurveCage(CC_points);
	auto CagevertexState = OpenMesh::getOrMakeProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
	for (auto vh : CC_mesh.vertices())
	{
		CagevertexState[vh] = NotSelected;
	}
	curvecage2 = CCpoints_fromCCmesh(CC_mesh, degree);
	MeshTools::AssignPoints(mesh, deformedMesh);
	return;
}

void MeshViewerWidget::Set_Texture_coord()
{
	LoadTexture();
	//ptMin = Mesh::Point(0, 0, 0);
	//ptMax = Mesh::Point(2.5, 2.5, 0);//cube
	//ptMin = Mesh::Point(-10, -11.26, 0);
	//ptMax = Mesh::Point(10, 11.26, 0);//deer
	//ptMin = Mesh::Point(-6.4, -6.4, 0);
	//ptMax = Mesh::Point(6.4, 6.4, 0);//ball
	//ptMin = Mesh::Point(-14, -14, 0);
	//ptMax = Mesh::Point(14, 14, 0);//giraffe
	ptMin = Mesh::Point(-1.98, -3.6, 0);
	ptMax = Mesh::Point(1.98, 3.6, 0);//paristower
	//ptMin = Mesh::Point(-5.405, -2.14, 0);
	//ptMax = Mesh::Point(5.405, 2.14, 0);//xiyi
	//ptMin = Mesh::Point(-1.80, -2.285, 0);
	//ptMax = Mesh::Point(1.80, 2.285, 0);//yu
	//ptMin = Mesh::Point(-15.01, 16.6, 0);
	//ptMax = Mesh::Point(15.01, 16.6, 0);//kuzi
	//ptMin = Mesh::Point(-16.91, -6.11, 0);
	//ptMax = Mesh::Point(16.91, 6.11, 0);//car
	//ptMin = Mesh::Point(-1.21, -1.635, 0);
	//ptMax = Mesh::Point(1.21, 1.635, 0);//tuzi
	//ptMin = Mesh::Point(-32.13, 5.25, 0);
	//ptMax = Mesh::Point(32.13, 5.25, 0);//daizi
	//ptMin = Mesh::Point(-9.655,-3.92, 0);
	//ptMax = Mesh::Point(9.655, 3.92, 0);//fish
	//ptMin = Mesh::Point(0,0, 0);
	//ptMax = Mesh::Point(1, 1, 0);//zhengfangxin
	//ptMin = Mesh::Point(-5.625,-5.625, 0);
	//ptMax = Mesh::Point(5.625, 5.625, 0);//choufish
	//ptMin = Mesh::Point(-16.87, -16.87, 0);
	//ptMax = Mesh::Point(16.87, 16.87, 0);//zoomfish
	//ptMin = Mesh::Point(-6.15, -5.855, 0);
	//ptMax = Mesh::Point(6.15, 5.855, 0);//circle
	//ptMin = Mesh::Point(-6.23, -6.23, 0);
	//ptMax = Mesh::Point(6.23, 6.23, 0);//human
	//ptMin = Mesh::Point(-5.475, -9.6, 0);
	//ptMax = Mesh::Point(5.475, 9.6, 0);//flower
	//ptMin = Mesh::Point(-10, -15, 0);
	//ptMax = Mesh::Point(10, 15, 0);//octopus//也是daizi
	//ptMin = Mesh::Point(-16.86, -16.86, 0);
	//ptMax = Mesh::Point(16.86, 16.86, 0);//sheji
	/*ptMin = Mesh::Point(-25.885, -25.885, 0);
	ptMax = Mesh::Point(25.885, 25.885, 0);*///pangxie
	//ptMin = Mesh::Point(-2.28, -2.285, 0);
	//ptMax = Mesh::Point(2.28,2.285, 0);//haixing
	//ptMin = Mesh::Point(-6.61, -9.6, 0);
	//ptMax = Mesh::Point(6.61, 9.6, 0);//fengzheng
	//ptMin = Mesh::Point(-5.405, -2.14, 0);
	//ptMax = Mesh::Point(5.405, 2.14, 0);//xiyi
	//ptMin = Mesh::Point(-8.1, -10.8, 0);
	//ptMax = Mesh::Point(8.1, 10.8, 0);//dol
	//ptMin = Mesh::Point(-3.78, -3.57, 0);
	//ptMax = Mesh::Point(3.78, 3.57, 0);//chong
	//ptMin = Mesh::Point(-2.255, -2.745, 0);
	//ptMax = Mesh::Point(2.255, 2.745, 0);//yezi
	//ptMin = Mesh::Point(-1.28, -2.55, 0);
	//ptMax = Mesh::Point(1.28, 2.55, 0);//hat
	//ptMin = Mesh::Point(-8.1, -10.8, 0);
	//ptMax = Mesh::Point(8.1, 10.8, 0);//seahorse
	//ptMin = Mesh::Point(-8.1, -10.8, 0);
	//ptMax = Mesh::Point(8.1, 10.8, 0);//jinglin
	//ptMin = Mesh::Point(-2.62, -2.7, 0);
	//ptMax = Mesh::Point(2.62, 2.7, 0);//tree
	//ptMin = Mesh::Point(-19.965, -12.925, 0);
	//ptMax = Mesh::Point(19.965, 12.925, 0);//sheji
	//ptMin = Mesh::Point(-9.6, -9.6, 0);
	//ptMax = Mesh::Point(9.6, 9.6, 0);//sharp
	//ptMin = Mesh::Point(-2.77, -2.70, 0);
	//ptMax = Mesh::Point(-2.77+3.6, -2.70+3.6, 0);//L
	//ptMin = Mesh::Point(-1, -1, 0);
	//ptMax = Mesh::Point(1, 1, 0);//banyuan
	//ptMin = Mesh::Point(-2.56, -2.56, 0);
	//ptMax = Mesh::Point(2.56, 2.56, 0);//zimu_S
	//ptMin = Mesh::Point(-1, -1, 0);
	//ptMax = Mesh::Point(1, 1, 0);//S green cube
	//ptMin = Mesh::Point(-13.3, -13.3, 0);
	//ptMax = Mesh::Point(13.3, 13.3, 0);//elephant
	//ptMin = Mesh::Point(-9.6, -6.08, 0);
	//ptMax = Mesh::Point(9.6, 6.08, 0);//rainbow
	float L = max({ ptMax[0] - ptMin[0],ptMax[1] - ptMin[1] });
	float Lx = 2 * ptMax[0];
	float Ly = 2 * ptMax[1];
	std::cout << "bbMIn:   " << ptMin[0] << " " << ptMin[1] << std::endl;
	std::cout << "bbMax:   " << ptMax[0] << " " << ptMax[1] << std::endl;
	/*ptMin = Mesh::Point(-10, -11.26, 0);
	ptMax = Mesh::Point(10, 11.26, 0);*/
	mesh.request_vertex_texcoords2D();//打开纹理坐标
	Mesh::Point P;
	for (auto v_it = mesh.vertices_begin(); v_it != mesh.vertices_end(); ++v_it)
	{
		P = mesh.point(*v_it) - ptMin;
		Mesh::TexCoord2D t = { P[0] / Lx,P[1] / Ly };
		mesh.set_texcoord2D(*v_it, t);
	}

	std::cout << "load coordinate ok!" << std::endl;
	if (draw_mesh2) {
		mesh2 = mesh;
		mesh3 = mesh;
	}
}

void MeshViewerWidget::DrawPoints(void)
{
	auto vertexState = OpenMesh::getProperty<OpenMesh::VertexHandle, VertexState>(mesh, "vertexState");
	glColor3d(0.2, 0.2, 0.2);
	glPointSize(10);
	glBegin(GL_POINTS);
	for (const auto& vh : mesh.vertices())
	{
		if (vertexState[vh] == NotSelected)
		{
			glNormal3dv(mesh.normal(vh).data());
			glVertex3dv(mesh.point(vh).data());
		}
	}
	glEnd();
	
	glColor3d(0.7, 0.7, 0.0);
	glPointSize(10);
	glBegin(GL_POINTS);
	for (const auto& vh : mesh.vertices())
	{
		if (vertexState[vh] == Custom)
		{
			glNormal3dv(mesh.normal(vh).data());
			glVertex3dv(mesh.point(vh).data());
		}
	}
	glEnd();

	glColor3d(0.7, 0.0, 0.0);
	glPointSize(10);
	glBegin(GL_POINTS);
	for (const auto& vh : mesh.vertices())
	{
		if (vertexState[vh] == Custom)
		{
			glNormal3dv(mesh.normal(vh).data());
			glVertex3dv(mesh.point(vh).data());
		}
	}
	glEnd();

	glColor3d(0.7, 0.0, 0.0);  // 设置点的颜色为红色
	glPointSize(15);  // 设置点的大小为10像素
	glBegin(GL_POINTS);  // 开始绘制点
	glVertex3d(0.0, 0.0, 0.0);  // 绘制点(0, 0, 0)
	glEnd();

	auto mesh1 = mesh;
	// 寻找 z 值的最大和最小点
	auto minMaxZ = std::minmax_element(mesh.vertices_begin(), mesh.vertices_end(),
		[&mesh1](const auto& vh1, const auto& vh2) {
			return mesh1.point(vh1)[2] < mesh1.point(vh2)[2];
		});

	auto minVertex = *minMaxZ.first;
	auto maxVertex = *minMaxZ.second;
	// 开始绘制
	glPointSize(50);
	glBegin(GL_POINTS);
	for (const auto& vh : mesh.vertices()) {
		if (vh == minVertex || vh == maxVertex) {
			// 最大或最小点，绘制为红色
			glColor3d(1.0, 0.0, 0.0); // 红色
			glNormal3dv(mesh.normal(vh).data());
			glVertex3dv(mesh.point(vh).data());
		}
		
		
	}
	glEnd();
}

void MeshViewerWidget::DrawWireframe(void)
{
	glColor3d(0.2, 0.2, 0.2);
	glBegin(GL_LINES);
	for (const auto& eh : mesh.edges())
	{
		auto heh = mesh.halfedge_handle(eh, 0);
		auto vh0 = mesh.from_vertex_handle(heh);
		auto vh1 = mesh.to_vertex_handle(heh);
		glNormal3dv(mesh.normal(vh0).data());
		glVertex3dv(mesh.point(vh0).data());
		glNormal3dv(mesh.normal(vh1).data());
		glVertex3dv(mesh.point(vh1).data());
	}
	glEnd();
	DrawPoints();
}

void MeshViewerWidget::DrawHiddenLines()
{
	glLineWidth(1.0);
	float backcolor[4];
	glGetFloatv(GL_COLOR_CLEAR_VALUE, backcolor);
	glColor4fv(backcolor);
	glDepthRange(0.01, 1.0);
	glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
	if (glIsEnabled(GL_LIGHTING))
	{
		glDisable(GL_LIGHTING);
		DrawFlat();
		glEnable(GL_LIGHTING);
	}
	else
	{
		DrawFlat();
	}
	glDepthRange(0.0, 1.0);
	glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
	glColor3d(.3, .3, .3);
	DrawFlat();
	glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
}

void MeshViewerWidget::DrawFlatLines(void)
{
	glEnable(GL_POLYGON_OFFSET_FILL);
	glPolygonOffset(1.5f, 2.0f);
	glShadeModel(GL_FLAT);
	//glColor3d(0.8, 0.8, 0.8);
	glColor3d(1.0, 1.0, 1.0);
	DrawFlat();
	glDisable(GL_POLYGON_OFFSET_FILL);
	if (glIsEnabled(GL_LIGHTING))
	{
		glDisable(GL_LIGHTING);
		DrawWireframe();
		glEnable(GL_LIGHTING);
	}
	else
	{
		DrawWireframe();
	}
}

void MeshViewerWidget::DrawFlat(void)
{
	glBegin(GL_TRIANGLES);
	for (const auto& fh : mesh.faces())
	{
		glNormal3dv(mesh.normal(fh).data());
		for (const auto& fvh : mesh.fv_range(fh))
		{
			glVertex3dv(mesh.point(fvh).data());
		}
	}
	glEnd();
	DrawPoints();
}

void MeshViewerWidget::DrawSmooth(void)
{
	glColor3d(0.8, 0.8, 0.8);
	glShadeModel(GL_SMOOTH);
	glLoadName(static_cast<GLuint>(mesh.n_vertices()));
	glEnableClientState(GL_VERTEX_ARRAY);
	glVertexPointer(3, GL_DOUBLE, 0, mesh.points());
	glEnableClientState(GL_NORMAL_ARRAY);
	glNormalPointer(GL_DOUBLE, 0, mesh.vertex_normals());
	for (const auto& fh : mesh.faces())
	{
		glBegin(GL_POLYGON);
		for (const auto& fvh : mesh.fv_range(fh))
		{
			glArrayElement(fvh.idx());
		}
		glEnd();
	}
	glDisableClientState(GL_VERTEX_ARRAY);
	glDisableClientState(GL_NORMAL_ARRAY);
	DrawPoints();
}

void MeshViewerWidget::DrawSmoothDistort(void)
{
	glColor3d(0.8, 0.8, 0.8);
	glShadeModel(GL_SMOOTH);
	glLoadName(static_cast<GLuint>(mesh.n_vertices()));
	glEnableClientState(GL_VERTEX_ARRAY);
	glVertexPointer(3, GL_DOUBLE, 0, mesh.points());
	glEnableClientState(GL_NORMAL_ARRAY);
	glNormalPointer(GL_DOUBLE, 0, mesh.vertex_normals());
	std::vector<double> results_distort;
	if (drawDistort)
		results_distort = calculateDistortARAP(mesh_beifen, mesh);
	if (drawDistortDirichlet)
		results_distort = calculateDistortSymDirichlet(mesh_beifen, mesh);
	if (!results_distort.empty()) {
		double max_val = *std::max_element(results_distort.begin(), results_distort.end());
		std::cout << "最大值: " << max_val << std::endl;
	}
	else {
		std::cerr << "错误: 扭曲值未计算" << std::endl;
	}
	std::vector<std::pair<double, std::array<double, 3>>> colorPoints;
	if(drawDistort) 
		colorPoints = {
		{ 0.0, {92. / 255, 167. / 255, 222. / 255}}, // 蓝
		//{ 5.0, {64. / 255, 224. / 255, 208. / 255}}, // 绿
		{ 3.0, {251. / 255,210. / 255, 106. / 255}}, // 黄
		{ 5.0, {218. / 255, 112. / 255, 214. / 255}},//紫色
		{ 52.0, {251. / 255,0. / 255, 0. / 255}}, // 红
		{ 55.0, {0. / 255,0. / 255, 0. / 255}} // 黑
	};
	if (drawDistortDirichlet) {
		colorPoints = {
		{ 4.0, {92. / 255, 167. / 255, 222. / 255}}, // 蓝
		//{ 5.0, {64. / 255, 224. / 255, 208. / 255}}, // 绿
		{ 7.0, {251. / 255,210. / 255, 106. / 255}}, // 黄
		{ 10.0, {218. / 255, 112. / 255, 214. / 255}},//紫色
		{ 20.0, {251. / 255,0. / 255, 0. / 255}}, // 红
		{ 55000000.0, {0. / 255,0. / 255, 0. / 255}} // 黑
		};
	}
	//for (const auto& fh : mesh.faces())
	//{
	//	glBegin(GL_POLYGON);
	//	
	//	for (const auto& fvh : mesh.fv_range(fh)) {
	//		double value = results_distort[fvh.idx()];

	//		// 确定插值区间
	//		std::array<double, 3> color = { 0.0, 0.0, 0.0 };
	//		for (size_t i = 1; i < colorPoints.size(); ++i) {
	//			if (value >= colorPoints[i - 1].first && value <= colorPoints[i].first) {
	//				// 计算插值比例
	//				double t = (value - colorPoints[i - 1].first) / (colorPoints[i].first - colorPoints[i - 1].first);
	//				// 插值计算颜色
	//				for (int j = 0; j < 3; ++j) {
	//					color[j] = (1.0 - t) * colorPoints[i - 1].second[j] + t * colorPoints[i].second[j];
	//				}
	//				break;
	//			}
	//		}

	//		// 设置颜色
	//		glColor3d(color[0], color[1], color[2]);
	//		glArrayElement(fvh.idx());
	//	}
	//	glEnd();
	//}
	//绘制面的颜色
	for (const auto& fh : mesh.faces()) {
		// 获取当前面的扭曲度结果
		double value = results_distort[fh.idx()];
		std::array<double, 3> color = { 0.0, 0.0, 0.0 };

		// 确定插值区间
		for (size_t i = 1; i < colorPoints.size(); ++i) {
			if (value >= colorPoints[i - 1].first && value <= colorPoints[i].first) {
				// 计算插值比例
				double t = (value - colorPoints[i - 1].first) / (colorPoints[i].first - colorPoints[i - 1].first);
				// 插值计算颜色
				for (int j = 0; j < 3; ++j) {
					color[j] = (1.0 - t) * colorPoints[i - 1].second[j] + t * colorPoints[i].second[j];
				}
				break;
			}
		}

		// 开始绘制面（整个面使用同一颜色）
		glBegin(GL_POLYGON);
		glColor3d(color[0], color[1], color[2]); // 设置面的颜色
		for (const auto& fvh : mesh.fv_range(fh)) {
			glArrayElement(fvh.idx()); // 添加顶点坐标
		}
		glEnd();
	}
	glDisableClientState(GL_VERTEX_ARRAY);
	glDisableClientState(GL_NORMAL_ARRAY);
}

void MeshViewerWidget::DrawBezierCurve(const BezierCurve& bezierCurve, float r, float g, float b, float linewidth, float pointSize, int subdiv) {
	//std::cout << r << g << b << std::endl;
	if (&bezierCurve == nullptr)
	{
		return;
	}
	if ((!bezierCurve.GetCtrlPoints().empty())) {
		//DrawPoints3d(bezierCurve.GetCtrlPoints());
		
		auto ctrlPoints = bezierCurve.GetCtrlPoints();
		double approxLen = 0.;
		int numPoints = ctrlPoints.size();
		for (size_t i = 0; i < numPoints - 1; i++) {
			approxLen += (ctrlPoints[i] - ctrlPoints[i + 1]).norm();
		}

		glLineWidth(linewidth);
		glColor3f(r, g, b);
		glBegin(GL_LINE_STRIP);
		OpenMesh::Vec3d p;
		double t = 0;
		double h = 1 / approxLen / subdiv;
		int i = 0;
		while (i <= 1 / h)
		{
			p = bezierCurve.Evaluate(t + i++ * h);
			glVertex3f(p[0],p[1],0);
		}
		p = ctrlPoints[numPoints - 1];
		glVertex3f(p[0], p[1], 0);
		glEnd();

		if (pointSize > 0.5) {
			glPointSize(pointSize);
			glColor3f(r, g, b);
			glBegin(GL_POINTS);
			i = 0;
			while (i <= 1 / h)
			{
				p = bezierCurve.Evaluate(t + i++ * h);
				glVertex3f(p[0], p[1],0);
			}
			p = ctrlPoints[numPoints - 1];
			glVertex3f(p[0], p[1], 0);
			glEnd();
		}
	}
	else {
		//cout << "Empty Bezier Curve\n";
		return;
	}
}

void MeshViewerWidget::DrawBezierCurves()
{
	size_t N = curvecage2.size();
	if (N == 0) return;
	std::vector<double> curveLengths(N);

	size_t totalApproxVertices = 0;
	for (size_t i = 0; i < N; i++) {
		const auto& curvePoints = curvecage2[i];
		double approxLen = 0.;
		int numPoints = curvePoints.size();
		for (size_t i = 0; i < numPoints - 1; i++) {
			approxLen += (curvePoints[i] - curvePoints[i + 1]).norm();
		}
		curveLengths[i] = approxLen;
		totalApproxVertices += approxLen * bezierSubdiv + 1;
	}
	std::vector<OpenMesh::Vec3d> points;
	points.reserve(totalApproxVertices);
	for (size_t i = 0; i < N; i++) {
		const auto& curvePoints = curvecage2[i];
		BezierCurve curve(curvePoints,use_rational);
		double approxLen = curveLengths[i];
		double h = 1. / approxLen / bezierSubdiv;
		int j = 0;
		while (j <= 1 / h)
		{
			auto p = curve.Evaluate(j++ * h);
			if (points.empty() || (p - *(points.rbegin())).norm() > 1e-4)
				points.push_back(p);
		}
	}
	while (!points.empty() && (*(points.rbegin()) - *(points.begin())).norm() < 1e-4) {
		points.erase(points.end() - 1);
	}
	size_t npoints = points.size();
	std::cout << totalApproxVertices << '\t' <<"bug?" << npoints << std::endl;
	std::vector<OpenMesh::Vec3d> normals(npoints);
	for (size_t i = 0; i < npoints; i++) {
		auto& currentPoint = points[i];
		auto& nextPoint = (i == npoints - 1) ? points[0] : points[i + 1];
		auto& lastPoint = (i == 0) ? points[npoints - 1] : points[i - 1];
		auto l1 = currentPoint - lastPoint;
		auto l2 = nextPoint - currentPoint;
		// z axis is 0
		OpenMesh::Vec3d n1(-l1[1], l1[0], 0);
		OpenMesh::Vec3d n2(-l2[1], l2[0], 0);
		n1.normalize();
		n2.normalize();
		auto n = (n1 + n2).normalized();
		normals[i] = n;
	}
	// draw
	glColor3f(bezierR, bezierG, bezierB);
	glBegin(GL_QUADS);
	for (size_t i = 0; i < npoints; i++) {
		const auto& point = points[i];
		const auto& normal = normals[i];
		const auto& nextPoint = (i == npoints - 1) ? points[0] : points[i + 1];
		const auto& nextNormal = (i == npoints - 1) ? normals[0] : normals[i + 1];
		auto v1 = point + normal / 2. * bezierLineWidth;
		auto v2 = nextPoint + nextNormal / 2. * bezierLineWidth;
		auto v4 = point - normal / 2. * bezierLineWidth;
		auto v3 = nextPoint - nextNormal / 2. * bezierLineWidth;
		glVertex3f(v1[0], v1[1], 0);
		glVertex3f(v2[0], v2[1], 0);
		glVertex3f(v3[0], v3[1], 0);
		glVertex3f(v4[0], v4[1], 0);
	}
	glEnd();

	
}

void MeshViewerWidget::DrawBezierCurves(std::vector<std::vector<Mesh::Point>> curvecage)
{
	size_t N = curvecage.size();
	if (N == 0) return;
	std::vector<double> curveLengths(N);

	size_t totalApproxVertices = 0;
	for (size_t i = 0; i < N; i++) {
		const auto& curvePoints = curvecage[i];
		double approxLen = 0.;
		int numPoints = curvePoints.size();
		for (size_t i = 0; i < numPoints - 1; i++) {
			approxLen += (curvePoints[i] - curvePoints[i + 1]).norm();
		}
		curveLengths[i] = approxLen;
		totalApproxVertices += approxLen * bezierSubdiv + 1;
	}
	std::vector<OpenMesh::Vec3d> points;
	points.reserve(totalApproxVertices);
	for (size_t i = 0; i < N; i++) {
		const auto& curvePoints = curvecage[i];
		BezierCurve curve(curvePoints, use_rational);
		double approxLen = curveLengths[i];
		double h = 1. / approxLen / bezierSubdiv;
		int j = 0;
		while (j <= 1 / h)
		{
			auto p = curve.Evaluate(j++ * h);
			p[2] -= 0.001;
			if (points.empty() || (p - *(points.rbegin())).norm() > 1e-4)
				points.push_back(p);
		}
	}
	while (!points.empty() && (*(points.rbegin()) - *(points.begin())).norm() < 1e-4) {
		points.erase(points.end() - 1);
	}
	size_t npoints = points.size();
	//std::cout << totalApproxVertices << '\t' << "bug?" << npoints << std::endl;
	std::vector<OpenMesh::Vec3d> normals(npoints);
	for (size_t i = 0; i < npoints; i++) {
		auto& currentPoint = points[i];
		auto& nextPoint = (i == npoints - 1) ? points[0] : points[i + 1];
		auto& lastPoint = (i == 0) ? points[npoints - 1] : points[i - 1];
		auto l1 = currentPoint - lastPoint;
		auto l2 = nextPoint - currentPoint;
		// z axis is 0
		OpenMesh::Vec3d n1(-l1[1], l1[0], 0);
		OpenMesh::Vec3d n2(-l2[1], l2[0], 0);
		n1.normalize();
		n2.normalize();
		auto n = (n1 + n2).normalized();
		normals[i] = n;
	}
	// draw
	glColor3f(bezierR, bezierG, bezierB);
	glBegin(GL_QUADS);
	for (size_t i = 0; i < npoints; i++) {
		const auto& point = points[i];
		const auto& normal = normals[i];
		const auto& nextPoint = (i == npoints - 1) ? points[0] : points[i + 1];
		const auto& nextNormal = (i == npoints - 1) ? normals[0] : normals[i + 1];
		auto v1 = point + normal / 2. * bezierLineWidth;
		auto v2 = nextPoint + nextNormal / 2. * bezierLineWidth;
		auto v4 = point - normal / 2. * bezierLineWidth;
		auto v3 = nextPoint - nextNormal / 2. * bezierLineWidth;
		glVertex3f(v1[0], v1[1], 0);
		glVertex3f(v2[0], v2[1], 0);
		glVertex3f(v3[0], v3[1], 0);
		glVertex3f(v4[0], v4[1], 0);
	}
	glEnd();


}

void MeshViewerWidget::DrawBezierControlPolylines()
{
	size_t N = curvecage2.size();
	if (N == 0) return;

	glColor3f(pointsR, pointsG, pointsB); // 控制向量颜色为红色
	glLineWidth(bezierPolyLineWidth);
	glBegin(GL_LINES);
	for (size_t i = 0; i < N; ++i) {
		const auto& ctrlPts = curvecage2[i];

		// 如果阶数为3，则应当有4个控制点
		if (ctrlPts.size() != 4) continue;

		// 第一个向量：P0 -> P1
		glVertex3f(ctrlPts[0][0], ctrlPts[0][1], ctrlPts[0][2]);
		glVertex3f(ctrlPts[1][0], ctrlPts[1][1], ctrlPts[1][2]);

		// 最后一个向量：P2 -> P3
		glVertex3f(ctrlPts[2][0], ctrlPts[2][1], ctrlPts[2][2]);
		glVertex3f(ctrlPts[3][0], ctrlPts[3][1], ctrlPts[3][2]);
	}
	glEnd();

	// 绘制控制点：使用点表示
	// 禁用混合，确保颜色完全不透明
	glDisable(GL_BLEND);
	glPointSize(bezierPolyPointWidth);
	glColor4f(pointsR, pointsG, pointsB,1.0f); // 控制点颜色
	glBegin(GL_POINTS);
	for (size_t i = 0; i < N; ++i) {
		const auto& ctrlPts = curvecage2[i];
		for (const auto& pt : ctrlPts) {
			glVertex3f(pt[0], pt[1], pt[2]);
		}
	}
	glEnd();
	glEnable(GL_BLEND);
}

void MeshViewerWidget::DrawBezierControlPolylines(std::vector<std::vector<Mesh::Point>> curvecage)
{
	size_t N = curvecage.size();
	if (N == 0) return;

	glColor3f(pointsR, pointsG, pointsB); // 控制向量颜色为红色
	glLineWidth(bezierPolyLineWidth);
	glBegin(GL_LINES);
	for (size_t i = 0; i < N; ++i) {
		const auto& ctrlPts = curvecage[i];

		// 如果阶数为3，则应当有4个控制点
		if (ctrlPts.size() != 4) continue;

		// 第一个向量：P0 -> P1
		glVertex3f(ctrlPts[0][0], ctrlPts[0][1], ctrlPts[0][2]);
		glVertex3f(ctrlPts[1][0], ctrlPts[1][1], ctrlPts[1][2]);

		// 最后一个向量：P2 -> P3
		glVertex3f(ctrlPts[2][0], ctrlPts[2][1], ctrlPts[2][2]);
		glVertex3f(ctrlPts[3][0], ctrlPts[3][1], ctrlPts[3][2]);
	}
	glEnd();

	// 绘制控制点：使用点表示
	// 禁用混合，确保颜色完全不透明
	glDisable(GL_BLEND);
	glPointSize(bezierPolyPointWidth);
	glColor4f(pointsR, pointsG, pointsB, 1.0f); // 控制点颜色
	glBegin(GL_POINTS);
	for (size_t i = 0; i < N; ++i) {
		const auto& ctrlPts = curvecage[i];
		for (const auto& pt : ctrlPts) {
			glVertex3f(pt[0], pt[1], pt[2]);
		}
	}
	glEnd();
	glEnable(GL_BLEND);
}


void MeshViewerWidget::DrawTexture()
{

	glShadeModel(GL_SMOOTH);

	glBindTexture(GL_TEXTURE_2D, glTextureID);

	glEnable(GL_TEXTURE_2D);//开启2D纹理功能

	std::vector<Triangle> triangles;

	// Step 1: Extract triangles and calculate their center z-coordinate
	for (auto f_it = mesh.faces_begin(); f_it != mesh.faces_end(); ++f_it)
	{
		Triangle tri;
		int i = 0;
		for (auto fv_it = mesh.fv_begin(*f_it); fv_it != mesh.fv_end(*f_it); ++fv_it, ++i)
		{
			tri.vertices[i] = mesh.point(*fv_it);
			tri.texcoords[i] = mesh.texcoord2D(*fv_it);
		}
		tri.zCenter = (tri.vertices[0][2] + tri.vertices[1][2] + tri.vertices[2][2]) / 3.0f;
		triangles.push_back(tri);
	}

	// Step 2: Sort triangles based on their zCenter (back to front)
	std::sort(triangles.begin(), triangles.end(), [](const Triangle& a, const Triangle& b) {
		return a.zCenter > b.zCenter;
		});

	// Step 3: Draw sorted triangles
	glBegin(GL_TRIANGLES);
	for (const auto& tri : triangles)
	{
		for (int i = 0; i < 3; ++i)
		{
			float uvScale = 1.0f; // or 3.0f depending on the use case
			glTexCoord2f(tri.texcoords[i][0] * uvScale, tri.texcoords[i][1] * uvScale);
			glVertex3fv(tri.vertices[i].data());
		}
	}
	glEnd();

	if (draw_mesh2) {
		std::vector<Triangle> triangles2;

		// Step 1: Extract triangles and calculate their center z-coordinate
		for (auto f_it = mesh2.faces_begin(); f_it != mesh2.faces_end(); ++f_it)
		{
			Triangle tri;
			int i = 0;
			for (auto fv_it = mesh2.fv_begin(*f_it); fv_it != mesh2.fv_end(*f_it); ++fv_it, ++i)
			{
				tri.vertices[i] = mesh2.point(*fv_it);
				tri.texcoords[i] = mesh2.texcoord2D(*fv_it);
			}
			// 所有顶点沿 X 轴平移 +3
			for (int j = 0; j < 3; ++j)
			{
				tri.vertices[j][0] += movemesh2; // x 分量加 3
			}
			tri.zCenter = (tri.vertices[0][2] + tri.vertices[1][2] + tri.vertices[2][2]) / 3.0f;
			triangles2.push_back(tri);
		}

		// Step 2: Sort triangles based on their zCenter (back to front)
		std::sort(triangles2.begin(), triangles2.end(), [](const Triangle& a, const Triangle& b) {
			return a.zCenter > b.zCenter;
			});

		// Step 3: Draw sorted triangles
		glBegin(GL_TRIANGLES);
		for (const auto& tri : triangles2)
		{
			for (int i = 0; i < 3; ++i)
			{
				float uvScale = 1.0f; // or 3.0f depending on the use case
				glTexCoord2f(tri.texcoords[i][0] * uvScale, tri.texcoords[i][1] * uvScale);
				glVertex3fv(tri.vertices[i].data());
			}
		}
		glEnd();

		////////////////////////////////////画第三个网格
		std::vector<Triangle> triangles3;

		// Step 1: Extract triangles and calculate their center z-coordinate
		for (auto f_it = mesh3.faces_begin(); f_it != mesh3.faces_end(); ++f_it)
		{
			Triangle tri;
			int i = 0;
			for (auto fv_it = mesh3.fv_begin(*f_it); fv_it != mesh3.fv_end(*f_it); ++fv_it, ++i)
			{
				tri.vertices[i] = mesh3.point(*fv_it);
				tri.texcoords[i] = mesh3.texcoord2D(*fv_it);
			}
			// 所有顶点沿 X 轴平移 +3
			for (int j = 0; j < 3; ++j)
			{
				tri.vertices[j][0] += movemesh3; // x 分量加 3
			}
			tri.zCenter = (tri.vertices[0][2] + tri.vertices[1][2] + tri.vertices[2][2]) / 3.0f;
			triangles3.push_back(tri);
		}

		// Step 2: Sort triangles based on their zCenter (back to front)
		std::sort(triangles3.begin(), triangles3.end(), [](const Triangle& a, const Triangle& b) {
			return a.zCenter > b.zCenter;
			});

		// Step 3: Draw sorted triangles
		glBegin(GL_TRIANGLES);
		for (const auto& tri : triangles3)
		{
			for (int i = 0; i < 3; ++i)
			{
				float uvScale = 1.0f; // or 3.0f depending on the use case
				glTexCoord2f(tri.texcoords[i][0] * uvScale, tri.texcoords[i][1] * uvScale);
				glVertex3fv(tri.vertices[i].data());
			}
		}
		glEnd();
	}

	glDisable(GL_TEXTURE_2D);

	//glBegin(GL_TRIANGLES);
	//{
	//	for (auto f_it = mesh.faces_begin(); f_it != mesh.faces_end(); f_it++)
	//	{
	//		for (auto fv_it = mesh.fv_begin(*f_it); fv_it != mesh.fv_end(*f_it); fv_it++)
	//		{
	//			auto uv = mesh.texcoord2D(*fv_it);
	//			float uvScale = 1.f;//怪兽的例子改成1.，其他改3.
	//			glTexCoord2f(uv[0] * uvScale, uv[1] * uvScale);
	//			glVertex3dv(mesh.point(*fv_it).data());

	//		}

	//	}


	//}
	//


	//glEnd();
	//glDisable(GL_TEXTURE_2D);//关闭纹理贴图功能
}

void MeshViewerWidget::DrawLinearCage(void)
{
	glColor3d(0.2, 0.2, 0.2);
	glBegin(GL_LINES);

	// 按顺序连接相邻的顶点
	for (size_t i = 0; i < linear_cage.size(); ++i) {
		auto point0 = linear_cage[i];
		auto point1 = linear_cage[(i + 1) % linear_cage.size()];  // 循环连接最后一个顶点和第一个顶点

		glVertex2d(point0[0], point0[1]);
		glVertex2d(point1[0], point1[1]);
	}

	glEnd();
}


void MeshViewerWidget::DrawCageWireframe(void)
{
	glColor3d(0.2, 0.2, 0.2);
	glLineWidth(3.0);
	glBegin(GL_LINES);
	// 获取所有顶点句柄
	std::vector<Mesh::VertexHandle> vhandles;
	for (const auto& vh : CC_mesh.vertices()) {
		vhandles.push_back(vh);
	}

	// 按顺序连接相邻的顶点
	for (size_t i = 0; i < vhandles.size(); ++i) {
		auto vh0 = vhandles[i];
		auto vh1 = vhandles[(i + 1) % vhandles.size()];  // 循环连接最后一个顶点和第一个顶点
		glVertex3d(CC_mesh.point(vh0).data()[0], CC_mesh.point(vh0).data()[1], 0);
		glVertex3d(CC_mesh.point(vh1).data()[0], CC_mesh.point(vh1).data()[1], 0);
	}
	glEnd();
	
}

void MeshViewerWidget::DrawCagePoints(void)
{	
	auto CC_vertexState = OpenMesh::getProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh, "vertexState");
	
	glColor3d(pointsR, pointsG, pointsB);
	glPointSize(8);
	glBegin(GL_POINTS);
	for (const auto& vh : CC_mesh.vertices())
	{
		if (CC_vertexState[vh] == NotSelected)
		{
			
			glVertex3d(CC_mesh.point(vh).data()[0], CC_mesh.point(vh).data()[1],0);
		}
	}
	glEnd();
	
	glColor3d(1.0, 0.3, 0.3);
	glPointSize(20);
	glBegin(GL_POINTS);
	for (const auto& vh : CC_mesh.vertices())
	{
		if (CC_vertexState[vh] == Custom)
		{
			
			glVertex3d(CC_mesh.point(vh).data()[0], CC_mesh.point(vh).data()[1],0);
		}
	}
	glEnd();

	if (isRotationMode) {
		glColor3d(0.0, 1.0, 0.0);
		glPointSize(50);
		glBegin(GL_POINTS);
		glVertex3dv(rotationCenter.data());
		glEnd();
	}

	if (1) {
		glColor3d(1.0, 0.0, 0.0);
		glPointSize(8);
		glBegin(GL_POINTS);
		// 遍历 LapLspoints 中的每个点
		for (const auto& point : LapLspoints) {
			// 转换每个 OpenMesh::Vec2d 为三维坐标 (x, y, 0)
			glVertex3d(point[0], point[1], 0.0);  // 这里假设 z = 0
		}
		glEnd();

		// 绘制连线
		glBegin(GL_LINE_STRIP);  // 使用 GL_LINE_STRIP 来依次连接点
		for (const auto& point : LapLspoints) {
			// 将每个 OpenMesh::Vec2d 转换为三维坐标 (x, y, 0)
			glVertex3d(point[0], point[1], 0.0);  // 这里假设 z = 0
		}
		glEnd();
	}
	if (useHandle)
	{
		auto Handle_vertexState = OpenMesh::getProperty<OpenMesh::VertexHandle, VertexState>(Handle_mesh, "vertexState");
		//绘制变形手柄
		glPointSize(20);
		glBegin(GL_POINTS);
		int vertex_id = 0;
		for (const auto& vh : Handle_mesh.vertices())
		{
			if (vertex_id % 2 == 0) {
				glColor3d(0., 0., 1.);
			}
			else {
				glColor3d(1., 0., 0.);
			}
			if (Handle_vertexState[vh] == Custom)
			{
				glVertex3dv(Handle_mesh.point(vh).data());
			}
			vertex_id++;
		}
		glEnd();

		glPointSize(10);
		glBegin(GL_POINTS);
		int vertex_id1 = 0;
		for (const auto& vh : Handle_mesh.vertices())
		{
			if (vertex_id1 % 2 == 0) {
				glColor3d(0., 0., 1.);
			}
			else {
				glColor3d(1., 0., 0.);
			}
			if (Handle_vertexState[vh] != Custom)
			{
				glVertex3dv(Handle_mesh.point(vh).data());
			}
			vertex_id1++;
		}
		glEnd();

		glLineWidth(2);  // 可根据需要调整线宽
		glBegin(GL_LINES);

		for (size_t i = 0; i + 1 < Handle_mesh.n_vertices(); i += 2)
		{
			// 获取顶点句柄
			auto vh1 = Handle_mesh.vertex_handle(i);
			auto vh2 = Handle_mesh.vertex_handle(i + 1);

			// 绘制从第i个顶点到第i+1个顶点的线段
			glColor3d(0., 0., 1.);  // 你可以自定义线段的颜色
			glVertex3dv(Handle_mesh.point(vh1).data());
			glVertex3dv(Handle_mesh.point(vh2).data());
		}
		glEnd();
	}
	
	if (draw_mesh2) {
		auto CC_vertexState22 = OpenMesh::getProperty<OpenMesh::VertexHandle, VertexState>(CC_mesh22, "vertexState");
		glColor3d(1.0, 0.3, 0.3);
		glPointSize(20);
		glBegin(GL_POINTS);
		for (const auto& vh : CC_mesh22.vertices())
		{
			if (CC_vertexState22[vh] == Custom)
			{

				glVertex3d(CC_mesh22.point(vh).data()[0]+movemesh2, CC_mesh22.point(vh).data()[1], 0);
			}
		}
		glEnd();
	}
}


void MeshViewerWidget::DrawHandlePoints(void)
{
	
	if (useHandle)
	{
		auto Handle_vertexState = OpenMesh::getProperty<OpenMesh::VertexHandle, VertexState>(Handle_mesh, "vertexState");
		//绘制变形手柄
		glPointSize(15);
		glBegin(GL_POINTS);
		int vertex_id = 0;
		for (const auto& vh : Handle_mesh.vertices())
		{
			if (vertex_id % 2 == 0) {
				vertex_id++;
				continue;
			}
			else {
				glColor3d(0.5, 0.75, 1.);
			}
			if (Handle_vertexState[vh] == Custom)
			{
				glVertex3dv(Handle_mesh.point(vh).data());
			}
			vertex_id++;
		}
		glEnd();

		glPointSize(10);
		glBegin(GL_POINTS);
		int vertex_id1 = 0;
		for (const auto& vh : Handle_mesh.vertices())
		{
			if (vertex_id1 % 2 == 0) {
				vertex_id1++;
				continue;
			}
			else {
				glColor3d(0.5, 0.75, 1.);
			}
			if (Handle_vertexState[vh] != Custom)
			{
				glVertex3dv(Handle_mesh.point(vh).data());
			}
			vertex_id1++;
		}
		glEnd();
	}

	
}

void MeshViewerWidget::DrawCurveCage(void)
{
	int N = curvecage2.size();
	std::cout << N << std::endl;
	/*for (int i = 0; i < N; i++) {
		DrawBezierCurve(curvecage2[i], bezierR, bezierG, bezierB, bezierLineWidth, bezierPointSize, bezierSubdiv);
	}*/
	
	if (draw_mesh2) {
		// 创建一个副本
		std::vector<std::vector<Mesh::Point>> movedCurvecage = curvecage22;
		for (auto& curve : movedCurvecage)
		{
			for (auto& p : curve)
			{
				p[0] += movemesh2;  // x 坐标加 3
			}
		}
		DrawBezierCurves(movedCurvecage);
		// 创建一个副本
		std::vector<std::vector<Mesh::Point>> movedCurvecage3 = curvecage33;
		for (auto& curve : movedCurvecage3)
		{
			for (auto& p : curve)
			{
				p[0] += movemesh3;  // x 坐标加 3
			}
		}
		DrawBezierCurves(movedCurvecage3);
		DrawBezierControlPolylines(movedCurvecage);
		DrawBezierControlPolylines(movedCurvecage3);
	}
	//DrawBezierControlPolylines();
	//DrawLinearCage();
	//DrawWireframe();
	/*if (drawpoints)
		DrawPoints();*/
	//cage的边和点
	if (drawpoints)
	{
		//DrawHandlePoints();
		/*DrawCagePoints();*/
		DrawBezierCurves(curvecage2);
		DrawBezierControlPolylines(curvecage2);
		
		//DrawWireframe();
		/*DrawPoints();
		DrawCagePoints();
		DrawCageWireframe();
		DrawCagePoints();*/
	}
	if (drawDistort||drawDistortDirichlet) {
		DrawSmoothDistort();
	}
	
	glColor3d(1.0, 1.0, 1.0);
	DrawTexture();
	
	//DrawFlat();
}

void MeshViewerWidget::DrawBoundingBox(void) const
{
	float linewidth;
	glGetFloatv(GL_LINE_WIDTH, &linewidth);
	glLineWidth(2.0f);
	glColor3d(.3, .7, .3);
	glBegin(GL_LINES);
	for (const auto& i : { 0, 1 })
	{
		for (const auto& j : { 0, 1 })
		{
			for (const auto& k : { 0, 1 })
			{
				glVertex3d(i ? ptMin[0] : ptMax[0], j ? ptMin[1] : ptMax[1], k ? ptMin[2] : ptMax[2]);
				glVertex3d(~i ? ptMin[0] : ptMax[0], j ? ptMin[1] : ptMax[1], k ? ptMin[2] : ptMax[2]);
				glVertex3d(i ? ptMin[0] : ptMax[0], j ? ptMin[1] : ptMax[1], k ? ptMin[2] : ptMax[2]);
				glVertex3d(i ? ptMin[0] : ptMax[0], ~j ? ptMin[1] : ptMax[1], k ? ptMin[2] : ptMax[2]);
				glVertex3d(i ? ptMin[0] : ptMax[0], j ? ptMin[1] : ptMax[1], k ? ptMin[2] : ptMax[2]);
				glVertex3d(i ? ptMin[0] : ptMax[0], j ? ptMin[1] : ptMax[1], ~k ? ptMin[2] : ptMax[2]);
			}
		}
	}
	glEnd();
	glLineWidth(linewidth);
}

void MeshViewerWidget::DrawBoundary(void) const
{
	float linewidth;
	glGetFloatv(GL_LINE_WIDTH, &linewidth);
	glLineWidth(20.0f);
	glColor3d(0.0, 0.0, 0.1);
	glBegin(GL_LINES);
	for (const auto& eh : mesh.edges())
	{
		if (mesh.is_boundary(eh))
		{
			auto heh = mesh.halfedge_handle(eh, 0);
			auto vh0 = mesh.from_vertex_handle(heh);
			auto vh1 = mesh.to_vertex_handle(heh);
			glNormal3dv(mesh.normal(vh0).data());
			glVertex3dv(mesh.point(vh0).data());
			glNormal3dv(mesh.normal(vh1).data());
			glVertex3dv(mesh.point(vh1).data());
		}
	}
	glEnd();
	glLineWidth(linewidth);
}


//void MeshViewerWidget::InitHighResFBO()
//{
//	if (fbo_ != 0) return;  // 已经初始化了
//
//	glGenTextures(1, &colorTex_);
//	glBindTexture(GL_TEXTURE_2D, colorTex_);
//	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, exportWidth_, exportHeight_, 0, GL_RGBA, GL_UNSIGNED_BYTE, nullptr);
//	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
//	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
//
//	glGenRenderbuffers(1, &depthRb_);
//	glBindRenderbuffer(GL_RENDERBUFFER, depthRb_);
//	glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, exportWidth_, exportHeight_);
//
//	glGenFramebuffers(1, &fbo_);
//	glBindFramebuffer(GL_FRAMEBUFFER, fbo_);
//	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, colorTex_, 0);
//	glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthRb_);
//
//	if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) {
//		std::cerr << "FBO creation failed!" << std::endl;
//	}
//}
//void MeshViewerWidget::RenderToFBO()
//{
//	glBindFramebuffer(GL_FRAMEBUFFER, fbo_);
//	glViewport(0, 0, exportWidth_, exportHeight_);
//
//	glClearColor(1.0, 1.0, 1.0, 1.0); // 白色背景
//	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
//
//	// 抗锯齿设置
//	glEnable(GL_LINE_SMOOTH);
//	glEnable(GL_MULTISAMPLE);
//	glEnable(GL_BLEND);
//	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
//	glDisable(GL_POLYGON_SMOOTH); // 防止边缘伪影
//	glDisable(GL_BLEND);         // 禁用 alpha 混合
//	glDisable(GL_POLYGON_SMOOTH); // 防止平滑造成边缘发灰
//	glDisable(GL_LINE_SMOOTH);    // 防止线条平滑混色
//	
//	DrawCurveCage();
//	//DrawSmooth();  // 正式绘图调用
//}

//void MeshViewerWidget::RenderToFBO(const std::vector<BezierCurve>& curves, int maxCurveIndex, int currentCurveIndex, double t_end)
//{
//	glBindFramebuffer(GL_FRAMEBUFFER, fbo_);
//	glViewport(0, 0, exportWidth_, exportHeight_);
//	glClearColor(1.0, 1.0, 1.0, 1.0);
//	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
//
//	glEnable(GL_LINE_SMOOTH);
//	glEnable(GL_MULTISAMPLE);
//	glEnable(GL_BLEND);
//	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
//	glDisable(GL_POLYGON_SMOOTH);
//
//	//DrawSmooth();
//	//glBindFramebuffer(GL_FRAMEBUFFER, 0);
//}
//
//
//
//void MeshViewerWidget::SaveImage(const QString& filename)
//{
//	std::vector<unsigned char> pixels(exportWidth_ * exportHeight_ * 4);
//	glReadPixels(0, 0, exportWidth_, exportHeight_, GL_RGBA, GL_UNSIGNED_BYTE, pixels.data());
//
//	for (int i = 0; i < exportWidth_ * exportHeight_; ++i) {
//		pixels[i * 4 + 3] = 255;
//	}
//	// 垂直翻转
//	for (int j = 0; j < exportHeight_ / 2; ++j) {
//		for (int i = 0; i < exportWidth_ * 4; ++i) {
//			std::swap(pixels[j * exportWidth_ * 4 + i],
//				pixels[(exportHeight_ - 1 - j) * exportWidth_ * 4 + i]);
//		}
//	}
//
//	// 设定目标尺寸为原来的 1/4
//	const int outW = exportWidth_ / 4;
//	const int outH = exportHeight_ / 4;
//	std::vector<unsigned char> downsampled(outW * outH * 4);
//
//	// 缩放图像
//	stbir_resize_uint8_linear(
//		pixels.data(), exportWidth_, exportHeight_, 0,
//		downsampled.data(), outW, outH, 0,
//		STBIR_RGBA  // RGBA channels
//	);
//
//
//	// 将 Qt 路径转为 C 风格 UTF-8 路径
//	QByteArray byteArray = filename.toUtf8();
//	const char* path = byteArray.constData();
//
//	// 保存为 PNG
//	stbi_write_png(path, outW, outH, 4, downsampled.data(), outW * 4);
//	std::cout << "Saved downsampled image to: " << path << std::endl;
//
//	// 恢复默认 framebuffer
//	glBindFramebuffer(GL_FRAMEBUFFER, 0);
//}
//
//
//void MeshViewerWidget::ExportHighResImage(const QString& filename)
//{
//	// 根据当前窗口宽高比设置导出分辨率，防止图像变形
//	double aspect = static_cast<double>(this->width()) / this->height();
//	exportWidth_ = this->width() * 4;
//	exportHeight_ = static_cast<int>(exportWidth_ / aspect);
//
//
//	InitHighResFBO();     // ✅ 创建 FBO 和纹理
//	RenderToFBO();        // ✅ 绘制图像到离屏 FBO
//	SaveImage(filename);
//}
//
//void MeshViewerWidget::ExportHighResImage(const QString& filename, const std::vector<BezierCurve>& curves, int maxIndex, int curIndex, double t_end)
//{
//	double aspect = static_cast<double>(this->width()) / this->height();
//	exportWidth_ = this->width() * 4;
//	exportHeight_ = static_cast<int>(exportWidth_ / aspect);
//
//	InitHighResFBO();
//	RenderToFBO(curves, maxIndex, curIndex, t_end);
//	SaveImage(filename);
//}